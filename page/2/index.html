<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.jpg?v=5.1.1" />






<meta name="description" content="博观而约取，厚积而薄发。">
<meta property="og:type" content="website">
<meta property="og:title" content="行次">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="行次">
<meta property="og:description" content="博观而约取，厚积而薄发。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行次">
<meta name="twitter:description" content="博观而约取，厚积而薄发。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>行次</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">行次</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/17/raspbarry-first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/17/raspbarry-first/" itemprop="url">Raspbarry first</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-17T00:00:00Z">
                2017-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index">
                    <span itemprop="name">Others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想要利用树莓派+DuerOS做一个可以人机交互的家用终端。<br>大概可以给讲故事，背诗词，报时，报天气。<br>车载大概可以导航，实时路况，广播之类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/17/android-system-service-Account-Manager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/17/android-system-service-Account-Manager/" itemprop="url">Android系统服务：AccountManager</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-17T00:00:00Z">
                2017-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-System-Framework/" itemprop="url" rel="index">
                    <span itemprop="name">Android System Framework</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前面"><a href="#前面" class="headerlink" title="前面"></a>前面</h4><p>以<code>AccountManager</code>为例，read the fucking code.</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>可以看到该类遵循Apache协议。也就是说允许商用，私用，分发，修改，专利授权，附件协议，作者不允许商标使用，不承担责任。</p>
<p>详细的各种协议区分，请看：<a href="http://xusx1024.com/2017/08/22/license-introduce/" target="_blank" rel="external">here</a></p>
<h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>类所在的包：<code>package android.accounts;</code> </p>
<ul>
<li>AbstractAccountAuthenticator</li>
<li>Account</li>
<li>AccountAuthenticatorActivity</li>
<li>AccountAuthenticatorResponse</li>
<li>AccountManagerCallback</li>
<li>AccountManagerFuture</li>
<li>AccountsException</li>
<li>AuthenticatorDescription</li>
<li>AuthenticatorException</li>
<li>NetworkErrorException</li>
<li>OnAccountsUpdateListener</li>
<li>OperationCanceledException</li>
</ul>
<h4 id="类说明"><a href="#类说明" class="headerlink" title="类说明"></a>类说明</h4><p>This class provides access to a centralized registry of the user’s online accounts.<br>The user enters credentials (username and password) once per account, granting applications access to online resources with “one-click” approval.</p>
<p>此类提供了用户在线账户集中注册的访问。<br>用户为每个账户输入用户密码作为证书，准许应用通过一次授权访问在线资源。</p>
<p></p><p>Different online services have different ways of handling accounts and authentication, so the account manager uses pluggable <em>authenticator</em> modules for different <em>account types</em>.<br>Authenticators (which may be written by third parties) handle the actual details of validating account credentials and storing account information.<br>For example, Google, Facebook, and Microsoft Exchange each have their own authenticator.</p>
<p>不同的线上服务处理账户和认证有不同的方式，因此账户管理者为不同的账户类型应用可插拔的认证模块。<br>验证者(也许是第三方写入)处理具体的账户证书细节，并且存储账户信息。<br>例如：Google，Facebook,Microsoft Exchange有各自的验证者。</p>
<p></p><p>Many servers support some notion[概念] of an <em>authentication token</em>, which can be used to authenticate a request to the server without sending the user’s actual password.<br>(Auth tokens are normally created with a separate request which does include the user’s credentials.)<br>AccountManager can generate auth tokens for applications, so the application doesn’t need to handle passwords directly.<br>Auth tokens are normally reusable and cached by AccountManager, but must be refreshed periodically[定期].<br>It’s the responsibility of applications to <em>invalidate</em> auth tokens when they stop working so the AccountManager knows it needs to regenerate them.</p>
<p>许多服务支持认证令牌的概念，可以无需用户确切的密码，即可向服务端认证一个请求。<br>(授权令牌通常创建在包含用户证书的一个单独的请求里。)<br>账户管理者可以为应用生成授权令牌，因此应用无需直接操作密码。<br>授权令牌通常是可重用的并由账户管理者缓存，但必须定期刷新。<br>当授权令牌停止工作时，应用的职责是废止这些授权，账户管理者依此得知需要重新生成。</p>
<p></p><p>Applications accessing a server normally go through these steps:</p>
<ul><br><li>Get an instance of AccountManager using {@link #get(Context)}.<br><br></li><li>List the available accounts using {@link #getAccountsByType} or {@link #getAccountsByTypeAndFeatures}.<br>Normally applications will only be interested in accounts with one particular <em>type</em>, which identifies the authenticator.<br>Account <em>features</em> are used to identify particular account subtypes and capabilities[功能].<br>Both the account type and features are authenticator-specific strings, and must be known by the application in coordination with its preferred authenticators.<br><br></li><li>Select one or more of the available accounts, possibly by asking the user for their preference.<br>If no suitable accounts are available, {@link #addAccount} may be called to prompt the user to create an account of the appropriate type.<br><br></li><li><b>Important:</b> If the application is using a previously remembered account selection, it must make sure the account is still in the list of accounts returned by {@link #getAccountsByType}.  Requesting an auth token for an account no longer on the device results in an undefined failure.<br><br></li><li>Request an auth token for the selected account(s) using one of the {@link #getAuthToken} methods or related helpers.<br>Refer to the description of each method for exact usage and error handling details.<br><br></li><li>Make the request using the auth token.  The form of the auth token, the format of the request, and the protocol used are all specific to the service you are accessing.<br>The application may use whatever network and protocol libraries are useful.<br><br></li><li><b>Important:</b> If the request fails with an authentication error, it could be that a cached auth token is stale and no longer honored by the server.<br>The application must call {@link #invalidateAuthToken} to remove the token from the cache, otherwise requests will continue failing!<br>After invalidating the auth token, immediately go back to the “Request an auth token” step above.<br>If the process fails the second time, then it can be treated as a “genuine” authentication failure and the user notified or other appropriate actions taken.<br></li></ul>

<p>应用访问服务一般有以下几个步骤：</p>
<ul><br><li>使用<code>get(Context)</code>获取账户管理者的实例<br></li><li>使用<code>getAccountsByType</code>或者<code>getAccountsByTypeAndFeatures</code>列出可用的账户。<br>通常应用只会被一个特定类型所吸引，该类型可用于识别验证者。<br>账户特征用来识别特定的账户子类型和功能。<br>账户类型和特征是验证者特定的字符串，必须由应用程序与其首选验证着协调知道。<br></li><li>选一或多个可用账户，可能通过询问用户的偏好。<br>如果没有适合的账户可用，指示用户调用<code>addAccount</code>创建一个适当类型的账户。<br></li><li><b>重要：</b>如果应用程序正在使用以前记录的账户选择，一定要确保此账户仍在<code>getAccountsByType</code>返回的账户列表里。<br>为不再在设备上的账户请求授权令牌，会导致未定义的错误。<br></li><li>为选择的账户请求授权令牌使用<code>getAuthToken</code>方法，或者相关的帮助者。<br>参考各个方法的描述，以确定用例使用、错误处理细节。<br></li><li>使用授权令牌发起请求。令牌的形式，请求的格式，使用的协议，这些都由你正在访问的服务指定。<br>应用程序可以使用任何网络和协议库都是可用的。<br></li><li><b>重要：</b>如果请求失败出现了授权错误，可能是缓存的令牌陈旧，不再由服务器兑现。<br>应用程序必须调用<code>invalidateAuthToken</code>去移除缓存的令牌，否则请求就会持续失败！<br>废止授权令牌之后，可以直接重复上面的步骤。<br>如果第二次操作也失败，就可以被对待为真实身份认证失败，用户需要被通知或采取别的行动.<br></li></ul>

<p></p><p>Some AccountManager methods may need to interact with the user to prompt for credentials, present options, or ask the user to add an account.<br>The caller may choose whether to allow AccountManager to directly launch the necessary user interface and wait for the user, or to return an Intent which the caller may use to launch the interface, or (in some cases) to install a notification which the user can select at any time to launch the interface.<br>To have AccountManager launch the interface directly, the caller must supply the current foreground {@link Activity} context.</p>
<p>一些账户管理者方法也许需要与用户交互来提示凭据，呈现选项，或要求用户添加一个账户。<br>调用者可以选择允许账户管理者直接登录必要的用户接口并且等待用户返回，也可以返回一个可以用来登录用户接口的意图，也可以展示一个通知，用户可以在任意时间选择去登录该接口。<br>要让账户管理者直接登录接口，调用者必须提供当前前台活动的上下文。</p>
<p></p><p>Many AccountManager methods take {@link AccountManagerCallback} and {@link Handler} as parameters.<br>These methods return immediately and run asynchronously.<br>If a callback is provided then {@link AccountManagerCallback#run} will be invoked on the Handler’s thread when the request completes, successfully or not.<br>The result is retrieved by calling {@link AccountManagerFuture#getResult()} on the {@link AccountManagerFuture} returned by the method (and also passed to the callback).<br>This method waits for the operation to complete (if necessary) and either returns the result or throws an exception if an error occurred during the operation.<br>To make the request synchronously, call {@link AccountManagerFuture#getResult()} immediately on receiving the future from the method; no callback need be supplied.</p>
<p></p><p>许多账户管理者持有<code>AccountManagerCallback</code>和<code>Handler</code>实例作为参数。<br>这些方法会异步执行并且立即返回。<br>如果一个回调被提供，在请求完成，成功或失败时，<code>AccountManagerCallback</code>将会在Handler的线程中被调用。<br>结果检索调用的方法是<code>AccountManagerFuture#getResult()</code>。<br>如果有必要，此方法等待操作的完成并且无论是返回结果或是在操作过程中产生错误并抛出异常。<br>为了异步执行请求，在接受到方法的未来时，直接调用<code>AccountManagerFuture#getResult()</code>；不需要提供回调。</p>
<p></p><p>Requests which may block, including {@link AccountManagerFuture#getResult()}, must never be called on the application’s main event thread.<br>These operations throw {@link IllegalStateException} if they are used on the main thread.</p>
<p>请求也许会阻塞，包括<code>AccountManagerFuture#getResult()</code>,绝对禁止在应用程序的主线程调用。<br>否则，这些操作会抛出<code>IllegalStateException</code>异常。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h5><ul>
<li><code>ERROR_CODE_REMOTE_EXCEPTION</code>:远程异常</li>
<li><code>ERROR_CODE_NETWORK_ERROR</code>:网络错误</li>
<li><code>ERROR_CODE_CANCELED</code>:取消</li>
<li><code>ERROR_CODE_INVALID_RESPONSE</code>:无效的响应</li>
<li><code>ERROR_CODE_UNSUPPORTED_OPERATION</code>:不支持的操作</li>
<li><code>ERROR_CODE_BAD_ARGUMENTS</code>:错误的参数</li>
<li><code>ERROR_CODE_BAD_REQUEST</code>:错误的请求</li>
<li><code>ERROR_CODE_BAD_AUTHENTICATION</code>:错误的授权</li>
<li><code>ERROR_CODE_BAD_AUTHENTICATION</code>:错误的已注册用户</li>
<li><code>ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE</code>:当前账户类型管理失效错误</li>
<li><code>KEY_ACCOUNT_NAME</code>:传值常量键，用于获取账户名</li>
<li><code>KEY_ACCOUNT_TYPE</code>:传值常量键，用于获取账户类型值</li>
<li><code>KEY_AUTHTOKEN</code>:传值常量键，用于获取授权令牌</li>
<li><code>KEY_INTENT</code>:传值常量键，用于启动相关的用户接口页面</li>
<li><code>KEY_PASSWORD</code>:传值常量键，用于获取密码</li>
<li><code>KEY_ACCOUNTS</code>:传值常量键，用于获取账户</li>
<li><code>KEY_ACCOUNT_AUTHENTICATOR_RESPONSE</code>:传值常量键，用于获取账户授权响应</li>
<li><code>KEY_ACCOUNT_MANAGER_RESPONSE</code>:传值常量键，用于获取账户管理者响应</li>
<li><code>KEY_AUTHENTICATOR_TYPES</code>:传值常量键，用于获取授权类型</li>
<li><code>KEY_AUTH_FAILED_MESSAGE</code>:授权失败信息</li>
<li><code>KEY_AUTH_TOKEN_LABEL</code>:授权令牌标签</li>
<li><code>KEY_BOOLEAN_RESULT</code>:结果布尔值</li>
<li><code>KEY_ERROR_CODE</code>:错误码</li>
<li><code>KEY_ERROR_MESSAGE</code>:错误消息</li>
<li><code>KEY_USERDATA</code>:用户数据</li>
<li><code>KEY_LAST_AUTHENTICATED_TIME</code>:上次授权时间</li>
<li><code>KEY_CALLER_UID</code>:调用者的UID</li>
<li><code>KEY_CALLER_PID</code>:调用者的PID</li>
<li><code>KEY_ANDROID_PACKAGE_NAME</code>:Android包名</li>
<li><code>KEY_NOTIFY_ON_FAILURE</code>:授权失败时是否提示，boolean值</li>
<li><code>ACTION_AUTHENTICATOR_INTENT</code>:<code>android.accounts.AccountAuthenticator</code></li>
<li><code>AUTHENTICATOR_META_DATA_NAME</code>:<code>android.accounts.AccountAuthenticator</code></li>
<li><code>AUTHENTICATOR_ATTRIBUTES_NAME</code>:授权者的name属性</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code>public AccountManager(Context context, IAccountManager service) {
   mContext = context;
   mService = service;
   mMainHandler = new Handler(mContext.getMainLooper());
}
</code></pre><p>不会用到，获取一个账户管理者的实例，使用如下方法即可：</p>
<pre><code>public static AccountManager get(Context context) {
       if (context == null) throw new IllegalArgumentException(&quot;context is null&quot;);
       return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);
   }
</code></pre><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><p><code>public class AccountManager{ ... }</code></p>
<p>public的类，没有实现任何接口。</p>
<h5 id="内部类-AmsTask"><a href="#内部类-AmsTask" class="headerlink" title="内部类-AmsTask"></a>内部类-AmsTask</h5><p><code>private abstract class AmsTask extends FutureTask&lt;Bundle&gt; implements AccountManagerFuture&lt;Bundle&gt; { ... }</code></p>
<p>看类修饰符：</p>
<ul>
<li>abstract ： 说明该类是一个模板类，必定有抽象方法，需要被子类化，实现具体的操作，</li>
<li>private：子类化应该是在外部类中<br>符合Java编码原则：使用函数对象代替策略。使类和成员的可访问性最小化。</li>
</ul>
<p>该类继承自一个可取消的异步计算，实现了一个处理计算结果的回调。</p>
<p>发现<code>AccountManagerFuture</code> 和<code>Future</code>两个接口的行为是一样的，一个在<code>android.accounts</code>里，另一个在<code>java.util.concurrent</code>.</p>
<p>AmsTask的构造方法为public，由于父类<code>FutureTask</code>的构造，必须要求传递<code>Callable</code>实例，如果没有这个实例，就会<code>NullPointerException</code>，所以直接在此截断抛出了。<br>因此，虽然传递了Callable，却禁止使用了，使用的还是Future。</p>
<pre><code>public AmsTask(Activity activity, Handler handler, AccountManagerCallback&lt;Bundle&gt; callback) {
      super(new Callable&lt;Bundle&gt;() {
          public Bundle call() throws Exception {
              throw new IllegalStateException(&quot;this should never be called&quot;);
          }
      });

      mHandler = handler;
      mCallback = callback;
      mActivity = activity;
      mResponse = new Response();
  }
</code></pre><ul>
<li>abstract void doWork()  由函数对象来具体实现操作</li>
<li>AccountManagerFuture<bundle> start() 开始执行<code>doWork()</code></bundle></li>
<li>void set(Bundle bundle) 父类方法，把结果设置给指定的Future，除非Future已经有结果或者已经被取消</li>
<li>Bundle getResult()、Bundle getResult(long timeout, TimeUnit unit)、Bundle internalGetResult(Long timeout, TimeUnit unit) 获取处理结果<blockquote>
<p>getResult最后都调用了<code>internalGetResult</code>方法。大概流程如下：</p>
<ul>
<li>判断线程是否执行结束</li>
<li>判断时间是否为null或已结束</li>
<li>获取结果</li>
<li>异常后取消线程执行</li>
</ul>
</blockquote>
</li>
</ul>
<p>确保当前线程不在主线程的代码：</p>
<pre><code>private void ensureNotOnMainThread() {
    final Looper looper = Looper.myLooper();
    if (looper != null &amp;&amp; looper == mContext.getMainLooper()) {
        final IllegalStateException exception = new IllegalStateException(
                &quot;calling this from your main thread can lead to deadlock&quot;);
        Log.e(TAG, &quot;calling this from your main thread can lead to deadlock and/or ANRs&quot;,
                exception);
        if (mContext.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.FROYO) {
            throw exception;
        }
    }
}
</code></pre><p>跟踪到<code>FutureTask</code>的<code>get</code>方法里，这里返回父类的一个Object实例：<code>outcome</code>存放我们想要的结果对象。</p>
<p>在<code>get</code>里还有许多操作，比如判断线程执行的状态：</p>
<ul>
<li>NEW         </li>
<li>COMPLETING  </li>
<li>NORMAL      </li>
<li>EXCEPTIONAL </li>
<li>CANCELLED   </li>
<li>INTERRUPTING</li>
<li>INTERRUPTED </li>
</ul>
<p>我看到在操作线程状态的时候，使用了该类：<code>private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</code>，用来保证原子操作，确定一个线程是<code>RUNNER</code>,<code>WAITER</code>.<br>这是一个JDK私有API，在Java9的时候可能移除，并使用<code>java.util.concurrent.LockSupport</code>实现。下面摘抄一段说明：</p>
<blockquote>
<p>原子访问是<code>sun.misc.Unsafe</code>被广泛应用的特性之一，特性包括简单的put、get操作(带有volatile语义或不带有volatile语义)以及比较并交换(compare and swap，CAS)操作。</p>
</blockquote>
<h5 id="AmsTask的内部类-Response"><a href="#AmsTask的内部类-Response" class="headerlink" title="AmsTask的内部类-Response"></a>AmsTask的内部类-Response</h5><p>AmsTask中有一个public的Response的引用。</p>
<p>操作一：<code>onResult</code></p>
<blockquote>
<p>响应有结果，跳转至用户提供的Activity，或是重试，再次调用<code>doWork()</code>，否则把响应数据bundle设置回父类的<code>outcome</code>里</p>
</blockquote>
<p>操作二：<code>onError</code></p>
<blockquote>
<p>取消线程的执行</p>
</blockquote>
<h5 id="内部类-BaseFutureTask"><a href="#内部类-BaseFutureTask" class="headerlink" title="内部类-BaseFutureTask"></a>内部类-BaseFutureTask</h5><p>可以看到这是一个抽象类，我们只要知道什么是需要子类实现的，什么是已经实现的。</p>
<pre><code>protected void postRunnableToHandler(Runnable runnable) {
       Handler handler = (mHandler == null) ? mMainHandler : mHandler;
       handler.post(runnable);
   }
</code></pre><p>把Runnable加入消息队列，可以当前线程的handler执行。</p>
<p><code>abstract void doWork()</code>  由函数对象来具体实现操作<br><code>abstract T bundleToResult(Bundle bundle)</code> 由函数对象来具体实现操作</p>
<h5 id="BaseFutureTask的内部类-Response"><a href="#BaseFutureTask的内部类-Response" class="headerlink" title="BaseFutureTask的内部类-Response"></a>BaseFutureTask的内部类-Response</h5><ul>
<li>onResult 调用外部类的<code>bundleToResult</code></li>
<li>onError 中断线程，抛出异常</li>
</ul>
<h5 id="内部类-Future2Task"><a href="#内部类-Future2Task" class="headerlink" title="内部类-Future2Task"></a>内部类-Future2Task</h5><ul>
<li>BaseFutureTask的子类，同时也是个抽象类，实现了<code>internalGetResult</code>，具体的贱<code>AmsTask$internalGetResult</code></li>
</ul>
<h5 id="内部类-GetAuthTokenByTypeAndFeaturesTask"><a href="#内部类-GetAuthTokenByTypeAndFeaturesTask" class="headerlink" title="内部类-GetAuthTokenByTypeAndFeaturesTask"></a>内部类-GetAuthTokenByTypeAndFeaturesTask</h5><p><code>AmsTask</code>的子类，顾名思义，根据类型和特征获取授权令牌的任务。</p>
<p><code>doWork()</code>的作用：</p>
<ul>
<li>根据类型和特征尝试获取已授权账户</li>
<li>未获取到账户，如果提示添加账户的activity为空，则把<code>KEY_ACCOUNT_NAME</code>,<code>KEY_ACCOUNT_TYPE</code>,<code>KEY_AUTHTOKEN</code>置为空，并返回</li>
<li>未获取到账户，如果提示添加账户的activity不为空，调用<code>addAccount</code>方法，这是一个Future，可以中断和等待结果的子线程</li>
<li>如果只获取到一个账户，获取AuthToken，放入响应</li>
<li>如果获取到了多个账户，启动<code>android.accounts.ChooseAccountActivity</code>,选择一个后，获取AuthToken，放入响应</li>
</ul>
<h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><h5 id="sanitizeResult"><a href="#sanitizeResult" class="headerlink" title="sanitizeResult"></a>sanitizeResult</h5><pre><code>public static Bundle sanitizeResult(Bundle result) {
      if (result != null) {
          if (result.containsKey(KEY_AUTHTOKEN)
                  &amp;&amp; !TextUtils.isEmpty(result.getString(KEY_AUTHTOKEN))) {
              final Bundle newResult = new Bundle(result);
              newResult.putString(KEY_AUTHTOKEN, &quot;&lt;omitted for logging purposes&gt;&quot;);
              return newResult;
          }
      }
      return result;
  }
</code></pre><p>如果返回的结果bundle中包含<code>KEY_AUTHTOKEN</code>，就把这个值变成“为了日志的目的而省略”，是对结果做一次“消毒”</p>
<h5 id="IAccountManager相关"><a href="#IAccountManager相关" class="headerlink" title="IAccountManager相关"></a>IAccountManager相关</h5><ul>
<li>getPassword</li>
<li>setPassword</li>
<li>clearPassword</li>
<li>getUserData</li>
<li>setUserData</li>
<li>getAuthenticatorTypes：此处返回一个数组，一个账户可以有多重类型，不需要权限</li>
<li>getAuthenticatorTypesAsUser：需要权限，或者相同的用户</li>
<li>getAccounts：需要权限</li>
<li>getAccountsAsUser</li>
<li>getAccountsForPackage：调用者可用的账户列表</li>
<li>updateAppPermission：仅被系统页面调用，不包含于SDK中</li>
<li>getAuthTokenLabel：获取与认证者相关联的用户友好标签，返回一个Future</li>
<li>hasFeatures：需要权限，指定的账户是拥有指定的权限。可用在任意线程，但返回结果不可用于主线程。</li>
<li>getAccountsByTypeAndFeatures：需要权限，根据类型和功能获取账户列表</li>
<li>addAccount</li>
<li>addSharedAccount</li>
<li>addAccountExplicitly：直接添加一个账户。这个方法不会刷新最近一次的时间戳，需要主动<code>notifyAccountAuthenticated</code>。但是，如果该方法触发了<code>addAccount()</code>或者<code>addAccountAsUser</code>，就不需要刷新时间戳，可以自动刷新了。可在主线程调用此方法。需要API22以上。</li>
<li>notifyAccountAuthenticated：通知系统账户刚刚被授权。可被其他程序用来验证账户。只有在授权成功方可调用。主线程不安全的。</li>
<li>renameAccount：先移除已有的账户，再添加重命名后的账户。</li>
<li>getPreviousName：获取改名前的名字，可能返回null，主线程安全的。</li>
<li>removeAccount：如果有，就从AccountManager删除账户，不会从服务器上删除。API22之前调用需要权限。</li>
<li>removeAccountAsUser</li>
<li>invalidateAuthToken：从AccountManager的缓存中移除授权。API22之前需要权限。</li>
<li>peekAuthToken：从缓存中取授权令牌，如果没有，生成一个新的，不会链接服务器。</li>
<li>setAuthToken</li>
<li>getAuthToken</li>
<li>getAuthTokenByFeatures</li>
<li>blockingGetAuthToken：会阻塞，不要在主线程调用，API22之前需要权限</li>
<li>copyAccountToUser</li>
<li>confirmCredentialsAsUser：</li>
<li>updateCredentials</li>
<li>editProperties：提供一个用户修改授权设置的机会。</li>
<li>ensureNotOnMainThread：确保不在主线程</li>
<li>postToHandler</li>
<li>convertErrorToException</li>
<li>newChooseAccountIntent：提供给用户一个可选账户的列表</li>
</ul>
<h4 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4><p><a href="https://github.com/xusx1024/AccountManagerDemo" target="_blank" rel="external">AccountManagerDemo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/14/android-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/14/android-notes/" itemprop="url">android - 消除非受检的警告</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T00:00:00Z">
                2017-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="using-setjavascriptenabled-can-introduce-xss-vulnerabilities-into-your-application"><a href="#using-setjavascriptenabled-can-introduce-xss-vulnerabilities-into-your-application" class="headerlink" title="using setjavascriptenabled can introduce xss vulnerabilities into your application"></a>using setjavascriptenabled can introduce xss vulnerabilities into your application</h4><p>在WebView中，如果你启用js，kotlin代码如下：</p>
<pre><code>webview.settings.javaScriptEnabled = true
</code></pre><p>会得到题目的警告提示。</p>
<p>原因是：启用js可能不安全，如果你真的需要，好好检查这些js。<br>消除：</p>
<pre><code>@SuppressLint(&quot;SetJavaScriptEnabled&quot;)
</code></pre><h4 id="WebView-addJavascriptInterface-should-not-be-called-with-minSdkVersion-lt-17-for-security-reasons-JavaScript-can-use-reflection-to-manipulate-application"><a href="#WebView-addJavascriptInterface-should-not-be-called-with-minSdkVersion-lt-17-for-security-reasons-JavaScript-can-use-reflection-to-manipulate-application" class="headerlink" title="WebView.addJavascriptInterface should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application"></a><code>WebView.addJavascriptInterface</code> should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application</h4><p>在WebView中，如果添加JS调用Java代码，kotlin代码如下：</p>
<pre><code>webview.addJavascriptInterface(JsObject(), &quot;onClick&quot;)
</code></pre><p>会得到题目的警告提示。</p>
<p>原因题目说的很清楚，“JavaScript可以通过反射操作应用”</p>
<p>官方的说明：<a href="https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29" target="_blank" rel="external">JavaScript安全不</a></p>
<p>一篇不错的<a href="http://blog.csdn.net/leehong2005/article/details/11808557" target="_blank" rel="external">blog</a></p>
<p>可以确定的是4.2，也就是17，JELLY BEAN之前，可以获取到SD读写权限，然后操作你的联系人、短信、etc</p>
<p>这个问题相当的经典。一般的应用估计都不会修复它。但如果应用用户太大，不得不修复。</p>
<h4 id="加载JS的时机"><a href="#加载JS的时机" class="headerlink" title="加载JS的时机"></a>加载JS的时机</h4><p>引申问题，你有一段JS，何时加载？</p>
<ul>
<li>onLoadResource</li>
<li>doUpdateVisitedHistory</li>
<li>onPageStarted</li>
<li>onPageFinished</li>
<li>onReceivedTitle</li>
<li>onProgressChanged</li>
</ul>
<h4 id="setRenderPriority-android-webkit-WebSettings-RenderPriority-’-is-deprecated"><a href="#setRenderPriority-android-webkit-WebSettings-RenderPriority-’-is-deprecated" class="headerlink" title="setRenderPriority(android.webkit.WebSettings.RenderPriority)’ is deprecated"></a>setRenderPriority(android.webkit.WebSettings.RenderPriority)’ is deprecated</h4><p>源码中：</p>
<blockquote>
<p>It is not recommended to adjust thread priorities, and this will not be supported in future versions.</p>
</blockquote>
<h4 id="webView-加载缓慢"><a href="#webView-加载缓慢" class="headerlink" title="webView 加载缓慢"></a>webView 加载缓慢</h4><pre><code>if (Build.VERSION.SDK_INT &gt;= 19) {//4.4，KK
           mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
       }
       else {
           mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
       }
</code></pre><h4 id="This-Handler-class-should-be-static-or-leaks-might-occur-anonymous-android-os-Handler"><a href="#This-Handler-class-should-be-static-or-leaks-might-occur-anonymous-android-os-Handler" class="headerlink" title="This Handler class should be static or leaks might occur (anonymous android.os.Handler)"></a>This Handler class should be static or leaks might occur (anonymous android.os.Handler)</h4><p>我们在使用Handler发送消息时，往往使用内部类来实现Handler，这样可能导致内存泄露。</p>
<p>原因：</p>
<p>handler实例做为一个嵌套类，确切的说是做为一个内部类时，默认持有外部类的引用，</p>
<p>假设外部类为<code>SampleActivity</code>，并且Handler里有延时执行的任务，并且Activity提前finish</p>
<p>这样，由于activity的引用还在Handler的延时任务里，GC判定，该Activity虽然finish，但是不可回收，此时就发生了内存泄露</p>
<p>解决：</p>
<p>Handler使用静态内部类</p>
<p>Handler类中使用弱引用维护对activity的引用：</p>
<pre><code>private static class MyHandler extends Handler {
    private final WeakReference&lt;SampleActivity&gt; mActivity;

    public MyHandler(SampleActivity activity) {
      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);
    }

    @Override
    public void handleMessage(Message msg) {
      SampleActivity activity = mActivity.get();
      if (activity != null) {
        // ...
      }
    }
  }

  private final MyHandler mHandler = new MyHandler(this);
</code></pre><p><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html" target="_blank" rel="external">E文传送</a><br><a href="http://www.jianshu.com/p/1b39416f1508" target="_blank" rel="external">译文传送</a></p>
<h4 id="Warning-168-72-Unchecked-assignment-‘java-util-List’-to-‘java-util-List‘-Reason-‘queries’-has-raw-type-so-result-of-list-is-erased"><a href="#Warning-168-72-Unchecked-assignment-‘java-util-List’-to-‘java-util-List‘-Reason-‘queries’-has-raw-type-so-result-of-list-is-erased" class="headerlink" title="Warning:(168, 72) Unchecked assignment: ‘java.util.List’ to ‘java.util.List‘. Reason: ‘queries’ has raw type, so result of list is erased"></a>Warning:(168, 72) Unchecked assignment: ‘java.util.List’ to ‘java.util.List<com.xxx.greendao.xxbean>‘. Reason: ‘queries’ has raw type, so result of list is erased</com.xxx.greendao.xxbean></h4><p>只能添加指定类型，不会有警告：</p>
<pre><code>ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
</code></pre><p>如果添加了String之外的类型，会有编译时警告：</p>
<pre><code>ArrayList&lt;String&gt; arr = new ArrayList();
</code></pre><p>这就是raw type，可以添加Object类型的对象，此时会提示<code>Unchecked assignment...</code>，</p>
<pre><code>ArrayList arr = new ArrayList&lt;String&gt;();
</code></pre><p>考察如下DEMO，可以编译通过，但是运行异常：</p>
<pre><code>import java.util.ArrayList;

public class TestRawType {

    public static void main(String[] args) {
          ArrayList arr = new ArrayList&lt;String&gt;();

          arr.add(&quot;qwer&quot;);
          arr.add(1234);
          arr.add(new Integer(2));

          System.out.println(arr.toString());

          for(Object o : arr){
              System.out.println((String)o);
          }
    }

}
</code></pre><blockquote>
<p>控制台输出：[qwer, 1234, 2]<br>qwer<br>Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String<br>    at TestRawType.main(TestRawType.java:17)</p>
</blockquote>
<p>更加详细的解释，参考《effective java》 2nd 第23条：请不要在新代码中使用原生态类型</p>
<h4 id="Static-member-‘android-support-v4-app-FragmentActivity-RESULT-OK’-accessed-via-instance-reference"><a href="#Static-member-‘android-support-v4-app-FragmentActivity-RESULT-OK’-accessed-via-instance-reference" class="headerlink" title="Static member ‘android.support.v4.app.FragmentActivity.RESULT_OK’ accessed via instance reference"></a>Static member ‘android.support.v4.app.FragmentActivity.RESULT_OK’ accessed via instance reference</h4><p>原因：通过实例引用了某个类的静态变量，如下：</p>
<pre><code>getActivity().RESULT_OK
</code></pre><p>修改：</p>
<pre><code>Activity.RESULT_OK;
</code></pre><p><code>update @ 2017年7月14日18:50:52</code></p>
<h4 id="Dangling-Javadoc-comment"><a href="#Dangling-Javadoc-comment" class="headerlink" title="Dangling Javadoc comment"></a>Dangling Javadoc comment</h4><p>原因：悬空的注释（在你导出文档时，可能会丢失）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/net-work-day03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/05/net-work-day03/" itemprop="url">《图解HTTP》第5、6、7章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T00:00:00Z">
                2017-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NetWork/" itemprop="url" rel="index">
                    <span itemprop="name">NetWork</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul>
<li>接收客户端请求，转发至源服务器</li>
<li>缓存请求，减少网络带宽流量</li>
<li>过滤请求</li>
<li>访问日志记录</li>
<li>多级代理，每通过一级会添加via首部，即可追踪报文的转发，还可避免请求回环的发生，经常和TRACE方法一起使用</li>
<li>透明/非透明代理：是否对报文内容进行加工</li>
</ul>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><ul>
<li>利用网关可以由HTTP请求转化为其他协议通信</li>
<li>网关和代理的工作机制十分相似，网关能使通信线路上的服务器提供非HTTP协议服务</li>
<li>利用网关能提高通信的安全性</li>
</ul>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><ul>
<li>安全：可使用SSL等加密手段进行通信</li>
<li>透明：隧道不解析HTTP请求，请求保持原样中转给之后的服务器</li>
</ul>
<h4 id="资源的缓存"><a href="#资源的缓存" class="headerlink" title="资源的缓存"></a>资源的缓存</h4><ul>
<li>代理服务器缓存</li>
<li>客户端缓存</li>
<li>减少流量带宽</li>
<li>减少服务器压力</li>
<li>减少响应时间</li>
<li>确定缓存的有效期</li>
</ul>
<h4 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h4><ul>
<li>HTTP首部字段重复的情况：根据浏览器不同，结果可能并不一致，有些优先处理先出现的，有些处理后出现的字段</li>
<li>请求首部、响应首部、通用首部、内容首部具体字段</li>
</ul>
<h4 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h4><ul>
<li>明文通信可能会被窃听</li>
<li>不验证通信方的身份，可能遭遇伪装：使用SSL[Secure Socket Layer]认证</li>
<li>无法证明报文的完整性，有可能遭遇篡改：中间人攻击</li>
</ul>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ul>
<li>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</li>
<li>HTTPS并非新协议，通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。HTTPS即身披SSL协议外壳的HTTP</li>
</ul>
<h4 id="用户身份认证"><a href="#用户身份认证" class="headerlink" title="用户身份认证"></a>用户身份认证</h4><ul>
<li>SSL认证 - 计算机</li>
<li>表单认证 - 用户</li>
</ul>
<h4 id="对Web应用的攻击"><a href="#对Web应用的攻击" class="headerlink" title="对Web应用的攻击"></a>对Web应用的攻击</h4><ul>
<li>主动攻击服务器：针对服务器上的资源，代表手法：SQL注入和OS命令注入</li>
<li>被动攻击服务器：诱使用户出发陷阱，窃取用户信息，代表手法：跨站脚本攻击、跨站点请求伪造<ul>
<li>可利用用户的身份攻击企业内部网络</li>
</ul>
</li>
</ul>
<h5 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h5><p>Cross-Site  Scripting,XSS :是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。</p>
<ul>
<li>输入框中增加窃取用户名、密码的script。</li>
<li>窃取用户的Cookie</li>
</ul>
<h5 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h5><p>SQL Injection：是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。<br>破坏SQL语句结构。</p>
<h5 id="OS命令注入攻击"><a href="#OS命令注入攻击" class="headerlink" title="OS命令注入攻击"></a>OS命令注入攻击</h5><p>OS命令注入攻击(OS Command Injection)是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。可从Web应用中通过Shell来调用操作系统命令，通过OS注入攻击可执行OS上安装着的各种程序。</p>
<h5 id="HTTP首部注入攻击"><a href="#HTTP首部注入攻击" class="headerlink" title="HTTP首部注入攻击"></a>HTTP首部注入攻击</h5><p>HTTP首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p>
<p>向首部主体内添加内容的攻击称为HTTP响应截断攻击。</p>
<ul>
<li>设置Cookie信息</li>
<li>重定向至指定URL</li>
<li>显示任意的主体</li>
</ul>
<h4 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="因设置或设计上的缺陷引发的安全漏洞"></a>因设置或设计上的缺陷引发的安全漏洞</h4><ul>
<li>强制浏览：浏览那些原本非自愿公开的文件</li>
<li>不正确的错误消息处理：Web应用的错误信息包含对攻击者有用的信息。Web应用不必在用户的浏览画面上展示详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。</li>
<li>开放重定向：对指定的任意URL作重定向跳转的功能，假如重定向到恶意的Web网站，那么用户就会被诱导至那个Web网站。</li>
</ul>
<h4 id="会话引发的安全漏洞"><a href="#会话引发的安全漏洞" class="headerlink" title="会话引发的安全漏洞"></a>会话引发的安全漏洞</h4><ul>
<li>会话劫持：攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。</li>
<li>会话固定攻击：强制用户使用攻击者指定的会话ID，属于被动攻击。</li>
<li>跨站点请求伪造：攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</li>
</ul>
<h4 id="其他安全漏洞"><a href="#其他安全漏洞" class="headerlink" title="其他安全漏洞"></a>其他安全漏洞</h4><ul>
<li>密码破解：密码试错[穷举法，字典攻击]、密码破解</li>
<li>点击劫持：界面伪装</li>
<li>dos攻击：让运行中的服务呈停止状态的攻击。<ul>
<li>集中利用访问请求[发送大量合法请求]造成资源过载，导致资源用尽，服务停止</li>
<li>通过攻击安全漏洞使服务停止</li>
</ul>
</li>
<li>后门程序250：开发设置的隐藏入口</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/net-work-day02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/net-work-day02/" itemprop="url">《图解HTTP》第3、4章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T00:00:00Z">
                2017-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NetWork/" itemprop="url" rel="index">
                    <span itemprop="name">NetWork</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><ul>
<li>使用HTTP协议进行交互的信息称为HTTP报文，有请求报文、响应报文两种</li>
<li>报文大致可分为报文首部和报文主体两块，两者由一个空行隔开，报文主体不一定有</li>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>
<li>其他：可能包含HTTP的RFC里未定义的首部，如Cookie等</li>
</ul>
<h4 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h4><p>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等做为判断的基准。</p>
<ul>
<li>服务器驱动协商：由服务端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息做为判定的依据，并不一定能筛选出最优内容</li>
<li>客户端驱动协商：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。</li>
<li>透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ul>
<h4 id="常用的14个HTTP状态码"><a href="#常用的14个HTTP状态码" class="headerlink" title="常用的14个HTTP状态码"></a>常用的14个HTTP状态码</h4><h5 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h5><ul>
<li>200 从客户端发来的请求在服务端被正常处理的</li>
<li>204 请求已经成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体，比如浏览器请求，返回204，那么浏览器页面不发生更新</li>
<li>206 客户端进行了范围请求，服务器成功执行了。响应报文中包含由Content-Range指定范围的实体内容</li>
</ul>
<h5 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h5><ul>
<li>301 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</li>
<li>302 临时性重定向</li>
<li>303 由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>304 客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。304和重定向没有关系</li>
<li>307 临时性重定向</li>
</ul>
<h5 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h5><ul>
<li>400 请求报文中存在语法错误，需要修改请求的内容后再次发送请求</li>
<li>401 表示发送的请求需要有通过HTTP认证，如果之前已经进行过一次请求，则表示用户认证失败，当浏览器初次接收到401响应，会弹出认证用的对话窗口</li>
<li>403 请求资源的访问被服务器拒绝</li>
<li>404 无法找到请求的资源，也可以在403时拒绝请求且不想说明理由时使用</li>
</ul>
<h5 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h5><ul>
<li>500 服务端在执行请求时发生了错误</li>
<li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/uses-feature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/uses-feature/" itemprop="url">AndroidManifest.xml中的uses-feature标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T00:00:00Z">
                2017-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>如果你有一个装有android 1.5的设备，你可能会注意到一些高版本的应用没有在手机上的Android Market中显示。这必定是应用使用了<uses-feature>的结果。</uses-feature></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>&lt;uses-feature
  android:name=&quot;string&quot;
  android:required=[&quot;true&quot; | &quot;false&quot;]
  android:glEsVersion=&quot;integer&quot; /&gt;
</code></pre><h5 id="android-name"><a href="#android-name" class="headerlink" title="android:name"></a>android:name</h5><p>以描述字符串形式指定应用使用的单一硬件或软件功能。详见:<a href="https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#features-reference" target="_blank" rel="external">HERE</a></p>
<pre><code>&lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;
</code></pre><h5 id="android-required"><a href="#android-required" class="headerlink" title="android:required"></a>android:required</h5><ul>
<li>android:required=”true”:当设备不具有该指定功能时，应用无法正常工作，或设计为无法正常工作</li>
<li>android:required=”false”：如果设备具有该功能，应用会在必要时优先使用该功能，但应用设计为不使用该指定功能也可正常工作</li>
<li><p>默认为true</p>
<pre><code> &lt;uses-feature 
android:name=&quot;android.hardware.camera&quot;
android:required=false /&gt;
</code></pre></li>
</ul>
<h5 id="android-glEsVersion"><a href="#android-glEsVersion" class="headerlink" title="android:glEsVersion"></a>android:glEsVersion</h5><p>应用需要的OpenGL ES版本。高16位表示主版本号，低16位表示次版本号。例如2.0 –&gt; 0x00020000;3.2 –&gt; 0x00030002</p>
<pre><code>&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; required=&quot;true&quot;/&gt;
</code></pre><ul>
<li>如果指定多个，将使用数值最高的</li>
<li>如果没有指定，系统假定只需要OpenGL ES 1.0</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><uses-feature> 声明的用途是将您的应用依赖的硬件和软件功能集通知任何外部实体</uses-feature></li>
<li>一般而言，您始终都应确保为应用需要的所有功能声明 <uses-feature> 元素</uses-feature></li>
<li>Android 系统本身在安装应用前不会检查设备是否提供相应的功能支持</li>
<li>其他服务（如 Google Play）或应用可能会在处理您的应用或与其交互的过程中检查它的 <uses-feature> 声明</uses-feature></li>
<li>如果minSdkVersion&lt;=4或者targetSdkVersion&lt;=4,googlePlay将不对该标签做任何过滤</li>
<li>蓝牙、相机、麦克风、定位、wifi、触屏、USB</li>
<li>输入法、多媒体、屏幕界面(小控件、壁纸等)</li>
</ul>
<p><a href="https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required" target="_blank" rel="external">https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/net-work-day01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/net-work-day01/" itemprop="url">《图解HTTP》第1、2章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T00:00:00Z">
                2017-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NetWork/" itemprop="url" rel="index">
                    <span itemprop="name">NetWork</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="tcp-ip的分层管理"><a href="#tcp-ip的分层管理" class="headerlink" title="tcp/ip的分层管理"></a>tcp/ip的分层管理</h4><ul>
<li>应用层 http、ftp、dns</li>
<li>传输层 tcp-提供可靠的字节流服务、udp</li>
<li>网络层 ip协议，作用是把各种数据包传送给对方</li>
<li>数据链路层 硬件相关</li>
</ul>
<h4 id="tcp-ip通信传输流"><a href="#tcp-ip通信传输流" class="headerlink" title="tcp/ip通信传输流"></a>tcp/ip通信传输流</h4><p>利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从数据链路层往上走。假下如图是客户端想要看某个web页面的http请求：</p>
<p><img src="/images/tcp-ip通信传输流.png" alt="通信传输流"></p>
<ul>
<li>在应用层，使用HTTP协议，发出请求，此处会先请求DNS服务，获取请求网址对应的IP地址</li>
<li>在传输层(TCP协议)，把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文段上打上标记序号及端口号后[可靠地]转发给网络层</li>
<li>在网络层(IP协议)，增加做为通信目的地的MAC地址后转发给链路层，接收端的服务器在链路层收到数据，按序往上层发送直至应用层</li>
</ul>
<p>发送端在层与层之间传输数据时，没经过一层必定会被打上一个该层所属的首部信息。在接收端则反之。</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><ul>
<li>发送端发送待遇SYN的数据包</li>
<li>接收端接收到后，发送带有SYN/ACK标志的数据包表示确认信息</li>
<li>发送端再回传一个带有ACK的数据包，代表“握手”结束</li>
<li>如果在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包</li>
</ul>
<h4 id="http-方法"><a href="#http-方法" class="headerlink" title="http 方法"></a>http 方法</h4><ul>
<li>get</li>
<li>post</li>
<li>delete</li>
<li>put</li>
<li>header</li>
<li>options</li>
<li>trace</li>
<li>connect</li>
<li>link 1.0</li>
<li>unlink 1.0</li>
</ul>
<h4 id="HTTP-持久链接"><a href="#HTTP-持久链接" class="headerlink" title="HTTP 持久链接"></a>HTTP 持久链接</h4><p><img src="/images/HTTP持久连接.png" alt="持久连接"></p>
<p>keep-alive,只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>HTTP/1.1中，连接默认是持久连接<br>HTTP是无状态的协议，可以使用Cookie来保存状态</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/design-patterns-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/design-patterns-proxy/" itemprop="url">代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T00:00:00Z">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>代理模式(proxy pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理的英文叫做Proxy或者Surrogate，它是一种对象结构型模式。</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>subject：抽象对象角色。声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象</li>
<li>realSubject：代理对象所代表的目标对象</li>
<li>proxy：代理对象角色。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象</li>
</ul>
<p><img src="/images/proxy_pattern_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/proxy_pattern_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ProxyPattern" target="_blank" rel="external">GitHub</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>
<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统的资源消耗，对系统进行优化并提高运行速度</li>
<li>保护代理，可以控制对真实对象的使用权限</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢</li>
<li>实现代理模式需要额外的工作，有些代理模式实现非常复杂</li>
</ul>
<h4 id="扩展-代理的应用"><a href="#扩展-代理的应用" class="headerlink" title="扩展-代理的应用"></a>扩展-代理的应用</h4><ul>
<li>远程（Remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又叫做大使。</li>
<li>虚拟（Virtual）代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：这是虚拟代理的一种，把克隆操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销比较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护（Protect of Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙（Firewall）代理：保护目标不让恶意用户接近。</li>
<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突</li>
<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。</li>
<li>图片代理：对大图浏览的控制。用户访问是先不加载真实的大图，而是通过代理对象的方法来进行处理，在该方法中，先使用一个线程为客户加载一个小图，然后在后天使用另一个线程加载大图。当需要浏览大图片时，再显示大图。如果用户浏览大图时，图片加载还没完成，可以再启动一个线程来显示相应的提示信息。</li>
<li>动态代理：较为高级的代理模式，典型应用是Spring AOP。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/design-patterns-flyweight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/design-patterns-flyweight/" itemprop="url">享元模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T00:00:00Z">
                2017-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>享元模式(flyweight pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Flyweight：抽象享元角色。给出抽象接口，定义具体享元角色需要实现的方法</li>
<li>ConcreteFlyweight：具体享元角色。实现抽象享元角色，如果有内蕴状态，必须负责为内蕴状态提供存储空间。</li>
<li>ConcreteCompositeFlyweight：复合享元角色。复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成多个本身是单纯享元对象的组合。复合享元对象又称作不可共享的享元对象。</li>
<li>FlyweightFactory：享元工厂角色。负责创建和管理享元角色。</li>
</ul>
<h5 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h5><p><img src="/images/flyweight_pattern_class_diagram_1.png" alt="类图"></p>
<h5 id="组合享元模式"><a href="#组合享元模式" class="headerlink" title="组合享元模式"></a>组合享元模式</h5><p><img src="/images/flyweight_pattern_class_diagram_2.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/flyweight_pattern_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FlyweightPattern" target="_blank" rel="external">GitHub</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份</li>
<li>外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>使系统更加复杂，需要分离出内部状态和外部状态，使逻辑复杂化</li>
<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/design-patterns-facade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/design-patterns-facade/" itemprop="url">外观模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T00:00:00Z">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>外观模式(facade pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
<p>注意：facade大概读音“佛撒的”，不要读做“非K特” ==！</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Facade：外观角色</li>
<li>SubSystem：子系统角色</li>
</ul>
<p><img src="/images/facade_pattern_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/facade_pattern_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FacadePattern" target="_blank" rel="external">GitHub</a></p>
<pre><code>package FacadePattern;

/**
 * 不要通过继承一个门面类，为某个子系统增加行为。&lt;br/&gt;
 * 
 * 使用装饰、适配器等为具体的子系统添加行为。&lt;br/&gt;
 * 
 * Facade只是为子系统提供一个集中化和简化的沟通管道，不能向子系统中添加行为。&lt;br/&gt;
 * 
 * final只能阻止继承，不能阻止通过其他方式添加行为，这个需要依靠开发者的自律的，是个缺点。&lt;br/&gt;
 * 
 * 外观类可以有多个，因此可以引入抽象外观类来对系统进行改进。&lt;br/&gt;
 * 
 * 这样又和策略模式相似了，策略是行为型，外观是对象型。
 * @author sxx.xu
 *
 */
public final class Facade {

    public void operation() {
        SystemA a = new SystemA();
        SystemB b = new SystemB();

        a.operationA();
        b.operationB();
    }
}
</code></pre><hr>
<pre><code>package FacadePattern;

/**
 * 可以同时有多个子系统类，每个子系统都不是一个单独的类，而是一个类的集合。&lt;br/&gt;
 * 
 * 子系统可以被客户端调用，也可以被外观调用。&lt;br/&gt;
 * 
 * @author sxx.xu
 *
 */
public class SystemA {

    public void operationA() {
        System.out.println(&quot;SystemA operation&quot;);
    }
}
</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</li>
<li>外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度</li>
<li>外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多限制则减少了可变性和灵活性</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.jpg"
               alt="XuShengSing" />
          <p class="site-author-name" itemprop="name">XuShengSing</p>
           
              <p class="site-description motion-element" itemprop="description">博观而约取，厚积而薄发。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">91</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xusx1024" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XuShengSing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">

  <div class="powered-by"></div>

<!-- <span class="post-count">博客共字</span> -->

</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

  <!-- 背景动画 -->
<script type="text/javascript" src="/js/src/particle.js"></script>

</body>
</html>
