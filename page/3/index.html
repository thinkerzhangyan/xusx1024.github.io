<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.jpg?v=5.1.1" />






<meta name="description" content="博观而约取，厚积而薄发。">
<meta property="og:type" content="website">
<meta property="og:title" content="行次">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="行次">
<meta property="og:description" content="博观而约取，厚积而薄发。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行次">
<meta name="twitter:description" content="博观而约取，厚积而薄发。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>行次</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">行次</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/13/httprequest-study-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/13/httprequest-study-tips/" itemprop="url">HttpRequest学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T20:13:51Z">
                2017-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="cvc-complex-type-2-4-a-Invalid-content-was-found-starting-with-element-‘display-name’"><a href="#cvc-complex-type-2-4-a-Invalid-content-was-found-starting-with-element-‘display-name’" class="headerlink" title="cvc-complex-type.2.4.a: Invalid content was found starting with element ‘display-name’"></a>cvc-complex-type.2.4.a: Invalid content was found starting with element ‘display-name’</h4><p><code>web.xml</code>在自动生成servlet的时候出现的提示。</p>
<p>通常是由于标签位置，标签DTD的校验规则所影响的。</p>
<p>删除 <code>http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd</code> 即不采用该校验规则 </p>
<h4 id="request-重要方法"><a href="#request-重要方法" class="headerlink" title="request 重要方法"></a>request 重要方法</h4><ul>
<li>获取IP</li>
<li>获取请求方法</li>
<li>获取请求参数</li>
<li>获取浏览器类型</li>
<li>获取协议</li>
<li>获取服务器名</li>
<li>获取服务器端口</li>
<li>获取项目名</li>
<li>获取servlet路径</li>
<li>获取GET参数</li>
<li>获取URI</li>
<li>获取URL</li>
</ul>
<h4 id="使用referer完成防盗链"><a href="#使用referer完成防盗链" class="headerlink" title="使用referer完成防盗链"></a>使用referer完成防盗链</h4><ul>
<li>在浏览器地址栏直接输入ip，referer为空</li>
<li>从百度输入ip，referer为百度</li>
</ul>
<h4 id="获取request参数"><a href="#获取request参数" class="headerlink" title="获取request参数"></a>获取request参数</h4><ul>
<li>获取get参数</li>
<li>获取post参数</li>
<li>获取单值</li>
<li>获取多值</li>
<li>获取map</li>
</ul>
<h4 id="请求转发和请求包含"><a href="#请求转发和请求包含" class="headerlink" title="请求转发和请求包含"></a>请求转发和请求包含</h4><ul>
<li>转发：下一个servlet设置响应体，当前servlet只能设置响应头</li>
<li>包含：共同完成响应体</li>
<li>无论转发或者包含，都是使用同一个request/response</li>
<li>使用set/getAttribute来，在两个servlet之间传递参数【request域、session域、application域中都有这个属性的操作，但是其生命周期不同】</li>
</ul>
<h5 id="和重定向的区别"><a href="#和重定向的区别" class="headerlink" title="和重定向的区别"></a>和重定向的区别</h5><ul>
<li>重定向是两个请求，地址栏地址会改变</li>
<li>转发/包含是一个请求</li>
<li>转发/包含只能转发到本项目的servl</li>
<li>重定向既可以到本项目也可以到别的项目</li>
<li>重定向需要给出requestURI，即全路径</li>
<li>转发/包含是服务端行为</li>
<li>转发/包含效率较高</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/design-patterns-observer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/09/design-patterns-observer/" itemprop="url">观察者设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-09T15:10:47Z">
                2017-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<p>观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Subject：目标</li>
<li>ConcreteSubject：具体目标</li>
<li>Observer：观察者</li>
<li>ConcreteObserver：具体观察者</li>
</ul>
<p><img src="/images/observer_pattern_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/observer_pattern_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ObserverPattern" target="_blank" rel="external">GitHub</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>可以实现表示层和数据逻辑层分离，并定义了稳定的消息更新传递机制</li>
<li>观察者和目标之间是一个抽象的耦合</li>
<li>支持广播通信</li>
<li>符合开闭原则</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>如果目标有许多观察者，通知所有观察者会花费许多时间</li>
<li>如果观察者和目标之间有循环依赖的话，目标会触发他们之间的循环调用</li>
<li>观察者无法知道目标是如何发生变化的，只是知道目标发生了变化</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>MVC模式可以用观察者模式来实现，其中观察目标就是Model，观察者就是View，中介者就是Controller。当Model数据发生改变，View将自动改变其显示内容。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/08/android-ipc-messenger-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/08/android-ipc-messenger-tips/" itemprop="url">使用Messenger进行进程间通信注意事项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-08T15:49:35Z">
                2017-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p><img src="/images/auth_sequence_diagram.png" alt="需求示意图"></p>
<p>看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来<br>本来懒得费事，一个<code>startActivityForResult</code>即可结束战斗<br>后来发现，我的SDK里没有UI，也就没有处理<code>onActivityResult</code>的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。</p>
<h4 id="Messenger的使用"><a href="#Messenger的使用" class="headerlink" title="Messenger的使用"></a>Messenger的使用</h4><p>此处不是我想略，网上教程很多，看个比较完善简单的：<a href="http://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="external">Android 基于Message的进程间通信 Messenger完全解析</a><br>代码有些地方不适合新的Android版本，但是也够用了。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="需求问题解决"><a href="#需求问题解决" class="headerlink" title="需求问题解决"></a>需求问题解决</h5><p>SDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。<br>其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。<br>kotlin代码如下：</p>
<pre><code>var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg
private val mMessenger = Messenger(object : Handler() {
    override fun handleMessage(msgfromClient: Message) {
        val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息
        try {
            when (msgfromClient.what) {
                REMOTE_CLIENT -&gt; {//远程访问-SDK
                    remoteMsg = msgfromClient.replyTo
                    var intent: Intent = Intent()
                    val bundle: Bundle = msgfromClient.obj as Bundle
                    val appID: String = bundle.get(&quot;APPID&quot;) as String

                    //开启授权页Activity
                    intent.setClass(this@AuthMessengerService, AuthActivity::class.java)
                    intent.putExtra(&quot;appID&quot;, appID)
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    startActivity(intent)
                }
                LOCAL_CLIENT -&gt; {//本地访问-授权页
                    val bundle: Bundle = msgfromClient.obj as Bundle
                    msgToClient.obj = bundle//拿到授权页信使带来的code
                    remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端
                }
            }
        } catch (e: InterruptedException) {
            e.printStackTrace()
        } catch (e: RemoteException) {
            e.printStackTrace()
        }

        super.handleMessage(msgfromClient)
    }
})
</code></pre><p>根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。</p>
<h5 id="单向双向"><a href="#单向双向" class="headerlink" title="单向双向"></a>单向双向</h5><pre><code>msgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使
</code></pre><p>这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。</p>
<h5 id="多向通信"><a href="#多向通信" class="headerlink" title="多向通信"></a>多向通信</h5><p>在这个里<a href="https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample" target="_blank" rel="external">Remote Messenger Service Sample</a>可以看到多个客户端互相通信的官方示例。<br>官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。</p>
<h5 id="隐式启动service"><a href="#隐式启动service" class="headerlink" title="隐式启动service"></a>隐式启动service</h5><p> 5.0之后需要：</p>
<pre><code>Intent intent = new Intent();
intent.setAction(action);
intent.setPackage(pkgName);
context.bindService(intent, mConn, Context.BIND_AUTO_CREATE);
</code></pre><h5 id="魅族手机无法启动"><a href="#魅族手机无法启动" class="headerlink" title="魅族手机无法启动"></a>魅族手机无法启动</h5><p>设置app权限，允许后台运行即可。话说这手机牌子坑爹。</p>
<h5 id="Can’t-marshal-non-Parcelable-objects-across-processes"><a href="#Can’t-marshal-non-Parcelable-objects-across-processes" class="headerlink" title="Can’t marshal non-Parcelable objects across processes"></a>Can’t marshal non-Parcelable objects across processes</h5><p>msg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。</p>
<h5 id="MainActivity-has-leaked-ServiceConnection"><a href="#MainActivity-has-leaked-ServiceConnection" class="headerlink" title="MainActivity has leaked ServiceConnection"></a>MainActivity has leaked ServiceConnection</h5><p>页面关闭时，记得unbind</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/02/design-patterns-interpreter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/02/design-patterns-interpreter/" itemprop="url">解释器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-02T09:39:35Z">
                2017-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。<br>解释器模式是一种行为型模式。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul>
<li>Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li>
<li>AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li>
<li>TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li>
<li>NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li>
</ul>
<p><img src="/images/interpreter_class_diagram.png" alt="类图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern" target="_blank" rel="external">GitHub</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>为自定义语言的设计和实现提供了一种解决方案</li>
<li>使用频率不高，在正则表达式、xml文档解析等领域广泛应用</li>
<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护</li>
<li>使用了大量的循环和递归，导致执行效率很低</li>
<li>尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足</li>
<li>一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具</li>
<li>如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/31/design-patterns-chain-of-responsibility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/design-patterns-chain-of-responsibility/" itemprop="url">责任链模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T00:00:00Z">
                2017-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>责任链模式是对象行为型模式<br></p>
<p>责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br></p>
<p>客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链</li>
<li>ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。</li>
</ul>
<p><img src="/images/chain_of_responsibility_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/chain_of_responsibility_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p> <a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility" target="_blank" rel="external">GitHub</a></p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型</li>
<li>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li>
<li>责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。</li>
<li>纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况</li>
<li>不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/31/anti-patterns-constant-interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/anti-patterns-constant-interface/" itemprop="url">接口常量反模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T00:00:00Z">
                2017-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br></p>
<p>下面是两个例子：</p>
<pre><code>public interface IConstant {
String NAME = &quot;&quot;;
int VALUE = 2;
boolean IS_TEACHER = false;
}    
</code></pre><p><br></p>
<pre><code>public class CConstant {
    public static final String NAME = &quot;&quot;;
    public static final int VALUE = 2;
    public static final boolean IS_TEACHER = false;
}
</code></pre><h4 id="接口的优点"><a href="#接口的优点" class="headerlink" title="接口的优点"></a>接口的优点</h4><ul>
<li>接口会自动将成员变量设置为static、final的</li>
<li>使得代码更加简单清晰</li>
<li>字节码文件相对于类来说更少，jvm加载和维护的成本变低</li>
<li>jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快</li>
</ul>
<h4 id="反模式之处"><a href="#反模式之处" class="headerlink" title="反模式之处"></a>反模式之处</h4><p>由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。</p>
<h4 id="反反模式的做法"><a href="#反反模式的做法" class="headerlink" title="反反模式的做法"></a>反反模式的做法</h4><p>final类 + 私有构造，如下：<br></p>
<pre><code>public final class Constants {
    private Constants() {
    }

    public static final String NAME = &quot;&quot;;
    public static final int VALUE = 2;
    public static final boolean IS_TEACHER = false;

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/31/anti-patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/31/anti-patterns/" itemprop="url">软件开发反模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T00:00:00Z">
                2017-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="过早优化"><a href="#过早优化" class="headerlink" title="过早优化"></a><strong>过早优化</strong></h4><h5 id="what"><a href="#what" class="headerlink" title="what"></a>what</h5><pre><code>在你有足够的信息能确定在哪优化、如何优化之前就展开优化。
</code></pre><h5 id="why"><a href="#why" class="headerlink" title="why"></a>why</h5><pre><code>想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 
Donald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。
</code></pre><h5 id="how"><a href="#how" class="headerlink" title="how"></a>how</h5><pre><code>把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。
当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 

不假思索就动手，还不如不做。——Tim Peter
</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。
</code></pre><h4 id="单车车库"><a href="#单车车库" class="headerlink" title="单车车库"></a>单车车库</h4><h5 id="what-1"><a href="#what-1" class="headerlink" title="what"></a>what</h5><pre><code>花大量时间来辩论和决定琐碎、太主观的问题的趋势。
</code></pre><h5 id="why-1"><a href="#why-1" class="headerlink" title="why"></a>why</h5><pre><code>浪费时间。
</code></pre><h5 id="how-1"><a href="#how-1" class="headerlink" title="how"></a>how</h5><pre><code>如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。
当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。
</code></pre><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><pre><code>单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。
避免花费太多时间在琐碎的事情上。
</code></pre><h4 id="分析瘫痪"><a href="#分析瘫痪" class="headerlink" title="分析瘫痪"></a>分析瘫痪</h4><h5 id="what-2"><a href="#what-2" class="headerlink" title="what"></a>what</h5><pre><code>对问题的过度分析，阻碍了行动和进展。
</code></pre><h5 id="why-2"><a href="#why-2" class="headerlink" title="why"></a>why</h5><pre><code>过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，
或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。    
</code></pre><h5 id="how-2"><a href="#how-2" class="headerlink" title="how"></a>how</h5><pre><code>意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，
每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。
</code></pre><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><pre><code>宁愿迭代，也不用过度分析和猜测。
</code></pre><h4 id="上帝类"><a href="#上帝类" class="headerlink" title="上帝类"></a>上帝类</h4><h5 id="what-3"><a href="#what-3" class="headerlink" title="what"></a>what</h5><pre><code>上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。
</code></pre><h5 id="why-3"><a href="#why-3" class="headerlink" title="why"></a>why</h5><pre><code>违反了单一责任原则，难以单元测试、调试和记录文档。
</code></pre><h5 id="how-3"><a href="#how-3" class="headerlink" title="how"></a>how</h5><pre><code>通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。
</code></pre><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><pre><code>避免有着太多责任和依赖的庞大的类。
</code></pre><h4 id="新增类恐惧症"><a href="#新增类恐惧症" class="headerlink" title="新增类恐惧症"></a>新增类恐惧症</h4><h5 id="what-4"><a href="#what-4" class="headerlink" title="what"></a>what</h5><pre><code>认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。
</code></pre><h5 id="why-4"><a href="#why-4" class="headerlink" title="why"></a>why</h5><pre><code>新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。
</code></pre><h5 id="how-4"><a href="#how-4" class="headerlink" title="how"></a>how</h5><pre><code>简化设计新增类，解耦代码中不必要的耦合部分。
</code></pre><h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><pre><code>类的数量多，并不能说明设计很糟糕。
</code></pre><h4 id="内部平台效应"><a href="#内部平台效应" class="headerlink" title="内部平台效应"></a>内部平台效应</h4><h5 id="what-5"><a href="#what-5" class="headerlink" title="what"></a>what</h5><pre><code>复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。
</code></pre><h5 id="why-5"><a href="#why-5" class="headerlink" title="why"></a>why</h5><pre><code>重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。
</code></pre><h5 id="how-5"><a href="#how-5" class="headerlink" title="how"></a>how</h5><pre><code>学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。
</code></pre><h5 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h5><pre><code>避免重新发明你的操作系统或开发平台已经做得很多的功能。    
</code></pre><h4 id="魔法数和字符串"><a href="#魔法数和字符串" class="headerlink" title="魔法数和字符串"></a>魔法数和字符串</h4><h5 id="what-6"><a href="#what-6" class="headerlink" title="what"></a>what</h5><pre><code>使用未命名的数字或字符串字面量，而不是在代码里命名为常量。
</code></pre><h5 id="why-6"><a href="#why-6" class="headerlink" title="why"></a>why</h5><pre><code>增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。
</code></pre><h5 id="how-6"><a href="#how-6" class="headerlink" title="how"></a>how</h5><pre><code>使用命名的常量、资源检索方法或者注释。
</code></pre><h5 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h5><pre><code>避免在代码中出现未注释、未命名的数字和字符串字面量。
</code></pre><h4 id="数字管理"><a href="#数字管理" class="headerlink" title="数字管理"></a>数字管理</h4><blockquote>
<p>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates</p>
</blockquote>
<h5 id="what-7"><a href="#what-7" class="headerlink" title="what"></a>what</h5><pre><code>严格地依靠数字来做决定。
</code></pre><h5 id="why-7"><a href="#why-7" class="headerlink" title="why"></a>why</h5><pre><code>在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。
例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。
</code></pre><h5 id="how-7"><a href="#how-7" class="headerlink" title="how"></a>how</h5><pre><code>理智地使用测量和数字，而非盲目。
</code></pre><h5 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h5><pre><code>用数字来得出你的决策，但不是用数字来做决定。
</code></pre><h4 id="幽灵类"><a href="#幽灵类" class="headerlink" title="幽灵类"></a>幽灵类</h4><blockquote>
<p>要想达到完美，不是没有东西可加，而是没有东西可减。</p>
</blockquote>
<h5 id="what-8"><a href="#what-8" class="headerlink" title="what"></a>what</h5><pre><code>无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。
</code></pre><h5 id="why-8"><a href="#why-8" class="headerlink" title="why"></a>why</h5><pre><code>增加了测试和维护的复杂度，降低了代码的可读性。
</code></pre><h5 id="how-8"><a href="#how-8" class="headerlink" title="how"></a>how</h5><pre><code>不要写无用的类，或者通过重构来消除。
</code></pre><h5 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h5><pre><code>避免没有真正责任的类。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/26/design-patterns-state-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/design-patterns-state-pattern/" itemprop="url">状态模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T00:00:00Z">
                2017-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>状态模式是对象行为型模式<br></p>
<p>看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br></p>
<p>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Context:环境类</li>
<li>State：抽象状态类</li>
<li>ConcreteState：具体状态类</li>
</ul>
<p><img src="/images/state_pattern_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/state_pattern_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p> <a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern" target="_blank" rel="external">GitHub</a></p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</li>
<li>简单状态模式和可切换状态的状态模式</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/25/design-patterns-abstract-factory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/design-patterns-abstract-factory/" itemprop="url">抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T00:00:00Z">
                2017-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="引入概念"><a href="#引入概念" class="headerlink" title="引入概念"></a>引入概念</h4><ul>
<li><strong>产品等级结构：</strong>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li><strong>产品族：</strong> 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。</li>
</ul>
<p><img src="/images/abstract_factory_product_level.png" alt="示例图"></p>
<h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Factory：抽象工厂</li>
<li>ConcreteFactory：具体工厂</li>
<li>Product：抽象产品</li>
<li>ConcreteProduct：具体产品</li>
</ul>
<p><img src="/images/abstract_factory_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/abstract_factory_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p> <a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory" target="_blank" rel="external">GitHub</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式</li>
<li></li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定</li>
<li>比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/25/design-patterns-strategy-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/design-patterns-strategy-pattern/" itemprop="url">策略模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T00:00:00Z">
                2017-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/work/" itemprop="url" rel="index">
                    <span itemprop="name">work</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="what"><a href="#what" class="headerlink" title="what"></a>what</h4><p>策略模式是对象行为型模式<br></p>
<p>策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).</p>
<h4 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h4><ul>
<li>Context:环境类</li>
<li>Strategy：抽象策略类</li>
<li>ConcreteStrategy：具体策略类</li>
</ul>
<p><img src="/images/strategy_pattern_class_diagram.png" alt="类图"></p>
<h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><p><img src="/images/strategy_pattern_sequence_diagram.png" alt="时序图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p> <a href="https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern" target="_blank" rel="external">GitHub</a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难</li>
<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。</li>
</ul>
<h4 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h4><ul>
<li>对开闭原则完美支持，用户自由切换算法，易于扩展</li>
<li><p>可以避免使用多重条件转移语句</p>
</li>
<li><p>必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则</p>
</li>
<li>需要维护许多策略类</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.jpg"
               alt="XuShengSing" />
          <p class="site-author-name" itemprop="name">XuShengSing</p>
           
              <p class="site-description motion-element" itemprop="description">博观而约取，厚积而薄发。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">78</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xusx1024" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XuShengSing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">

  <div class="powered-by"></div>

<!-- <span class="post-count">博客共字</span> -->

</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

  <!-- 背景动画 -->
<script type="text/javascript" src="/js/src/particle.js"></script>

</body>
</html>
