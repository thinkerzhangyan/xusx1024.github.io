{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.MDOWN","path":"README.MDOWN","modified":0,"renderable":0},{"_id":"source/images/Application_launch.jpg","path":"images/Application_launch.jpg","modified":0,"renderable":0},{"_id":"source/images/abstract_factory_class_diagram.png","path":"images/abstract_factory_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/SA&rank.png","path":"images/SA&rank.png","modified":0,"renderable":0},{"_id":"source/images/abstract_factory_product_level.png","path":"images/abstract_factory_product_level.png","modified":0,"renderable":0},{"_id":"source/images/abstract_factory_sequence_diagram.png","path":"images/abstract_factory_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/adb_launch_time.png","path":"images/adb_launch_time.png","modified":0,"renderable":0},{"_id":"source/images/alertDialog.png","path":"images/alertDialog.png","modified":0,"renderable":0},{"_id":"source/images/adm_question.png","path":"images/adm_question.png","modified":0,"renderable":0},{"_id":"source/images/andfix-yuanli.png","path":"images/andfix-yuanli.png","modified":0,"renderable":0},{"_id":"source/images/auth_sequence_diagram.png","path":"images/auth_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/bucket-sort-2.png","path":"images/bucket-sort-2.png","modified":0,"renderable":0},{"_id":"source/images/bucket-sort-1.png","path":"images/bucket-sort-1.png","modified":0,"renderable":0},{"_id":"source/images/cas.png","path":"images/cas.png","modified":0,"renderable":0},{"_id":"source/images/chain_of_responsibility_class_diagram.png","path":"images/chain_of_responsibility_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/chain_of_responsibility_sequence_diagram.png","path":"images/chain_of_responsibility_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/color-key-for-debug-GPU-overdraw-output.png","path":"images/color-key-for-debug-GPU-overdraw-output.png","modified":0,"renderable":0},{"_id":"source/images/counting_sort_1.png","path":"images/counting_sort_1.png","modified":0,"renderable":0},{"_id":"source/images/display_activity.png","path":"images/display_activity.png","modified":0,"renderable":0},{"_id":"source/images/dalvik&art.png","path":"images/dalvik&art.png","modified":0,"renderable":0},{"_id":"source/images/display_time.png","path":"images/display_time.png","modified":0,"renderable":0},{"_id":"source/images/factory_method_class_diagram.png","path":"images/factory_method_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/factory_method_sequence_diagram.png","path":"images/factory_method_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/favicon.jpg","path":"images/favicon.jpg","modified":0,"renderable":0},{"_id":"source/images/freud.jpg","path":"images/freud.jpg","modified":0,"renderable":0},{"_id":"source/images/interpreter_class_diagram.png","path":"images/interpreter_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-1.png","path":"images/nimabledroid-1.png","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-3.png","path":"images/nimabledroid-3.png","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-2.png","path":"images/nimabledroid-2.png","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-4.png","path":"images/nimabledroid-4.png","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-6.png","path":"images/nimabledroid-6.png","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-5.png","path":"images/nimabledroid-5.png","modified":0,"renderable":0},{"_id":"source/images/prefix_doubleing_demo_1.png","path":"images/prefix_doubleing_demo_1.png","modified":0,"renderable":0},{"_id":"source/images/profileGPURendering.png","path":"images/profileGPURendering.png","modified":0,"renderable":0},{"_id":"source/images/prototype_class_uml.png","path":"images/prototype_class_uml.png","modified":0,"renderable":0},{"_id":"source/images/prototype_sequence_uml.png","path":"images/prototype_sequence_uml.png","modified":0,"renderable":0},{"_id":"source/images/report_full_drawn.png","path":"images/report_full_drawn.png","modified":0,"renderable":0},{"_id":"source/images/simple_factory_class_diagram.png","path":"images/simple_factory_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/simple_factory_sequence_diagram.png","path":"images/simple_factory_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/strategy_pattern_class_diagram.png","path":"images/strategy_pattern_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/state_pattern_class_diagram.png","path":"images/state_pattern_class_diagram.png","modified":0,"renderable":0},{"_id":"source/images/state_pattern_sequence_diagram.png","path":"images/state_pattern_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/thread-read-write.jpg","path":"images/thread-read-write.jpg","modified":0,"renderable":0},{"_id":"source/images/strategy_pattern_sequence_diagram.png","path":"images/strategy_pattern_sequence_diagram.png","modified":0,"renderable":0},{"_id":"source/images/weixin.png","path":"images/weixin.png","modified":0,"renderable":0},{"_id":"source/images/window_uml.jpg","path":"images/window_uml.jpg","modified":0,"renderable":0},{"_id":"source/images/zhifubao.PNG","path":"images/zhifubao.PNG","modified":0,"renderable":0},{"_id":"source/images/why_need_lock.jpg","path":"images/why_need_lock.jpg","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-8.png","path":"images/nimabledroid-8.png","modified":0,"renderable":0},{"_id":"source/images/andfix-guocheng.png","path":"images/andfix-guocheng.png","modified":0,"renderable":0},{"_id":"source/images/android-singleton-1.png","path":"images/android-singleton-1.png","modified":0,"renderable":0},{"_id":"source/images/android-framework.png","path":"images/android-framework.png","modified":0,"renderable":0},{"_id":"source/images/android-singleton-2.png","path":"images/android-singleton-2.png","modified":0,"renderable":0},{"_id":"source/images/android-start-1.png","path":"images/android-start-1.png","modified":0,"renderable":0},{"_id":"source/images/android-start-2.png","path":"images/android-start-2.png","modified":0,"renderable":0},{"_id":"source/images/apk-build.jpg","path":"images/apk-build.jpg","modified":0,"renderable":0},{"_id":"source/images/bind_application.jpg","path":"images/bind_application.jpg","modified":0,"renderable":0},{"_id":"source/images/buckets_sort.png","path":"images/buckets_sort.png","modified":0,"renderable":0},{"_id":"source/images/jiezishu.jpg","path":"images/jiezishu.jpg","modified":0,"renderable":0},{"_id":"source/images/launch_android.png","path":"images/launch_android.png","modified":0,"renderable":0},{"_id":"source/images/nimabledroid-7.png","path":"images/nimabledroid-7.png","modified":0,"renderable":0},{"_id":"source/images/process_creation.jpg","path":"images/process_creation.jpg","modified":0,"renderable":0},{"_id":"source/images/radix_sort.png","path":"images/radix_sort.png","modified":0,"renderable":0},{"_id":"source/images/start_activity.jpg","path":"images/start_activity.jpg","modified":0,"renderable":0},{"_id":"source/images/window_layer.jpg","path":"images/window_layer.jpg","modified":0,"renderable":0},{"_id":"source/images/counting_sort_2.png","path":"images/counting_sort_2.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"source/images/banner.jpg","path":"images/banner.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/particle.js","path":"js/src/particle.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"source/images/activity-window-layer.jpg","path":"images/activity-window-layer.jpg","modified":0,"renderable":0},{"_id":"source/images/java_web_study_path.png","path":"images/java_web_study_path.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/images/executePhase.png","path":"images/executePhase.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/observer_pattern_class_diagram.png","path":"images/observer_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/observer_pattern_sequence_diagram.png","path":"images/observer_pattern_sequence_diagram.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"ade5084bc2268cad70fa91a177ff21e537983169","modified":1487228298683},{"_id":"source/README.MDOWN","hash":"333070538f45d2ca6a79d385c52c5c2dc62de6c2","modified":1496310320063},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1496297484613},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1496297484613},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1496297484615},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1496297484617},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1496297484617},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1496297484617},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1496297484618},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1496297484619},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1496297484619},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1496297484618},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1496297484619},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1496297484620},{"_id":"themes/next/_config.yml","hash":"c847400bc979ddff7b746123e1eeca36d7f53772","modified":1496364952489},{"_id":"themes/next/bower.json","hash":"936b9aed1934471bb74cdaacc3fb8031eb01fe23","modified":1496297484621},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1496297484621},{"_id":"themes/next/package.json","hash":"a5c189d4c4e946e936d3b5e29e2d81ddaf03ff96","modified":1496297484668},{"_id":"source/_posts/2017-02-06-first-post.md","hash":"b73b9997c557cb429252bca1aeef8c97c54c9d17","modified":1496300704534},{"_id":"source/_posts/2017-02-07-stack-with-getmin-fun.md","hash":"9aeb86482179aef5c3168254017023a42bfeddad","modified":1496300712309},{"_id":"source/_posts/2017-02-09-Debug-GPU-Overdraw-Walkthrough.md","hash":"df5ca155e00d4ca97b9844c72b65577dc582283b","modified":1496303270885},{"_id":"source/_posts/2017-02-10-how-use-android-device-monitor.md","hash":"785ce608f18665004a8f8d1ba5ea95abe1bbf6aa","modified":1496303199279},{"_id":"source/_posts/2017-02-09-Profile-Gpu-rendering.md","hash":"8b5c6c09542c0279a48c8b6631a00cceeca4aeb8","modified":1496303249562},{"_id":"source/_posts/2017-02-11-design-patterns-singleton-2.md","hash":"3ac2d4bcae22406bd9787b5e509ed8121c30528f","modified":1496303148799},{"_id":"source/_posts/2017-02-11-design-patterns-singleton-3.md","hash":"983ec796c9231cff5c13d7f00f64a415e6b77472","modified":1496303142479},{"_id":"source/_posts/2017-02-11-design-patterns-singleton-1.md","hash":"4e6ab7585035d472617c68c4e01abb97377b6720","modified":1496303163279},{"_id":"source/_posts/2017-02-11-reverse-stack.md","hash":"22ef786b8040036cf5d178323aeb8db4422d9dd7","modified":1496303118880},{"_id":"source/_posts/2017-02-12-design-patterns-singleton-4.md","hash":"10d33440b5ddfa848a551e77748b5c4c1b500a54","modified":1496303099225},{"_id":"source/_posts/2017-02-11-different-between-ADT.md","hash":"0002461216d4b3823c9d8b49ea0556772cf11bb8","modified":1496303131876},{"_id":"source/_posts/2017-02-16-get-max-window.md","hash":"57d804d5b0c20cab3b31787e42155a9a03105488","modified":1496302845499},{"_id":"source/_posts/2017-02-13-optimization-app-launch.md","hash":"1ca53a839aaf02b622c6cc028f8c646696b7ae0f","modified":1496303062207},{"_id":"source/_posts/2017-02-16-hanoi-problom.md","hash":"a32c27fae3d667ce9d07b61bcc1057686ebca49f","modified":1496302811976},{"_id":"source/_posts/2017-02-14-sort-stack-by-stack.md","hash":"3c7f7145282b3c021dc6d208563e112bf423c392","modified":1496302857897},{"_id":"source/_posts/2017-02-17-get-max-tree.md","hash":"a5e00b5cd90fbffece63c2013dfb1100a59c6a51","modified":1496302789907},{"_id":"source/_posts/2017-02-20-decrease-apk-size.md","hash":"aa40ac84a424b33a1896f1b9d517149c80bab9c8","modified":1496302756310},{"_id":"source/_posts/2017-02-21-design-patterns-singleton-5.md","hash":"271373c17f5fe627e21e7b1d18efabdadf9f93b0","modified":1496302630884},{"_id":"source/_posts/2017-02-22-android-system-service-all.md","hash":"2534b0950a03e32a369d038496680286cbe3d31f","modified":1496302525504},{"_id":"source/_posts/2017-02-23-java-volatile.md","hash":"068c8ad8708e6304cdad097fd5f8604103579a92","modified":1496302347884},{"_id":"source/_posts/2017-03-03-design-patterns-builder-1.md","hash":"aee53daac676ce299dd656eedd6da1a8b3f75525","modified":1496302077013},{"_id":"source/_posts/2017-02-23-android-system-service-LayoutInflater.md","hash":"cce0721a9fb1aaec162ff231f4fce0f3e8240603","modified":1496302425116},{"_id":"source/_posts/2017-03-02-android-system-service-window-manager.md","hash":"aabd4a29d30a4e16a885d5148f839732ebd7de35","modified":1496302170196},{"_id":"source/_posts/2017-03-03-design-patterns-builder-2.md","hash":"96b3870e3f9e57ebb92b3ba86643d9e56dd2335a","modified":1496302030773},{"_id":"source/_posts/2017-03-18-design-patterns-start.md","hash":"646d7dbaf16df459a8ffb150fe9e20881b71630a","modified":1496363875361},{"_id":"source/_posts/2017-03-27-kernel-user-space.md","hash":"4358701a73dc01097ecb7b59bafe07458884be09","modified":1496301809481},{"_id":"source/_posts/2017-03-19-design-patterns-prototype-2.md","hash":"91b5c179b56d97d69890138a78e6d150252d6bbd","modified":1496301832697},{"_id":"source/_posts/2017-03-30-tinker-source-code-2.md","hash":"a264f6e3379f49264df2f8ce7639553ebea6c7a2","modified":1496301753755},{"_id":"source/_posts/2017-03-30-tinker-source-code-3.md","hash":"9af545ebce4d6150a8a86d0e5dfe467eb6c85b78","modified":1496301731042},{"_id":"source/_posts/2017-03-01-kotlin-in-project.md","hash":"09f5658af7045a49e851fa33aa56ca96e1ce5bbb","modified":1496302206822},{"_id":"source/_posts/2017-02-11-two-stacks-makeup-queue.md","hash":"c08ac205e267f70187b056ebe0d2d75510701ee5","modified":1496303113396},{"_id":"source/_posts/2017-03-18-design-patterns-prototype-1.md","hash":"e34cc2f6142608b77ce7ee482abc66f8d13bc598","modified":1496364455047},{"_id":"source/_posts/2017-04-01-findbug-notes.md","hash":"950df07b2d2ca86fe5cd5f1d2e97591c21a42fe5","modified":1496301664950},{"_id":"source/_posts/2017-04-10-radix-sort.md","hash":"21fa6b628ca137726649e39c43e1a4d0fc449875","modified":1496301515942},{"_id":"source/_posts/2017-04-10-bucket-sort.md","hash":"21f72a34766105ca7d56f2887c55b95bccf678d3","modified":1496301615911},{"_id":"source/_posts/2017-04-11-counting-sort.md","hash":"212dd071ca88ae39e7917f117dc265a52011d10c","modified":1496301438448},{"_id":"source/_posts/2017-03-15-tinker-source-code-1.md","hash":"7d24c6d4bfcd8c6829cac3b77213a2b0d52c559b","modified":1496301966132},{"_id":"source/_posts/2017-04-11-suffix-sort-baseon-prefix-doubleing.md","hash":"e83afe6125579ee7a56cb3ada1650f41747f05a3","modified":1496301355886},{"_id":"source/_posts/2017-04-13-suffix-sort-baseon-dc3.md","hash":"b1f0ceb3430af9ab0728be36e160c5736e6aa212","modified":1496301207115},{"_id":"source/_posts/2017-05-15-javaee-tips.md","hash":"87ca1162b90ae7bd816282facabc5d2080b48409","modified":1496300884006},{"_id":"source/_posts/2017-05-09-android-develop-sdk-tips.md","hash":"ca93313b89a0e889b9339a4cfb55452c5ffbdede","modified":1496300922885},{"_id":"source/_posts/2017-05-18-android-system-service-CaptioningManager.md","hash":"4558ad4ee9c95d152b7ad9cb0f8b85427116e562","modified":1496299998813},{"_id":"source/_posts/2017-04-21-android-special-api.md","hash":"d044c13c697099723e71988a59d134f864cfa370","modified":1496300958071},{"_id":"source/_posts/2017-04-20-android-system-service-AccessibilityManager.md","hash":"8611ffbb9b33d0361b85d01e0117cbd71dcb116a","modified":1496301185458},{"_id":"source/_posts/2017-05-23-design-patterns-simple-factory.md","hash":"758f474846468277f1d412d7aa38a779a664033d","modified":1496299964960},{"_id":"source/_posts/2017-05-25-design-patterns-abstract-factory.md","hash":"8906833373247c74faee50dffbee585f7146afb4","modified":1496299804091},{"_id":"source/_posts/2017-05-25-design-patterns-strategy-pattern.md","hash":"58cf8f4a9f2e0ed1923f35b13e083899298c638c","modified":1496299595826},{"_id":"source/_posts/2017-05-24-design-patterns-factory-method.md","hash":"f7d30384a673c53c31c67e35c8ddee7899f1177b","modified":1496299864134},{"_id":"source/_posts/2017-05-31-anti-patterns-constant-interface.md","hash":"dcd105217523691efe4914d3be80f55bda496673","modified":1496299095750},{"_id":"source/_posts/2017-06-02-design-patterns-interpreter.md","hash":"b6f7e9e5e64540ff4f4c087b7167d0584081602b","modified":1496386905864},{"_id":"source/_posts/2017-05-26-design-patterns-state-pattern.md","hash":"8bd51d5a7d075e6fbf49effed8024b8e59d78a19","modified":1496299493387},{"_id":"source/_posts/2017-06-09-design-patterns-observer.md","hash":"a2fc95dab014dae5e9a4ee830a8d0f533bd1384c","modified":1497255722824},{"_id":"source/categories/index.md","hash":"90b0dd05e7d51a9877e0e134900d2ca8da4b5bdb","modified":1496300382475},{"_id":"source/_posts/2017-05-31-anti-patterns.md","hash":"2be24120b40b3c53015a27268bee63e5dc0179a1","modified":1496299398436},{"_id":"source/_posts/2017-05-31-design-patterns-chain-of-responsibility.md","hash":"bad1f9312c027bfbd17bda936fa6b60f52835f10","modified":1496307681372},{"_id":"source/images/Application_launch.jpg","hash":"d6683ac86c393d27adccc2c5c9a2b91797f8db5e","modified":1486970914262},{"_id":"source/images/abstract_factory_class_diagram.png","hash":"c0e466213adbf9931c6616057b7617372cd5a8be","modified":1495677427686},{"_id":"source/images/SA&rank.png","hash":"cba2f733f3df9592b626f087d03b14747dbcc363","modified":1491967520879},{"_id":"source/_posts/2017-04-01-android-study-path.md","hash":"6b3986d6560434dd4aac4cb1c28a11ff5adbf601","modified":1496301678848},{"_id":"source/images/abstract_factory_product_level.png","hash":"bcbe45cdd1b1f733f697cc1dbdbf6ad53f09ed26","modified":1495679636006},{"_id":"source/_posts/2017-04-07-git-command.md","hash":"479c1874ad1b747d01d1bbaf00844be8565373be","modified":1496301633325},{"_id":"source/images/abstract_factory_sequence_diagram.png","hash":"e04578d76c60f9bd05a6e9c9e4f077f1127c69e5","modified":1495678670690},{"_id":"source/_posts/2017-06-08-android-ipc-messenger-tips - 副本.md","hash":"a8eaf8fe7440e241294455e2e8d2132738b48e91","modified":1496912014054},{"_id":"source/images/adb_launch_time.png","hash":"b6880efe89603403fa3c8ea114c41cd4476480cc","modified":1487052269659},{"_id":"source/images/alertDialog.png","hash":"b1a4a11ae6842152215a369a3ba0ac63b6e0467b","modified":1489579827478},{"_id":"source/images/adm_question.png","hash":"16e6f5732a97f4f6befad08cea95e2becabe707e","modified":1486636592674},{"_id":"source/images/andfix-yuanli.png","hash":"9a6606d861e34760311ab0802898a8da64cc3837","modified":1490853022941},{"_id":"source/images/auth_sequence_diagram.png","hash":"9c7a7d8e7448dd8fffd466e12985e2a1df804d01","modified":1496909629143},{"_id":"source/images/bucket-sort-2.png","hash":"accd3506e9d5601e300163825057b89daabd7d18","modified":1491817608442},{"_id":"source/images/bucket-sort-1.png","hash":"d2940855ea9a6787ebb32a3f934e08dc778f3c77","modified":1491817600790},{"_id":"source/images/cas.png","hash":"7242110c25aeb18b24d04f0f43c40e0f91c17236","modified":1487829400646},{"_id":"source/images/chain_of_responsibility_class_diagram.png","hash":"0abcf5464f6e932116cf458b9086f67c09d6aab1","modified":1496199741997},{"_id":"source/images/chain_of_responsibility_sequence_diagram.png","hash":"c8cd464b1f95cec18f88f58a74e2f63f20c6df99","modified":1496200207473},{"_id":"source/images/color-key-for-debug-GPU-overdraw-output.png","hash":"4d59e7f47921bbf3e92d5427bc15cfede1488fb7","modified":1486623494826},{"_id":"source/images/counting_sort_1.png","hash":"d8103872bcdfaa6d5a3929f6b66a6a2662bbfa7b","modified":1491891306062},{"_id":"source/images/display_activity.png","hash":"b610bec11cb27ae9c4f4d6ac23ee2ba8f8eeea2f","modified":1487043483456},{"_id":"source/images/dalvik&art.png","hash":"d5863fd26b9cf58eda0f1f94f4628378e4c9a360","modified":1490844718748},{"_id":"source/images/display_time.png","hash":"6f501173846bfb463090ebb95b8d14a615e5674d","modified":1487044421629},{"_id":"source/images/factory_method_class_diagram.png","hash":"bab58386656070f96e1e90fbc0fdf054a49e9421","modified":1495606530857},{"_id":"source/images/factory_method_sequence_diagram.png","hash":"4835d6de18f5f4321a9de33df2f2dd037c77ba5e","modified":1495607020115},{"_id":"source/images/favicon.jpg","hash":"b177f603573fbc6a9e1625fa772ec7205769e852","modified":1469170995790},{"_id":"source/images/freud.jpg","hash":"9357a1a99b199e45887664c60f0f0f11f24041ec","modified":1486363512704},{"_id":"source/images/interpreter_class_diagram.png","hash":"6f7e54dd97607bc6d93ebcbe1784d4dd9e257cca","modified":1496385969235},{"_id":"source/images/logo.jpg","hash":"3eb36e46abf8a787451602b2ddffcf6bb09a6399","modified":1486450208784},{"_id":"source/images/nimabledroid-1.png","hash":"6586e412624c993930f805c86e41d0c0b2654f94","modified":1487571934483},{"_id":"source/images/nimabledroid-3.png","hash":"e796783e61b8fe32567653d078d13404a0af1ba1","modified":1487572981474},{"_id":"source/images/nimabledroid-2.png","hash":"65bf7c4291610546e76f44d569f1be171fe57f0f","modified":1487572357630},{"_id":"source/images/nimabledroid-4.png","hash":"847fc2be037605236a1f2b63ce00a003f51a8ac0","modified":1487573340332},{"_id":"source/images/nimabledroid-6.png","hash":"464ab8612bdd72ea1a4b8fe36bb12a2fc39d6d1a","modified":1487575007185},{"_id":"source/images/nimabledroid-5.png","hash":"b23531d50109d46e72638565e91894f3f95f0097","modified":1487573490523},{"_id":"source/images/prefix_doubleing_demo_1.png","hash":"9c567fbb4d66317428cf0e1600e21fe0b6c3de1f","modified":1492051945807},{"_id":"source/images/profileGPURendering.png","hash":"e708185ee02ef267aaae5a556b2f6192ed0c37db","modified":1486610828032},{"_id":"source/images/prototype_class_uml.png","hash":"59db65d97c32c411d02c0260bf7f6b9ababc5574","modified":1489988778878},{"_id":"source/images/prototype_sequence_uml.png","hash":"6bb2bfc16855bd8f1520922854269ca69ec4de92","modified":1489988778880},{"_id":"source/images/report_full_drawn.png","hash":"b741e0e7e917080d77c0b67de552d5bf586c258d","modified":1487054066113},{"_id":"source/images/simple_factory_class_diagram.png","hash":"c9a60d7d16a5100c862351012c4fa95ff9937a62","modified":1495530790779},{"_id":"source/images/simple_factory_sequence_diagram.png","hash":"83a65c92511df27418d6ad52128c16ccd0178a70","modified":1495607141686},{"_id":"source/images/strategy_pattern_class_diagram.png","hash":"fae1e60d37de870a9af4801c9b208f3988404a88","modified":1495696109940},{"_id":"source/images/state_pattern_class_diagram.png","hash":"8ccc786c93967c02ea18c33c641c1df90a0421a0","modified":1495857456210},{"_id":"source/images/state_pattern_sequence_diagram.png","hash":"ff39a9772c06b964949d6ec02475972f4dfeccae","modified":1496195062893},{"_id":"source/images/thread-read-write.jpg","hash":"7580f93e70460f1b1505ede59c4275347ced7115","modified":1487815329892},{"_id":"source/images/strategy_pattern_sequence_diagram.png","hash":"a7b78bd51a57cf1cb9f03e40c55efdb2a5b7c2fb","modified":1495696701537},{"_id":"source/images/weixin.png","hash":"8440a3c8373959f478b3157ccab4757177e1a26a","modified":1486367323710},{"_id":"source/tags/index.md","hash":"91194adb308c25130702a2d8d0f772a3801a8992","modified":1496300609182},{"_id":"source/images/window_uml.jpg","hash":"765d329cd78215084c4948c3d1b7e16a31b0e47f","modified":1488445004924},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"6070278c2e3b31bc1e40c485f66da5336bd2cbb0","modified":1496306036064},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1496297484603},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1496297484596},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1496297034938},{"_id":"source/images/zhifubao.PNG","hash":"c63413255fb1ce7fc4fbcfc111d778eb15d7a311","modified":1486365955635},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1496297484616},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"4de856de657a27f340f245eb491a1f52ceba1735","modified":1496297484616},{"_id":"source/images/why_need_lock.jpg","hash":"0af05020d7e3eb07f9ac89546700f572ad330a05","modified":1487832203771},{"_id":"source/images/nimabledroid-8.png","hash":"f5a6abb86c236c06aeb499a365e837e88fb33e79","modified":1487577966839},{"_id":"themes/next/.git/packed-refs","hash":"563200918c3db98fcd347e91e8e9a5c1d211b309","modified":1496297484590},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1496297484669},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1496297484670},{"_id":"themes/next/.git/index","hash":"84df8f0eee70a1f0a50d132276cac81ff71b98c5","modified":1496306027407},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1496297484813},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1496297484814},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1496297484814},{"_id":"source/images/andfix-guocheng.png","hash":"7c93e893cd6c6671329a11f1bf8decc42c6f86ef","modified":1490853038512},{"_id":"source/images/android-singleton-1.png","hash":"fd6ab0facbbab4aad00bb97a14e6fde34c652dce","modified":1487644625164},{"_id":"source/images/android-framework.png","hash":"230c46a62b62d7ef52794f90a9edb1d6bf98103c","modified":1466994725423},{"_id":"source/images/android-singleton-2.png","hash":"18d9b78197c5c7d212cce529c19991b80a860eb9","modified":1487654246983},{"_id":"source/images/android-start-1.png","hash":"e4d5954607ba63ec61e3453782ca07c698ef1981","modified":1488425852425},{"_id":"source/images/android-start-2.png","hash":"ded4bfb0aede0b4014560e617dced60d0a89daa6","modified":1488425752626},{"_id":"source/images/apk-build.jpg","hash":"5644bbecb5a042ba8f98fbe531f8d13fb7c31180","modified":1487812074207},{"_id":"source/images/bind_application.jpg","hash":"77f938f4d138a8cbd2700ff1234f5a8690d6dc6c","modified":1487041684318},{"_id":"source/images/buckets_sort.png","hash":"6fa55aa83587eb6715d7452ebf2eb1249845a6bf","modified":1491815003024},{"_id":"source/images/jiezishu.jpg","hash":"93fd6ae5c99759843193e372dad75d7361505418","modified":1486363512706},{"_id":"source/images/launch_android.png","hash":"ded4bfb0aede0b4014560e617dced60d0a89daa6","modified":1488421669608},{"_id":"source/images/nimabledroid-7.png","hash":"1b49612acbfff4dbf21943a71d0a1df01a53aa21","modified":1487576625904},{"_id":"source/images/process_creation.jpg","hash":"bf904f21499ae9777995e9294df6970601711236","modified":1487041453091},{"_id":"source/images/radix_sort.png","hash":"3a7613976d28adcb24a2e8b807baa7838193f36f","modified":1491812052327},{"_id":"source/images/start_activity.jpg","hash":"f9ff94c1e1643f253544813cf414cd8a44a90a99","modified":1487042238975},{"_id":"themes/next/layout/archive.swig","hash":"a1d1e91013baaaeb7deaf35c6d3975971ce38e02","modified":1496297484665},{"_id":"themes/next/layout/category.swig","hash":"f315f12651de8065fdad73b003da4335ef177173","modified":1496297484665},{"_id":"themes/next/layout/_layout.swig","hash":"7dcdf10b62918f1a37ee7220d6dcd9269604581b","modified":1496307274591},{"_id":"themes/next/layout/schedule.swig","hash":"8086f1163b10460258ecbbbe48b057b22bb2f02e","modified":1496297484667},{"_id":"themes/next/layout/tag.swig","hash":"cc9878932580c890f8f3e569225e29bb37e25b49","modified":1496297484668},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1496297484666},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1496297484667},{"_id":"themes/next/layout/page.swig","hash":"22ba721a9688d490fc66f360e5a319288b63b05a","modified":1496297484666},{"_id":"source/images/window_layer.jpg","hash":"fc810796fc8470dbcf319d3b38eb548d16bb2409","modified":1488441257895},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1496297484622},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1496297484623},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1496297484623},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1496297484625},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1496297484626},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1496297484626},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1496297484627},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1496297484624},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1496297484624},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1496297484625},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3111ce4cc5f30868b3628f9f805d2aef3b75d1c1","modified":1496297484627},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1496297484628},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1496297484627},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484726},{"_id":"source/images/counting_sort_2.png","hash":"0723b9f177fc026062d9d7d42ad074874b216744","modified":1491891439935},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1496297034946},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1496297034939},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1496297034940},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1496297034941},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1496297034940},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1496297034944},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1496297034942},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1496297034943},{"_id":"themes/next/.git/logs/HEAD","hash":"72708db86b454856abfb7c1b50eb704f5d315603","modified":1496306036069},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1496297034945},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1496297034945},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1496297034943},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1496297484670},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1496297484671},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1496297484671},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1496297484672},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1496297484672},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1496297484673},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1496297484673},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1496297484728},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1496297484728},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1496297484727},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1496297484731},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1496297484731},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1496297484729},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1496297484730},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1496297484732},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1496297484732},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1496297484733},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1496297484732},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1496297484734},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1496297484729},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1496297484733},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1496297484726},{"_id":"source/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1496286231020},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1496297484629},{"_id":"themes/next/layout/_partials/head.swig","hash":"09b110f77c415c5b71ebd886771a10bc84b95633","modified":1496297484635},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1496297484637},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1496297484637},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1496297484637},{"_id":"themes/next/layout/_partials/footer.swig","hash":"5bb9b02b1cdf24569d468c1ca2c9ee545d8358bd","modified":1496309907512},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5258c03149aa18e9abfeb8de10e435a406d9c924","modified":1496297484634},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1496297484629},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1496297484638},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1496297484642},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1496297484643},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1496297484658},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1496297484659},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1496297484661},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1496297484660},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1496297484645},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1496297484659},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1496297484660},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1496297484630},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1496297484632},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1496297484633},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1496297484631},{"_id":"themes/next/layout/_macro/post.swig","hash":"6f3c6078b9dbc238ccf86fb228c24c0b94f67d47","modified":1496297484631},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"4b029551ddb44c53f895e96cf8ff5ffbe02322fb","modified":1496297484633},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484710},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484709},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484711},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484724},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484725},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484644},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484644},{"_id":"themes/next/.git/objects/f6/2b02317374740a2b286814eb8008e12341431c","hash":"f8dd696af6b5a7f92fda1e4ad3a2056fb600218a","modified":1496306036065},{"_id":"themes/next/.git/objects/50/50716176f1fb5c6ac661d827006e260ca25328","hash":"3b0b9213cec7c64997dea871fc0f921a293cdb61","modified":1496306027406},{"_id":"themes/next/.git/refs/heads/master","hash":"ddccc60ee50c8fca1811f756ccaa3bcdbe2b6cfb","modified":1496306036068},{"_id":"themes/next/.git/objects/50/7a32b3adba9938ecf9eef90a55a395758eb4da","hash":"788128321c30ad07f19729747d394f26e3ea116e","modified":1496306021850},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1496297484735},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1496297484735},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ec035e20d1f26bf553a79877180ba312bea885c","modified":1496297484736},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1496297484736},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1496297484737},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1496297484738},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1496297484737},{"_id":"themes/next/source/js/src/particle.js","hash":"914c8e99af756e7004359aaa71fee4e59f214649","modified":1496307229919},{"_id":"themes/next/source/js/src/post-details.js","hash":"bfaf52b69aad96566aa21b785973441a2555b4ba","modified":1496297484738},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1496297484709},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1496297484739},{"_id":"themes/next/source/js/src/utils.js","hash":"c976214b8bbaa9512b886bf3687e94696f705e33","modified":1496297484740},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1496297484740},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1496297484710},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1496297484711},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1496297484753},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1496297484723},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"68db2c0bf1064176627199394f25f6dc37ea23ad","modified":1496297484754},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1496297484749},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1496297484724},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dacede1cc110c762e7a5468dc0e34ae1a962d5aa","modified":1496297484725},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1496297484787},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1496297484764},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1496297484766},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1496297484765},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1496297484769},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1496297484765},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1496297484769},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1496297484768},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1496297484770},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1496297484770},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1496297484754},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1496297484755},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1496297484800},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1496297484800},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1496297484801},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1496297484793},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1496297484792},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1496297484793},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1496297484794},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1496297484794},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1496297484796},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1496297484795},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1496297484795},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1496297484796},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1496297484798},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1496297484799},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1496297484789},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1496297484798},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1496297484797},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1496297484797},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1496297484790},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1496297484791},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1496297484792},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1496297484791},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1496297484808},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1496297484808},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1496297484789},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1496297484811},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1496297484813},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1496297484812},{"_id":"source/images/activity-window-layer.jpg","hash":"652713e1e4c2feefd06cefa58fb09e0710b67eae","modified":1487918148014},{"_id":"source/images/java_web_study_path.png","hash":"3842d0a0718999b0dd3b9b52e37e896a922888ae","modified":1495021333231},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1496297484636},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1496297484639},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1496297484638},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1496297484645},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1496297484639},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1496297484652},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1496297484636},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"0f38f053841ef77cdce56a84cfbb4dd4c3329486","modified":1496297484653},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"0399bbdc524ba50930cb6f8e2d5628ff682fc612","modified":1496297484654},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1496297484651},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"de95ec8920d1660680078451008f8bd69f14d082","modified":1496297484655},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1496297484646},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1496297484647},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1496297484647},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1496297484648},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"c75024151fc63220e7d01035d8a1aff9affdecc7","modified":1496297484654},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1496297484648},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1496297484649},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1496297484652},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1496297484647},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1496297484650},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1496297484653},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1496297484650},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1496297484649},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1496297484640},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1496297484651},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1496297484643},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1496297484665},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1496297484641},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1496297484662},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1496297484664},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"a0c042a74ea1afcb19daac7e2604a2bc5495037b","modified":1496297484663},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1496297484641},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1496297484640},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1496297484788},{"_id":"source/images/executePhase.png","hash":"db3135e42a00e47cad7b3a3be301438f82969b20","modified":1486621071269},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"72708db86b454856abfb7c1b50eb704f5d315603","modified":1496306036070},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1496297484594},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1496297484739},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1496297484718},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1496297484717},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1496297484717},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1496297484720},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1496297484719},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1496297484722},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1496297484722},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1496297484712},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1496297484721},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1496297484721},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1496297484718},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1496297484722},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1496297484713},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1496297484714},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1496297484712},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1496297484715},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1496297484714},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1496297484706},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1496297484713},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4ba6f2a615693b9b5afc266d9c833697016085fd","modified":1496297484675},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1496297484676},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1496297484677},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1496297484685},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1496297484676},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"1dc2ed435e41ca041f43bd9633d5d95139afbb42","modified":1496297484675},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1496297484697},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1496297484748},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4998bedff9c84a09a294b8ef36ede2e3644d3528","modified":1496297484706},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"95518d298d3c5c271faec2e4977df9e5dedd5d84","modified":1496297484747},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1496297484708},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1496297484707},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1496297484708},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1496297484707},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1496297484768},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1496297484767},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1496297484771},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1496297484773},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1496297484772},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1496297484755},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1496297484756},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1496297484756},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1496297484757},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1496297484758},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1496297484758},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1496297484762},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1496297484763},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1496297484764},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1496297484806},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1496297484807},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1496297484662},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1496297484662},{"_id":"themes/next/.git/objects/pack/pack-3595cf5ed2e58730f18acba487797f4280a52c6f.idx","hash":"b3e79ce106d78a3125b9530d58dc6cbafeafd73d","modified":1496297484505},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1496297484746},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"524cfca7b6ab135d81ea723d8de06fdf0dbe7e56","modified":1496297484745},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1496297484786},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1496297484785},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1496297484810},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"e926e30eca94fc2adcd9132d9e5d6f88b114b05f","modified":1496297484594},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1496297484719},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1496297484715},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1496297484716},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1496297484677},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1496297484678},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1496297484678},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1496297484686},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1496297484685},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1496297484687},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1496297484679},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1496297484679},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1496297484686},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1496297484680},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1496297484687},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"658accf8e196721f295003da66941e6d1f7b81b0","modified":1496297484688},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1496297484690},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1496297484690},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2cb09973d29a8e34e2a3425ac6e0938296970d8e","modified":1496297484691},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1496297484689},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"268c9704481fdb0b4d1e646196386143990fe235","modified":1496297484691},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1496297484690},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1496297484689},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1496297484688},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bc08cfb2ef2ff44ba3fc7dffdb2deb01a9d17d15","modified":1496297484692},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1496297484682},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1496297484684},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1496297484681},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1496297484680},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1496297484683},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1496297484682},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1496297484702},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1496297484683},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"cd526e814f9323a79fe835085d64867d34b3715d","modified":1496297484703},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1496297484704},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1496297484704},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"eb45ee16051624c6e36a274c0a9538e961f10c4d","modified":1496297484705},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1496297484692},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1496297484684},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1496297484701},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1496297484704},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1496297484694},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1496297484701},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1496297484703},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1496297484693},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c9f76d4f6806ef70fa2160c97afa0a0e0ae5373e","modified":1496297484696},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1496297484695},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1496297484695},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1496297484694},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1496297484696},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1496297484697},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1496297484742},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1496297484698},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1496297484699},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1496297484742},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1496297484744},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1496297484743},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1496297484700},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"8420b4be386469337243336aee694297875bd439","modified":1496297484700},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1496297484699},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1496297484775},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1496297484698},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1496297484778},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1496297484784},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1496297484760},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1496297484761},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1496297484759},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1496297484759},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1496297484761},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1496297484761},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1496297484752},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1496297484805},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1496297484782},{"_id":"themes/next/.git/objects/pack/pack-3595cf5ed2e58730f18acba487797f4280a52c6f.pack","hash":"304720442ad2c867514e7afe59c469bf14d7c347","modified":1496297484513},{"_id":"source/images/observer_pattern_class_diagram.png","hash":"4a1ac8301f3bfd6f7449d63d1d82d410dbe54076","modified":1497248504012},{"_id":"source/images/observer_pattern_sequence_diagram.png","hash":"2f178bb114c24c65c75a90d1ec9b39428a34f5b3","modified":1497249548256},{"_id":"public/categories/index.html","hash":"6e6efffc0a193b69fb3f23c20854e10778931c7e","modified":1497267232022},{"_id":"public/tags/index.html","hash":"1003826b3cfe9f2ec14a7cb8f663c2c171fcf8e9","modified":1497267232022},{"_id":"public/2017/05/17/javaee-tips/index.html","hash":"a3689bd7a491d0cea8220bbafc6cff2bb9aada84","modified":1497267232022},{"_id":"public/2017/03/19/design-patterns-prototype-2/index.html","hash":"6272b1f269f8c3a6ee94ca9a231a0f3f1072a195","modified":1497267232022},{"_id":"public/2017/02/06/first-post/index.html","hash":"50012006d1f11e0ac3b60cc6e15e9a0025a12c10","modified":1497267232023},{"_id":"public/archives/page/6/index.html","hash":"26c381af2edcaeeb66ebb2eeefe5e797dae64cba","modified":1497267232023},{"_id":"public/archives/2017/02/page/3/index.html","hash":"ba1e79f08470b073405f07d6aa216fc6c0ef32a2","modified":1497267232023},{"_id":"public/archives/2017/03/page/2/index.html","hash":"e6e4a05742c244f5f28a5fc63bdb0e834a1a90ea","modified":1497267232023},{"_id":"public/archives/2017/05/page/2/index.html","hash":"89e053b10c1a17c2e0af59890a7de1e95d5d60c7","modified":1497267232023},{"_id":"public/archives/2017/page/6/index.html","hash":"c773861baedf5bca298e48ad4b27bb83f4eb17c1","modified":1497267232023},{"_id":"public/archives/2017/06/index.html","hash":"aa3fe84f29d8d1b8f49e6ae7d5dd48a8086e157d","modified":1497267232023},{"_id":"public/tags/算法/page/2/index.html","hash":"eb837f2394b624dc1ccc553cd1c8eac49c3f63c2","modified":1497267232023},{"_id":"public/categories/work/page/6/index.html","hash":"9802e1eec4dbd1454869344d4c95de4b48db6c10","modified":1497267232023},{"_id":"public/tags/杂项/index.html","hash":"f96047f46dfb8e847f03e24cd813b95a494e25de","modified":1497267232023},{"_id":"public/tags/android/page/2/index.html","hash":"9a76f60acf27387f5bb0776f2b52ac5f2634537a","modified":1497267232023},{"_id":"public/2017/06/09/design-patterns-observer/index.html","hash":"aecde607a0d66e82117769f39f33c20dec823fb1","modified":1497267232023},{"_id":"public/2017/06/08/android-ipc-messenger-tips - 副本/index.html","hash":"b72018d3874dc99c1013cb849c9e7c9c2900c46a","modified":1497267232023},{"_id":"public/2017/06/02/design-patterns-interpreter/index.html","hash":"aa88577453b72b1885ec9b23904f8e4c7d1f95ae","modified":1497267232023},{"_id":"public/2017/05/26/design-patterns-state-pattern/index.html","hash":"60ea5c6e1ecf8795177b08a6ade79cf961226ce6","modified":1497267232023},{"_id":"public/2017/05/31/design-patterns-chain-of-responsibility/index.html","hash":"2a942f5c44c9fd924280fc727a8c9fb61d090404","modified":1497267232023},{"_id":"public/2017/05/31/anti-patterns-constant-interface/index.html","hash":"5e2db8c24d5fb827fe4a22a2db2384e390a6b758","modified":1497267232023},{"_id":"public/2017/05/31/anti-patterns/index.html","hash":"a685b71f9061129ae53f850ca1227b147224609f","modified":1497267232023},{"_id":"public/2017/05/25/design-patterns-abstract-factory/index.html","hash":"bedc69d369043629eee7419a6628679513cf5fe8","modified":1497267232023},{"_id":"public/2017/05/25/design-patterns-strategy-pattern/index.html","hash":"9ca0b3c0a6e7ad71c6eb720ef66187394a464466","modified":1497267232023},{"_id":"public/2017/05/24/design-patterns-factory-method/index.html","hash":"fa8d7bd3ff8a98a905aecebae148fae7c9238040","modified":1497267232024},{"_id":"public/2017/05/23/design-patterns-simple-factory/index.html","hash":"0f4f9b6e1127cdd69a48b5edf13930426ed9da8a","modified":1497267232024},{"_id":"public/2017/05/18/android-system-service-CaptioningManager/index.html","hash":"8ef895be939565e816375e4ff200334b8f1557d9","modified":1497267232024},{"_id":"public/2017/05/09/android-develop-sdk-tips/index.html","hash":"e90f600ea160dc22882ff45ee7b4b421805b6cf2","modified":1497267232024},{"_id":"public/2017/04/13/suffix-sort-baseon-dc3/index.html","hash":"41c049a9fac7a4ae42294c71dc387cd5d9834a4d","modified":1497267232024},{"_id":"public/2017/04/20/android-system-service-AccessibilityManager/index.html","hash":"4ced5994b3a89b37203479b5c924f82f4167d38b","modified":1497267232024},{"_id":"public/2017/04/21/android-special-api/index.html","hash":"4ebe9c0a14e2ecefa60d081c1bc4bd85a8ef0815","modified":1497267232024},{"_id":"public/2017/04/11/suffix-sort-baseon-prefix-doubleing/index.html","hash":"39ca4c60dcfd8a4431a072df708abb1589485f43","modified":1497267232024},{"_id":"public/2017/04/07/git-command/index.html","hash":"8707b761b6173b8740baf40e8d69ada549cbcaa1","modified":1497267232024},{"_id":"public/2017/04/10/radix-sort/index.html","hash":"9460b3706a8df78abecc949d1ea5976d84158a61","modified":1497267232024},{"_id":"public/2017/04/10/bucket-sort/index.html","hash":"77658968612377fa641672fc0dd18f067dc734cb","modified":1497267232024},{"_id":"public/2017/04/11/counting-sort/index.html","hash":"096c44820d0a89b2155a8b5c5ff4051c1c1eef1d","modified":1497267232024},{"_id":"public/2017/04/01/android-study-path/index.html","hash":"94b4ebae443c57a0fb5a48268feb6644f409ce19","modified":1497267232024},{"_id":"public/2017/04/01/findbug-notes/index.html","hash":"a8a54c4f1b8484ce7955e93174206e059242af00","modified":1497267232024},{"_id":"public/2017/03/18/design-patterns-prototype-1/index.html","hash":"27642cbc393140f042fd7a303b2fef9e1955d067","modified":1497267232024},{"_id":"public/2017/03/18/design-patterns-start/index.html","hash":"dd205b3a0957c1f43114414c68f860620a4ff926","modified":1497267232024},{"_id":"public/2017/03/15/tinker-source-code-1/index.html","hash":"fbcc30f63fcfcd0fcff33ef9df331fc9392b2cd9","modified":1497267232024},{"_id":"public/2017/03/03/design-patterns-builder-2/index.html","hash":"1e5fd55d1e023baf7cbc21a70b9f147ec3c3ee73","modified":1497267232024},{"_id":"public/2017/03/03/design-patterns-builder-1/index.html","hash":"de5cd659f3768d9b85d685a8419d9e694e73c042","modified":1497267232024},{"_id":"public/2017/03/30/tinker-source-code-3/index.html","hash":"69a4db672faabf1982c444807932656de69596cc","modified":1497267232025},{"_id":"public/2017/03/27/kernel-user-space/index.html","hash":"71b12c0705fce761517c375f6e68a46c2f8de136","modified":1497267232025},{"_id":"public/2017/03/30/tinker-source-code-2/index.html","hash":"ab60038aa25e1d413a21f3f7955a285f0065ee6a","modified":1497267232025},{"_id":"public/2017/03/01/kotlin-in-project/index.html","hash":"0ae513a1df335ff2f967adcc668602c18f5ae899","modified":1497267232025},{"_id":"public/2017/02/22/android-system-service-all/index.html","hash":"cb2bb22e5e41b32fdc7032829252dfcc004a7caa","modified":1497267232025},{"_id":"public/2017/02/23/android-system-service-LayoutInflater/index.html","hash":"b0815c7dadeca3eeecd9693869a00d6e3f6a83ab","modified":1497267232025},{"_id":"public/2017/03/02/android-system-service-window-manager/index.html","hash":"bf53300b947235221978a84d8566f2aa6090b11e","modified":1497267232025},{"_id":"public/2017/02/17/get-max-tree/index.html","hash":"82612a1bdfe8c67aa5977165a7e5b2a3f091d475","modified":1497267232025},{"_id":"public/2017/02/21/design-patterns-singleton-5/index.html","hash":"c3b3dfc753b7b43a0e14e1ce8c95ac2ef5f331ab","modified":1497267232025},{"_id":"public/2017/02/16/get-max-window/index.html","hash":"98946067db70608a69f49a95b9a0d74ad26a8e58","modified":1497267232025},{"_id":"public/2017/02/23/java-volatile/index.html","hash":"f48b054ee96e9ea289d5c0ff84d5752e39e6dcca","modified":1497267232025},{"_id":"public/2017/02/20/decrease-apk-size/index.html","hash":"9116f555e5ff82c639baa094e6dee139670c034a","modified":1497267232025},{"_id":"public/2017/02/16/hanoi-problom/index.html","hash":"7602386ef5d09b14a18382b8eb3b74f540f184a7","modified":1497267232025},{"_id":"public/2017/02/13/optimization-app-launch/index.html","hash":"452aa0dba876f0a5d7ac5c8ccb0094cfd8a2dec3","modified":1497267232025},{"_id":"public/2017/02/12/design-patterns-singleton-4/index.html","hash":"63a1cad9ba93bea36c7384a946d20ce21dad3078","modified":1497267232025},{"_id":"public/2017/02/14/sort-stack-by-stack/index.html","hash":"6c95372240fd5915cc09449da164a401f7f1d904","modified":1497267232025},{"_id":"public/2017/02/11/different-between-ADT/index.html","hash":"9d0b199eb6081cd7e537d5277e60a8847e568748","modified":1497267232025},{"_id":"public/2017/02/11/design-patterns-singleton-2/index.html","hash":"e331f0416f4a0d513e53318754705e262f9c114d","modified":1497267232025},{"_id":"public/2017/02/11/design-patterns-singleton-1/index.html","hash":"2a7b1b788621af717c536c40b716f8d187e1dacf","modified":1497267232025},{"_id":"public/2017/02/11/two-stacks-makeup-queue/index.html","hash":"7f49fb45a8793fe8c4f67dca092c3246807e93c8","modified":1497267232025},{"_id":"public/2017/02/11/design-patterns-singleton-3/index.html","hash":"654f86a65fae12a079a50998518b0c43ac509f17","modified":1497267232025},{"_id":"public/2017/02/09/Profile-Gpu-rendering/index.html","hash":"8cb2382fed19b4399c342ffca517660cf7002c45","modified":1497267232025},{"_id":"public/2017/02/09/Debug-GPU-Overdraw-Walkthrough/index.html","hash":"2f814a84d0aa013d2eea381003f1730a13ed4901","modified":1497267232025},{"_id":"public/2017/02/07/stack-with-getmin-fun/index.html","hash":"0f36a1a4e0df1e7cd25230d270a7ce9b25bd3850","modified":1497267232025},{"_id":"public/2017/02/10/how-use-android-device-monitor/index.html","hash":"09e122b88c65b211e2680250a22ae1f0619e580d","modified":1497267232026},{"_id":"public/2017/02/11/reverse-stack/index.html","hash":"0a02e7788b9924d4dc4f5446961fc936504a0c20","modified":1497267232026},{"_id":"public/archives/index.html","hash":"9c30d8bc7891e528893c325981fce240d35c426d","modified":1497267232026},{"_id":"public/archives/page/2/index.html","hash":"2557d3fe1858ec1afb5892a5cf9fb77cd25293bf","modified":1497267232026},{"_id":"public/archives/page/5/index.html","hash":"d469a96bc8000aabc450fec24a99cf05336f104a","modified":1497267232026},{"_id":"public/archives/page/4/index.html","hash":"34b33f96fae996d48c8bf08cd0d0bea9edcf64ae","modified":1497267232026},{"_id":"public/archives/page/3/index.html","hash":"6c4a0ab892a4db89bb5d1726ad0468b08591201f","modified":1497267232026},{"_id":"public/archives/2017/index.html","hash":"3d2ecaa602f4e2fad16e291b193ef014567bd61c","modified":1497267232026},{"_id":"public/archives/2017/page/2/index.html","hash":"d85ceab35e54dfbb85f9cf920cf4b5dfe73a389d","modified":1497267232026},{"_id":"public/archives/2017/page/5/index.html","hash":"e42132ced69166b110e34caeb44499c2f87731c3","modified":1497267232026},{"_id":"public/archives/2017/page/3/index.html","hash":"58b3db271fb2a1f5fc1ddad27c96250a953296f0","modified":1497267232026},{"_id":"public/archives/2017/02/index.html","hash":"f6a53fd8cc193cee9bb8eb5174f9c04377706367","modified":1497267232026},{"_id":"public/archives/2017/02/page/2/index.html","hash":"87d4a073895876d9c331d1e1573cbda07f24bd39","modified":1497267232026},{"_id":"public/archives/2017/03/index.html","hash":"2a94f9d0162eae1a1005cb409dfd5bdf7d8a857a","modified":1497267232026},{"_id":"public/archives/2017/04/index.html","hash":"88eb3348ade732792388e025927b756aa79fb476","modified":1497267232026},{"_id":"public/archives/2017/05/index.html","hash":"5a5ea864f9332fbd5d4267cf1e52145251de6f64","modified":1497267232026},{"_id":"public/archives/2017/page/4/index.html","hash":"a7fdd47026083eced29953cda9e2d3e25d090488","modified":1497267232026},{"_id":"public/categories/work/index.html","hash":"404158ddf1566931160a8660fd8f199ede908634","modified":1497267232026},{"_id":"public/categories/work/page/2/index.html","hash":"d68f7e1f6c4cb9c3dc8248a3c20274b7a90622f0","modified":1497267232026},{"_id":"public/categories/work/page/5/index.html","hash":"2ab92aae18f96ca13d543130d4e7f5390452d5f8","modified":1497267232026},{"_id":"public/categories/work/page/3/index.html","hash":"62b33777358969115d678bc15fd351721850ba9b","modified":1497267232026},{"_id":"public/index.html","hash":"eb6caf33d222c501d3df961aa0cc8d2020de3d4d","modified":1497267232026},{"_id":"public/categories/work/page/4/index.html","hash":"593137bc5329048edbd59185d71500783aa8589e","modified":1497267232026},{"_id":"public/page/2/index.html","hash":"ee0492eea8011bbf4413bd0c33c5e59c303c8771","modified":1497267232026},{"_id":"public/page/4/index.html","hash":"5b35c821195bfaa4a0a2d12bd8a640d6dc589096","modified":1497267232027},{"_id":"public/page/5/index.html","hash":"8d26f4905154dad970a3e25af1af98223f91735f","modified":1497267232027},{"_id":"public/page/6/index.html","hash":"6a7578778a0a4482174bb9891090eb947e9a5a22","modified":1497267232027},{"_id":"public/tags/算法/index.html","hash":"2ecc6850c017470c9d7b0399b6e158f1f805f315","modified":1497267232027},{"_id":"public/tags/android/index.html","hash":"595b3dfa83d87e02959f8aeeb0a3d06e20815259","modified":1497267232027},{"_id":"public/tags/设计模式/index.html","hash":"905ab4d5be9981c2f721214a9c83299ca472c874","modified":1497267232027},{"_id":"public/page/3/index.html","hash":"9abb4320d389b2d1bdcb8862491f94490a05c664","modified":1497267232027},{"_id":"public/tags/设计模式/page/2/index.html","hash":"5ab218fddf441c040523342e09fe8566686a49f4","modified":1497267232027},{"_id":"public/images/observer_pattern_class_diagram.png","hash":"4a1ac8301f3bfd6f7449d63d1d82d410dbe54076","modified":1497267232032},{"_id":"public/images/observer_pattern_sequence_diagram.png","hash":"2f178bb114c24c65c75a90d1ec9b39428a34f5b3","modified":1497267232032}],"Category":[{"name":"work","_id":"cj3tijdh60003h8iv9a4p1142"}],"Data":[],"Page":[{"title":"categories","date":"2017-06-01T14:58:36.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-06-01 14:58:36\ntype: \"categories\"\ncomments: false\t\t\n---\n","updated":"2017-06-01T06:59:42.475Z","path":"categories/index.html","layout":"page","_id":"cj3tijdh10001h8ivni5lmsrw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-06-01T15:02:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-06-01 15:02:25\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-06-01T07:03:29.182Z","path":"tags/index.html","layout":"page","_id":"cj3tijdmm0053h8ivc4lkxw8q","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"设计一个有getMin功能的栈","date":"2017-02-07T00:00:00.000Z","_content":" \n\n#### **题目** ####\n\n\n##### 设计一个有getMin功能的栈 #####\n>\n实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。\n\n#### **要求** ####\n>\n1. pop,push,getMin操作的时间复杂度都是O(1)-【注】：*pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM *\n2. 设计的栈类型可以使用现成的栈结构-【注】：*使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM * \n\n\n#### **难度** ####\n>\n士 ★☆☆☆\n\n\n#### **解答** ####\n>\n在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。\n\n##### **第一种设计方案** #####\n\n\t\n 压入数据规则\n \n\n假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；\n\t\n- 如果为空，则newNum也压入stackMin\n- 如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小\n- 如果newNum更小或两者相等，则newNum也压入stackMin\n- 如果stackMin中栈顶元素小，则stackMin不压入任何内容\n\n\n\n 弹出数据规则\n\n先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。\n\n通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。\n\n当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。\n\n\n\n**查询当前栈中最小值的操作**\n\t\n即stackMin的栈顶元素\n\n\n\t\tpublic class MyStack1 {\n\t\tprivate Stack<Integer> stackData;\n\t\tprivate Stack<Integer> stackMin;\n\t\n\t\tpublic MyStack1() {\n\t\t\tthis.stackData = new Stack<>();\n\t\t\tthis.stackMin = new Stack<>();\n\t\t}\n\t\n\t\tpublic void push(int newNum) {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t} else if (newNum <= this.getmin()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t}\n\t\n\t\t\tthis.stackData.push(newNum);\n\t\t}\n\t\n\t\tpublic int pop() {\n\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t}\n\t\t\tint value = stackData.peek();\n\t\t\tif (value == this.getmin()) {\n\t\t\t\tstackMin.pop();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\n\t\tpublic int getmin() {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t}\n\t\t\treturn stackMin.peek();\n\t\t}\n\t\n\t    }\n\n \n\n\n##### **第二种设计方案** #####\n\n - 压入数据规则\n\n>\n假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。\n如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：\n如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。\n\n\n- 弹出数据规则\n\n\n>\n在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value\n\n- 查询当前栈中最小值的操作\n\n\n>\n即stackMin的栈顶元素\n\n\n\t\t\n\t\tpublic class MyStack2 {\n\t\t\n\t\t\tprivate Stack<Integer> stackData;\n\t\t\tprivate Stack<Integer> stackMin;\n\t\t\n\t\t\tpublic MyStack2() {\n\t\t\t\tthis.stackData = new Stack<>();\n\t\t\t\tthis.stackMin = new Stack<>();\n\t\t\t}\n\t\t\n\t\t\tpublic void push(int newNum) {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else if (newNum < this.getmin()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else {\n\t\t\t\t\tint newMin = stackMin.peek();\n\t\t\t\t\tstackMin.push(newMin);\n\t\t\t\t}\n\t\t\n\t\t\t\tthis.stackData.push(newNum);\n\t\t\t}\n\t\t\n\t\t\tpublic int pop() {\n\t\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t\t}\n\t\t\n\t\t\t\tint value = stackData.peek();\n\t\t\t\tstackMin.pop();\n\t\t\t\tstackData.pop();\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\n\t\t\tpublic int getmin() {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t\t}\n\t\t\t\treturn stackMin.peek();\n\t\t\t}\n\t\t}\n\n\n\n#### **点评** ####\n\n\t方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n\t区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n\n\n#### **java.util.stack** ####\n\n \n\n\tpackage java.util;\n\t \n\tpublic class Stack<E> extends Vector<E> {\n\t    /**\n\t     * Creates an empty Stack.\n\t     */\n\t    public Stack() {\n\t    }\n\t\n\t    /**\n\t     * Pushes an item onto the top of this stack. This has exactly\n\t     * the same effect as:\n\t     * <blockquote><pre>\n\t     * addElement(item)</pre></blockquote>\n\t     *\n\t     * @param   item   the item to be pushed onto this stack.\n\t     * @return  the <code>item</code> argument.\n\t     * @see     java.util.Vector#addElement\n\t     */\n\t    public E push(E item) {\n\t        addElement(item);\n\t\n\t        return item;\n\t    }\n\t\n\t    /**\n\t     * Removes the object at the top of this stack and returns that\n\t     * object as the value of this function.\n\t     *\n\t     * @return  The object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E pop() {\n\t        E       obj;\n\t        int     len = size();\n\t\n\t        obj = peek();\n\t        removeElementAt(len - 1);\n\t\n\t        return obj;\n\t    }\n\t\n\t    /**\n\t     * Looks at the object at the top of this stack without removing it\n\t     * from the stack.\n\t     *\n\t     * @return  the object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E peek() {\n\t        int     len = size();\n\t\n\t        if (len == 0)\n\t            throw new EmptyStackException();\n\t        return elementAt(len - 1);\n\t    }\n\t\n\t    /**\n\t     * Tests if this stack is empty.\n\t     *\n\t     * @return  <code>true</code> if and only if this stack contains\n\t     *          no items; <code>false</code> otherwise.\n\t     */\n\t    public boolean empty() {\n\t        return size() == 0;\n\t    }\n\t\n\t    /**\n\t     * Returns the 1-based position where an object is on this stack.\n\t     * If the object <tt>o</tt> occurs as an item in this stack, this\n\t     * method returns the distance from the top of the stack of the\n\t     * occurrence nearest the top of the stack; the topmost item on the\n\t     * stack is considered to be at distance <tt>1</tt>. The <tt>equals</tt>\n\t     * method is used to compare <tt>o</tt> to the\n\t     * items in this stack.\n\t     *\n\t     * @param   o   the desired object.\n\t     * @return  the 1-based position from the top of the stack where\n\t     *          the object is located; the return value <code>-1</code>\n\t     *          indicates that the object is not on the stack.\n\t     */\n\t    public synchronized int search(Object o) {\n\t        int i = lastIndexOf(o);\n\t\n\t        if (i >= 0) {\n\t            return size() - i;\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n\t    private static final long serialVersionUID = 1224463164541339165L;\n\t}\n\n#### **栈的简单概念** ####\n\n>\n栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。\n \n\n【注】*栈在java中有[数据结构和数据存储结构](http://xusx1024.com/2017/02/11/different-between-ADT/)两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。*3/3/2017 11:13:33 AM \n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-07-stack-with-getmin-fun.md","raw":"---\nlayout: post\ntitle:  设计一个有getMin功能的栈\ndate:   2017-02-07\ncategories: work\ntag: 算法\n---\n \n\n#### **题目** ####\n\n\n##### 设计一个有getMin功能的栈 #####\n>\n实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。\n\n#### **要求** ####\n>\n1. pop,push,getMin操作的时间复杂度都是O(1)-【注】：*pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM *\n2. 设计的栈类型可以使用现成的栈结构-【注】：*使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM * \n\n\n#### **难度** ####\n>\n士 ★☆☆☆\n\n\n#### **解答** ####\n>\n在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。\n\n##### **第一种设计方案** #####\n\n\t\n 压入数据规则\n \n\n假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；\n\t\n- 如果为空，则newNum也压入stackMin\n- 如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小\n- 如果newNum更小或两者相等，则newNum也压入stackMin\n- 如果stackMin中栈顶元素小，则stackMin不压入任何内容\n\n\n\n 弹出数据规则\n\n先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。\n\n通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。\n\n当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。\n\n\n\n**查询当前栈中最小值的操作**\n\t\n即stackMin的栈顶元素\n\n\n\t\tpublic class MyStack1 {\n\t\tprivate Stack<Integer> stackData;\n\t\tprivate Stack<Integer> stackMin;\n\t\n\t\tpublic MyStack1() {\n\t\t\tthis.stackData = new Stack<>();\n\t\t\tthis.stackMin = new Stack<>();\n\t\t}\n\t\n\t\tpublic void push(int newNum) {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t} else if (newNum <= this.getmin()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t}\n\t\n\t\t\tthis.stackData.push(newNum);\n\t\t}\n\t\n\t\tpublic int pop() {\n\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t}\n\t\t\tint value = stackData.peek();\n\t\t\tif (value == this.getmin()) {\n\t\t\t\tstackMin.pop();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\n\t\tpublic int getmin() {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t}\n\t\t\treturn stackMin.peek();\n\t\t}\n\t\n\t    }\n\n \n\n\n##### **第二种设计方案** #####\n\n - 压入数据规则\n\n>\n假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。\n如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：\n如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。\n\n\n- 弹出数据规则\n\n\n>\n在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value\n\n- 查询当前栈中最小值的操作\n\n\n>\n即stackMin的栈顶元素\n\n\n\t\t\n\t\tpublic class MyStack2 {\n\t\t\n\t\t\tprivate Stack<Integer> stackData;\n\t\t\tprivate Stack<Integer> stackMin;\n\t\t\n\t\t\tpublic MyStack2() {\n\t\t\t\tthis.stackData = new Stack<>();\n\t\t\t\tthis.stackMin = new Stack<>();\n\t\t\t}\n\t\t\n\t\t\tpublic void push(int newNum) {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else if (newNum < this.getmin()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else {\n\t\t\t\t\tint newMin = stackMin.peek();\n\t\t\t\t\tstackMin.push(newMin);\n\t\t\t\t}\n\t\t\n\t\t\t\tthis.stackData.push(newNum);\n\t\t\t}\n\t\t\n\t\t\tpublic int pop() {\n\t\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t\t}\n\t\t\n\t\t\t\tint value = stackData.peek();\n\t\t\t\tstackMin.pop();\n\t\t\t\tstackData.pop();\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\n\t\t\tpublic int getmin() {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t\t}\n\t\t\t\treturn stackMin.peek();\n\t\t\t}\n\t\t}\n\n\n\n#### **点评** ####\n\n\t方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n\t区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n\n\n#### **java.util.stack** ####\n\n \n\n\tpackage java.util;\n\t \n\tpublic class Stack<E> extends Vector<E> {\n\t    /**\n\t     * Creates an empty Stack.\n\t     */\n\t    public Stack() {\n\t    }\n\t\n\t    /**\n\t     * Pushes an item onto the top of this stack. This has exactly\n\t     * the same effect as:\n\t     * <blockquote><pre>\n\t     * addElement(item)</pre></blockquote>\n\t     *\n\t     * @param   item   the item to be pushed onto this stack.\n\t     * @return  the <code>item</code> argument.\n\t     * @see     java.util.Vector#addElement\n\t     */\n\t    public E push(E item) {\n\t        addElement(item);\n\t\n\t        return item;\n\t    }\n\t\n\t    /**\n\t     * Removes the object at the top of this stack and returns that\n\t     * object as the value of this function.\n\t     *\n\t     * @return  The object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E pop() {\n\t        E       obj;\n\t        int     len = size();\n\t\n\t        obj = peek();\n\t        removeElementAt(len - 1);\n\t\n\t        return obj;\n\t    }\n\t\n\t    /**\n\t     * Looks at the object at the top of this stack without removing it\n\t     * from the stack.\n\t     *\n\t     * @return  the object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E peek() {\n\t        int     len = size();\n\t\n\t        if (len == 0)\n\t            throw new EmptyStackException();\n\t        return elementAt(len - 1);\n\t    }\n\t\n\t    /**\n\t     * Tests if this stack is empty.\n\t     *\n\t     * @return  <code>true</code> if and only if this stack contains\n\t     *          no items; <code>false</code> otherwise.\n\t     */\n\t    public boolean empty() {\n\t        return size() == 0;\n\t    }\n\t\n\t    /**\n\t     * Returns the 1-based position where an object is on this stack.\n\t     * If the object <tt>o</tt> occurs as an item in this stack, this\n\t     * method returns the distance from the top of the stack of the\n\t     * occurrence nearest the top of the stack; the topmost item on the\n\t     * stack is considered to be at distance <tt>1</tt>. The <tt>equals</tt>\n\t     * method is used to compare <tt>o</tt> to the\n\t     * items in this stack.\n\t     *\n\t     * @param   o   the desired object.\n\t     * @return  the 1-based position from the top of the stack where\n\t     *          the object is located; the return value <code>-1</code>\n\t     *          indicates that the object is not on the stack.\n\t     */\n\t    public synchronized int search(Object o) {\n\t        int i = lastIndexOf(o);\n\t\n\t        if (i >= 0) {\n\t            return size() - i;\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n\t    private static final long serialVersionUID = 1224463164541339165L;\n\t}\n\n#### **栈的简单概念** ####\n\n>\n栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。\n \n\n【注】*栈在java中有[数据结构和数据存储结构](http://xusx1024.com/2017/02/11/different-between-ADT/)两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。*3/3/2017 11:13:33 AM \n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"stack-with-getmin-fun","published":1,"updated":"2017-06-01T07:05:12.309Z","comments":1,"photos":[],"link":"","_id":"cj3tijdgv0000h8iv3oydp7o8","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a><strong>题目</strong></h4><h5 id=\"设计一个有getMin功能的栈\"><a href=\"#设计一个有getMin功能的栈\" class=\"headerlink\" title=\"设计一个有getMin功能的栈\"></a>设计一个有getMin功能的栈</h5><p>&gt;<br>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>\n<h4 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a><strong>要求</strong></h4><p>&gt;</p>\n<ol>\n<li>pop,push,getMin操作的时间复杂度都是O(1)-【注】：<em>pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM </em></li>\n<li>设计的栈类型可以使用现成的栈结构-【注】：<em>使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM </em> </li>\n</ol>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a><strong>难度</strong></h4><p>&gt;<br>士 ★☆☆☆</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a><strong>解答</strong></h4><p>&gt;<br>在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。</p>\n<h5 id=\"第一种设计方案\"><a href=\"#第一种设计方案\" class=\"headerlink\" title=\"第一种设计方案\"></a><strong>第一种设计方案</strong></h5><p> 压入数据规则</p>\n<p>假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；</p>\n<ul>\n<li>如果为空，则newNum也压入stackMin</li>\n<li>如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小</li>\n<li>如果newNum更小或两者相等，则newNum也压入stackMin</li>\n<li>如果stackMin中栈顶元素小，则stackMin不压入任何内容</li>\n</ul>\n<p> 弹出数据规则</p>\n<p>先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。</p>\n<p>通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。</p>\n<p>当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。</p>\n<p><strong>查询当前栈中最小值的操作</strong></p>\n<p>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack1 {\nprivate Stack&lt;Integer&gt; stackData;\nprivate Stack&lt;Integer&gt; stackMin;\n\npublic MyStack1() {\n    this.stackData = new Stack&lt;&gt;();\n    this.stackMin = new Stack&lt;&gt;();\n}\n\npublic void push(int newNum) {\n    if (this.stackMin.isEmpty()) {\n        stackMin.push(newNum);\n    } else if (newNum &lt;= this.getmin()) {\n        stackMin.push(newNum);\n    }\n\n    this.stackData.push(newNum);\n}\n\npublic int pop() {\n    if (this.stackData.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n    }\n    int value = stackData.peek();\n    if (value == this.getmin()) {\n        stackMin.pop();\n    }\n    return value;\n}\n\npublic int getmin() {\n    if (this.stackMin.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is empty.&quot;);\n    }\n    return stackMin.peek();\n}\n\n}\n</code></pre><h5 id=\"第二种设计方案\"><a href=\"#第二种设计方案\" class=\"headerlink\" title=\"第二种设计方案\"></a><strong>第二种设计方案</strong></h5><ul>\n<li>压入数据规则</li>\n</ul>\n<p>&gt;<br>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。<br>如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：<br>如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。</p>\n<ul>\n<li>弹出数据规则</li>\n</ul>\n<p>&gt;<br>在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value</p>\n<ul>\n<li>查询当前栈中最小值的操作</li>\n</ul>\n<p>&gt;<br>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack2 {\n\n    private Stack&lt;Integer&gt; stackData;\n    private Stack&lt;Integer&gt; stackMin;\n\n    public MyStack2() {\n        this.stackData = new Stack&lt;&gt;();\n        this.stackMin = new Stack&lt;&gt;();\n    }\n\n    public void push(int newNum) {\n        if (this.stackMin.isEmpty()) {\n            stackMin.push(newNum);\n        } else if (newNum &lt; this.getmin()) {\n            stackMin.push(newNum);\n        } else {\n            int newMin = stackMin.peek();\n            stackMin.push(newMin);\n        }\n\n        this.stackData.push(newNum);\n    }\n\n    public int pop() {\n        if (this.stackData.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n        }\n\n        int value = stackData.peek();\n        stackMin.pop();\n        stackData.pop();\n        return value;\n    }\n\n    public int getmin() {\n        if (this.stackMin.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is empty.&quot;);\n        }\n        return stackMin.peek();\n    }\n}\n</code></pre><h4 id=\"点评\"><a href=\"#点评\" class=\"headerlink\" title=\"点评\"></a><strong>点评</strong></h4><pre><code>方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n</code></pre><h4 id=\"java-util-stack\"><a href=\"#java-util-stack\" class=\"headerlink\" title=\"java.util.stack\"></a><strong>java.util.stack</strong></h4><pre><code>package java.util;\n\npublic class Stack&lt;E&gt; extends Vector&lt;E&gt; {\n    /**\n     * Creates an empty Stack.\n     */\n    public Stack() {\n    }\n\n    /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * &lt;blockquote&gt;&lt;pre&gt;\n     * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt;\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the &lt;code&gt;item&lt;/code&gt; argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n\n    /**\n     * Removes the object at the top of this stack and returns that\n     * object as the value of this function.\n     *\n     * @return  The object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E pop() {\n        E       obj;\n        int     len = size();\n\n        obj = peek();\n        removeElementAt(len - 1);\n\n        return obj;\n    }\n\n    /**\n     * Looks at the object at the top of this stack without removing it\n     * from the stack.\n     *\n     * @return  the object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E peek() {\n        int     len = size();\n\n        if (len == 0)\n            throw new EmptyStackException();\n        return elementAt(len - 1);\n    }\n\n    /**\n     * Tests if this stack is empty.\n     *\n     * @return  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains\n     *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.\n     */\n    public boolean empty() {\n        return size() == 0;\n    }\n\n    /**\n     * Returns the 1-based position where an object is on this stack.\n     * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this\n     * method returns the distance from the top of the stack of the\n     * occurrence nearest the top of the stack; the topmost item on the\n     * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt;\n     * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the\n     * items in this stack.\n     *\n     * @param   o   the desired object.\n     * @return  the 1-based position from the top of the stack where\n     *          the object is located; the return value &lt;code&gt;-1&lt;/code&gt;\n     *          indicates that the object is not on the stack.\n     */\n    public synchronized int search(Object o) {\n        int i = lastIndexOf(o);\n\n        if (i &gt;= 0) {\n            return size() - i;\n        }\n        return -1;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = 1224463164541339165L;\n}\n</code></pre><h4 id=\"栈的简单概念\"><a href=\"#栈的简单概念\" class=\"headerlink\" title=\"栈的简单概念\"></a><strong>栈的简单概念</strong></h4><p>&gt;<br>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。</p>\n<p>【注】<em>栈在java中有<a href=\"http://xusx1024.com/2017/02/11/different-between-ADT/\" target=\"_blank\" rel=\"external\">数据结构和数据存储结构</a>两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。</em>3/3/2017 11:13:33 AM </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a><strong>题目</strong></h4><h5 id=\"设计一个有getMin功能的栈\"><a href=\"#设计一个有getMin功能的栈\" class=\"headerlink\" title=\"设计一个有getMin功能的栈\"></a>设计一个有getMin功能的栈</h5><p>&gt;<br>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>\n<h4 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a><strong>要求</strong></h4><p>&gt;</p>\n<ol>\n<li>pop,push,getMin操作的时间复杂度都是O(1)-【注】：<em>pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM </em></li>\n<li>设计的栈类型可以使用现成的栈结构-【注】：<em>使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM </em> </li>\n</ol>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a><strong>难度</strong></h4><p>&gt;<br>士 ★☆☆☆</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a><strong>解答</strong></h4><p>&gt;<br>在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。</p>\n<h5 id=\"第一种设计方案\"><a href=\"#第一种设计方案\" class=\"headerlink\" title=\"第一种设计方案\"></a><strong>第一种设计方案</strong></h5><p> 压入数据规则</p>\n<p>假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；</p>\n<ul>\n<li>如果为空，则newNum也压入stackMin</li>\n<li>如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小</li>\n<li>如果newNum更小或两者相等，则newNum也压入stackMin</li>\n<li>如果stackMin中栈顶元素小，则stackMin不压入任何内容</li>\n</ul>\n<p> 弹出数据规则</p>\n<p>先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。</p>\n<p>通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。</p>\n<p>当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。</p>\n<p><strong>查询当前栈中最小值的操作</strong></p>\n<p>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack1 {\nprivate Stack&lt;Integer&gt; stackData;\nprivate Stack&lt;Integer&gt; stackMin;\n\npublic MyStack1() {\n    this.stackData = new Stack&lt;&gt;();\n    this.stackMin = new Stack&lt;&gt;();\n}\n\npublic void push(int newNum) {\n    if (this.stackMin.isEmpty()) {\n        stackMin.push(newNum);\n    } else if (newNum &lt;= this.getmin()) {\n        stackMin.push(newNum);\n    }\n\n    this.stackData.push(newNum);\n}\n\npublic int pop() {\n    if (this.stackData.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n    }\n    int value = stackData.peek();\n    if (value == this.getmin()) {\n        stackMin.pop();\n    }\n    return value;\n}\n\npublic int getmin() {\n    if (this.stackMin.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is empty.&quot;);\n    }\n    return stackMin.peek();\n}\n\n}\n</code></pre><h5 id=\"第二种设计方案\"><a href=\"#第二种设计方案\" class=\"headerlink\" title=\"第二种设计方案\"></a><strong>第二种设计方案</strong></h5><ul>\n<li>压入数据规则</li>\n</ul>\n<p>&gt;<br>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。<br>如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：<br>如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。</p>\n<ul>\n<li>弹出数据规则</li>\n</ul>\n<p>&gt;<br>在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value</p>\n<ul>\n<li>查询当前栈中最小值的操作</li>\n</ul>\n<p>&gt;<br>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack2 {\n\n    private Stack&lt;Integer&gt; stackData;\n    private Stack&lt;Integer&gt; stackMin;\n\n    public MyStack2() {\n        this.stackData = new Stack&lt;&gt;();\n        this.stackMin = new Stack&lt;&gt;();\n    }\n\n    public void push(int newNum) {\n        if (this.stackMin.isEmpty()) {\n            stackMin.push(newNum);\n        } else if (newNum &lt; this.getmin()) {\n            stackMin.push(newNum);\n        } else {\n            int newMin = stackMin.peek();\n            stackMin.push(newMin);\n        }\n\n        this.stackData.push(newNum);\n    }\n\n    public int pop() {\n        if (this.stackData.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n        }\n\n        int value = stackData.peek();\n        stackMin.pop();\n        stackData.pop();\n        return value;\n    }\n\n    public int getmin() {\n        if (this.stackMin.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is empty.&quot;);\n        }\n        return stackMin.peek();\n    }\n}\n</code></pre><h4 id=\"点评\"><a href=\"#点评\" class=\"headerlink\" title=\"点评\"></a><strong>点评</strong></h4><pre><code>方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n</code></pre><h4 id=\"java-util-stack\"><a href=\"#java-util-stack\" class=\"headerlink\" title=\"java.util.stack\"></a><strong>java.util.stack</strong></h4><pre><code>package java.util;\n\npublic class Stack&lt;E&gt; extends Vector&lt;E&gt; {\n    /**\n     * Creates an empty Stack.\n     */\n    public Stack() {\n    }\n\n    /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * &lt;blockquote&gt;&lt;pre&gt;\n     * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt;\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the &lt;code&gt;item&lt;/code&gt; argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n\n    /**\n     * Removes the object at the top of this stack and returns that\n     * object as the value of this function.\n     *\n     * @return  The object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E pop() {\n        E       obj;\n        int     len = size();\n\n        obj = peek();\n        removeElementAt(len - 1);\n\n        return obj;\n    }\n\n    /**\n     * Looks at the object at the top of this stack without removing it\n     * from the stack.\n     *\n     * @return  the object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E peek() {\n        int     len = size();\n\n        if (len == 0)\n            throw new EmptyStackException();\n        return elementAt(len - 1);\n    }\n\n    /**\n     * Tests if this stack is empty.\n     *\n     * @return  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains\n     *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.\n     */\n    public boolean empty() {\n        return size() == 0;\n    }\n\n    /**\n     * Returns the 1-based position where an object is on this stack.\n     * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this\n     * method returns the distance from the top of the stack of the\n     * occurrence nearest the top of the stack; the topmost item on the\n     * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt;\n     * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the\n     * items in this stack.\n     *\n     * @param   o   the desired object.\n     * @return  the 1-based position from the top of the stack where\n     *          the object is located; the return value &lt;code&gt;-1&lt;/code&gt;\n     *          indicates that the object is not on the stack.\n     */\n    public synchronized int search(Object o) {\n        int i = lastIndexOf(o);\n\n        if (i &gt;= 0) {\n            return size() - i;\n        }\n        return -1;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = 1224463164541339165L;\n}\n</code></pre><h4 id=\"栈的简单概念\"><a href=\"#栈的简单概念\" class=\"headerlink\" title=\"栈的简单概念\"></a><strong>栈的简单概念</strong></h4><p>&gt;<br>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。</p>\n<p>【注】<em>栈在java中有<a href=\"http://xusx1024.com/2017/02/11/different-between-ADT/\" target=\"_blank\" rel=\"external\">数据结构和数据存储结构</a>两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。</em>3/3/2017 11:13:33 AM </p>\n"},{"layout":"post","title":"Android Device Monitor不显示App进程信息问题","date":"2017-02-10T00:00:00.000Z","_content":"\n \n#### 问题现象 ####\n\n\t\n![ADM现象截图](/images/adm_question.png)\n\n\t如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n\n> 去查看Hierarchy View，提示如下：\t\t\n> \n-  Unable to get view server version from device;\n-  Unable to get view server protocol version from device\n-  Unable to get the focused window from device\n-  Unable to debug device\n \t \n\n#### 原因 ####\n\n\tFor security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n \n\n#### 解决方法 ####\n\n##### 方法一 #####\n\n\t使用模拟器，推荐\n\n##### 方法二 #####\n\n\tapp不签名，也可以查看到\n\n##### 方法三 #####\n\n\t经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n\t[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n\n\n\n#### 名词解释 ####\n\n\tDDMS：Dalvik Debug Monitor Server","source":"_posts/2017-02-10-how-use-android-device-monitor.md","raw":"---\nlayout: post\ntitle:  Android Device Monitor不显示App进程信息问题\ndate:   2017-02-10\ncategories: work\ntag: android\n---\n\n \n#### 问题现象 ####\n\n\t\n![ADM现象截图](/images/adm_question.png)\n\n\t如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n\n> 去查看Hierarchy View，提示如下：\t\t\n> \n-  Unable to get view server version from device;\n-  Unable to get view server protocol version from device\n-  Unable to get the focused window from device\n-  Unable to debug device\n \t \n\n#### 原因 ####\n\n\tFor security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n \n\n#### 解决方法 ####\n\n##### 方法一 #####\n\n\t使用模拟器，推荐\n\n##### 方法二 #####\n\n\tapp不签名，也可以查看到\n\n##### 方法三 #####\n\n\t经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n\t[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n\n\n\n#### 名词解释 ####\n\n\tDDMS：Dalvik Debug Monitor Server","slug":"how-use-android-device-monitor","published":1,"updated":"2017-06-01T07:46:39.279Z","comments":1,"photos":[],"link":"","_id":"cj3tijdh30002h8ivhh91f7i1","content":"<h4 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h4><p><img src=\"/images/adm_question.png\" alt=\"ADM现象截图\"></p>\n<pre><code>如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n</code></pre><blockquote>\n<p>去查看Hierarchy View，提示如下：        </p>\n<ul>\n<li>Unable to get view server version from device;</li>\n<li>Unable to get view server protocol version from device</li>\n<li>Unable to get the focused window from device</li>\n<li>Unable to debug device</li>\n</ul>\n</blockquote>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><pre><code>For security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n</code></pre><h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>使用模拟器，推荐\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>app不签名，也可以查看到\n</code></pre><h5 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h5><pre><code>经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n</code></pre><h4 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h4><pre><code>DDMS：Dalvik Debug Monitor Server\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h4><p><img src=\"/images/adm_question.png\" alt=\"ADM现象截图\"></p>\n<pre><code>如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n</code></pre><blockquote>\n<p>去查看Hierarchy View，提示如下：        </p>\n<ul>\n<li>Unable to get view server version from device;</li>\n<li>Unable to get view server protocol version from device</li>\n<li>Unable to get the focused window from device</li>\n<li>Unable to debug device</li>\n</ul>\n</blockquote>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><pre><code>For security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n</code></pre><h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>使用模拟器，推荐\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>app不签名，也可以查看到\n</code></pre><h5 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h5><pre><code>经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n</code></pre><h4 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h4><pre><code>DDMS：Dalvik Debug Monitor Server\n</code></pre>"},{"layout":"post","title":"Android过度绘制优化","date":"2017-02-09T00:00:00.000Z","_content":"\n \n\n#### what ####\n \n\n##### 过渡绘制 #####\n \n\n\t过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n\n##### 开启 #####\n\n\t\n\t开发者选项 - 调试GPU过渡绘制\n\n##### 解释 #####\n\n\n![示例图](/images/color-key-for-debug-GPU-overdraw-output.png)\n\n- True color: No overdraw\n- Blue: Overdrawn once\n- Green: Overdrawn twice\n- Pink: Overdrawn three times\n- Red: Overdrawn four or more times\n\n#### how ####\n\n\t\n\n1.  >去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。\n\t>\n    \t修改页面的主题：\n\t\t<item name=\"android:windowBackground\">@android:color/transparent</item>\n    \t<item name=\"android:windowBackground\">@null</item>\n\t>\t\t\n\t\t代码中修改：\n\t\tgetWindow().setBackgroundDrawable(null)\n\t\tgetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\n\t>\t null和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n\n2. >移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。\n\n3. >选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。\n\n4. >对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过[canvas.clipRect()](https://developer.android.com/reference/android/graphics/Canvas.html)来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用[canvas.quickreject()](https://developer.android.com/reference/android/graphics/Canvas.html)来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。\n\n5. >使用merge标签，减少布局嵌套层次。\n\n6. >使用动态inflate或者ViewStub替代setVisibility。\n\n7. >对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。\n\n8. >使用.9图，透明区域会被android的2D渲染器优化。\n\n9. >好的展示设计和交互。使UI宽而浅而不是浅而深。\n\n\n#### 标准 ####\n\n\t\t\n\t  过度绘制不可避免\n\t\n\t  尽量控制在绿色及其以下\n\t\n\t  尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n\t  不允许出现超过屏幕1/4的红色区域\n   ","source":"_posts/2017-02-09-Debug-GPU-Overdraw-Walkthrough.md","raw":"---\nlayout: post\ntitle:  Android过度绘制优化\ndate:   2017-02-09\ncategories: work\ntag: android\n---\n\n \n\n#### what ####\n \n\n##### 过渡绘制 #####\n \n\n\t过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n\n##### 开启 #####\n\n\t\n\t开发者选项 - 调试GPU过渡绘制\n\n##### 解释 #####\n\n\n![示例图](/images/color-key-for-debug-GPU-overdraw-output.png)\n\n- True color: No overdraw\n- Blue: Overdrawn once\n- Green: Overdrawn twice\n- Pink: Overdrawn three times\n- Red: Overdrawn four or more times\n\n#### how ####\n\n\t\n\n1.  >去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。\n\t>\n    \t修改页面的主题：\n\t\t<item name=\"android:windowBackground\">@android:color/transparent</item>\n    \t<item name=\"android:windowBackground\">@null</item>\n\t>\t\t\n\t\t代码中修改：\n\t\tgetWindow().setBackgroundDrawable(null)\n\t\tgetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\n\t>\t null和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n\n2. >移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。\n\n3. >选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。\n\n4. >对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过[canvas.clipRect()](https://developer.android.com/reference/android/graphics/Canvas.html)来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用[canvas.quickreject()](https://developer.android.com/reference/android/graphics/Canvas.html)来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。\n\n5. >使用merge标签，减少布局嵌套层次。\n\n6. >使用动态inflate或者ViewStub替代setVisibility。\n\n7. >对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。\n\n8. >使用.9图，透明区域会被android的2D渲染器优化。\n\n9. >好的展示设计和交互。使UI宽而浅而不是浅而深。\n\n\n#### 标准 ####\n\n\t\t\n\t  过度绘制不可避免\n\t\n\t  尽量控制在绿色及其以下\n\t\n\t  尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n\t  不允许出现超过屏幕1/4的红色区域\n   ","slug":"Debug-GPU-Overdraw-Walkthrough","published":1,"updated":"2017-06-01T07:47:50.885Z","comments":1,"photos":[],"link":"","_id":"cj3tijdha0005h8ivchn6m37t","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"过渡绘制\"><a href=\"#过渡绘制\" class=\"headerlink\" title=\"过渡绘制\"></a>过渡绘制</h5><pre><code>过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n</code></pre><h5 id=\"开启\"><a href=\"#开启\" class=\"headerlink\" title=\"开启\"></a>开启</h5><pre><code>开发者选项 - 调试GPU过渡绘制\n</code></pre><h5 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h5><p><img src=\"/images/color-key-for-debug-GPU-overdraw-output.png\" alt=\"示例图\"></p>\n<ul>\n<li>True color: No overdraw</li>\n<li>Blue: Overdrawn once</li>\n<li>Green: Overdrawn twice</li>\n<li>Pink: Overdrawn three times</li>\n<li>Red: Overdrawn four or more times</li>\n</ul>\n<h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><ol>\n<li><blockquote>\n<p>去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。</p>\n<pre><code>修改页面的主题：\n&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;\n&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;\n\n代码中修改：\ngetWindow().setBackgroundDrawable(null)\ngetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\nnull和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n</code></pre></blockquote>\n</li>\n<li><blockquote>\n<p>移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用merge标签，减少布局嵌套层次。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用动态inflate或者ViewStub替代setVisibility。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用.9图，透明区域会被android的2D渲染器优化。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>好的展示设计和交互。使UI宽而浅而不是浅而深。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"标准\"><a href=\"#标准\" class=\"headerlink\" title=\"标准\"></a>标准</h4><pre><code>过度绘制不可避免\n\n尽量控制在绿色及其以下\n\n尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n不允许出现超过屏幕1/4的红色区域\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"过渡绘制\"><a href=\"#过渡绘制\" class=\"headerlink\" title=\"过渡绘制\"></a>过渡绘制</h5><pre><code>过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n</code></pre><h5 id=\"开启\"><a href=\"#开启\" class=\"headerlink\" title=\"开启\"></a>开启</h5><pre><code>开发者选项 - 调试GPU过渡绘制\n</code></pre><h5 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h5><p><img src=\"/images/color-key-for-debug-GPU-overdraw-output.png\" alt=\"示例图\"></p>\n<ul>\n<li>True color: No overdraw</li>\n<li>Blue: Overdrawn once</li>\n<li>Green: Overdrawn twice</li>\n<li>Pink: Overdrawn three times</li>\n<li>Red: Overdrawn four or more times</li>\n</ul>\n<h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><ol>\n<li><blockquote>\n<p>去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。</p>\n<pre><code>修改页面的主题：\n&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;\n&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;\n\n代码中修改：\ngetWindow().setBackgroundDrawable(null)\ngetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\nnull和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n</code></pre></blockquote>\n</li>\n<li><blockquote>\n<p>移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用merge标签，减少布局嵌套层次。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用动态inflate或者ViewStub替代setVisibility。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用.9图，透明区域会被android的2D渲染器优化。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>好的展示设计和交互。使UI宽而浅而不是浅而深。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"标准\"><a href=\"#标准\" class=\"headerlink\" title=\"标准\"></a>标准</h4><pre><code>过度绘制不可避免\n\n尽量控制在绿色及其以下\n\n尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n不允许出现超过屏幕1/4的红色区域\n</code></pre>"},{"layout":"post","title":"Gpu呈现模式分析","date":"2017-02-09T00:00:00.000Z","_content":" \n\n#### 引言 ####\n\n \t在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n\n![玄学曲线](/images/profileGPURendering.png)\n\n\n#### 说说这张图片 ####\n\n##### 绿横线 #####\n\n\t在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n\n##### 红柱 #####\n\n\t红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n\n![绘图执行图](/images/executePhase.png)\n\n##### 黄柱 #####\n\n\t黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n\n##### 蓝柱 #####\n\n\t假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n\t在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n\t所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n\n\n","source":"_posts/2017-02-09-Profile-Gpu-rendering.md","raw":"---\nlayout: post\ntitle:  Gpu呈现模式分析\ndate:   2017-02-09\ncategories: work\ntag: android\n---\n \n\n#### 引言 ####\n\n \t在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n\n![玄学曲线](/images/profileGPURendering.png)\n\n\n#### 说说这张图片 ####\n\n##### 绿横线 #####\n\n\t在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n\n##### 红柱 #####\n\n\t红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n\n![绘图执行图](/images/executePhase.png)\n\n##### 黄柱 #####\n\n\t黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n\n##### 蓝柱 #####\n\n\t假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n\t在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n\t所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n\n\n","slug":"Profile-Gpu-rendering","published":1,"updated":"2017-06-01T07:47:29.562Z","comments":1,"photos":[],"link":"","_id":"cj3tijdhf0006h8ivsk3kt690","content":"<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><pre><code>在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n</code></pre><p><img src=\"/images/profileGPURendering.png\" alt=\"玄学曲线\"></p>\n<h4 id=\"说说这张图片\"><a href=\"#说说这张图片\" class=\"headerlink\" title=\"说说这张图片\"></a>说说这张图片</h4><h5 id=\"绿横线\"><a href=\"#绿横线\" class=\"headerlink\" title=\"绿横线\"></a>绿横线</h5><pre><code>在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n</code></pre><h5 id=\"红柱\"><a href=\"#红柱\" class=\"headerlink\" title=\"红柱\"></a>红柱</h5><pre><code>红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n</code></pre><p><img src=\"/images/executePhase.png\" alt=\"绘图执行图\"></p>\n<h5 id=\"黄柱\"><a href=\"#黄柱\" class=\"headerlink\" title=\"黄柱\"></a>黄柱</h5><pre><code>黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n</code></pre><h5 id=\"蓝柱\"><a href=\"#蓝柱\" class=\"headerlink\" title=\"蓝柱\"></a>蓝柱</h5><pre><code>假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><pre><code>在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n</code></pre><p><img src=\"/images/profileGPURendering.png\" alt=\"玄学曲线\"></p>\n<h4 id=\"说说这张图片\"><a href=\"#说说这张图片\" class=\"headerlink\" title=\"说说这张图片\"></a>说说这张图片</h4><h5 id=\"绿横线\"><a href=\"#绿横线\" class=\"headerlink\" title=\"绿横线\"></a>绿横线</h5><pre><code>在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n</code></pre><h5 id=\"红柱\"><a href=\"#红柱\" class=\"headerlink\" title=\"红柱\"></a>红柱</h5><pre><code>红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n</code></pre><p><img src=\"/images/executePhase.png\" alt=\"绘图执行图\"></p>\n<h5 id=\"黄柱\"><a href=\"#黄柱\" class=\"headerlink\" title=\"黄柱\"></a>黄柱</h5><pre><code>黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n</code></pre><h5 id=\"蓝柱\"><a href=\"#蓝柱\" class=\"headerlink\" title=\"蓝柱\"></a>蓝柱</h5><pre><code>假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n</code></pre>"},{"layout":"post","title":"first test post","date":"2017-02-06T00:00:00.000Z","_content":" \n\n#### 目录1 ####\n\n\n##### 正文标题 #####\n\n表格：\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 |\n\n图片：\n![test](/images/SA&rank.png)\n","source":"_posts/2017-02-06-first-post.md","raw":"---\nlayout: post\ntitle:  first test post\ndate:   2017-02-06\ncategories: work\ntag: 杂项\n---\n \n\n#### 目录1 ####\n\n\n##### 正文标题 #####\n\n表格：\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 |\n\n图片：\n![test](/images/SA&rank.png)\n","slug":"first-post","published":1,"updated":"2017-06-01T07:05:04.534Z","comments":1,"photos":[],"link":"","_id":"cj3tijdhh0007h8ivwnlf4ji4","content":"<h4 id=\"目录1\"><a href=\"#目录1\" class=\"headerlink\" title=\"目录1\"></a>目录1</h4><h5 id=\"正文标题\"><a href=\"#正文标题\" class=\"headerlink\" title=\"正文标题\"></a>正文标题</h5><p>表格：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务</td>\n</tr>\n</tbody>\n</table>\n<p>图片：<br><img src=\"/images/SA&amp;rank.png\" alt=\"test\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"目录1\"><a href=\"#目录1\" class=\"headerlink\" title=\"目录1\"></a>目录1</h4><h5 id=\"正文标题\"><a href=\"#正文标题\" class=\"headerlink\" title=\"正文标题\"></a>正文标题</h5><p>表格：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务</td>\n</tr>\n</tbody>\n</table>\n<p>图片：<br><img src=\"/images/SA&amp;rank.png\" alt=\"test\"></p>\n"},{"layout":"post","title":"单例设计模式(二)真●单例唯一$序列化","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 序列化对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n\n然后看我们的测试代码：\n\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.io.FileOutputStream;\n\timport java.io.ObjectInputStream;\n\timport java.io.ObjectOutputStream;\n\n\tpublic class SerializableDemo1 {\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\"tempFile\"));\n\t\t\t\toos.writeObject(Singleton.getInstance());\n\t\t\t\tFile file = new File(\"tempFile\");\n\t\t\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n\t\t\t\t\t\tfile));\n\t\t\t\tSingleton instance = (Singleton) ois.readObject();\n\t\t\t\tSystem.out.println(\"反序列化后的对象和原来的是否相等？\"\n\t\t\t\t\t\t+ (Singleton.getInstance() == instance));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n> 运行后： ``` 反序列化后的对象和原来的是否相等？false ```\n\n> 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。\n\n\n#### 序列化破坏单例の原因 ####\n\n反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,<br/>\n发现：``` Object obj = readObject0(false);```<br/>\n继续：\n\n\t case TC_OBJECT:\n\t                    return checkResolve(readOrdinaryObject(unshared));\n\n探究： ```ObjectInputStream$readOrdinaryObject```\n\n该方法关键代码片段一：\n\n\t Object obj;\n\t        try {\n\t            obj = desc.isInstantiable() ? desc.newInstance() : null;\n\t        } catch (Exception ex) {\n\t            throw (IOException) new InvalidClassException(\n\t                desc.forClass().getName(),\n\t                \"unable to create instance\").initCause(ex);\n\t        }\n\n> 该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br/>\n> ```isInstantiable```：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。\n> ```desc.newInstance()```：该方法通过反射的方式调用无参构造方法新建一个对象\n\n所以：\n\n> 反序列化会通过反射调用无参的构造创建一个新的对象\n\n该方法关键代码片段二：\n\n\t if (obj != null &&\n\t            handles.lookupException(passHandle) == null &&\n\t            desc.hasReadResolveMethod())\n\t        {\n\t            Object rep = desc.invokeReadResolve(obj);\n\t            if (unshared && rep.getClass().isArray()) {\n\t                rep = cloneArray(rep);\n\t            }\n\t            if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }\n\t        }\n\n> ```hasReadResolveMethod```： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br/>\n> ```invokeReadResolve```： 通过反射的方式调用要被反序列化的类的readResolve方法<br/>\n> ```if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }```：\n>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。\n\n#### 结论一 ####\n\n\t由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n","source":"_posts/2017-02-11-design-patterns-singleton-2.md","raw":"---\nlayout: post\ntitle:  单例设计模式(二)真●单例唯一$序列化\ndate:   2017-02-11\ncategories: work\ntag: 设计模式\n---\n \n\n#### 序列化对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n\n然后看我们的测试代码：\n\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.io.FileOutputStream;\n\timport java.io.ObjectInputStream;\n\timport java.io.ObjectOutputStream;\n\n\tpublic class SerializableDemo1 {\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\"tempFile\"));\n\t\t\t\toos.writeObject(Singleton.getInstance());\n\t\t\t\tFile file = new File(\"tempFile\");\n\t\t\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n\t\t\t\t\t\tfile));\n\t\t\t\tSingleton instance = (Singleton) ois.readObject();\n\t\t\t\tSystem.out.println(\"反序列化后的对象和原来的是否相等？\"\n\t\t\t\t\t\t+ (Singleton.getInstance() == instance));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n> 运行后： ``` 反序列化后的对象和原来的是否相等？false ```\n\n> 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。\n\n\n#### 序列化破坏单例の原因 ####\n\n反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,<br/>\n发现：``` Object obj = readObject0(false);```<br/>\n继续：\n\n\t case TC_OBJECT:\n\t                    return checkResolve(readOrdinaryObject(unshared));\n\n探究： ```ObjectInputStream$readOrdinaryObject```\n\n该方法关键代码片段一：\n\n\t Object obj;\n\t        try {\n\t            obj = desc.isInstantiable() ? desc.newInstance() : null;\n\t        } catch (Exception ex) {\n\t            throw (IOException) new InvalidClassException(\n\t                desc.forClass().getName(),\n\t                \"unable to create instance\").initCause(ex);\n\t        }\n\n> 该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br/>\n> ```isInstantiable```：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。\n> ```desc.newInstance()```：该方法通过反射的方式调用无参构造方法新建一个对象\n\n所以：\n\n> 反序列化会通过反射调用无参的构造创建一个新的对象\n\n该方法关键代码片段二：\n\n\t if (obj != null &&\n\t            handles.lookupException(passHandle) == null &&\n\t            desc.hasReadResolveMethod())\n\t        {\n\t            Object rep = desc.invokeReadResolve(obj);\n\t            if (unshared && rep.getClass().isArray()) {\n\t                rep = cloneArray(rep);\n\t            }\n\t            if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }\n\t        }\n\n> ```hasReadResolveMethod```： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br/>\n> ```invokeReadResolve```： 通过反射的方式调用要被反序列化的类的readResolve方法<br/>\n> ```if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }```：\n>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。\n\n#### 结论一 ####\n\n\t由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n","slug":"design-patterns-singleton-2","published":1,"updated":"2017-06-01T07:45:48.799Z","comments":1,"photos":[],"link":"","_id":"cj3tijdhl000bh8ivud0oyezz","content":"<h4 id=\"序列化对单例的破坏\"><a href=\"#序列化对单例的破坏\" class=\"headerlink\" title=\"序列化对单例的破坏\"></a>序列化对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class SerializableDemo1 {\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(\n                    new FileOutputStream(&quot;tempFile&quot;));\n            oos.writeObject(Singleton.getInstance());\n            File file = new File(&quot;tempFile&quot;);\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n                    file));\n            Singleton instance = (Singleton) ois.readObject();\n            System.out.println(&quot;反序列化后的对象和原来的是否相等？&quot;\n                    + (Singleton.getInstance() == instance));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt; 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 序列化破坏单例の原因 ####</div><div class=\"line\"></div><div class=\"line\">反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,&lt;br/&gt;</div><div class=\"line\">发现：``` Object obj = readObject0(false);```&lt;br/&gt;</div><div class=\"line\">继续：</div><div class=\"line\"></div><div class=\"line\">\t case TC_OBJECT:</div><div class=\"line\">\t                    return checkResolve(readOrdinaryObject(unshared));</div><div class=\"line\"></div><div class=\"line\">探究： ```ObjectInputStream$readOrdinaryObject</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>该方法关键代码片段一：</p>\n<pre><code>Object obj;\n       try {\n           obj = desc.isInstantiable() ? desc.newInstance() : null;\n       } catch (Exception ex) {\n           throw (IOException) new InvalidClassException(\n               desc.forClass().getName(),\n               &quot;unable to create instance&quot;).initCause(ex);\n       }\n</code></pre><blockquote>\n<p>该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br><br><code>isInstantiable</code>：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。<br><code>desc.newInstance()</code>：该方法通过反射的方式调用无参构造方法新建一个对象</p>\n</blockquote>\n<p>所以：</p>\n<blockquote>\n<p>反序列化会通过反射调用无参的构造创建一个新的对象</p>\n</blockquote>\n<p>该方法关键代码片段二：</p>\n<pre><code>if (obj != null &amp;&amp;\n           handles.lookupException(passHandle) == null &amp;&amp;\n           desc.hasReadResolveMethod())\n       {\n           Object rep = desc.invokeReadResolve(obj);\n           if (unshared &amp;&amp; rep.getClass().isArray()) {\n               rep = cloneArray(rep);\n           }\n           if (rep != obj) {\n               handles.setObject(passHandle, obj = rep);\n           }\n       }\n</code></pre><blockquote>\n<p><code>hasReadResolveMethod</code>： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br><br><code>invokeReadResolve</code>： 通过反射的方式调用要被反序列化的类的readResolve方法<br><br><code>if (rep != obj) {\n                    handles.setObject(passHandle, obj = rep);\n                }</code>：<br>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。</p>\n</blockquote>\n<h4 id=\"结论一\"><a href=\"#结论一\" class=\"headerlink\" title=\"结论一\"></a>结论一</h4><pre><code>由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\nimport java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    private Object readResolve() {\n        return singleton;\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"序列化对单例的破坏\"><a href=\"#序列化对单例的破坏\" class=\"headerlink\" title=\"序列化对单例的破坏\"></a>序列化对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class SerializableDemo1 {\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(\n                    new FileOutputStream(&quot;tempFile&quot;));\n            oos.writeObject(Singleton.getInstance());\n            File file = new File(&quot;tempFile&quot;);\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n                    file));\n            Singleton instance = (Singleton) ois.readObject();\n            System.out.println(&quot;反序列化后的对象和原来的是否相等？&quot;\n                    + (Singleton.getInstance() == instance));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt; 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 序列化破坏单例の原因 ####</div><div class=\"line\"></div><div class=\"line\">反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,&lt;br/&gt;</div><div class=\"line\">发现：``` Object obj = readObject0(false);```&lt;br/&gt;</div><div class=\"line\">继续：</div><div class=\"line\"></div><div class=\"line\">\t case TC_OBJECT:</div><div class=\"line\">\t                    return checkResolve(readOrdinaryObject(unshared));</div><div class=\"line\"></div><div class=\"line\">探究： ```ObjectInputStream$readOrdinaryObject</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>该方法关键代码片段一：</p>\n<pre><code>Object obj;\n       try {\n           obj = desc.isInstantiable() ? desc.newInstance() : null;\n       } catch (Exception ex) {\n           throw (IOException) new InvalidClassException(\n               desc.forClass().getName(),\n               &quot;unable to create instance&quot;).initCause(ex);\n       }\n</code></pre><blockquote>\n<p>该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br><br><code>isInstantiable</code>：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。<br><code>desc.newInstance()</code>：该方法通过反射的方式调用无参构造方法新建一个对象</p>\n</blockquote>\n<p>所以：</p>\n<blockquote>\n<p>反序列化会通过反射调用无参的构造创建一个新的对象</p>\n</blockquote>\n<p>该方法关键代码片段二：</p>\n<pre><code>if (obj != null &amp;&amp;\n           handles.lookupException(passHandle) == null &amp;&amp;\n           desc.hasReadResolveMethod())\n       {\n           Object rep = desc.invokeReadResolve(obj);\n           if (unshared &amp;&amp; rep.getClass().isArray()) {\n               rep = cloneArray(rep);\n           }\n           if (rep != obj) {\n               handles.setObject(passHandle, obj = rep);\n           }\n       }\n</code></pre><blockquote>\n<p><code>hasReadResolveMethod</code>： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br><br><code>invokeReadResolve</code>： 通过反射的方式调用要被反序列化的类的readResolve方法<br><br><code>if (rep != obj) {\n                    handles.setObject(passHandle, obj = rep);\n                }</code>：<br>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。</p>\n</blockquote>\n<h4 id=\"结论一\"><a href=\"#结论一\" class=\"headerlink\" title=\"结论一\"></a>结论一</h4><pre><code>由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\nimport java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    private Object readResolve() {\n        return singleton;\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"单例设计模式(三)真●单例唯一$反射","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 反射对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\t\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\t\n\t\tpublic static volatile Singleton singleton;\n\t\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\t\n\t}\n\n然后看我们的测试代码：\n\t\n\t\n\timport java.lang.reflect.Constructor;\n\t\n\tpublic class ReflectAttackSingleton {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tClass<?> classType = Singleton.class;\n\t\t\t\tConstructor<?> c;\n\t\t\t\tc = classType.getDeclaredConstructor(null);\n\t\t\t\tc.setAccessible(true);\n\t\t\t\tSingleton instance1 = (Singleton) c.newInstance();\n\t\t\t\tSingleton instance2 = Singleton.getInstance();\n\t\t\t\tSystem.out.println(\"反射得到的实例与单例中的实例是否相等？\" +(instance1 == instance2));\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t}\n\t}\n\n> 运行后： ``` 反射得到的实例与单例中的实例是否相等？false ```\n\n> 通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。\n\n\n#### 修改构造器抵御攻击 ####\n\t\n\tprivate static boolean flag = false;\n\tprivate Singleton() {\n\t\tsynchronized (Singleton.class) {\n\t\t\tif(flag == false)\n\t\t\t\tflag = !flag;\n\t\t\telse\n\t\t\t\tthrow new RuntimeException(\"单例模式被攻击！\");\n\t\t}\n\t};\n \n\n#### 终极方法 ####\n \t\n\t使用枚举单例","source":"_posts/2017-02-11-design-patterns-singleton-3.md","raw":"---\nlayout: post\ntitle:  单例设计模式(三)真●单例唯一$反射\ndate:   2017-02-11\ncategories: work\ntag: 设计模式\n---\n \n\n#### 反射对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\t\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\t\n\t\tpublic static volatile Singleton singleton;\n\t\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\t\n\t}\n\n然后看我们的测试代码：\n\t\n\t\n\timport java.lang.reflect.Constructor;\n\t\n\tpublic class ReflectAttackSingleton {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tClass<?> classType = Singleton.class;\n\t\t\t\tConstructor<?> c;\n\t\t\t\tc = classType.getDeclaredConstructor(null);\n\t\t\t\tc.setAccessible(true);\n\t\t\t\tSingleton instance1 = (Singleton) c.newInstance();\n\t\t\t\tSingleton instance2 = Singleton.getInstance();\n\t\t\t\tSystem.out.println(\"反射得到的实例与单例中的实例是否相等？\" +(instance1 == instance2));\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t}\n\t}\n\n> 运行后： ``` 反射得到的实例与单例中的实例是否相等？false ```\n\n> 通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。\n\n\n#### 修改构造器抵御攻击 ####\n\t\n\tprivate static boolean flag = false;\n\tprivate Singleton() {\n\t\tsynchronized (Singleton.class) {\n\t\t\tif(flag == false)\n\t\t\t\tflag = !flag;\n\t\t\telse\n\t\t\t\tthrow new RuntimeException(\"单例模式被攻击！\");\n\t\t}\n\t};\n \n\n#### 终极方法 ####\n \t\n\t使用枚举单例","slug":"design-patterns-singleton-3","published":1,"updated":"2017-06-01T07:45:42.479Z","comments":1,"photos":[],"link":"","_id":"cj3tijdhq000dh8ivkbyt4gc6","content":"<h4 id=\"反射对单例的破坏\"><a href=\"#反射对单例的破坏\" class=\"headerlink\" title=\"反射对单例的破坏\"></a>反射对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.lang.reflect.Constructor;\n\npublic class ReflectAttackSingleton {\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; classType = Singleton.class;\n            Constructor&lt;?&gt; c;\n            c = classType.getDeclaredConstructor(null);\n            c.setAccessible(true);\n            Singleton instance1 = (Singleton) c.newInstance();\n            Singleton instance2 = Singleton.getInstance();\n            System.out.println(&quot;反射得到的实例与单例中的实例是否相等？&quot; +(instance1 == instance2));\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <code>反射得到的实例与单例中的实例是否相等？false</code></p>\n<p>通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。</p>\n</blockquote>\n<h4 id=\"修改构造器抵御攻击\"><a href=\"#修改构造器抵御攻击\" class=\"headerlink\" title=\"修改构造器抵御攻击\"></a>修改构造器抵御攻击</h4><pre><code>private static boolean flag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if(flag == false)\n            flag = !flag;\n        else\n            throw new RuntimeException(&quot;单例模式被攻击！&quot;);\n    }\n};\n</code></pre><h4 id=\"终极方法\"><a href=\"#终极方法\" class=\"headerlink\" title=\"终极方法\"></a>终极方法</h4><pre><code>使用枚举单例\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"反射对单例的破坏\"><a href=\"#反射对单例的破坏\" class=\"headerlink\" title=\"反射对单例的破坏\"></a>反射对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.lang.reflect.Constructor;\n\npublic class ReflectAttackSingleton {\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; classType = Singleton.class;\n            Constructor&lt;?&gt; c;\n            c = classType.getDeclaredConstructor(null);\n            c.setAccessible(true);\n            Singleton instance1 = (Singleton) c.newInstance();\n            Singleton instance2 = Singleton.getInstance();\n            System.out.println(&quot;反射得到的实例与单例中的实例是否相等？&quot; +(instance1 == instance2));\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <code>反射得到的实例与单例中的实例是否相等？false</code></p>\n<p>通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。</p>\n</blockquote>\n<h4 id=\"修改构造器抵御攻击\"><a href=\"#修改构造器抵御攻击\" class=\"headerlink\" title=\"修改构造器抵御攻击\"></a>修改构造器抵御攻击</h4><pre><code>private static boolean flag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if(flag == false)\n            flag = !flag;\n        else\n            throw new RuntimeException(&quot;单例模式被攻击！&quot;);\n    }\n};\n</code></pre><h4 id=\"终极方法\"><a href=\"#终极方法\" class=\"headerlink\" title=\"终极方法\"></a>终极方法</h4><pre><code>使用枚举单例\n</code></pre>"},{"layout":"post","title":"单例设计模式(一)基础知识","date":"2017-02-11T00:00:00.000Z","_content":"\n#### what ####\n\n##### 来自wiki #####\n \n\t[单例模式](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。\n\t比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\n\n##### 来自IBM #####\n\t与wiki相重复的内容，不再摘录。\n\t[单例模式](http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：\n\t1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n\t2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 \n\n#### how ####\n\n##### 饿汉单例 #####\n\tpublic class Singleton {\n\t private Singleton(){}\n\t private static Singleton instance = new Singleton();\n\t public static Singleton getInsatnce(){\n\t return instance;\n\t }\n\t}\n\n> 上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。\n\n##### 懒汉单例 #####\n\n\tpublic class LazySingleton {\n\t\n\t\tprivate LazySingleton() {\n\t\t}\n\t\n\t\tpublic static LazySingleton instance = null;\n\t\n\t\tpublic static synchronized LazySingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tinstance = new LazySingleton();\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br/>\n\n> 在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。\n\n##### 懒汉单例的改进：静态内部类单例 #####\n\n\tpublic class StaticInnerClassSingleton {\n\t\n\t\tprivate StaticInnerClassSingleton() {\n\t\t}\n\t\n\t\tpublic StaticInnerClassSingleton getInstance() {\n\t\t\treturn SingletonHolder.instance;\n\t\t}\n\t\n\t\tprivate static class SingletonHolder {\n\t\t\tprivate static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n\t\t}\n\t}\n\n> 使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。\n\n##### DoubleCheckLock 实现单例 #####\n\t\n\tpublic class DCLSingleton {\n\t\n\t\tprivate static DCLSingleton instance = null;\n\t\n\t\tprivate DCLSingleton() {\n\t\t}\n\t\n\t\tpublic DCLSingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tsynchronized (DCLSingleton.class) {\n\t\t\t\t\tif (instance == null) {\n\t\t\t\t\t\tinstance = new DCLSingleton();\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br/>因为\n> ```instance = new DCLSingleton();```\n>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br/>\n>1.给DCLSingleton的实例分配内存<br/>\n>2.调用DCLSingleton的构造，初始化成员字段<br/>\n>3.将instance对象指向分配的内存空间<br/>\n\n\n>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中*Cache、寄存器到主内存回写顺序*的规定，上面2、3的顺序无法保证先后执行的。<br/>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br/>\n>解决：JDK1.5之后，```private static volatile DCLSingleton instance = null;``` \n>使用volatile关键字，可以保证instance对象*每次都是从主内存中读取*。\n\n##### 容器维护多个单例 #####\n\n\n\timport java.util.HashMap;\n\timport java.util.Map;\n\t\n\tpublic class SingletonManager {\n\t\tprivate static Map<String,Object> objMap = new HashMap<>();\n\t\t\n\t\tprivate SingletonManager(){}\n\t\t\n\t\tpublic static void registerService(String key,Object instance){\n\t\t\tif(!objMap.containsKey(key)){\n\t\t\t\tobjMap.put(key, instance);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Object getService(String key){\n\t\t\treturn objMap.get(key);\n\t\t}\n\t\n\t}\n\n> 根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)\n \n##### 枚举单例 #####\n\n\tpublic enum EnumSingleton {\n\t\n\t\tINSTANCE;\n\t\n\t\tpublic void doSomething() {\n\t\t}\n\t}\n\n> 写法简单，线程安全，在任何情况下都是单例！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-11-design-patterns-singleton-1.md","raw":"---\nlayout: post\ntitle:  单例设计模式(一)基础知识\ndate:   2017-02-11\ncategories: work\ntag: 设计模式\n---\n\n#### what ####\n\n##### 来自wiki #####\n \n\t[单例模式](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。\n\t比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\n\n##### 来自IBM #####\n\t与wiki相重复的内容，不再摘录。\n\t[单例模式](http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：\n\t1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n\t2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 \n\n#### how ####\n\n##### 饿汉单例 #####\n\tpublic class Singleton {\n\t private Singleton(){}\n\t private static Singleton instance = new Singleton();\n\t public static Singleton getInsatnce(){\n\t return instance;\n\t }\n\t}\n\n> 上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。\n\n##### 懒汉单例 #####\n\n\tpublic class LazySingleton {\n\t\n\t\tprivate LazySingleton() {\n\t\t}\n\t\n\t\tpublic static LazySingleton instance = null;\n\t\n\t\tpublic static synchronized LazySingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tinstance = new LazySingleton();\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br/>\n\n> 在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。\n\n##### 懒汉单例的改进：静态内部类单例 #####\n\n\tpublic class StaticInnerClassSingleton {\n\t\n\t\tprivate StaticInnerClassSingleton() {\n\t\t}\n\t\n\t\tpublic StaticInnerClassSingleton getInstance() {\n\t\t\treturn SingletonHolder.instance;\n\t\t}\n\t\n\t\tprivate static class SingletonHolder {\n\t\t\tprivate static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n\t\t}\n\t}\n\n> 使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。\n\n##### DoubleCheckLock 实现单例 #####\n\t\n\tpublic class DCLSingleton {\n\t\n\t\tprivate static DCLSingleton instance = null;\n\t\n\t\tprivate DCLSingleton() {\n\t\t}\n\t\n\t\tpublic DCLSingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tsynchronized (DCLSingleton.class) {\n\t\t\t\t\tif (instance == null) {\n\t\t\t\t\t\tinstance = new DCLSingleton();\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br/>因为\n> ```instance = new DCLSingleton();```\n>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br/>\n>1.给DCLSingleton的实例分配内存<br/>\n>2.调用DCLSingleton的构造，初始化成员字段<br/>\n>3.将instance对象指向分配的内存空间<br/>\n\n\n>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中*Cache、寄存器到主内存回写顺序*的规定，上面2、3的顺序无法保证先后执行的。<br/>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br/>\n>解决：JDK1.5之后，```private static volatile DCLSingleton instance = null;``` \n>使用volatile关键字，可以保证instance对象*每次都是从主内存中读取*。\n\n##### 容器维护多个单例 #####\n\n\n\timport java.util.HashMap;\n\timport java.util.Map;\n\t\n\tpublic class SingletonManager {\n\t\tprivate static Map<String,Object> objMap = new HashMap<>();\n\t\t\n\t\tprivate SingletonManager(){}\n\t\t\n\t\tpublic static void registerService(String key,Object instance){\n\t\t\tif(!objMap.containsKey(key)){\n\t\t\t\tobjMap.put(key, instance);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Object getService(String key){\n\t\t\treturn objMap.get(key);\n\t\t}\n\t\n\t}\n\n> 根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)\n \n##### 枚举单例 #####\n\n\tpublic enum EnumSingleton {\n\t\n\t\tINSTANCE;\n\t\n\t\tpublic void doSomething() {\n\t\t}\n\t}\n\n> 写法简单，线程安全，在任何情况下都是单例！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"design-patterns-singleton-1","published":1,"updated":"2017-06-01T07:46:03.279Z","comments":1,"photos":[],"link":"","_id":"cj3tijdht000hh8ivl3lqyb80","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"来自wiki\"><a href=\"#来自wiki\" class=\"headerlink\" title=\"来自wiki\"></a>来自wiki</h5><pre><code>[单例模式](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。\n比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\n</code></pre><h5 id=\"来自IBM\"><a href=\"#来自IBM\" class=\"headerlink\" title=\"来自IBM\"></a>来自IBM</h5><pre><code>与wiki相重复的内容，不再摘录。\n[单例模式](http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：\n1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 \n</code></pre><h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><h5 id=\"饿汉单例\"><a href=\"#饿汉单例\" class=\"headerlink\" title=\"饿汉单例\"></a>饿汉单例</h5><pre><code>public class Singleton {\n private Singleton(){}\n private static Singleton instance = new Singleton();\n public static Singleton getInsatnce(){\n return instance;\n }\n}\n</code></pre><blockquote>\n<p>上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。</p>\n</blockquote>\n<h5 id=\"懒汉单例\"><a href=\"#懒汉单例\" class=\"headerlink\" title=\"懒汉单例\"></a>懒汉单例</h5><pre><code>public class LazySingleton {\n\n    private LazySingleton() {\n    }\n\n    public static LazySingleton instance = null;\n\n    public static synchronized LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br></p>\n<p>在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。</p>\n</blockquote>\n<h5 id=\"懒汉单例的改进：静态内部类单例\"><a href=\"#懒汉单例的改进：静态内部类单例\" class=\"headerlink\" title=\"懒汉单例的改进：静态内部类单例\"></a>懒汉单例的改进：静态内部类单例</h5><pre><code>public class StaticInnerClassSingleton {\n\n    private StaticInnerClassSingleton() {\n    }\n\n    public StaticInnerClassSingleton getInstance() {\n        return SingletonHolder.instance;\n    }\n\n    private static class SingletonHolder {\n        private static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n    }\n}\n</code></pre><blockquote>\n<p>使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。</p>\n</blockquote>\n<h5 id=\"DoubleCheckLock-实现单例\"><a href=\"#DoubleCheckLock-实现单例\" class=\"headerlink\" title=\"DoubleCheckLock 实现单例\"></a>DoubleCheckLock 实现单例</h5><pre><code>public class DCLSingleton {\n\n    private static DCLSingleton instance = null;\n\n    private DCLSingleton() {\n    }\n\n    public DCLSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DCLSingleton.class) {\n                if (instance == null) {\n                    instance = new DCLSingleton();\n                }\n\n            }\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br>因为<br><code>instance = new DCLSingleton();</code><br>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br><br>1.给DCLSingleton的实例分配内存<br><br>2.调用DCLSingleton的构造，初始化成员字段<br><br>3.将instance对象指向分配的内存空间<br></p>\n<p>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中<em>Cache、寄存器到主内存回写顺序</em>的规定，上面2、3的顺序无法保证先后执行的。<br>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br><br>解决：JDK1.5之后，<code>private static volatile DCLSingleton instance = null;</code><br>使用volatile关键字，可以保证instance对象<em>每次都是从主内存中读取</em>。</p>\n</blockquote>\n<h5 id=\"容器维护多个单例\"><a href=\"#容器维护多个单例\" class=\"headerlink\" title=\"容器维护多个单例\"></a>容器维护多个单例</h5><pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class SingletonManager {\n    private static Map&lt;String,Object&gt; objMap = new HashMap&lt;&gt;();\n\n    private SingletonManager(){}\n\n    public static void registerService(String key,Object instance){\n        if(!objMap.containsKey(key)){\n            objMap.put(key, instance);\n        }\n    }\n\n    public static Object getService(String key){\n        return objMap.get(key);\n    }\n\n}\n</code></pre><blockquote>\n<p>根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)</p>\n</blockquote>\n<h5 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h5><pre><code>public enum EnumSingleton {\n\n    INSTANCE;\n\n    public void doSomething() {\n    }\n}\n</code></pre><blockquote>\n<p>写法简单，线程安全，在任何情况下都是单例！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"来自wiki\"><a href=\"#来自wiki\" class=\"headerlink\" title=\"来自wiki\"></a>来自wiki</h5><pre><code>[单例模式](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。\n比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\n</code></pre><h5 id=\"来自IBM\"><a href=\"#来自IBM\" class=\"headerlink\" title=\"来自IBM\"></a>来自IBM</h5><pre><code>与wiki相重复的内容，不再摘录。\n[单例模式](http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：\n1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 \n</code></pre><h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><h5 id=\"饿汉单例\"><a href=\"#饿汉单例\" class=\"headerlink\" title=\"饿汉单例\"></a>饿汉单例</h5><pre><code>public class Singleton {\n private Singleton(){}\n private static Singleton instance = new Singleton();\n public static Singleton getInsatnce(){\n return instance;\n }\n}\n</code></pre><blockquote>\n<p>上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。</p>\n</blockquote>\n<h5 id=\"懒汉单例\"><a href=\"#懒汉单例\" class=\"headerlink\" title=\"懒汉单例\"></a>懒汉单例</h5><pre><code>public class LazySingleton {\n\n    private LazySingleton() {\n    }\n\n    public static LazySingleton instance = null;\n\n    public static synchronized LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br></p>\n<p>在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。</p>\n</blockquote>\n<h5 id=\"懒汉单例的改进：静态内部类单例\"><a href=\"#懒汉单例的改进：静态内部类单例\" class=\"headerlink\" title=\"懒汉单例的改进：静态内部类单例\"></a>懒汉单例的改进：静态内部类单例</h5><pre><code>public class StaticInnerClassSingleton {\n\n    private StaticInnerClassSingleton() {\n    }\n\n    public StaticInnerClassSingleton getInstance() {\n        return SingletonHolder.instance;\n    }\n\n    private static class SingletonHolder {\n        private static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n    }\n}\n</code></pre><blockquote>\n<p>使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。</p>\n</blockquote>\n<h5 id=\"DoubleCheckLock-实现单例\"><a href=\"#DoubleCheckLock-实现单例\" class=\"headerlink\" title=\"DoubleCheckLock 实现单例\"></a>DoubleCheckLock 实现单例</h5><pre><code>public class DCLSingleton {\n\n    private static DCLSingleton instance = null;\n\n    private DCLSingleton() {\n    }\n\n    public DCLSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DCLSingleton.class) {\n                if (instance == null) {\n                    instance = new DCLSingleton();\n                }\n\n            }\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br>因为<br><code>instance = new DCLSingleton();</code><br>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br><br>1.给DCLSingleton的实例分配内存<br><br>2.调用DCLSingleton的构造，初始化成员字段<br><br>3.将instance对象指向分配的内存空间<br></p>\n<p>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中<em>Cache、寄存器到主内存回写顺序</em>的规定，上面2、3的顺序无法保证先后执行的。<br>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br><br>解决：JDK1.5之后，<code>private static volatile DCLSingleton instance = null;</code><br>使用volatile关键字，可以保证instance对象<em>每次都是从主内存中读取</em>。</p>\n</blockquote>\n<h5 id=\"容器维护多个单例\"><a href=\"#容器维护多个单例\" class=\"headerlink\" title=\"容器维护多个单例\"></a>容器维护多个单例</h5><pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class SingletonManager {\n    private static Map&lt;String,Object&gt; objMap = new HashMap&lt;&gt;();\n\n    private SingletonManager(){}\n\n    public static void registerService(String key,Object instance){\n        if(!objMap.containsKey(key)){\n            objMap.put(key, instance);\n        }\n    }\n\n    public static Object getService(String key){\n        return objMap.get(key);\n    }\n\n}\n</code></pre><blockquote>\n<p>根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)</p>\n</blockquote>\n<h5 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h5><pre><code>public enum EnumSingleton {\n\n    INSTANCE;\n\n    public void doSomething() {\n    }\n}\n</code></pre><blockquote>\n<p>写法简单，线程安全，在任何情况下都是单例！</p>\n</blockquote>\n"},{"layout":"post","title":"如何仅用递归函数和栈操作逆序一个栈","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n\t一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t需要设计两个递归函数。\n\t1，将stack的栈底元素返回并移除；\n\t2，将stack逆序；\n\n \n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\n\tpublic class ReverseStack {\n\n\tprivate static int getAndRemoveLastElement(Stack<Integer> stack) {\n\t\tint result = stack.pop();\n\t\tif (stack.empty()) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\tint last = getAndRemoveLastElement(stack);\n\t\t\tstack.push(result);//此处将除栈底外的元素重新压入\n\t\t\treturn last;\n\t\t}\n\t}\n\n\tpublic static void reverse(Stack<Integer> stack) {\n\t\tif (stack.empty()) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tint i = getAndRemoveLastElement(stack);\n\t\t\treverse(stack);\n\t\t\tstack.push(i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-11-reverse-stack.md","raw":"---\nlayout: post\ntitle:  如何仅用递归函数和栈操作逆序一个栈\ndate:   2017-02-11\ncategories: work\ntag: 算法\n---\n \n\n#### 题目 ####\n\n\t一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t需要设计两个递归函数。\n\t1，将stack的栈底元素返回并移除；\n\t2，将stack逆序；\n\n \n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\n\tpublic class ReverseStack {\n\n\tprivate static int getAndRemoveLastElement(Stack<Integer> stack) {\n\t\tint result = stack.pop();\n\t\tif (stack.empty()) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\tint last = getAndRemoveLastElement(stack);\n\t\t\tstack.push(result);//此处将除栈底外的元素重新压入\n\t\t\treturn last;\n\t\t}\n\t}\n\n\tpublic static void reverse(Stack<Integer> stack) {\n\t\tif (stack.empty()) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tint i = getAndRemoveLastElement(stack);\n\t\t\treverse(stack);\n\t\t\tstack.push(i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"reverse-stack","published":1,"updated":"2017-06-01T07:45:18.880Z","comments":1,"photos":[],"link":"","_id":"cj3tijdhx000kh8iv9ui2iale","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>需要设计两个递归函数。\n1，将stack的栈底元素返回并移除；\n2，将stack逆序；\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class ReverseStack {\n\nprivate static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) {\n    int result = stack.pop();\n    if (stack.empty()) {\n        return result;\n    } else {\n        int last = getAndRemoveLastElement(stack);\n        stack.push(result);//此处将除栈底外的元素重新压入\n        return last;\n    }\n}\n\npublic static void reverse(Stack&lt;Integer&gt; stack) {\n    if (stack.empty()) {\n        return;\n    } else {\n        int i = getAndRemoveLastElement(stack);\n        reverse(stack);\n        stack.push(i);\n    }\n}\n</code></pre><p>}</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>需要设计两个递归函数。\n1，将stack的栈底元素返回并移除；\n2，将stack逆序；\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class ReverseStack {\n\nprivate static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) {\n    int result = stack.pop();\n    if (stack.empty()) {\n        return result;\n    } else {\n        int last = getAndRemoveLastElement(stack);\n        stack.push(result);//此处将除栈底外的元素重新压入\n        return last;\n    }\n}\n\npublic static void reverse(Stack&lt;Integer&gt; stack) {\n    if (stack.empty()) {\n        return;\n    } else {\n        int i = getAndRemoveLastElement(stack);\n        reverse(stack);\n        stack.push(i);\n    }\n}\n</code></pre><p>}</p>\n"},{"layout":"post","title":"队列、堆栈与数组链表的关系","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 数据结构的概念 ####\n\n\t指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n\n\n#### 数据存储结构的概念 ####\n\t\n\t这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n\t非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n\n##### 数组和链表 #####\n\t\n\t数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n\t链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n\t\n\n|类型 |内存空间 |长度的可变性 |对数据的访问\n|-----|:-------:|:----------:|:----------:|\n|数组|连续的内存空间，相同多数据下占用较小内存|需要提前给定|移动数据麻烦，访问数据方便|\n|链表|可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间|可以伸缩|移动数据方便，访问数据麻烦|\n\n##### 堆栈和栈 #####\n\t[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n\n##### Java中的堆和栈#####\n\t\t\n\t1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n\t2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。","source":"_posts/2017-02-11-different-between-ADT.md","raw":"---\nlayout: post\ntitle:  队列、堆栈与数组链表的关系\ndate:   2017-02-11\ncategories: work\ntag: 算法\n---\n \n\n#### 数据结构的概念 ####\n\n\t指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n\n\n#### 数据存储结构的概念 ####\n\t\n\t这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n\t非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n\n##### 数组和链表 #####\n\t\n\t数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n\t链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n\t\n\n|类型 |内存空间 |长度的可变性 |对数据的访问\n|-----|:-------:|:----------:|:----------:|\n|数组|连续的内存空间，相同多数据下占用较小内存|需要提前给定|移动数据麻烦，访问数据方便|\n|链表|可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间|可以伸缩|移动数据方便，访问数据麻烦|\n\n##### 堆栈和栈 #####\n\t[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n\n##### Java中的堆和栈#####\n\t\t\n\t1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n\t2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。","slug":"different-between-ADT","published":1,"updated":"2017-06-01T07:45:31.876Z","comments":1,"photos":[],"link":"","_id":"cj3tijdi0000nh8ivmuq252cn","content":"<h4 id=\"数据结构的概念\"><a href=\"#数据结构的概念\" class=\"headerlink\" title=\"数据结构的概念\"></a>数据结构的概念</h4><pre><code>指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n</code></pre><h4 id=\"数据存储结构的概念\"><a href=\"#数据存储结构的概念\" class=\"headerlink\" title=\"数据存储结构的概念\"></a>数据存储结构的概念</h4><pre><code>这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n</code></pre><h5 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h5><pre><code>数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n</code></pre><table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:center\">内存空间</th>\n<th style=\"text-align:center\">长度的可变性</th>\n<th style=\"text-align:center\">对数据的访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数组</td>\n<td style=\"text-align:center\">连续的内存空间，相同多数据下占用较小内存</td>\n<td style=\"text-align:center\">需要提前给定</td>\n<td style=\"text-align:center\">移动数据麻烦，访问数据方便</td>\n</tr>\n<tr>\n<td>链表</td>\n<td style=\"text-align:center\">可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间</td>\n<td style=\"text-align:center\">可以伸缩</td>\n<td style=\"text-align:center\">移动数据方便，访问数据麻烦</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"堆栈和栈\"><a href=\"#堆栈和栈\" class=\"headerlink\" title=\"堆栈和栈\"></a>堆栈和栈</h5><pre><code>[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n</code></pre><h5 id=\"Java中的堆和栈\"><a href=\"#Java中的堆和栈\" class=\"headerlink\" title=\"Java中的堆和栈\"></a>Java中的堆和栈</h5><pre><code>1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"数据结构的概念\"><a href=\"#数据结构的概念\" class=\"headerlink\" title=\"数据结构的概念\"></a>数据结构的概念</h4><pre><code>指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n</code></pre><h4 id=\"数据存储结构的概念\"><a href=\"#数据存储结构的概念\" class=\"headerlink\" title=\"数据存储结构的概念\"></a>数据存储结构的概念</h4><pre><code>这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n</code></pre><h5 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h5><pre><code>数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n</code></pre><table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:center\">内存空间</th>\n<th style=\"text-align:center\">长度的可变性</th>\n<th style=\"text-align:center\">对数据的访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数组</td>\n<td style=\"text-align:center\">连续的内存空间，相同多数据下占用较小内存</td>\n<td style=\"text-align:center\">需要提前给定</td>\n<td style=\"text-align:center\">移动数据麻烦，访问数据方便</td>\n</tr>\n<tr>\n<td>链表</td>\n<td style=\"text-align:center\">可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间</td>\n<td style=\"text-align:center\">可以伸缩</td>\n<td style=\"text-align:center\">移动数据方便，访问数据麻烦</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"堆栈和栈\"><a href=\"#堆栈和栈\" class=\"headerlink\" title=\"堆栈和栈\"></a>堆栈和栈</h5><pre><code>[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n</code></pre><h5 id=\"Java中的堆和栈\"><a href=\"#Java中的堆和栈\" class=\"headerlink\" title=\"Java中的堆和栈\"></a>Java中的堆和栈</h5><pre><code>1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。\n</code></pre>"},{"layout":"post","title":"单例设计模式(四)并不总是有效的readResolve","date":"2017-02-12T00:00:00.000Z","_content":" \n#### what ####\n\n在[《单例设计模式(二)真●单例唯一$序列化》](http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2)中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。\n\n1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。\n\n2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：\n\t\n\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。\n事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。\n\n\n4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。\n\n\n#### 题外话-readObject ####\n\n是的，关于反序列时的攻击。\n\n伪字节流的攻击法：对应的策略是提供一个readObject方法。\n但是并没有完成足够的保护性拷贝。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t    // 再进行状态参数的有效性验证\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n内部私有域盗用攻击法：对应的处理代码如下。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t \n\t    // 对可变组件进行保护性拷贝\n\t    start = new Date(start.getTime());\n\t    end = new Date(end.getTime());\n\t \n\t    // 进一步检测内部状态参数是否有效\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n#### 鸣谢 ####\n\n[代码迷](http://www.daimami.com/java-other/356857.htm)\n\n\n","source":"_posts/2017-02-12-design-patterns-singleton-4.md","raw":"---\nlayout: post\ntitle:  单例设计模式(四)并不总是有效的readResolve\ndate:   2017-02-12\ncategories: work\ntag: 设计模式\n---\n \n#### what ####\n\n在[《单例设计模式(二)真●单例唯一$序列化》](http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2)中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。\n\n1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。\n\n2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：\n\t\n\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。\n事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。\n\n\n4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。\n\n\n#### 题外话-readObject ####\n\n是的，关于反序列时的攻击。\n\n伪字节流的攻击法：对应的策略是提供一个readObject方法。\n但是并没有完成足够的保护性拷贝。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t    // 再进行状态参数的有效性验证\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n内部私有域盗用攻击法：对应的处理代码如下。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t \n\t    // 对可变组件进行保护性拷贝\n\t    start = new Date(start.getTime());\n\t    end = new Date(end.getTime());\n\t \n\t    // 进一步检测内部状态参数是否有效\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n#### 鸣谢 ####\n\n[代码迷](http://www.daimami.com/java-other/356857.htm)\n\n\n","slug":"design-patterns-singleton-4","published":1,"updated":"2017-06-01T07:44:59.225Z","comments":1,"photos":[],"link":"","_id":"cj3tijdi3000qh8iv466urr2u","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在<a href=\"http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2\" target=\"_blank\" rel=\"external\">《单例设计模式(二)真●单例唯一$序列化》</a>中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。</p>\n<p>1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。</p>\n<p>2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：</p>\n<pre><code>private Object readResolve() {\n        return singleton;\n    }\n</code></pre><p>3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。<br>事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。</p>\n<p>4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。</p>\n<h4 id=\"题外话-readObject\"><a href=\"#题外话-readObject\" class=\"headerlink\" title=\"题外话-readObject\"></a>题外话-readObject</h4><p>是的，关于反序列时的攻击。</p>\n<p>伪字节流的攻击法：对应的策略是提供一个readObject方法。<br>但是并没有完成足够的保护性拷贝。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n    // 再进行状态参数的有效性验证\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><p>内部私有域盗用攻击法：对应的处理代码如下。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n\n    // 对可变组件进行保护性拷贝\n    start = new Date(start.getTime());\n    end = new Date(end.getTime());\n\n    // 进一步检测内部状态参数是否有效\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"http://www.daimami.com/java-other/356857.htm\" target=\"_blank\" rel=\"external\">代码迷</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在<a href=\"http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2\" target=\"_blank\" rel=\"external\">《单例设计模式(二)真●单例唯一$序列化》</a>中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。</p>\n<p>1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。</p>\n<p>2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：</p>\n<pre><code>private Object readResolve() {\n        return singleton;\n    }\n</code></pre><p>3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。<br>事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。</p>\n<p>4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。</p>\n<h4 id=\"题外话-readObject\"><a href=\"#题外话-readObject\" class=\"headerlink\" title=\"题外话-readObject\"></a>题外话-readObject</h4><p>是的，关于反序列时的攻击。</p>\n<p>伪字节流的攻击法：对应的策略是提供一个readObject方法。<br>但是并没有完成足够的保护性拷贝。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n    // 再进行状态参数的有效性验证\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><p>内部私有域盗用攻击法：对应的处理代码如下。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n\n    // 对可变组件进行保护性拷贝\n    start = new Date(start.getTime());\n    end = new Date(end.getTime());\n\n    // 进一步检测内部状态参数是否有效\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"http://www.daimami.com/java-other/356857.htm\" target=\"_blank\" rel=\"external\">代码迷</a></p>\n"},{"layout":"post","title":"生成窗口最大值数组","date":"2017-02-16T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 生成窗口最大值数组 #####\n\n有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。\n例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：\n\n>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br/>\n>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br/>\n>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br/>\n>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br/>\n>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br/>\n>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br/>\n \n\n>请实现一个函数：\n>\n- 输入：整型数组arr，窗口大小为w\n- 输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。\n\n以上例，结果应为：{5,5,5,4,6,7}.\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一:O(N * w)#####\n\n\t public class Demo {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static int[] getMaxWindow(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tfor (int i = 0; i < arr.length - w + 1; i++) {\n\t\t\t\tint x = arr[i];\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (arr[i + j] >= x)\n\t\t\t\t\t\tx = arr[i + j];\n\t\t\t\t}\n\t\t\t\tresult[i] = x;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n##### 方法二:O(N)#####\n\n>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。\n>放入规则：\n1. 如果qmax为空，直接把下标i放入；\n2. 如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；\n\n>弹出规则：\n如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。\n\n>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).\n\n>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则`java.lang.ArrayIndexOutOfBoundsException`.\n\n\tpublic static int[] getMaxWindow2(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tLinkedList<Integer> qmax = new LinkedList<>();\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\n\t\t\t\twhile (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {\n\t\t\t\t\tqmax.pollLast();\n\t\t\t\t}\n\t\t\t\tqmax.addLast(i);\n\t\t\t\tif (qmax.peekFirst() == i - w) {\n\t\t\t\t\tqmax.pollFirst();\n\t\t\t\t}\n\t\t\t\tif (i >= w - 1)\n\t\t\t\t\tresult[index++] = arr[qmax.peekFirst()];\n\t\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n###### 双端队列的实现类 ######\n\n\n\tpublic class LinkedList<E> extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n\n \n\n\tpublic class ArrayDeque<E> extends AbstractCollection<E>\n\t                           implements Deque<E>, Cloneable, Serializable\n\n  \n\n\n[java集合类深入分析之Queue篇](http://shmilyaw-hotmail-com.iteye.com/blog/1700599)\n\n\n","source":"_posts/2017-02-16-get-max-window.md","raw":"---\nlayout: post\ntitle:  生成窗口最大值数组\ndate:   2017-02-16\ncategories: work\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 生成窗口最大值数组 #####\n\n有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。\n例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：\n\n>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br/>\n>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br/>\n>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br/>\n>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br/>\n>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br/>\n>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br/>\n \n\n>请实现一个函数：\n>\n- 输入：整型数组arr，窗口大小为w\n- 输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。\n\n以上例，结果应为：{5,5,5,4,6,7}.\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一:O(N * w)#####\n\n\t public class Demo {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static int[] getMaxWindow(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tfor (int i = 0; i < arr.length - w + 1; i++) {\n\t\t\t\tint x = arr[i];\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (arr[i + j] >= x)\n\t\t\t\t\t\tx = arr[i + j];\n\t\t\t\t}\n\t\t\t\tresult[i] = x;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n##### 方法二:O(N)#####\n\n>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。\n>放入规则：\n1. 如果qmax为空，直接把下标i放入；\n2. 如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；\n\n>弹出规则：\n如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。\n\n>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).\n\n>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则`java.lang.ArrayIndexOutOfBoundsException`.\n\n\tpublic static int[] getMaxWindow2(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tLinkedList<Integer> qmax = new LinkedList<>();\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\n\t\t\t\twhile (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {\n\t\t\t\t\tqmax.pollLast();\n\t\t\t\t}\n\t\t\t\tqmax.addLast(i);\n\t\t\t\tif (qmax.peekFirst() == i - w) {\n\t\t\t\t\tqmax.pollFirst();\n\t\t\t\t}\n\t\t\t\tif (i >= w - 1)\n\t\t\t\t\tresult[index++] = arr[qmax.peekFirst()];\n\t\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n###### 双端队列的实现类 ######\n\n\n\tpublic class LinkedList<E> extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n\n \n\n\tpublic class ArrayDeque<E> extends AbstractCollection<E>\n\t                           implements Deque<E>, Cloneable, Serializable\n\n  \n\n\n[java集合类深入分析之Queue篇](http://shmilyaw-hotmail-com.iteye.com/blog/1700599)\n\n\n","slug":"get-max-window","published":1,"updated":"2017-06-01T07:40:45.499Z","comments":1,"photos":[],"link":"","_id":"cj3tijdi7000uh8ivx58zom4k","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"生成窗口最大值数组\"><a href=\"#生成窗口最大值数组\" class=\"headerlink\" title=\"生成窗口最大值数组\"></a>生成窗口最大值数组</h5><p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。<br>例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：</p>\n<blockquote>\n<p>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br><br>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br><br>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br><br>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br><br>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br><br>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br></p>\n<p>请实现一个函数：</p>\n<ul>\n<li>输入：整型数组arr，窗口大小为w</li>\n<li>输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。</li>\n</ul>\n</blockquote>\n<p>以上例，结果应为：{5,5,5,4,6,7}.</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一-O-N-w\"><a href=\"#方法一-O-N-w\" class=\"headerlink\" title=\"方法一:O(N * w)\"></a>方法一:O(N * w)</h5><pre><code> public class Demo {\n\n    public static void main(String[] args) {\n        int[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n\n    public static int[] getMaxWindow(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        for (int i = 0; i &lt; arr.length - w + 1; i++) {\n            int x = arr[i];\n            for (int j = 0; j &lt; w; j++) {\n                if (arr[i + j] &gt;= x)\n                    x = arr[i + j];\n            }\n            result[i] = x;\n        }\n        return result;\n    }\n}\n</code></pre><h5 id=\"方法二-O-N\"><a href=\"#方法二-O-N\" class=\"headerlink\" title=\"方法二:O(N)\"></a>方法二:O(N)</h5><blockquote>\n<p>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。<br>放入规则：</p>\n<ol>\n<li>如果qmax为空，直接把下标i放入；</li>\n<li>如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；</li>\n</ol>\n<p>弹出规则：<br>如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。</p>\n<p>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).</p>\n<p>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则<code>java.lang.ArrayIndexOutOfBoundsException</code>.</p>\n</blockquote>\n<pre><code>public static int[] getMaxWindow2(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();\n        int index = 0;\n        for (int i = 0; i &lt; arr.length; i++) {\n\n            while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) {\n                qmax.pollLast();\n            }\n            qmax.addLast(i);\n            if (qmax.peekFirst() == i - w) {\n                qmax.pollFirst();\n            }\n            if (i &gt;= w - 1)\n                result[index++] = arr[qmax.peekFirst()];\n\n        }\n        return result;\n    }\n</code></pre><h6 id=\"双端队列的实现类\"><a href=\"#双端队列的实现类\" class=\"headerlink\" title=\"双端队列的实现类\"></a>双端队列的实现类</h6><pre><code>public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable\n\n\n\npublic class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;\n                           implements Deque&lt;E&gt;, Cloneable, Serializable\n</code></pre><p><a href=\"http://shmilyaw-hotmail-com.iteye.com/blog/1700599\" target=\"_blank\" rel=\"external\">java集合类深入分析之Queue篇</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"生成窗口最大值数组\"><a href=\"#生成窗口最大值数组\" class=\"headerlink\" title=\"生成窗口最大值数组\"></a>生成窗口最大值数组</h5><p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。<br>例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：</p>\n<blockquote>\n<p>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br><br>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br><br>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br><br>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br><br>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br><br>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br></p>\n<p>请实现一个函数：</p>\n<ul>\n<li>输入：整型数组arr，窗口大小为w</li>\n<li>输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。</li>\n</ul>\n</blockquote>\n<p>以上例，结果应为：{5,5,5,4,6,7}.</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一-O-N-w\"><a href=\"#方法一-O-N-w\" class=\"headerlink\" title=\"方法一:O(N * w)\"></a>方法一:O(N * w)</h5><pre><code> public class Demo {\n\n    public static void main(String[] args) {\n        int[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n\n    public static int[] getMaxWindow(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        for (int i = 0; i &lt; arr.length - w + 1; i++) {\n            int x = arr[i];\n            for (int j = 0; j &lt; w; j++) {\n                if (arr[i + j] &gt;= x)\n                    x = arr[i + j];\n            }\n            result[i] = x;\n        }\n        return result;\n    }\n}\n</code></pre><h5 id=\"方法二-O-N\"><a href=\"#方法二-O-N\" class=\"headerlink\" title=\"方法二:O(N)\"></a>方法二:O(N)</h5><blockquote>\n<p>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。<br>放入规则：</p>\n<ol>\n<li>如果qmax为空，直接把下标i放入；</li>\n<li>如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；</li>\n</ol>\n<p>弹出规则：<br>如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。</p>\n<p>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).</p>\n<p>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则<code>java.lang.ArrayIndexOutOfBoundsException</code>.</p>\n</blockquote>\n<pre><code>public static int[] getMaxWindow2(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();\n        int index = 0;\n        for (int i = 0; i &lt; arr.length; i++) {\n\n            while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) {\n                qmax.pollLast();\n            }\n            qmax.addLast(i);\n            if (qmax.peekFirst() == i - w) {\n                qmax.pollFirst();\n            }\n            if (i &gt;= w - 1)\n                result[index++] = arr[qmax.peekFirst()];\n\n        }\n        return result;\n    }\n</code></pre><h6 id=\"双端队列的实现类\"><a href=\"#双端队列的实现类\" class=\"headerlink\" title=\"双端队列的实现类\"></a>双端队列的实现类</h6><pre><code>public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable\n\n\n\npublic class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;\n                           implements Deque&lt;E&gt;, Cloneable, Serializable\n</code></pre><p><a href=\"http://shmilyaw-hotmail-com.iteye.com/blog/1700599\" target=\"_blank\" rel=\"external\">java集合类深入分析之Queue篇</a></p>\n"},{"layout":"post","title":"用栈来求解汉诺塔的问题","date":"2017-02-16T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 用栈来求解汉诺塔问题 #####\n\n\n\t汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n\t例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n\tMove 2 from left to mid\n\tMove 1 from right to mid\n\tMove 1 from mid to left\n\tMove 2 from mid to right\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n \n\n用以下两种方法解决\n\n- 方法一：递归的方法\n- 方法二：非递归的方法，用栈来模拟汉诺塔的三个塔\n\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一 #####\n\n\t/**\n\t * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n\t * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n\t * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n\t * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n\t * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n\t * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n\t * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n\t * \n\t */\n\tpublic class HanoiProblem {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(process(7, \"left\", \"mid\", \"right\", \"left\", \"right\"));\n\t\t}\n\t\n\t\tpublic static int hanoiProblem1(int num, String left, String mid, String right) {\n\t\t\tif (num < 1)\n\t\t\t\treturn 0;\n\t\n\t\t\treturn process(num, left, mid, right, left, right);\n\t\n\t\t}\n\t\n\t\tpublic static int process(int num, String left, String mid, String right, String from, String to) {\n\t\t\tif (num == 1) {\n\t\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + mid);\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + mid + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\tString another = (from.equals(left) || to.equals(left)) ? right : left;\n\t\t\t\tint part1 = process(num, left, mid, right, from, another);\n\t\t\t\tint part2 = 1;// what's this?\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + to);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, another, to);\n\t\t\t\treturn part1 + part2 + part3;\n\t\t\t} else {\n\t\t\t\tint part1 = process(num - 1, left, mid, right, from, to);\n\t\t\t\tint part2 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + mid);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, to, from);\n\t\t\t\tint part4 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + mid + \" to \" + to);\n\t\t\t\tint part5 = process(num - 1, left, mid, right, from, to);\n\t\t\t\treturn part1 + part2 + part3 + part4 + part5;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n##### 方法二 #####\n\t\n\timport java.util.Stack;\n\t\n\t/**\n\t * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n\t * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n\t * \n\t * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n\t * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n\t * \n\t * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n\t * 第二原则：相邻不可逆原则；比如L->M发生了，那么下一步一定不可为：M->L这样的操作，没意义。\n\t * \n\t * 非递归方法结论： <br/>\n\t * 1.第一个动作一定是L->M；<br/>\n\t * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class HanoiProblem2 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(hanoi(4, \"L\", \"M\", \"R\"));\n\t\t}\n\t\tpublic static int hanoi(int num, String left, String mid, String right) {\n\t\t\tStack<Integer> lS = new Stack<>();\n\t\t\tStack<Integer> mS = new Stack<>();\n\t\t\tStack<Integer> rS = new Stack<>();\n\t\t\tlS.push(Integer.MAX_VALUE);\n\t\t\tmS.push(Integer.MAX_VALUE);\n\t\t\trS.push(Integer.MAX_VALUE);\n\t\t\tfor (int i = num; i > 0; i--) {\n\t\t\t\tlS.push(i);\n\t\t\t}\n\t\n\t\t\tAction[] record = { Action.No };\n\t\t\tint step = 0;\n\t\t\twhile (rS.size() != num + 1) {\n\t\t\t\tstep += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n\t\t\t\tstep += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n\t\t\t\tstep += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n\t\t\t\tstep += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n\t\t\t}\n\t\t\treturn step;\n\t\t}\n\t\n\t\tpublic static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack<Integer> fStack,\n\t\t\t\tStack<Integer> tStack, String from, String to) {\n\t\t\tif (record[0] != preNoAct && fStack.peek() < tStack.peek()) {\n\t\t\t\ttStack.push(fStack.pop());\n\t\t\t\tSystem.out.println(\"Move \" + tStack.peek() + \" from \" + from + \" to \" + to);\n\t\t\t\trecord[0] = nowAct;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\t\n\tenum Action {\n\t\tNo, LToM, MToL, MToR, RToM\n\t\n\t} \n\n\n\n\n\n\n\n","source":"_posts/2017-02-16-hanoi-problom.md","raw":"---\nlayout: post\ntitle:  用栈来求解汉诺塔的问题\ndate:   2017-02-16\ncategories: work\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 用栈来求解汉诺塔问题 #####\n\n\n\t汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n\t例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n\tMove 2 from left to mid\n\tMove 1 from right to mid\n\tMove 1 from mid to left\n\tMove 2 from mid to right\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n \n\n用以下两种方法解决\n\n- 方法一：递归的方法\n- 方法二：非递归的方法，用栈来模拟汉诺塔的三个塔\n\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一 #####\n\n\t/**\n\t * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n\t * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n\t * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n\t * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n\t * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n\t * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n\t * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n\t * \n\t */\n\tpublic class HanoiProblem {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(process(7, \"left\", \"mid\", \"right\", \"left\", \"right\"));\n\t\t}\n\t\n\t\tpublic static int hanoiProblem1(int num, String left, String mid, String right) {\n\t\t\tif (num < 1)\n\t\t\t\treturn 0;\n\t\n\t\t\treturn process(num, left, mid, right, left, right);\n\t\n\t\t}\n\t\n\t\tpublic static int process(int num, String left, String mid, String right, String from, String to) {\n\t\t\tif (num == 1) {\n\t\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + mid);\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + mid + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\tString another = (from.equals(left) || to.equals(left)) ? right : left;\n\t\t\t\tint part1 = process(num, left, mid, right, from, another);\n\t\t\t\tint part2 = 1;// what's this?\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + to);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, another, to);\n\t\t\t\treturn part1 + part2 + part3;\n\t\t\t} else {\n\t\t\t\tint part1 = process(num - 1, left, mid, right, from, to);\n\t\t\t\tint part2 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + mid);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, to, from);\n\t\t\t\tint part4 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + mid + \" to \" + to);\n\t\t\t\tint part5 = process(num - 1, left, mid, right, from, to);\n\t\t\t\treturn part1 + part2 + part3 + part4 + part5;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n##### 方法二 #####\n\t\n\timport java.util.Stack;\n\t\n\t/**\n\t * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n\t * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n\t * \n\t * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n\t * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n\t * \n\t * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n\t * 第二原则：相邻不可逆原则；比如L->M发生了，那么下一步一定不可为：M->L这样的操作，没意义。\n\t * \n\t * 非递归方法结论： <br/>\n\t * 1.第一个动作一定是L->M；<br/>\n\t * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class HanoiProblem2 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(hanoi(4, \"L\", \"M\", \"R\"));\n\t\t}\n\t\tpublic static int hanoi(int num, String left, String mid, String right) {\n\t\t\tStack<Integer> lS = new Stack<>();\n\t\t\tStack<Integer> mS = new Stack<>();\n\t\t\tStack<Integer> rS = new Stack<>();\n\t\t\tlS.push(Integer.MAX_VALUE);\n\t\t\tmS.push(Integer.MAX_VALUE);\n\t\t\trS.push(Integer.MAX_VALUE);\n\t\t\tfor (int i = num; i > 0; i--) {\n\t\t\t\tlS.push(i);\n\t\t\t}\n\t\n\t\t\tAction[] record = { Action.No };\n\t\t\tint step = 0;\n\t\t\twhile (rS.size() != num + 1) {\n\t\t\t\tstep += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n\t\t\t\tstep += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n\t\t\t\tstep += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n\t\t\t\tstep += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n\t\t\t}\n\t\t\treturn step;\n\t\t}\n\t\n\t\tpublic static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack<Integer> fStack,\n\t\t\t\tStack<Integer> tStack, String from, String to) {\n\t\t\tif (record[0] != preNoAct && fStack.peek() < tStack.peek()) {\n\t\t\t\ttStack.push(fStack.pop());\n\t\t\t\tSystem.out.println(\"Move \" + tStack.peek() + \" from \" + from + \" to \" + to);\n\t\t\t\trecord[0] = nowAct;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\t\n\tenum Action {\n\t\tNo, LToM, MToL, MToR, RToM\n\t\n\t} \n\n\n\n\n\n\n\n","slug":"hanoi-problom","published":1,"updated":"2017-06-01T07:40:11.976Z","comments":1,"photos":[],"link":"","_id":"cj3tijdi9000xh8ivg16dp68e","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"用栈来求解汉诺塔问题\"><a href=\"#用栈来求解汉诺塔问题\" class=\"headerlink\" title=\"用栈来求解汉诺塔问题\"></a>用栈来求解汉诺塔问题</h5><pre><code>汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\nMove 1 from left to mid\nMove 1 from mid to right\nMove 2 from left to mid\nMove 1 from right to mid\nMove 1 from mid to left\nMove 2 from mid to right\nMove 1 from left to mid\nMove 1 from mid to right\n</code></pre><p>用以下两种方法解决</p>\n<ul>\n<li>方法一：递归的方法</li>\n<li>方法二：非递归的方法，用栈来模拟汉诺塔的三个塔</li>\n</ul>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>/**\n * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n * \n */\npublic class HanoiProblem {\n\n    public static void main(String[] args) {\n        System.out.println(process(7, &quot;left&quot;, &quot;mid&quot;, &quot;right&quot;, &quot;left&quot;, &quot;right&quot;));\n    }\n\n    public static int hanoiProblem1(int num, String left, String mid, String right) {\n        if (num &lt; 1)\n            return 0;\n\n        return process(num, left, mid, right, left, right);\n\n    }\n\n    public static int process(int num, String left, String mid, String right, String from, String to) {\n        if (num == 1) {\n            if (from.equals(mid) || to.equals(mid)) {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to);\n                return 1;\n            } else {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + mid);\n                System.out.println(&quot;Move 1 from &quot; + mid + &quot; to &quot; + to);\n                return 1;\n            }\n        }\n        if (from.equals(mid) || to.equals(mid)) {\n            String another = (from.equals(left) || to.equals(left)) ? right : left;\n            int part1 = process(num, left, mid, right, from, another);\n            int part2 = 1;// what&apos;s this?\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to);\n            int part3 = process(num - 1, left, mid, right, another, to);\n            return part1 + part2 + part3;\n        } else {\n            int part1 = process(num - 1, left, mid, right, from, to);\n            int part2 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + mid);\n            int part3 = process(num - 1, left, mid, right, to, from);\n            int part4 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + mid + &quot; to &quot; + to);\n            int part5 = process(num - 1, left, mid, right, from, to);\n            return part1 + part2 + part3 + part4 + part5;\n        }\n    }\n}\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>import java.util.Stack;\n\n/**\n * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n * \n * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n * \n * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n * 第二原则：相邻不可逆原则；比如L-&gt;M发生了，那么下一步一定不可为：M-&gt;L这样的操作，没意义。\n * \n * 非递归方法结论： &lt;br/&gt;\n * 1.第一个动作一定是L-&gt;M；&lt;br/&gt;\n * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n * \n * @author sxx.xu\n *\n */\npublic class HanoiProblem2 {\n\n    public static void main(String[] args) {\n        System.out.println(hanoi(4, &quot;L&quot;, &quot;M&quot;, &quot;R&quot;));\n    }\n    public static int hanoi(int num, String left, String mid, String right) {\n        Stack&lt;Integer&gt; lS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; mS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; rS = new Stack&lt;&gt;();\n        lS.push(Integer.MAX_VALUE);\n        mS.push(Integer.MAX_VALUE);\n        rS.push(Integer.MAX_VALUE);\n        for (int i = num; i &gt; 0; i--) {\n            lS.push(i);\n        }\n\n        Action[] record = { Action.No };\n        int step = 0;\n        while (rS.size() != num + 1) {\n            step += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n            step += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n            step += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n            step += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n        }\n        return step;\n    }\n\n    public static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack&lt;Integer&gt; fStack,\n            Stack&lt;Integer&gt; tStack, String from, String to) {\n        if (record[0] != preNoAct &amp;&amp; fStack.peek() &lt; tStack.peek()) {\n            tStack.push(fStack.pop());\n            System.out.println(&quot;Move &quot; + tStack.peek() + &quot; from &quot; + from + &quot; to &quot; + to);\n            record[0] = nowAct;\n            return 1;\n        }\n        return 0;\n    }\n\n}\n\nenum Action {\n    No, LToM, MToL, MToR, RToM\n\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"用栈来求解汉诺塔问题\"><a href=\"#用栈来求解汉诺塔问题\" class=\"headerlink\" title=\"用栈来求解汉诺塔问题\"></a>用栈来求解汉诺塔问题</h5><pre><code>汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\nMove 1 from left to mid\nMove 1 from mid to right\nMove 2 from left to mid\nMove 1 from right to mid\nMove 1 from mid to left\nMove 2 from mid to right\nMove 1 from left to mid\nMove 1 from mid to right\n</code></pre><p>用以下两种方法解决</p>\n<ul>\n<li>方法一：递归的方法</li>\n<li>方法二：非递归的方法，用栈来模拟汉诺塔的三个塔</li>\n</ul>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>/**\n * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n * \n */\npublic class HanoiProblem {\n\n    public static void main(String[] args) {\n        System.out.println(process(7, &quot;left&quot;, &quot;mid&quot;, &quot;right&quot;, &quot;left&quot;, &quot;right&quot;));\n    }\n\n    public static int hanoiProblem1(int num, String left, String mid, String right) {\n        if (num &lt; 1)\n            return 0;\n\n        return process(num, left, mid, right, left, right);\n\n    }\n\n    public static int process(int num, String left, String mid, String right, String from, String to) {\n        if (num == 1) {\n            if (from.equals(mid) || to.equals(mid)) {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to);\n                return 1;\n            } else {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + mid);\n                System.out.println(&quot;Move 1 from &quot; + mid + &quot; to &quot; + to);\n                return 1;\n            }\n        }\n        if (from.equals(mid) || to.equals(mid)) {\n            String another = (from.equals(left) || to.equals(left)) ? right : left;\n            int part1 = process(num, left, mid, right, from, another);\n            int part2 = 1;// what&apos;s this?\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to);\n            int part3 = process(num - 1, left, mid, right, another, to);\n            return part1 + part2 + part3;\n        } else {\n            int part1 = process(num - 1, left, mid, right, from, to);\n            int part2 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + mid);\n            int part3 = process(num - 1, left, mid, right, to, from);\n            int part4 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + mid + &quot; to &quot; + to);\n            int part5 = process(num - 1, left, mid, right, from, to);\n            return part1 + part2 + part3 + part4 + part5;\n        }\n    }\n}\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>import java.util.Stack;\n\n/**\n * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n * \n * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n * \n * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n * 第二原则：相邻不可逆原则；比如L-&gt;M发生了，那么下一步一定不可为：M-&gt;L这样的操作，没意义。\n * \n * 非递归方法结论： &lt;br/&gt;\n * 1.第一个动作一定是L-&gt;M；&lt;br/&gt;\n * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n * \n * @author sxx.xu\n *\n */\npublic class HanoiProblem2 {\n\n    public static void main(String[] args) {\n        System.out.println(hanoi(4, &quot;L&quot;, &quot;M&quot;, &quot;R&quot;));\n    }\n    public static int hanoi(int num, String left, String mid, String right) {\n        Stack&lt;Integer&gt; lS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; mS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; rS = new Stack&lt;&gt;();\n        lS.push(Integer.MAX_VALUE);\n        mS.push(Integer.MAX_VALUE);\n        rS.push(Integer.MAX_VALUE);\n        for (int i = num; i &gt; 0; i--) {\n            lS.push(i);\n        }\n\n        Action[] record = { Action.No };\n        int step = 0;\n        while (rS.size() != num + 1) {\n            step += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n            step += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n            step += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n            step += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n        }\n        return step;\n    }\n\n    public static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack&lt;Integer&gt; fStack,\n            Stack&lt;Integer&gt; tStack, String from, String to) {\n        if (record[0] != preNoAct &amp;&amp; fStack.peek() &lt; tStack.peek()) {\n            tStack.push(fStack.pop());\n            System.out.println(&quot;Move &quot; + tStack.peek() + &quot; from &quot; + from + &quot; to &quot; + to);\n            record[0] = nowAct;\n            return 1;\n        }\n        return 0;\n    }\n\n}\n\nenum Action {\n    No, LToM, MToL, MToR, RToM\n\n} \n</code></pre>"},{"layout":"post","title":"Android app 启动优化","date":"2017-02-13T00:00:00.000Z","_content":" \n\n\n#### 基本概念 ####\n    Android Application与其他移动平台有两个重大不同点：\n\n    1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n    2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\n    Android进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n\n#### 进程启动策略 ####\n\n    简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n\n#### Android系统的启动 ####\n\n    与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为\"daemons\"的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n    随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n    启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n\n\n#### App的启动 ####\n\n![app launch](/images/Application_launch.jpg)\n\n>\nclick事件会调用```startActivity(Intent)```，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：\n>\n- 第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息\n- 指向信息被存储在一个intent对象中\n- 下面重要的一步是通过```grantUriPermissionLocked()```方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity\n- 如果有权限，ActivityManagerService会检查并在新的task中启动目标activity\n- 现在，是时候检查这个进程的ProcessRecord是否存在了\n- 如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。\n\n##### 创建进程 #####\n\n> ActivityManagerService调用```startProcessLocked()```方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用```ZygoteInit.main()```方法来实例化ActivityThread对象并最终返回新进程的pid.\n> ActivityThread随后依次调用```Looper.prepareLoop()```和```Looper.loop()```来开启消息循环。\n\n流程图如下：\n![process creation](/images/process_creation.jpg)\n\n##### 绑定Application #####\n\n> 接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用```bindApplication()```方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过```handleBindApplication()```处理该消息。然后调用```makeApplication()```方法来加载App的classes到内存中。\n 流程如下：\n\n![bind application](/images/bind_application.jpg)\n\t\n##### 启动Activity #####\n\n> 经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。\n> 实际调用方法是```realStartActivity()```，它会调用application线程对象中的```sheduleLaunchActivity()```发送一个LAUNCH_ACTIVITY消息到消息队列中，通过```handleLaunchActivity()```来处理该消息。\n\n 假设点击的是一个视频浏览的App，其流程如下：\n\n![start activity](/images/start_activity.jpg)\n##### Activity显示 #####\n\n> Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。\n\n如图：\n![display activity](/images/display_activity.png)\n\n#### 测量App的启动时间 ####\n\n\tactivity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n\n##### Display Time #####\n\n\tapi19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n\n图为抓取微信开启时间：\n![wechat display time](/images/display_time.png)\n\n##### ADB命令查看启动时间 #####\n\n`adb shell am start -W [packageName]/[packageName.MainActivity]`\n\n![adb see launch time](/images/adb_launch_time.png)\n>\n- ThisTime：最后一个启动的Activity的启动耗时；\n- TotalTime:到达当前页面的所有Activity的启动耗时；\n- WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。\n\n`adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4`\n\n>\n这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，`bugreport`参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。\n\n\n##### 代码中自定义上报启动时间 #####\n\n由于我们在一个App启动的开始，会做一些预操作，比如：\n- 加载第三方黑盒SDK\n- 网络、图片等框架的构造\n- 业务数据预请求\n\n所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API>=19的版本，在这些预操作做完之后手动调用`reportFullyDrawn`。这样Log中会增加一条日志：\n\n![reportFullyDrawn time](/images/report_full_drawn.png)\n\n#### 优化点 ####\n\n##### 背景Theme #####\n\t\n\t当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n\n>\t\n\t<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t            android:opacity=\"opaque\">\n\t<!-- android:opacity=\"opaque\"防止在启动的时候出现背景的闪烁 -->\n\t    <item android:drawable=\"@android:color/darker_gray\"/>\n\t    <item>\n\t        <bitmap\n\t            android:gravity=\"center\"\n\t            android:src=\"@mipmap/ic_launcher\"/>\n\t    </item>\n\t</layer-list>\n\n>\n\t<style name=\"StartStyle\" parent=\"AppTheme\">\n        <item name=\"android:windowBackground\">@drawable/start_window</item>\n    </style>\n\n\n##### 异步初始化 #####\n\t\n\t根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n\n##### 资源优化 #####\n\n>\t\n- 布局宽而浅，不要窄而深\n- \t使用.9\n- \ttinyPNG\n- \t混淆\n\n\n\n\n\n#### 鸣谢 ####\n\n[Launch-Time Performance ](https://developer.android.com/topic/performance/launch-time.html)\n\n[Android Application启动流程分析](http://www.jianshu.com/p/a5532ecc8377)\n\n[一触即发 App启动优化最佳实践](https://segmentfault.com/a/1190000007406875#articleHeader9)\n\n在线检测App：[nimbledroid](https://nimbledroid.com/) \n\t","source":"_posts/2017-02-13-optimization-app-launch.md","raw":"---\nlayout: post\ntitle:  Android app 启动优化\ndate:   2017-02-13\ncategories: work\ntag: android\n---\n \n\n\n#### 基本概念 ####\n    Android Application与其他移动平台有两个重大不同点：\n\n    1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n    2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\n    Android进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n\n#### 进程启动策略 ####\n\n    简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n\n#### Android系统的启动 ####\n\n    与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为\"daemons\"的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n    随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n    启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n\n\n#### App的启动 ####\n\n![app launch](/images/Application_launch.jpg)\n\n>\nclick事件会调用```startActivity(Intent)```，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：\n>\n- 第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息\n- 指向信息被存储在一个intent对象中\n- 下面重要的一步是通过```grantUriPermissionLocked()```方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity\n- 如果有权限，ActivityManagerService会检查并在新的task中启动目标activity\n- 现在，是时候检查这个进程的ProcessRecord是否存在了\n- 如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。\n\n##### 创建进程 #####\n\n> ActivityManagerService调用```startProcessLocked()```方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用```ZygoteInit.main()```方法来实例化ActivityThread对象并最终返回新进程的pid.\n> ActivityThread随后依次调用```Looper.prepareLoop()```和```Looper.loop()```来开启消息循环。\n\n流程图如下：\n![process creation](/images/process_creation.jpg)\n\n##### 绑定Application #####\n\n> 接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用```bindApplication()```方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过```handleBindApplication()```处理该消息。然后调用```makeApplication()```方法来加载App的classes到内存中。\n 流程如下：\n\n![bind application](/images/bind_application.jpg)\n\t\n##### 启动Activity #####\n\n> 经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。\n> 实际调用方法是```realStartActivity()```，它会调用application线程对象中的```sheduleLaunchActivity()```发送一个LAUNCH_ACTIVITY消息到消息队列中，通过```handleLaunchActivity()```来处理该消息。\n\n 假设点击的是一个视频浏览的App，其流程如下：\n\n![start activity](/images/start_activity.jpg)\n##### Activity显示 #####\n\n> Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。\n\n如图：\n![display activity](/images/display_activity.png)\n\n#### 测量App的启动时间 ####\n\n\tactivity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n\n##### Display Time #####\n\n\tapi19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n\n图为抓取微信开启时间：\n![wechat display time](/images/display_time.png)\n\n##### ADB命令查看启动时间 #####\n\n`adb shell am start -W [packageName]/[packageName.MainActivity]`\n\n![adb see launch time](/images/adb_launch_time.png)\n>\n- ThisTime：最后一个启动的Activity的启动耗时；\n- TotalTime:到达当前页面的所有Activity的启动耗时；\n- WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。\n\n`adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4`\n\n>\n这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，`bugreport`参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。\n\n\n##### 代码中自定义上报启动时间 #####\n\n由于我们在一个App启动的开始，会做一些预操作，比如：\n- 加载第三方黑盒SDK\n- 网络、图片等框架的构造\n- 业务数据预请求\n\n所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API>=19的版本，在这些预操作做完之后手动调用`reportFullyDrawn`。这样Log中会增加一条日志：\n\n![reportFullyDrawn time](/images/report_full_drawn.png)\n\n#### 优化点 ####\n\n##### 背景Theme #####\n\t\n\t当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n\n>\t\n\t<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t            android:opacity=\"opaque\">\n\t<!-- android:opacity=\"opaque\"防止在启动的时候出现背景的闪烁 -->\n\t    <item android:drawable=\"@android:color/darker_gray\"/>\n\t    <item>\n\t        <bitmap\n\t            android:gravity=\"center\"\n\t            android:src=\"@mipmap/ic_launcher\"/>\n\t    </item>\n\t</layer-list>\n\n>\n\t<style name=\"StartStyle\" parent=\"AppTheme\">\n        <item name=\"android:windowBackground\">@drawable/start_window</item>\n    </style>\n\n\n##### 异步初始化 #####\n\t\n\t根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n\n##### 资源优化 #####\n\n>\t\n- 布局宽而浅，不要窄而深\n- \t使用.9\n- \ttinyPNG\n- \t混淆\n\n\n\n\n\n#### 鸣谢 ####\n\n[Launch-Time Performance ](https://developer.android.com/topic/performance/launch-time.html)\n\n[Android Application启动流程分析](http://www.jianshu.com/p/a5532ecc8377)\n\n[一触即发 App启动优化最佳实践](https://segmentfault.com/a/1190000007406875#articleHeader9)\n\n在线检测App：[nimbledroid](https://nimbledroid.com/) \n\t","slug":"optimization-app-launch","published":1,"updated":"2017-06-01T07:44:22.207Z","comments":1,"photos":[],"link":"","_id":"cj3tijdic0011h8ivwntlyjxq","content":"<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><pre><code>Android Application与其他移动平台有两个重大不同点：\n\n1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\nAndroid进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n</code></pre><h4 id=\"进程启动策略\"><a href=\"#进程启动策略\" class=\"headerlink\" title=\"进程启动策略\"></a>进程启动策略</h4><pre><code>简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n</code></pre><h4 id=\"Android系统的启动\"><a href=\"#Android系统的启动\" class=\"headerlink\" title=\"Android系统的启动\"></a>Android系统的启动</h4><pre><code>与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为&quot;daemons&quot;的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n</code></pre><h4 id=\"App的启动\"><a href=\"#App的启动\" class=\"headerlink\" title=\"App的启动\"></a>App的启动</h4><p><img src=\"/images/Application_launch.jpg\" alt=\"app launch\"></p>\n<p>&gt;<br>click事件会调用<code>startActivity(Intent)</code>，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：<br>&gt;</p>\n<ul>\n<li>第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息</li>\n<li>指向信息被存储在一个intent对象中</li>\n<li>下面重要的一步是通过<code>grantUriPermissionLocked()</code>方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity</li>\n<li>如果有权限，ActivityManagerService会检查并在新的task中启动目标activity</li>\n<li>现在，是时候检查这个进程的ProcessRecord是否存在了</li>\n<li>如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。</li>\n</ul>\n<h5 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h5><blockquote>\n<p>ActivityManagerService调用<code>startProcessLocked()</code>方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用<code>ZygoteInit.main()</code>方法来实例化ActivityThread对象并最终返回新进程的pid.<br>ActivityThread随后依次调用<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>来开启消息循环。</p>\n</blockquote>\n<p>流程图如下：<br><img src=\"/images/process_creation.jpg\" alt=\"process creation\"></p>\n<h5 id=\"绑定Application\"><a href=\"#绑定Application\" class=\"headerlink\" title=\"绑定Application\"></a>绑定Application</h5><blockquote>\n<p>接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用<code>bindApplication()</code>方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过<code>handleBindApplication()</code>处理该消息。然后调用<code>makeApplication()</code>方法来加载App的classes到内存中。<br> 流程如下：</p>\n</blockquote>\n<p><img src=\"/images/bind_application.jpg\" alt=\"bind application\"></p>\n<h5 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h5><blockquote>\n<p>经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。<br>实际调用方法是<code>realStartActivity()</code>，它会调用application线程对象中的<code>sheduleLaunchActivity()</code>发送一个LAUNCH_ACTIVITY消息到消息队列中，通过<code>handleLaunchActivity()</code>来处理该消息。</p>\n</blockquote>\n<p> 假设点击的是一个视频浏览的App，其流程如下：</p>\n<p><img src=\"/images/start_activity.jpg\" alt=\"start activity\"></p>\n<h5 id=\"Activity显示\"><a href=\"#Activity显示\" class=\"headerlink\" title=\"Activity显示\"></a>Activity显示</h5><blockquote>\n<p>Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。</p>\n</blockquote>\n<p>如图：<br><img src=\"/images/display_activity.png\" alt=\"display activity\"></p>\n<h4 id=\"测量App的启动时间\"><a href=\"#测量App的启动时间\" class=\"headerlink\" title=\"测量App的启动时间\"></a>测量App的启动时间</h4><pre><code>activity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n</code></pre><h5 id=\"Display-Time\"><a href=\"#Display-Time\" class=\"headerlink\" title=\"Display Time\"></a>Display Time</h5><pre><code>api19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n</code></pre><p>图为抓取微信开启时间：<br><img src=\"/images/display_time.png\" alt=\"wechat display time\"></p>\n<h5 id=\"ADB命令查看启动时间\"><a href=\"#ADB命令查看启动时间\" class=\"headerlink\" title=\"ADB命令查看启动时间\"></a>ADB命令查看启动时间</h5><p><code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></p>\n<p><img src=\"/images/adb_launch_time.png\" alt=\"adb see launch time\"><br>&gt;</p>\n<ul>\n<li>ThisTime：最后一个启动的Activity的启动耗时；</li>\n<li>TotalTime:到达当前页面的所有Activity的启动耗时；</li>\n<li>WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。</li>\n</ul>\n<p><code>adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4</code></p>\n<p>&gt;<br>这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，<code>bugreport</code>参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。</p>\n<h5 id=\"代码中自定义上报启动时间\"><a href=\"#代码中自定义上报启动时间\" class=\"headerlink\" title=\"代码中自定义上报启动时间\"></a>代码中自定义上报启动时间</h5><p>由于我们在一个App启动的开始，会做一些预操作，比如：</p>\n<ul>\n<li>加载第三方黑盒SDK</li>\n<li>网络、图片等框架的构造</li>\n<li>业务数据预请求</li>\n</ul>\n<p>所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API&gt;=19的版本，在这些预操作做完之后手动调用<code>reportFullyDrawn</code>。这样Log中会增加一条日志：</p>\n<p><img src=\"/images/report_full_drawn.png\" alt=\"reportFullyDrawn time\"></p>\n<h4 id=\"优化点\"><a href=\"#优化点\" class=\"headerlink\" title=\"优化点\"></a>优化点</h4><h5 id=\"背景Theme\"><a href=\"#背景Theme\" class=\"headerlink\" title=\"背景Theme\"></a>背景Theme</h5><pre><code>当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n</code></pre><blockquote>\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            android:opacity=&quot;opaque&quot;&gt;\n&lt;!-- android:opacity=&quot;opaque&quot;防止在启动的时候出现背景的闪烁 --&gt;\n    &lt;item android:drawable=&quot;@android:color/darker_gray&quot;/&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:gravity=&quot;center&quot;\n            android:src=&quot;@mipmap/ic_launcher&quot;/&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre></blockquote>\n<p>&gt;<br>    <style name=\"StartStyle\" parent=\"AppTheme\"><br>        <item name=\"android:windowBackground\">@drawable/start_window</item><br>    </style></p>\n<h5 id=\"异步初始化\"><a href=\"#异步初始化\" class=\"headerlink\" title=\"异步初始化\"></a>异步初始化</h5><pre><code>根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n</code></pre><h5 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h5><blockquote>\n<ul>\n<li>布局宽而浅，不要窄而深</li>\n<li>使用.9</li>\n<li>tinyPNG</li>\n<li>混淆</li>\n</ul>\n</blockquote>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://developer.android.com/topic/performance/launch-time.html\" target=\"_blank\" rel=\"external\">Launch-Time Performance </a></p>\n<p><a href=\"http://www.jianshu.com/p/a5532ecc8377\" target=\"_blank\" rel=\"external\">Android Application启动流程分析</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007406875#articleHeader9\" target=\"_blank\" rel=\"external\">一触即发 App启动优化最佳实践</a></p>\n<p>在线检测App：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">nimbledroid</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><pre><code>Android Application与其他移动平台有两个重大不同点：\n\n1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\nAndroid进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n</code></pre><h4 id=\"进程启动策略\"><a href=\"#进程启动策略\" class=\"headerlink\" title=\"进程启动策略\"></a>进程启动策略</h4><pre><code>简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n</code></pre><h4 id=\"Android系统的启动\"><a href=\"#Android系统的启动\" class=\"headerlink\" title=\"Android系统的启动\"></a>Android系统的启动</h4><pre><code>与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为&quot;daemons&quot;的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n</code></pre><h4 id=\"App的启动\"><a href=\"#App的启动\" class=\"headerlink\" title=\"App的启动\"></a>App的启动</h4><p><img src=\"/images/Application_launch.jpg\" alt=\"app launch\"></p>\n<p>&gt;<br>click事件会调用<code>startActivity(Intent)</code>，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：<br>&gt;</p>\n<ul>\n<li>第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息</li>\n<li>指向信息被存储在一个intent对象中</li>\n<li>下面重要的一步是通过<code>grantUriPermissionLocked()</code>方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity</li>\n<li>如果有权限，ActivityManagerService会检查并在新的task中启动目标activity</li>\n<li>现在，是时候检查这个进程的ProcessRecord是否存在了</li>\n<li>如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。</li>\n</ul>\n<h5 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h5><blockquote>\n<p>ActivityManagerService调用<code>startProcessLocked()</code>方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用<code>ZygoteInit.main()</code>方法来实例化ActivityThread对象并最终返回新进程的pid.<br>ActivityThread随后依次调用<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>来开启消息循环。</p>\n</blockquote>\n<p>流程图如下：<br><img src=\"/images/process_creation.jpg\" alt=\"process creation\"></p>\n<h5 id=\"绑定Application\"><a href=\"#绑定Application\" class=\"headerlink\" title=\"绑定Application\"></a>绑定Application</h5><blockquote>\n<p>接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用<code>bindApplication()</code>方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过<code>handleBindApplication()</code>处理该消息。然后调用<code>makeApplication()</code>方法来加载App的classes到内存中。<br> 流程如下：</p>\n</blockquote>\n<p><img src=\"/images/bind_application.jpg\" alt=\"bind application\"></p>\n<h5 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h5><blockquote>\n<p>经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。<br>实际调用方法是<code>realStartActivity()</code>，它会调用application线程对象中的<code>sheduleLaunchActivity()</code>发送一个LAUNCH_ACTIVITY消息到消息队列中，通过<code>handleLaunchActivity()</code>来处理该消息。</p>\n</blockquote>\n<p> 假设点击的是一个视频浏览的App，其流程如下：</p>\n<p><img src=\"/images/start_activity.jpg\" alt=\"start activity\"></p>\n<h5 id=\"Activity显示\"><a href=\"#Activity显示\" class=\"headerlink\" title=\"Activity显示\"></a>Activity显示</h5><blockquote>\n<p>Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。</p>\n</blockquote>\n<p>如图：<br><img src=\"/images/display_activity.png\" alt=\"display activity\"></p>\n<h4 id=\"测量App的启动时间\"><a href=\"#测量App的启动时间\" class=\"headerlink\" title=\"测量App的启动时间\"></a>测量App的启动时间</h4><pre><code>activity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n</code></pre><h5 id=\"Display-Time\"><a href=\"#Display-Time\" class=\"headerlink\" title=\"Display Time\"></a>Display Time</h5><pre><code>api19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n</code></pre><p>图为抓取微信开启时间：<br><img src=\"/images/display_time.png\" alt=\"wechat display time\"></p>\n<h5 id=\"ADB命令查看启动时间\"><a href=\"#ADB命令查看启动时间\" class=\"headerlink\" title=\"ADB命令查看启动时间\"></a>ADB命令查看启动时间</h5><p><code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></p>\n<p><img src=\"/images/adb_launch_time.png\" alt=\"adb see launch time\"><br>&gt;</p>\n<ul>\n<li>ThisTime：最后一个启动的Activity的启动耗时；</li>\n<li>TotalTime:到达当前页面的所有Activity的启动耗时；</li>\n<li>WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。</li>\n</ul>\n<p><code>adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4</code></p>\n<p>&gt;<br>这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，<code>bugreport</code>参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。</p>\n<h5 id=\"代码中自定义上报启动时间\"><a href=\"#代码中自定义上报启动时间\" class=\"headerlink\" title=\"代码中自定义上报启动时间\"></a>代码中自定义上报启动时间</h5><p>由于我们在一个App启动的开始，会做一些预操作，比如：</p>\n<ul>\n<li>加载第三方黑盒SDK</li>\n<li>网络、图片等框架的构造</li>\n<li>业务数据预请求</li>\n</ul>\n<p>所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API&gt;=19的版本，在这些预操作做完之后手动调用<code>reportFullyDrawn</code>。这样Log中会增加一条日志：</p>\n<p><img src=\"/images/report_full_drawn.png\" alt=\"reportFullyDrawn time\"></p>\n<h4 id=\"优化点\"><a href=\"#优化点\" class=\"headerlink\" title=\"优化点\"></a>优化点</h4><h5 id=\"背景Theme\"><a href=\"#背景Theme\" class=\"headerlink\" title=\"背景Theme\"></a>背景Theme</h5><pre><code>当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n</code></pre><blockquote>\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            android:opacity=&quot;opaque&quot;&gt;\n&lt;!-- android:opacity=&quot;opaque&quot;防止在启动的时候出现背景的闪烁 --&gt;\n    &lt;item android:drawable=&quot;@android:color/darker_gray&quot;/&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:gravity=&quot;center&quot;\n            android:src=&quot;@mipmap/ic_launcher&quot;/&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre></blockquote>\n<p>&gt;<br>    <style name=\"StartStyle\" parent=\"AppTheme\"><br>        <item name=\"android:windowBackground\">@drawable/start_window</item><br>    </style></p>\n<h5 id=\"异步初始化\"><a href=\"#异步初始化\" class=\"headerlink\" title=\"异步初始化\"></a>异步初始化</h5><pre><code>根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n</code></pre><h5 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h5><blockquote>\n<ul>\n<li>布局宽而浅，不要窄而深</li>\n<li>使用.9</li>\n<li>tinyPNG</li>\n<li>混淆</li>\n</ul>\n</blockquote>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://developer.android.com/topic/performance/launch-time.html\" target=\"_blank\" rel=\"external\">Launch-Time Performance </a></p>\n<p><a href=\"http://www.jianshu.com/p/a5532ecc8377\" target=\"_blank\" rel=\"external\">Android Application启动流程分析</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007406875#articleHeader9\" target=\"_blank\" rel=\"external\">一触即发 App启动优化最佳实践</a></p>\n<p>在线检测App：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">nimbledroid</a> </p>\n"},{"layout":"post","title":"用一个栈实现另一个栈的排序","date":"2017-02-14T00:00:00.000Z","_content":" \n\n\n#### 题目 ####\n    \n\t一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n\n#### 难度 ####\n\n\t士 ★☆☆☆\n\n\n#### 解答 ####\n \n\t将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n\n- 如果cur小于或等于help的栈顶元素，将cur压入help；\n- 如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；\n\n示例代码如下：\n\n\t\n\timport java.util.Stack;\n\t\n\tpublic class SortStackByStack {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tStack<Integer> ss = new Stack<>();\n\t\t\tss.push(7);\n\t\t\tss.push(2);\n\t\t\tss.push(8);\n\t\t\tss.push(3);\n\t\t\tss.push(9);\n\t\t\tsortStackByStack(ss);\n\t\n\t\t}\n\t\n\t\tpublic static void sortStackByStack(Stack<Integer> stack) {\n\t\t\tStack<Integer> help = new Stack<>();\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint cur = stack.pop();\n\t\t\t\twhile (!help.isEmpty() && help.peek() < cur) {\n\t\t\t\t\tstack.push(help.pop());\n\t\t\t\t}\n\t\t\t\thelp.push(cur);\n\t\t\t}\n\t\t\twhile (!help.isEmpty()) {\n\t\t\t\tstack.push(help.pop());\n\t\t\t}\n\t\t}\n\t}\n","source":"_posts/2017-02-14-sort-stack-by-stack.md","raw":"---\nlayout: post\ntitle:  用一个栈实现另一个栈的排序\ndate:   2017-02-14\ncategories: work\ntag: 算法\n---\n \n\n\n#### 题目 ####\n    \n\t一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n\n#### 难度 ####\n\n\t士 ★☆☆☆\n\n\n#### 解答 ####\n \n\t将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n\n- 如果cur小于或等于help的栈顶元素，将cur压入help；\n- 如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；\n\n示例代码如下：\n\n\t\n\timport java.util.Stack;\n\t\n\tpublic class SortStackByStack {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tStack<Integer> ss = new Stack<>();\n\t\t\tss.push(7);\n\t\t\tss.push(2);\n\t\t\tss.push(8);\n\t\t\tss.push(3);\n\t\t\tss.push(9);\n\t\t\tsortStackByStack(ss);\n\t\n\t\t}\n\t\n\t\tpublic static void sortStackByStack(Stack<Integer> stack) {\n\t\t\tStack<Integer> help = new Stack<>();\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint cur = stack.pop();\n\t\t\t\twhile (!help.isEmpty() && help.peek() < cur) {\n\t\t\t\t\tstack.push(help.pop());\n\t\t\t\t}\n\t\t\t\thelp.push(cur);\n\t\t\t}\n\t\t\twhile (!help.isEmpty()) {\n\t\t\t\tstack.push(help.pop());\n\t\t\t}\n\t\t}\n\t}\n","slug":"sort-stack-by-stack","published":1,"updated":"2017-06-01T07:40:57.897Z","comments":1,"photos":[],"link":"","_id":"cj3tijdii0014h8iv36klxljb","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>士 ★☆☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n</code></pre><ul>\n<li>如果cur小于或等于help的栈顶元素，将cur压入help；</li>\n<li>如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.Stack;\n\npublic class SortStackByStack {\n\n    public static void main(String[] args) {\n        Stack&lt;Integer&gt; ss = new Stack&lt;&gt;();\n        ss.push(7);\n        ss.push(2);\n        ss.push(8);\n        ss.push(3);\n        ss.push(9);\n        sortStackByStack(ss);\n\n    }\n\n    public static void sortStackByStack(Stack&lt;Integer&gt; stack) {\n        Stack&lt;Integer&gt; help = new Stack&lt;&gt;();\n        while (!stack.isEmpty()) {\n            int cur = stack.pop();\n            while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) {\n                stack.push(help.pop());\n            }\n            help.push(cur);\n        }\n        while (!help.isEmpty()) {\n            stack.push(help.pop());\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>士 ★☆☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n</code></pre><ul>\n<li>如果cur小于或等于help的栈顶元素，将cur压入help；</li>\n<li>如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.Stack;\n\npublic class SortStackByStack {\n\n    public static void main(String[] args) {\n        Stack&lt;Integer&gt; ss = new Stack&lt;&gt;();\n        ss.push(7);\n        ss.push(2);\n        ss.push(8);\n        ss.push(3);\n        ss.push(9);\n        sortStackByStack(ss);\n\n    }\n\n    public static void sortStackByStack(Stack&lt;Integer&gt; stack) {\n        Stack&lt;Integer&gt; help = new Stack&lt;&gt;();\n        while (!stack.isEmpty()) {\n            int cur = stack.pop();\n            while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) {\n                stack.push(help.pop());\n            }\n            help.push(cur);\n        }\n        while (!help.isEmpty()) {\n            stack.push(help.pop());\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"构造数组的MaxTree","date":"2017-02-17T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 构造数组的MaxTree #####\n\n定义二叉树结点如下：\n\n\tpublic class Node {\n\t\tpublic int value;\n\t\tpublic Node left;\n\t\tpublic Node right;\n\t\n\t\tpublic Node(int data) {\n\t\t\tthis.value = data;\n\t\t}\n\t}\n\n一个数组的MaxTree定义如下。\n\n- 数组必须没有重复元素。\n- MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。\n- 包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。\n\n给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n#### 解答 ####\n\n下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。\n\n> arr = {3,4,5,1,2}<br/>\n> 3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br/>\n> 4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br/>\n> 5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br/>\n> 1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br/>\n> 2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br/>\n\n以下列原则来建立这颗树：\n\n - 每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。\n - 如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。\n\n示例代码如下：\n\t\t\n\t\timport java.util.HashMap;\n\t\timport java.util.Stack;\n\t\t\n\t\tpublic class MaxTree {\n\t\t\n\t\t\tpublic Node getMaxTree(int[] arr) {\n\t\t\n\t\t\t\tNode[] nArr = new Node[arr.length];\n\t\t\t\tfor (int i = 0; i != arr.length; i++) {\n\t\t\t\t\tnArr[i] = new Node(arr[i]);\n\t\t\t\t}\n\t\t\n\t\t\t\tStack<Node> stack = new Stack<>();\n\t\t\t\tHashMap<Node, Node> lBigMap = new HashMap<>();\n\t\t\t\tHashMap<Node, Node> rBigMap = new HashMap<>();\n\t\t\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tfor (int i = nArr.length; i != -1; i--) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tNode head = null;\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\tNode left = lBigMap.get(curNode);\n\t\t\t\t\tNode right = rBigMap.get(curNode);\n\t\t\n\t\t\t\t\tif (left == null && right == null) {\n\t\t\t\t\t\thead = curNode;\n\t\t\t\t\t} else if (left == null) {\n\t\t\t\t\t\tif (right.left == null) {\n\t\t\t\t\t\t\tright.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tright.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (right == null) {\n\t\t\t\t\t\tif (left.left == null) {\n\t\t\t\t\t\t\tleft.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNode parent = left.value < right.value ? left : right;\n\t\t\t\t\t\tif (parent.left == null) {\n\t\t\t\t\t\t\tparent.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\n\t\t\t\t}\n\t\t\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\n\t\t\tprivate void popStackSetMap(Stack<Node> stack, HashMap<Node, Node> map) {\n\t\t\t\tNode popNode = stack.pop();\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tmap.put(popNode, null);\n\t\t\t\t} else {\n\t\t\t\t\tmap.put(popNode, stack.peek());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t","source":"_posts/2017-02-17-get-max-tree.md","raw":"---\nlayout: post\ntitle:  构造数组的MaxTree\ndate:   2017-02-17\ncategories: work\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 构造数组的MaxTree #####\n\n定义二叉树结点如下：\n\n\tpublic class Node {\n\t\tpublic int value;\n\t\tpublic Node left;\n\t\tpublic Node right;\n\t\n\t\tpublic Node(int data) {\n\t\t\tthis.value = data;\n\t\t}\n\t}\n\n一个数组的MaxTree定义如下。\n\n- 数组必须没有重复元素。\n- MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。\n- 包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。\n\n给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n#### 解答 ####\n\n下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。\n\n> arr = {3,4,5,1,2}<br/>\n> 3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br/>\n> 4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br/>\n> 5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br/>\n> 1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br/>\n> 2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br/>\n\n以下列原则来建立这颗树：\n\n - 每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。\n - 如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。\n\n示例代码如下：\n\t\t\n\t\timport java.util.HashMap;\n\t\timport java.util.Stack;\n\t\t\n\t\tpublic class MaxTree {\n\t\t\n\t\t\tpublic Node getMaxTree(int[] arr) {\n\t\t\n\t\t\t\tNode[] nArr = new Node[arr.length];\n\t\t\t\tfor (int i = 0; i != arr.length; i++) {\n\t\t\t\t\tnArr[i] = new Node(arr[i]);\n\t\t\t\t}\n\t\t\n\t\t\t\tStack<Node> stack = new Stack<>();\n\t\t\t\tHashMap<Node, Node> lBigMap = new HashMap<>();\n\t\t\t\tHashMap<Node, Node> rBigMap = new HashMap<>();\n\t\t\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tfor (int i = nArr.length; i != -1; i--) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tNode head = null;\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\tNode left = lBigMap.get(curNode);\n\t\t\t\t\tNode right = rBigMap.get(curNode);\n\t\t\n\t\t\t\t\tif (left == null && right == null) {\n\t\t\t\t\t\thead = curNode;\n\t\t\t\t\t} else if (left == null) {\n\t\t\t\t\t\tif (right.left == null) {\n\t\t\t\t\t\t\tright.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tright.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (right == null) {\n\t\t\t\t\t\tif (left.left == null) {\n\t\t\t\t\t\t\tleft.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNode parent = left.value < right.value ? left : right;\n\t\t\t\t\t\tif (parent.left == null) {\n\t\t\t\t\t\t\tparent.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\n\t\t\t\t}\n\t\t\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\n\t\t\tprivate void popStackSetMap(Stack<Node> stack, HashMap<Node, Node> map) {\n\t\t\t\tNode popNode = stack.pop();\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tmap.put(popNode, null);\n\t\t\t\t} else {\n\t\t\t\t\tmap.put(popNode, stack.peek());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t","slug":"get-max-tree","published":1,"updated":"2017-06-01T07:39:49.907Z","comments":1,"photos":[],"link":"","_id":"cj3tijdin0018h8ivqol8eeea","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"构造数组的MaxTree\"><a href=\"#构造数组的MaxTree\" class=\"headerlink\" title=\"构造数组的MaxTree\"></a>构造数组的MaxTree</h5><p>定义二叉树结点如下：</p>\n<pre><code>public class Node {\n    public int value;\n    public Node left;\n    public Node right;\n\n    public Node(int data) {\n        this.value = data;\n    }\n}\n</code></pre><p>一个数组的MaxTree定义如下。</p>\n<ul>\n<li>数组必须没有重复元素。</li>\n<li>MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。</li>\n<li>包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。</li>\n</ul>\n<p>给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><p>下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。</p>\n<blockquote>\n<p>arr = {3,4,5,1,2}<br><br>3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br><br>4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br><br>5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br><br>1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br><br>2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br></p>\n</blockquote>\n<p>以下列原则来建立这颗树：</p>\n<ul>\n<li>每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。</li>\n<li>如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.HashMap;\nimport java.util.Stack;\n\npublic class MaxTree {\n\n    public Node getMaxTree(int[] arr) {\n\n        Node[] nArr = new Node[arr.length];\n        for (int i = 0; i != arr.length; i++) {\n            nArr[i] = new Node(arr[i]);\n        }\n\n        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();\n        HashMap&lt;Node, Node&gt; lBigMap = new HashMap&lt;&gt;();\n        HashMap&lt;Node, Node&gt; rBigMap = new HashMap&lt;&gt;();\n\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, lBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, lBigMap);\n        }\n\n        for (int i = nArr.length; i != -1; i--) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, rBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, rBigMap);\n        }\n\n        Node head = null;\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            Node left = lBigMap.get(curNode);\n            Node right = rBigMap.get(curNode);\n\n            if (left == null &amp;&amp; right == null) {\n                head = curNode;\n            } else if (left == null) {\n                if (right.left == null) {\n                    right.left = curNode;\n                } else {\n                    right.right = curNode;\n                }\n            } else if (right == null) {\n                if (left.left == null) {\n                    left.left = curNode;\n                } else {\n                    left.right = curNode;\n                }\n            } else {\n                Node parent = left.value &lt; right.value ? left : right;\n                if (parent.left == null) {\n                    parent.left = curNode;\n                } else {\n                    parent.right = curNode;\n                }\n            }\n\n        }\n\n        return head;\n    }\n\n    private void popStackSetMap(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map) {\n        Node popNode = stack.pop();\n        if (stack.isEmpty()) {\n            map.put(popNode, null);\n        } else {\n            map.put(popNode, stack.peek());\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"构造数组的MaxTree\"><a href=\"#构造数组的MaxTree\" class=\"headerlink\" title=\"构造数组的MaxTree\"></a>构造数组的MaxTree</h5><p>定义二叉树结点如下：</p>\n<pre><code>public class Node {\n    public int value;\n    public Node left;\n    public Node right;\n\n    public Node(int data) {\n        this.value = data;\n    }\n}\n</code></pre><p>一个数组的MaxTree定义如下。</p>\n<ul>\n<li>数组必须没有重复元素。</li>\n<li>MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。</li>\n<li>包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。</li>\n</ul>\n<p>给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><p>下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。</p>\n<blockquote>\n<p>arr = {3,4,5,1,2}<br><br>3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br><br>4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br><br>5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br><br>1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br><br>2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br></p>\n</blockquote>\n<p>以下列原则来建立这颗树：</p>\n<ul>\n<li>每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。</li>\n<li>如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.HashMap;\nimport java.util.Stack;\n\npublic class MaxTree {\n\n    public Node getMaxTree(int[] arr) {\n\n        Node[] nArr = new Node[arr.length];\n        for (int i = 0; i != arr.length; i++) {\n            nArr[i] = new Node(arr[i]);\n        }\n\n        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();\n        HashMap&lt;Node, Node&gt; lBigMap = new HashMap&lt;&gt;();\n        HashMap&lt;Node, Node&gt; rBigMap = new HashMap&lt;&gt;();\n\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, lBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, lBigMap);\n        }\n\n        for (int i = nArr.length; i != -1; i--) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, rBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, rBigMap);\n        }\n\n        Node head = null;\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            Node left = lBigMap.get(curNode);\n            Node right = rBigMap.get(curNode);\n\n            if (left == null &amp;&amp; right == null) {\n                head = curNode;\n            } else if (left == null) {\n                if (right.left == null) {\n                    right.left = curNode;\n                } else {\n                    right.right = curNode;\n                }\n            } else if (right == null) {\n                if (left.left == null) {\n                    left.left = curNode;\n                } else {\n                    left.right = curNode;\n                }\n            } else {\n                Node parent = left.value &lt; right.value ? left : right;\n                if (parent.left == null) {\n                    parent.left = curNode;\n                } else {\n                    parent.right = curNode;\n                }\n            }\n\n        }\n\n        return head;\n    }\n\n    private void popStackSetMap(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map) {\n        Node popNode = stack.pop();\n        if (stack.isEmpty()) {\n            map.put(popNode, null);\n        } else {\n            map.put(popNode, stack.peek());\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"APK瘦身","date":"2017-02-20T00:00:00.000Z","_content":" \n#### 在线检测 ####\n\n>在线分析APK：[NimbleDroid](https://nimbledroid.com/)\n\n\n##### 实例分析-Summary #####\n\n\t我们上传一个apk，看看这款App的分析结果。\n\n![Summary](/images/nimabledroid-1.png)\n\n- File Name 我们上传的App名字\n- File Size 文件大小\n- Method Count 方法总数\n- Uploaded via Site 谁在什么时间上传 \n\n\n![Summary](/images/nimabledroid-2.png)\n\n- Scenario：Cold StartUp 冷启动场景下\n- Slowdowns 速度减缓的地方\n- Merm Leaks 内存泄漏的地方\n- Time-Real Time 时间花费\n- Memory-Max Use 内存占用\n- Network-down 下载数据量\n- Network-up 上传数据量\n- Disk I/O-Read 从磁盘读取数据量\n- Disk I/O-Write 写入磁盘的数据量\n\n\n##### 实例分析-File Sizes #####\n\n![Summary](/images/nimabledroid-3.png)\n\n> 在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。\n\n![Summary](/images/nimabledroid-4.png)\n>不同类型的文件所占体积大小。\n\n\n##### 实例分析-Method Count #####\n![Summary](/images/nimabledroid-5.png)\n\n>各SDK方法数统计。\n\n\n##### 实例分析-具体Scenario分析 #####\n\n我们考察冷启动从欢迎页启动到主页这个场景。看到时间为`4.8s`,感觉有些长了。我们使用Android Monitor的日志，过滤`ActivityManager:Displayed`，看到欢迎页是`569ms`，主页是`613ms`。\n\n![Summary](/images/nimabledroid-6.png)\n如图：\n\n- Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。\n- Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。\n- Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。\n- Speed - Dependencies 有时应用中的依赖关系会影响性能。\n\n- BaseActivity、BaseFragment的初始化操作\n- PushAgent.onAppStart 推送服务启动\n- ClassUtil.getGenericSuperclass fastjson的方法\n- ViewPager.onMeasure 欢迎页的测量\n- Jackson JSON Parser jackjson的解析\n \n我们选取一个方法点击进入详细，如图：\n\n![Summary](/images/nimabledroid-7.png)\n\n在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。\n\n\n![Summary](/images/nimabledroid-8.png)\n\n> 看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！\n\n\n\n#### 优化注意点 ####\n\n\n##### 资源 #####\n\n- 清除未使用的资源，Android lint analyze & shrinkResource\n- 大图片使用tinyPNG\n- png转webp\n- [AndResGuard](https://github.com/shwenzhang/AndResGuard)\n\n\n##### 第三方库 #####\n\t\n- 清除不必须的第三方jar，尤其是Android support \n\n##### 冗余代码 #####\n\n- inspect code","source":"_posts/2017-02-20-decrease-apk-size.md","raw":"---\nlayout: post\ntitle:  APK瘦身\ndate:   2017-02-20\ncategories: work\ntag: android\n---\n \n#### 在线检测 ####\n\n>在线分析APK：[NimbleDroid](https://nimbledroid.com/)\n\n\n##### 实例分析-Summary #####\n\n\t我们上传一个apk，看看这款App的分析结果。\n\n![Summary](/images/nimabledroid-1.png)\n\n- File Name 我们上传的App名字\n- File Size 文件大小\n- Method Count 方法总数\n- Uploaded via Site 谁在什么时间上传 \n\n\n![Summary](/images/nimabledroid-2.png)\n\n- Scenario：Cold StartUp 冷启动场景下\n- Slowdowns 速度减缓的地方\n- Merm Leaks 内存泄漏的地方\n- Time-Real Time 时间花费\n- Memory-Max Use 内存占用\n- Network-down 下载数据量\n- Network-up 上传数据量\n- Disk I/O-Read 从磁盘读取数据量\n- Disk I/O-Write 写入磁盘的数据量\n\n\n##### 实例分析-File Sizes #####\n\n![Summary](/images/nimabledroid-3.png)\n\n> 在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。\n\n![Summary](/images/nimabledroid-4.png)\n>不同类型的文件所占体积大小。\n\n\n##### 实例分析-Method Count #####\n![Summary](/images/nimabledroid-5.png)\n\n>各SDK方法数统计。\n\n\n##### 实例分析-具体Scenario分析 #####\n\n我们考察冷启动从欢迎页启动到主页这个场景。看到时间为`4.8s`,感觉有些长了。我们使用Android Monitor的日志，过滤`ActivityManager:Displayed`，看到欢迎页是`569ms`，主页是`613ms`。\n\n![Summary](/images/nimabledroid-6.png)\n如图：\n\n- Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。\n- Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。\n- Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。\n- Speed - Dependencies 有时应用中的依赖关系会影响性能。\n\n- BaseActivity、BaseFragment的初始化操作\n- PushAgent.onAppStart 推送服务启动\n- ClassUtil.getGenericSuperclass fastjson的方法\n- ViewPager.onMeasure 欢迎页的测量\n- Jackson JSON Parser jackjson的解析\n \n我们选取一个方法点击进入详细，如图：\n\n![Summary](/images/nimabledroid-7.png)\n\n在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。\n\n\n![Summary](/images/nimabledroid-8.png)\n\n> 看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！\n\n\n\n#### 优化注意点 ####\n\n\n##### 资源 #####\n\n- 清除未使用的资源，Android lint analyze & shrinkResource\n- 大图片使用tinyPNG\n- png转webp\n- [AndResGuard](https://github.com/shwenzhang/AndResGuard)\n\n\n##### 第三方库 #####\n\t\n- 清除不必须的第三方jar，尤其是Android support \n\n##### 冗余代码 #####\n\n- inspect code","slug":"decrease-apk-size","published":1,"updated":"2017-06-01T07:39:16.310Z","comments":1,"photos":[],"link":"","_id":"cj3tijdir001bh8ivfxczs8lj","content":"<h4 id=\"在线检测\"><a href=\"#在线检测\" class=\"headerlink\" title=\"在线检测\"></a>在线检测</h4><blockquote>\n<p>在线分析APK：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">NimbleDroid</a></p>\n</blockquote>\n<h5 id=\"实例分析-Summary\"><a href=\"#实例分析-Summary\" class=\"headerlink\" title=\"实例分析-Summary\"></a>实例分析-Summary</h5><pre><code>我们上传一个apk，看看这款App的分析结果。\n</code></pre><p><img src=\"/images/nimabledroid-1.png\" alt=\"Summary\"></p>\n<ul>\n<li>File Name 我们上传的App名字</li>\n<li>File Size 文件大小</li>\n<li>Method Count 方法总数</li>\n<li>Uploaded via Site 谁在什么时间上传 </li>\n</ul>\n<p><img src=\"/images/nimabledroid-2.png\" alt=\"Summary\"></p>\n<ul>\n<li>Scenario：Cold StartUp 冷启动场景下</li>\n<li>Slowdowns 速度减缓的地方</li>\n<li>Merm Leaks 内存泄漏的地方</li>\n<li>Time-Real Time 时间花费</li>\n<li>Memory-Max Use 内存占用</li>\n<li>Network-down 下载数据量</li>\n<li>Network-up 上传数据量</li>\n<li>Disk I/O-Read 从磁盘读取数据量</li>\n<li>Disk I/O-Write 写入磁盘的数据量</li>\n</ul>\n<h5 id=\"实例分析-File-Sizes\"><a href=\"#实例分析-File-Sizes\" class=\"headerlink\" title=\"实例分析-File Sizes\"></a>实例分析-File Sizes</h5><p><img src=\"/images/nimabledroid-3.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。</p>\n</blockquote>\n<p><img src=\"/images/nimabledroid-4.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>不同类型的文件所占体积大小。</p>\n</blockquote>\n<h5 id=\"实例分析-Method-Count\"><a href=\"#实例分析-Method-Count\" class=\"headerlink\" title=\"实例分析-Method Count\"></a>实例分析-Method Count</h5><p><img src=\"/images/nimabledroid-5.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>各SDK方法数统计。</p>\n</blockquote>\n<h5 id=\"实例分析-具体Scenario分析\"><a href=\"#实例分析-具体Scenario分析\" class=\"headerlink\" title=\"实例分析-具体Scenario分析\"></a>实例分析-具体Scenario分析</h5><p>我们考察冷启动从欢迎页启动到主页这个场景。看到时间为<code>4.8s</code>,感觉有些长了。我们使用Android Monitor的日志，过滤<code>ActivityManager:Displayed</code>，看到欢迎页是<code>569ms</code>，主页是<code>613ms</code>。</p>\n<p><img src=\"/images/nimabledroid-6.png\" alt=\"Summary\"><br>如图：</p>\n<ul>\n<li>Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。</li>\n<li>Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。</li>\n<li>Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。</li>\n<li><p>Speed - Dependencies 有时应用中的依赖关系会影响性能。</p>\n</li>\n<li><p>BaseActivity、BaseFragment的初始化操作</p>\n</li>\n<li>PushAgent.onAppStart 推送服务启动</li>\n<li>ClassUtil.getGenericSuperclass fastjson的方法</li>\n<li>ViewPager.onMeasure 欢迎页的测量</li>\n<li>Jackson JSON Parser jackjson的解析</li>\n</ul>\n<p>我们选取一个方法点击进入详细，如图：</p>\n<p><img src=\"/images/nimabledroid-7.png\" alt=\"Summary\"></p>\n<p>在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。</p>\n<p><img src=\"/images/nimabledroid-8.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！</p>\n</blockquote>\n<h4 id=\"优化注意点\"><a href=\"#优化注意点\" class=\"headerlink\" title=\"优化注意点\"></a>优化注意点</h4><h5 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h5><ul>\n<li>清除未使用的资源，Android lint analyze &amp; shrinkResource</li>\n<li>大图片使用tinyPNG</li>\n<li>png转webp</li>\n<li><a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"external\">AndResGuard</a></li>\n</ul>\n<h5 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h5><ul>\n<li>清除不必须的第三方jar，尤其是Android support </li>\n</ul>\n<h5 id=\"冗余代码\"><a href=\"#冗余代码\" class=\"headerlink\" title=\"冗余代码\"></a>冗余代码</h5><ul>\n<li>inspect code</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"在线检测\"><a href=\"#在线检测\" class=\"headerlink\" title=\"在线检测\"></a>在线检测</h4><blockquote>\n<p>在线分析APK：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">NimbleDroid</a></p>\n</blockquote>\n<h5 id=\"实例分析-Summary\"><a href=\"#实例分析-Summary\" class=\"headerlink\" title=\"实例分析-Summary\"></a>实例分析-Summary</h5><pre><code>我们上传一个apk，看看这款App的分析结果。\n</code></pre><p><img src=\"/images/nimabledroid-1.png\" alt=\"Summary\"></p>\n<ul>\n<li>File Name 我们上传的App名字</li>\n<li>File Size 文件大小</li>\n<li>Method Count 方法总数</li>\n<li>Uploaded via Site 谁在什么时间上传 </li>\n</ul>\n<p><img src=\"/images/nimabledroid-2.png\" alt=\"Summary\"></p>\n<ul>\n<li>Scenario：Cold StartUp 冷启动场景下</li>\n<li>Slowdowns 速度减缓的地方</li>\n<li>Merm Leaks 内存泄漏的地方</li>\n<li>Time-Real Time 时间花费</li>\n<li>Memory-Max Use 内存占用</li>\n<li>Network-down 下载数据量</li>\n<li>Network-up 上传数据量</li>\n<li>Disk I/O-Read 从磁盘读取数据量</li>\n<li>Disk I/O-Write 写入磁盘的数据量</li>\n</ul>\n<h5 id=\"实例分析-File-Sizes\"><a href=\"#实例分析-File-Sizes\" class=\"headerlink\" title=\"实例分析-File Sizes\"></a>实例分析-File Sizes</h5><p><img src=\"/images/nimabledroid-3.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。</p>\n</blockquote>\n<p><img src=\"/images/nimabledroid-4.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>不同类型的文件所占体积大小。</p>\n</blockquote>\n<h5 id=\"实例分析-Method-Count\"><a href=\"#实例分析-Method-Count\" class=\"headerlink\" title=\"实例分析-Method Count\"></a>实例分析-Method Count</h5><p><img src=\"/images/nimabledroid-5.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>各SDK方法数统计。</p>\n</blockquote>\n<h5 id=\"实例分析-具体Scenario分析\"><a href=\"#实例分析-具体Scenario分析\" class=\"headerlink\" title=\"实例分析-具体Scenario分析\"></a>实例分析-具体Scenario分析</h5><p>我们考察冷启动从欢迎页启动到主页这个场景。看到时间为<code>4.8s</code>,感觉有些长了。我们使用Android Monitor的日志，过滤<code>ActivityManager:Displayed</code>，看到欢迎页是<code>569ms</code>，主页是<code>613ms</code>。</p>\n<p><img src=\"/images/nimabledroid-6.png\" alt=\"Summary\"><br>如图：</p>\n<ul>\n<li>Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。</li>\n<li>Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。</li>\n<li>Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。</li>\n<li><p>Speed - Dependencies 有时应用中的依赖关系会影响性能。</p>\n</li>\n<li><p>BaseActivity、BaseFragment的初始化操作</p>\n</li>\n<li>PushAgent.onAppStart 推送服务启动</li>\n<li>ClassUtil.getGenericSuperclass fastjson的方法</li>\n<li>ViewPager.onMeasure 欢迎页的测量</li>\n<li>Jackson JSON Parser jackjson的解析</li>\n</ul>\n<p>我们选取一个方法点击进入详细，如图：</p>\n<p><img src=\"/images/nimabledroid-7.png\" alt=\"Summary\"></p>\n<p>在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。</p>\n<p><img src=\"/images/nimabledroid-8.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！</p>\n</blockquote>\n<h4 id=\"优化注意点\"><a href=\"#优化注意点\" class=\"headerlink\" title=\"优化注意点\"></a>优化注意点</h4><h5 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h5><ul>\n<li>清除未使用的资源，Android lint analyze &amp; shrinkResource</li>\n<li>大图片使用tinyPNG</li>\n<li>png转webp</li>\n<li><a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"external\">AndResGuard</a></li>\n</ul>\n<h5 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h5><ul>\n<li>清除不必须的第三方jar，尤其是Android support </li>\n</ul>\n<h5 id=\"冗余代码\"><a href=\"#冗余代码\" class=\"headerlink\" title=\"冗余代码\"></a>冗余代码</h5><ul>\n<li>inspect code</li>\n</ul>\n"},{"layout":"post","title":"Android系统服务:服务概览","date":"2017-02-22T00:00:00.000Z","_content":" \n\n#### 一些说明 ####\n\n这个系列学习的系统服务，绝大多数是`android.app.SystemServiceRegistry`里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层`Application framework`。\n \n![application framework](/images/android-framework.png)\n\n其中核心平台服务包括：\n\n- Context.ACTIVITY_SERVICE -> ActivityManager\n- Context.WINDOW_SERVICE -> WindowManager\n- PackageManagerService [该服务并非在SystemServiceRegistry中注册]\n \n![android start 1](/images/android-start-1.png)\n \n![android start 2](/images/android-start-2.png)\n\n\n对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。\n<br/>\n<br/>\n\n再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。\n\n##### daemon #####\n- USB Daemon(usbd):管理USB连接\n- Android Debug Bridge Daemon(adbd):安卓调试桥链接管理\n- Debugger Daemon(debuggerd):启动Debugger系统\n- Radio Interface Layer Daemon(rild):管理无线通信连接\n\n##### Context Manager ##### \n管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。\n\nContext Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。\n\n同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。\n\n\n##### Media Server #####\n\nMedia Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.\n\n##### Zygote #####\n\nZygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。\n\n##### System Server #####\n\nSystem Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。\n\n##### Binder #####\n\nIPC(InterProcess Communication)进程间通信方式。<br/>\nRPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br/>\nBinder即支持IPC也支持RPC。\n\n#### android系统服务列表[基于7.0] ####\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 [传送](http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/)|\n| CAPTIONING_SERVICE | CaptioningManager | 弹幕、字幕管理[传送](http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/) |\n| ACCOUNT_SERVICE | AccountManager | 账户管理器 |\n| ACTIVITY_SERVICE | ActivityManager | 管理应用程序的系统状态 |\n| ALARM_SERVICE | AlarmManager | 闹钟的服务 |\n| AUDIO_SERVICE | AudioManager | 声音管理 |\n| MEDIA_ROUTER_SERVICE | MediaRouter | 扩展屏幕 |\n| BLUETOOTH_SERVICE | BluetoothManager | 蓝牙 |\n| HDMI_CONTROL_SERVICE |  HdmiControlManager | 管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。|\n| CLIPBOARD_SERVICE | ClipboardManager | 剪贴板管理器 |\n| CONNECTIVITY_SERVICE | ConnectivityManager | 网络连接管理器 |\n| COUNTRY_DETECTOR | CountryDetector | 获取用户所在地国家码 |\n| DEVICE_POLICY_SERVICE | DevicePolicyManager | 设备管理器 |\n| DOWNLOAD_SERVICE | DownloadManager | 下载管理器 |\n| BATTERY_SERVICE | BatteryManager | 电池管理器 |\n| NFC_SERVICE | NfcManager | NFC管理器 |\n| DROPBOX_SERVICE | DropBoxManager | 持续化存储系统数据管理器 |\n| INPUT_SERVICE | InputManager | 输入事件管理器如触摸点击etc |\n| DISPLAY_SERVICE | DisplayManager | 显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。 |\n| INPUT_METHOD_SERVICE | InputMethodManager | 输入法管理器 |\n| TEXT_SERVICES_MANAGER_SERVICE | TextServicesManager | 检查拼写管理器 |\n| KEYGUARD_SERVICE | KeyguardManager | 屏保管理器 |\n| LAYOUT_INFLATER_SERVICE | [LayoutInflater](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) | 布局填充管理器 [传送](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) |\n| NETWORK_POLICY_SERVICE | NetworkPolicyManager | 网络链接策略管理器 |\n| NOTIFICATION_SERVICE | NotificationManager | 通知管理器 |\n| NSD_SERVICE | NsdManager | 网络服务发现协议管理器 |\n| POWER_SERVICE | PowerManager | 电源管理器 |\n| RECOVERY_SERVICE | RecoverySystem | 刷机相关的-恢复模式服务 |\n| SEARCH_SERVICE | SearchManager | 搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索 |\n| SENSOR_SERVICE | SensorManager | 传感器管理器 |\n| STATUS_BAR_SERVICE | StatusBarManager | 状态栏管理器 |\n| STORAGE_SERVICE | StorageManager | 磁盘管理器 |\n| TELEPHONY_SERVICE | TelephonyManager | 电话管理器 |\n| TELEPHONY_SUBSCRIPTION_SERVICE | SubscriptionManager | SIM卡管理器 |\n| CARRIER_CONFIG_SERVICE | CarrierConfigManager | 提供对特定于运营商的电话配置值的访问 |\n| TELECOM_SERVICE | TelecomManager | 电话管理器 |\n| UI_MODE_SERVICE | UiModeManager | 夜间模式这样的切换 |\n| USB_SERVICE | UsbManager | USB管理器 |\n| SERIAL_SERVICE | SerialManager | 端口管理器 |\n| VIBRATOR_SERVICE | Vibrator | 振动器管理器 |\n| WALLPAPER_SERVICE | WallpaperManager | 壁纸管理器 |\n| WIFI_SERVICE | WifiManager | 无线网络管理器 |\n| WIFI_P2P_SERVICE | WifiP2pManager | 点对点设备连接管理器，无需连接到网络 |\n| WIFI_NAN_SERVICE | WifiNanManager |  neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。 |\n| WIFI_SCANNING_SERVICE | WifiScanner | wifi扫描管理器 |\n| WIFI_RTT_SERVICE | RttManager | round-trip time (RTT)管理器 |\n| ETHERNET_SERVICE | EthernetManager | 以太网IP配置管理器 |\n| WINDOW_SERVICE | WindowManager | 窗口管理器 |\n| USER_SERVICE | UserManager | 多用户管理器 |\n| APP_OPS_SERVICE | AppOpsManager | Application Operations权限管理器 |\n| CAMERA_SERVICE | CameraManager | 相机管理器 |\n| LAUNCHER_APPS_SERVICE | LauncherApps | 不同用户的不同package管理器 |\n| RESTRICTIONS_SERVICE | RestrictionsManager | 限制管理器 |\n| PRINT_SERVICE | PrintManager | 打印管理器 |\n| CONSUMER_IR_SERVICE | ConsumerIrManager | 红外发射管理器 |\n| MEDIA_SESSION_SERVICE | MediaSessionManager | MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器 |\n| TRUST_SERVICE | TrustManager | 信任证书管理器 |\n| FINGERPRINT_SERVICE | FingerprintManager | 指纹管理器 |\n| TV_INPUT_SERVICE | TvInputManager | 电视管理器 |\n| NETWORK_SCORE_SERVICE | NetworkScoreManager | 网络子系统和网络记分器之间的通信管理器 |\n| USAGE_STATS_SERVICE | UsageStatsManager | 使用情况统计管理器 |\n| NETWORK_STATS_SERVICE | NetworkStatsManager | 流量统计管理器 |\n| JOB_SCHEDULER_SERVICE | JobScheduler | 定时任务管理器 |\n| PERSISTENT_DATA_BLOCK_SERVICE | PersistentDataBlockManager | 持久数据区管理器-出厂设置擦除数据相关 |\n| MEDIA_PROJECTION_SERVICE | MediaProjectionManager | 系统屏幕截图管理器 |\n| APPWIDGET_SERVICE | AppWidgetManager | 桌面组件管理器 |\n| MIDI_SERVICE | MidiManager | （Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。 |\n| RADIO_SERVICE | RadioManager | 收音机管理器 |\n| HARDWARE_PROPERTIES_SERVICE | HardwarePropertiesManager | 硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度 |\n| SOUND_TRIGGER_SERVICE | SoundTriggerManager | 语音识别管理器 |\n| SHORTCUT_SERVICE | ShortcutManager | App Shortcuts是指在桌面长按app图标而出现的快捷方式 |\n| SYSTEM_HEALTH_SERVICE | SystemHealthManager | 系统资源使用情况管理器 |\n| CONTEXTHUB_SERVICE | ContextHubManager | 上下文中心管理器 |\n\n\n \n ","source":"_posts/2017-02-22-android-system-service-all.md","raw":"---\nlayout: post\ntitle:  Android系统服务:服务概览\ndate:   2017-02-22\ncategories: work\ntag: android\n---\n \n\n#### 一些说明 ####\n\n这个系列学习的系统服务，绝大多数是`android.app.SystemServiceRegistry`里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层`Application framework`。\n \n![application framework](/images/android-framework.png)\n\n其中核心平台服务包括：\n\n- Context.ACTIVITY_SERVICE -> ActivityManager\n- Context.WINDOW_SERVICE -> WindowManager\n- PackageManagerService [该服务并非在SystemServiceRegistry中注册]\n \n![android start 1](/images/android-start-1.png)\n \n![android start 2](/images/android-start-2.png)\n\n\n对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。\n<br/>\n<br/>\n\n再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。\n\n##### daemon #####\n- USB Daemon(usbd):管理USB连接\n- Android Debug Bridge Daemon(adbd):安卓调试桥链接管理\n- Debugger Daemon(debuggerd):启动Debugger系统\n- Radio Interface Layer Daemon(rild):管理无线通信连接\n\n##### Context Manager ##### \n管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。\n\nContext Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。\n\n同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。\n\n\n##### Media Server #####\n\nMedia Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.\n\n##### Zygote #####\n\nZygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。\n\n##### System Server #####\n\nSystem Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。\n\n##### Binder #####\n\nIPC(InterProcess Communication)进程间通信方式。<br/>\nRPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br/>\nBinder即支持IPC也支持RPC。\n\n#### android系统服务列表[基于7.0] ####\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 [传送](http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/)|\n| CAPTIONING_SERVICE | CaptioningManager | 弹幕、字幕管理[传送](http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/) |\n| ACCOUNT_SERVICE | AccountManager | 账户管理器 |\n| ACTIVITY_SERVICE | ActivityManager | 管理应用程序的系统状态 |\n| ALARM_SERVICE | AlarmManager | 闹钟的服务 |\n| AUDIO_SERVICE | AudioManager | 声音管理 |\n| MEDIA_ROUTER_SERVICE | MediaRouter | 扩展屏幕 |\n| BLUETOOTH_SERVICE | BluetoothManager | 蓝牙 |\n| HDMI_CONTROL_SERVICE |  HdmiControlManager | 管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。|\n| CLIPBOARD_SERVICE | ClipboardManager | 剪贴板管理器 |\n| CONNECTIVITY_SERVICE | ConnectivityManager | 网络连接管理器 |\n| COUNTRY_DETECTOR | CountryDetector | 获取用户所在地国家码 |\n| DEVICE_POLICY_SERVICE | DevicePolicyManager | 设备管理器 |\n| DOWNLOAD_SERVICE | DownloadManager | 下载管理器 |\n| BATTERY_SERVICE | BatteryManager | 电池管理器 |\n| NFC_SERVICE | NfcManager | NFC管理器 |\n| DROPBOX_SERVICE | DropBoxManager | 持续化存储系统数据管理器 |\n| INPUT_SERVICE | InputManager | 输入事件管理器如触摸点击etc |\n| DISPLAY_SERVICE | DisplayManager | 显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。 |\n| INPUT_METHOD_SERVICE | InputMethodManager | 输入法管理器 |\n| TEXT_SERVICES_MANAGER_SERVICE | TextServicesManager | 检查拼写管理器 |\n| KEYGUARD_SERVICE | KeyguardManager | 屏保管理器 |\n| LAYOUT_INFLATER_SERVICE | [LayoutInflater](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) | 布局填充管理器 [传送](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) |\n| NETWORK_POLICY_SERVICE | NetworkPolicyManager | 网络链接策略管理器 |\n| NOTIFICATION_SERVICE | NotificationManager | 通知管理器 |\n| NSD_SERVICE | NsdManager | 网络服务发现协议管理器 |\n| POWER_SERVICE | PowerManager | 电源管理器 |\n| RECOVERY_SERVICE | RecoverySystem | 刷机相关的-恢复模式服务 |\n| SEARCH_SERVICE | SearchManager | 搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索 |\n| SENSOR_SERVICE | SensorManager | 传感器管理器 |\n| STATUS_BAR_SERVICE | StatusBarManager | 状态栏管理器 |\n| STORAGE_SERVICE | StorageManager | 磁盘管理器 |\n| TELEPHONY_SERVICE | TelephonyManager | 电话管理器 |\n| TELEPHONY_SUBSCRIPTION_SERVICE | SubscriptionManager | SIM卡管理器 |\n| CARRIER_CONFIG_SERVICE | CarrierConfigManager | 提供对特定于运营商的电话配置值的访问 |\n| TELECOM_SERVICE | TelecomManager | 电话管理器 |\n| UI_MODE_SERVICE | UiModeManager | 夜间模式这样的切换 |\n| USB_SERVICE | UsbManager | USB管理器 |\n| SERIAL_SERVICE | SerialManager | 端口管理器 |\n| VIBRATOR_SERVICE | Vibrator | 振动器管理器 |\n| WALLPAPER_SERVICE | WallpaperManager | 壁纸管理器 |\n| WIFI_SERVICE | WifiManager | 无线网络管理器 |\n| WIFI_P2P_SERVICE | WifiP2pManager | 点对点设备连接管理器，无需连接到网络 |\n| WIFI_NAN_SERVICE | WifiNanManager |  neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。 |\n| WIFI_SCANNING_SERVICE | WifiScanner | wifi扫描管理器 |\n| WIFI_RTT_SERVICE | RttManager | round-trip time (RTT)管理器 |\n| ETHERNET_SERVICE | EthernetManager | 以太网IP配置管理器 |\n| WINDOW_SERVICE | WindowManager | 窗口管理器 |\n| USER_SERVICE | UserManager | 多用户管理器 |\n| APP_OPS_SERVICE | AppOpsManager | Application Operations权限管理器 |\n| CAMERA_SERVICE | CameraManager | 相机管理器 |\n| LAUNCHER_APPS_SERVICE | LauncherApps | 不同用户的不同package管理器 |\n| RESTRICTIONS_SERVICE | RestrictionsManager | 限制管理器 |\n| PRINT_SERVICE | PrintManager | 打印管理器 |\n| CONSUMER_IR_SERVICE | ConsumerIrManager | 红外发射管理器 |\n| MEDIA_SESSION_SERVICE | MediaSessionManager | MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器 |\n| TRUST_SERVICE | TrustManager | 信任证书管理器 |\n| FINGERPRINT_SERVICE | FingerprintManager | 指纹管理器 |\n| TV_INPUT_SERVICE | TvInputManager | 电视管理器 |\n| NETWORK_SCORE_SERVICE | NetworkScoreManager | 网络子系统和网络记分器之间的通信管理器 |\n| USAGE_STATS_SERVICE | UsageStatsManager | 使用情况统计管理器 |\n| NETWORK_STATS_SERVICE | NetworkStatsManager | 流量统计管理器 |\n| JOB_SCHEDULER_SERVICE | JobScheduler | 定时任务管理器 |\n| PERSISTENT_DATA_BLOCK_SERVICE | PersistentDataBlockManager | 持久数据区管理器-出厂设置擦除数据相关 |\n| MEDIA_PROJECTION_SERVICE | MediaProjectionManager | 系统屏幕截图管理器 |\n| APPWIDGET_SERVICE | AppWidgetManager | 桌面组件管理器 |\n| MIDI_SERVICE | MidiManager | （Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。 |\n| RADIO_SERVICE | RadioManager | 收音机管理器 |\n| HARDWARE_PROPERTIES_SERVICE | HardwarePropertiesManager | 硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度 |\n| SOUND_TRIGGER_SERVICE | SoundTriggerManager | 语音识别管理器 |\n| SHORTCUT_SERVICE | ShortcutManager | App Shortcuts是指在桌面长按app图标而出现的快捷方式 |\n| SYSTEM_HEALTH_SERVICE | SystemHealthManager | 系统资源使用情况管理器 |\n| CONTEXTHUB_SERVICE | ContextHubManager | 上下文中心管理器 |\n\n\n \n ","slug":"android-system-service-all","published":1,"updated":"2017-06-01T07:35:25.504Z","comments":1,"photos":[],"link":"","_id":"cj3tijdiv001fh8ivxryotn4n","content":"<h4 id=\"一些说明\"><a href=\"#一些说明\" class=\"headerlink\" title=\"一些说明\"></a>一些说明</h4><p>这个系列学习的系统服务，绝大多数是<code>android.app.SystemServiceRegistry</code>里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层<code>Application framework</code>。</p>\n<p><img src=\"/images/android-framework.png\" alt=\"application framework\"></p>\n<p>其中核心平台服务包括：</p>\n<ul>\n<li>Context.ACTIVITY_SERVICE -&gt; ActivityManager</li>\n<li>Context.WINDOW_SERVICE -&gt; WindowManager</li>\n<li>PackageManagerService [该服务并非在SystemServiceRegistry中注册]</li>\n</ul>\n<p><img src=\"/images/android-start-1.png\" alt=\"android start 1\"></p>\n<p><img src=\"/images/android-start-2.png\" alt=\"android start 2\"></p>\n<p>对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。<br><br><br><br></p>\n<p>再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。</p>\n<h5 id=\"daemon\"><a href=\"#daemon\" class=\"headerlink\" title=\"daemon\"></a>daemon</h5><ul>\n<li>USB Daemon(usbd):管理USB连接</li>\n<li>Android Debug Bridge Daemon(adbd):安卓调试桥链接管理</li>\n<li>Debugger Daemon(debuggerd):启动Debugger系统</li>\n<li>Radio Interface Layer Daemon(rild):管理无线通信连接</li>\n</ul>\n<h5 id=\"Context-Manager\"><a href=\"#Context-Manager\" class=\"headerlink\" title=\"Context Manager\"></a>Context Manager</h5><p>管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。</p>\n<p>Context Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。</p>\n<p>同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。</p>\n<h5 id=\"Media-Server\"><a href=\"#Media-Server\" class=\"headerlink\" title=\"Media Server\"></a>Media Server</h5><p>Media Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.</p>\n<h5 id=\"Zygote\"><a href=\"#Zygote\" class=\"headerlink\" title=\"Zygote\"></a>Zygote</h5><p>Zygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。</p>\n<h5 id=\"System-Server\"><a href=\"#System-Server\" class=\"headerlink\" title=\"System Server\"></a>System Server</h5><p>System Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。</p>\n<h5 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h5><p>IPC(InterProcess Communication)进程间通信方式。<br><br>RPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br><br>Binder即支持IPC也支持RPC。</p>\n<h4 id=\"android系统服务列表-基于7-0\"><a href=\"#android系统服务列表-基于7-0\" class=\"headerlink\" title=\"android系统服务列表[基于7.0]\"></a>android系统服务列表[基于7.0]</h4><table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务 <a href=\"http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>CAPTIONING_SERVICE</td>\n<td style=\"text-align:center\">CaptioningManager</td>\n<td style=\"text-align:right\">弹幕、字幕管理<a href=\"http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ACCOUNT_SERVICE</td>\n<td style=\"text-align:center\">AccountManager</td>\n<td style=\"text-align:right\">账户管理器</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ActivityManager</td>\n<td style=\"text-align:right\">管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td style=\"text-align:center\">AlarmManager</td>\n<td style=\"text-align:right\">闹钟的服务</td>\n</tr>\n<tr>\n<td>AUDIO_SERVICE</td>\n<td style=\"text-align:center\">AudioManager</td>\n<td style=\"text-align:right\">声音管理</td>\n</tr>\n<tr>\n<td>MEDIA_ROUTER_SERVICE</td>\n<td style=\"text-align:center\">MediaRouter</td>\n<td style=\"text-align:right\">扩展屏幕</td>\n</tr>\n<tr>\n<td>BLUETOOTH_SERVICE</td>\n<td style=\"text-align:center\">BluetoothManager</td>\n<td style=\"text-align:right\">蓝牙</td>\n</tr>\n<tr>\n<td>HDMI_CONTROL_SERVICE</td>\n<td style=\"text-align:center\">HdmiControlManager</td>\n<td style=\"text-align:right\">管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。</td>\n</tr>\n<tr>\n<td>CLIPBOARD_SERVICE</td>\n<td style=\"text-align:center\">ClipboardManager</td>\n<td style=\"text-align:right\">剪贴板管理器</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ConnectivityManager</td>\n<td style=\"text-align:right\">网络连接管理器</td>\n</tr>\n<tr>\n<td>COUNTRY_DETECTOR</td>\n<td style=\"text-align:center\">CountryDetector</td>\n<td style=\"text-align:right\">获取用户所在地国家码</td>\n</tr>\n<tr>\n<td>DEVICE_POLICY_SERVICE</td>\n<td style=\"text-align:center\">DevicePolicyManager</td>\n<td style=\"text-align:right\">设备管理器</td>\n</tr>\n<tr>\n<td>DOWNLOAD_SERVICE</td>\n<td style=\"text-align:center\">DownloadManager</td>\n<td style=\"text-align:right\">下载管理器</td>\n</tr>\n<tr>\n<td>BATTERY_SERVICE</td>\n<td style=\"text-align:center\">BatteryManager</td>\n<td style=\"text-align:right\">电池管理器</td>\n</tr>\n<tr>\n<td>NFC_SERVICE</td>\n<td style=\"text-align:center\">NfcManager</td>\n<td style=\"text-align:right\">NFC管理器</td>\n</tr>\n<tr>\n<td>DROPBOX_SERVICE</td>\n<td style=\"text-align:center\">DropBoxManager</td>\n<td style=\"text-align:right\">持续化存储系统数据管理器</td>\n</tr>\n<tr>\n<td>INPUT_SERVICE</td>\n<td style=\"text-align:center\">InputManager</td>\n<td style=\"text-align:right\">输入事件管理器如触摸点击etc</td>\n</tr>\n<tr>\n<td>DISPLAY_SERVICE</td>\n<td style=\"text-align:center\">DisplayManager</td>\n<td style=\"text-align:right\">显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。</td>\n</tr>\n<tr>\n<td>INPUT_METHOD_SERVICE</td>\n<td style=\"text-align:center\">InputMethodManager</td>\n<td style=\"text-align:right\">输入法管理器</td>\n</tr>\n<tr>\n<td>TEXT_SERVICES_MANAGER_SERVICE</td>\n<td style=\"text-align:center\">TextServicesManager</td>\n<td style=\"text-align:right\">检查拼写管理器</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td style=\"text-align:center\">KeyguardManager</td>\n<td style=\"text-align:right\">屏保管理器</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td style=\"text-align:center\"><a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">LayoutInflater</a></td>\n<td style=\"text-align:right\">布局填充管理器 <a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>NETWORK_POLICY_SERVICE</td>\n<td style=\"text-align:center\">NetworkPolicyManager</td>\n<td style=\"text-align:right\">网络链接策略管理器</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td style=\"text-align:center\">NotificationManager</td>\n<td style=\"text-align:right\">通知管理器</td>\n</tr>\n<tr>\n<td>NSD_SERVICE</td>\n<td style=\"text-align:center\">NsdManager</td>\n<td style=\"text-align:right\">网络服务发现协议管理器</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td style=\"text-align:center\">PowerManager</td>\n<td style=\"text-align:right\">电源管理器</td>\n</tr>\n<tr>\n<td>RECOVERY_SERVICE</td>\n<td style=\"text-align:center\">RecoverySystem</td>\n<td style=\"text-align:right\">刷机相关的-恢复模式服务</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td style=\"text-align:center\">SearchManager</td>\n<td style=\"text-align:right\">搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索</td>\n</tr>\n<tr>\n<td>SENSOR_SERVICE</td>\n<td style=\"text-align:center\">SensorManager</td>\n<td style=\"text-align:right\">传感器管理器</td>\n</tr>\n<tr>\n<td>STATUS_BAR_SERVICE</td>\n<td style=\"text-align:center\">StatusBarManager</td>\n<td style=\"text-align:right\">状态栏管理器</td>\n</tr>\n<tr>\n<td>STORAGE_SERVICE</td>\n<td style=\"text-align:center\">StorageManager</td>\n<td style=\"text-align:right\">磁盘管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td style=\"text-align:center\">TelephonyManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SUBSCRIPTION_SERVICE</td>\n<td style=\"text-align:center\">SubscriptionManager</td>\n<td style=\"text-align:right\">SIM卡管理器</td>\n</tr>\n<tr>\n<td>CARRIER_CONFIG_SERVICE</td>\n<td style=\"text-align:center\">CarrierConfigManager</td>\n<td style=\"text-align:right\">提供对特定于运营商的电话配置值的访问</td>\n</tr>\n<tr>\n<td>TELECOM_SERVICE</td>\n<td style=\"text-align:center\">TelecomManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>UI_MODE_SERVICE</td>\n<td style=\"text-align:center\">UiModeManager</td>\n<td style=\"text-align:right\">夜间模式这样的切换</td>\n</tr>\n<tr>\n<td>USB_SERVICE</td>\n<td style=\"text-align:center\">UsbManager</td>\n<td style=\"text-align:right\">USB管理器</td>\n</tr>\n<tr>\n<td>SERIAL_SERVICE</td>\n<td style=\"text-align:center\">SerialManager</td>\n<td style=\"text-align:right\">端口管理器</td>\n</tr>\n<tr>\n<td>VIBRATOR_SERVICE</td>\n<td style=\"text-align:center\">Vibrator</td>\n<td style=\"text-align:right\">振动器管理器</td>\n</tr>\n<tr>\n<td>WALLPAPER_SERVICE</td>\n<td style=\"text-align:center\">WallpaperManager</td>\n<td style=\"text-align:right\">壁纸管理器</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td style=\"text-align:center\">WifiManager</td>\n<td style=\"text-align:right\">无线网络管理器</td>\n</tr>\n<tr>\n<td>WIFI_P2P_SERVICE</td>\n<td style=\"text-align:center\">WifiP2pManager</td>\n<td style=\"text-align:right\">点对点设备连接管理器，无需连接到网络</td>\n</tr>\n<tr>\n<td>WIFI_NAN_SERVICE</td>\n<td style=\"text-align:center\">WifiNanManager</td>\n<td style=\"text-align:right\">neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。</td>\n</tr>\n<tr>\n<td>WIFI_SCANNING_SERVICE</td>\n<td style=\"text-align:center\">WifiScanner</td>\n<td style=\"text-align:right\">wifi扫描管理器</td>\n</tr>\n<tr>\n<td>WIFI_RTT_SERVICE</td>\n<td style=\"text-align:center\">RttManager</td>\n<td style=\"text-align:right\">round-trip time (RTT)管理器</td>\n</tr>\n<tr>\n<td>ETHERNET_SERVICE</td>\n<td style=\"text-align:center\">EthernetManager</td>\n<td style=\"text-align:right\">以太网IP配置管理器</td>\n</tr>\n<tr>\n<td>WINDOW_SERVICE</td>\n<td style=\"text-align:center\">WindowManager</td>\n<td style=\"text-align:right\">窗口管理器</td>\n</tr>\n<tr>\n<td>USER_SERVICE</td>\n<td style=\"text-align:center\">UserManager</td>\n<td style=\"text-align:right\">多用户管理器</td>\n</tr>\n<tr>\n<td>APP_OPS_SERVICE</td>\n<td style=\"text-align:center\">AppOpsManager</td>\n<td style=\"text-align:right\">Application Operations权限管理器</td>\n</tr>\n<tr>\n<td>CAMERA_SERVICE</td>\n<td style=\"text-align:center\">CameraManager</td>\n<td style=\"text-align:right\">相机管理器</td>\n</tr>\n<tr>\n<td>LAUNCHER_APPS_SERVICE</td>\n<td style=\"text-align:center\">LauncherApps</td>\n<td style=\"text-align:right\">不同用户的不同package管理器</td>\n</tr>\n<tr>\n<td>RESTRICTIONS_SERVICE</td>\n<td style=\"text-align:center\">RestrictionsManager</td>\n<td style=\"text-align:right\">限制管理器</td>\n</tr>\n<tr>\n<td>PRINT_SERVICE</td>\n<td style=\"text-align:center\">PrintManager</td>\n<td style=\"text-align:right\">打印管理器</td>\n</tr>\n<tr>\n<td>CONSUMER_IR_SERVICE</td>\n<td style=\"text-align:center\">ConsumerIrManager</td>\n<td style=\"text-align:right\">红外发射管理器</td>\n</tr>\n<tr>\n<td>MEDIA_SESSION_SERVICE</td>\n<td style=\"text-align:center\">MediaSessionManager</td>\n<td style=\"text-align:right\">MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器</td>\n</tr>\n<tr>\n<td>TRUST_SERVICE</td>\n<td style=\"text-align:center\">TrustManager</td>\n<td style=\"text-align:right\">信任证书管理器</td>\n</tr>\n<tr>\n<td>FINGERPRINT_SERVICE</td>\n<td style=\"text-align:center\">FingerprintManager</td>\n<td style=\"text-align:right\">指纹管理器</td>\n</tr>\n<tr>\n<td>TV_INPUT_SERVICE</td>\n<td style=\"text-align:center\">TvInputManager</td>\n<td style=\"text-align:right\">电视管理器</td>\n</tr>\n<tr>\n<td>NETWORK_SCORE_SERVICE</td>\n<td style=\"text-align:center\">NetworkScoreManager</td>\n<td style=\"text-align:right\">网络子系统和网络记分器之间的通信管理器</td>\n</tr>\n<tr>\n<td>USAGE_STATS_SERVICE</td>\n<td style=\"text-align:center\">UsageStatsManager</td>\n<td style=\"text-align:right\">使用情况统计管理器</td>\n</tr>\n<tr>\n<td>NETWORK_STATS_SERVICE</td>\n<td style=\"text-align:center\">NetworkStatsManager</td>\n<td style=\"text-align:right\">流量统计管理器</td>\n</tr>\n<tr>\n<td>JOB_SCHEDULER_SERVICE</td>\n<td style=\"text-align:center\">JobScheduler</td>\n<td style=\"text-align:right\">定时任务管理器</td>\n</tr>\n<tr>\n<td>PERSISTENT_DATA_BLOCK_SERVICE</td>\n<td style=\"text-align:center\">PersistentDataBlockManager</td>\n<td style=\"text-align:right\">持久数据区管理器-出厂设置擦除数据相关</td>\n</tr>\n<tr>\n<td>MEDIA_PROJECTION_SERVICE</td>\n<td style=\"text-align:center\">MediaProjectionManager</td>\n<td style=\"text-align:right\">系统屏幕截图管理器</td>\n</tr>\n<tr>\n<td>APPWIDGET_SERVICE</td>\n<td style=\"text-align:center\">AppWidgetManager</td>\n<td style=\"text-align:right\">桌面组件管理器</td>\n</tr>\n<tr>\n<td>MIDI_SERVICE</td>\n<td style=\"text-align:center\">MidiManager</td>\n<td style=\"text-align:right\">（Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。</td>\n</tr>\n<tr>\n<td>RADIO_SERVICE</td>\n<td style=\"text-align:center\">RadioManager</td>\n<td style=\"text-align:right\">收音机管理器</td>\n</tr>\n<tr>\n<td>HARDWARE_PROPERTIES_SERVICE</td>\n<td style=\"text-align:center\">HardwarePropertiesManager</td>\n<td style=\"text-align:right\">硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度</td>\n</tr>\n<tr>\n<td>SOUND_TRIGGER_SERVICE</td>\n<td style=\"text-align:center\">SoundTriggerManager</td>\n<td style=\"text-align:right\">语音识别管理器</td>\n</tr>\n<tr>\n<td>SHORTCUT_SERVICE</td>\n<td style=\"text-align:center\">ShortcutManager</td>\n<td style=\"text-align:right\">App Shortcuts是指在桌面长按app图标而出现的快捷方式</td>\n</tr>\n<tr>\n<td>SYSTEM_HEALTH_SERVICE</td>\n<td style=\"text-align:center\">SystemHealthManager</td>\n<td style=\"text-align:right\">系统资源使用情况管理器</td>\n</tr>\n<tr>\n<td>CONTEXTHUB_SERVICE</td>\n<td style=\"text-align:center\">ContextHubManager</td>\n<td style=\"text-align:right\">上下文中心管理器</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一些说明\"><a href=\"#一些说明\" class=\"headerlink\" title=\"一些说明\"></a>一些说明</h4><p>这个系列学习的系统服务，绝大多数是<code>android.app.SystemServiceRegistry</code>里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层<code>Application framework</code>。</p>\n<p><img src=\"/images/android-framework.png\" alt=\"application framework\"></p>\n<p>其中核心平台服务包括：</p>\n<ul>\n<li>Context.ACTIVITY_SERVICE -&gt; ActivityManager</li>\n<li>Context.WINDOW_SERVICE -&gt; WindowManager</li>\n<li>PackageManagerService [该服务并非在SystemServiceRegistry中注册]</li>\n</ul>\n<p><img src=\"/images/android-start-1.png\" alt=\"android start 1\"></p>\n<p><img src=\"/images/android-start-2.png\" alt=\"android start 2\"></p>\n<p>对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。<br><br><br><br></p>\n<p>再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。</p>\n<h5 id=\"daemon\"><a href=\"#daemon\" class=\"headerlink\" title=\"daemon\"></a>daemon</h5><ul>\n<li>USB Daemon(usbd):管理USB连接</li>\n<li>Android Debug Bridge Daemon(adbd):安卓调试桥链接管理</li>\n<li>Debugger Daemon(debuggerd):启动Debugger系统</li>\n<li>Radio Interface Layer Daemon(rild):管理无线通信连接</li>\n</ul>\n<h5 id=\"Context-Manager\"><a href=\"#Context-Manager\" class=\"headerlink\" title=\"Context Manager\"></a>Context Manager</h5><p>管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。</p>\n<p>Context Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。</p>\n<p>同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。</p>\n<h5 id=\"Media-Server\"><a href=\"#Media-Server\" class=\"headerlink\" title=\"Media Server\"></a>Media Server</h5><p>Media Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.</p>\n<h5 id=\"Zygote\"><a href=\"#Zygote\" class=\"headerlink\" title=\"Zygote\"></a>Zygote</h5><p>Zygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。</p>\n<h5 id=\"System-Server\"><a href=\"#System-Server\" class=\"headerlink\" title=\"System Server\"></a>System Server</h5><p>System Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。</p>\n<h5 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h5><p>IPC(InterProcess Communication)进程间通信方式。<br><br>RPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br><br>Binder即支持IPC也支持RPC。</p>\n<h4 id=\"android系统服务列表-基于7-0\"><a href=\"#android系统服务列表-基于7-0\" class=\"headerlink\" title=\"android系统服务列表[基于7.0]\"></a>android系统服务列表[基于7.0]</h4><table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务 <a href=\"http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>CAPTIONING_SERVICE</td>\n<td style=\"text-align:center\">CaptioningManager</td>\n<td style=\"text-align:right\">弹幕、字幕管理<a href=\"http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ACCOUNT_SERVICE</td>\n<td style=\"text-align:center\">AccountManager</td>\n<td style=\"text-align:right\">账户管理器</td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ActivityManager</td>\n<td style=\"text-align:right\">管理应用程序的系统状态</td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td style=\"text-align:center\">AlarmManager</td>\n<td style=\"text-align:right\">闹钟的服务</td>\n</tr>\n<tr>\n<td>AUDIO_SERVICE</td>\n<td style=\"text-align:center\">AudioManager</td>\n<td style=\"text-align:right\">声音管理</td>\n</tr>\n<tr>\n<td>MEDIA_ROUTER_SERVICE</td>\n<td style=\"text-align:center\">MediaRouter</td>\n<td style=\"text-align:right\">扩展屏幕</td>\n</tr>\n<tr>\n<td>BLUETOOTH_SERVICE</td>\n<td style=\"text-align:center\">BluetoothManager</td>\n<td style=\"text-align:right\">蓝牙</td>\n</tr>\n<tr>\n<td>HDMI_CONTROL_SERVICE</td>\n<td style=\"text-align:center\">HdmiControlManager</td>\n<td style=\"text-align:right\">管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。</td>\n</tr>\n<tr>\n<td>CLIPBOARD_SERVICE</td>\n<td style=\"text-align:center\">ClipboardManager</td>\n<td style=\"text-align:right\">剪贴板管理器</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ConnectivityManager</td>\n<td style=\"text-align:right\">网络连接管理器</td>\n</tr>\n<tr>\n<td>COUNTRY_DETECTOR</td>\n<td style=\"text-align:center\">CountryDetector</td>\n<td style=\"text-align:right\">获取用户所在地国家码</td>\n</tr>\n<tr>\n<td>DEVICE_POLICY_SERVICE</td>\n<td style=\"text-align:center\">DevicePolicyManager</td>\n<td style=\"text-align:right\">设备管理器</td>\n</tr>\n<tr>\n<td>DOWNLOAD_SERVICE</td>\n<td style=\"text-align:center\">DownloadManager</td>\n<td style=\"text-align:right\">下载管理器</td>\n</tr>\n<tr>\n<td>BATTERY_SERVICE</td>\n<td style=\"text-align:center\">BatteryManager</td>\n<td style=\"text-align:right\">电池管理器</td>\n</tr>\n<tr>\n<td>NFC_SERVICE</td>\n<td style=\"text-align:center\">NfcManager</td>\n<td style=\"text-align:right\">NFC管理器</td>\n</tr>\n<tr>\n<td>DROPBOX_SERVICE</td>\n<td style=\"text-align:center\">DropBoxManager</td>\n<td style=\"text-align:right\">持续化存储系统数据管理器</td>\n</tr>\n<tr>\n<td>INPUT_SERVICE</td>\n<td style=\"text-align:center\">InputManager</td>\n<td style=\"text-align:right\">输入事件管理器如触摸点击etc</td>\n</tr>\n<tr>\n<td>DISPLAY_SERVICE</td>\n<td style=\"text-align:center\">DisplayManager</td>\n<td style=\"text-align:right\">显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。</td>\n</tr>\n<tr>\n<td>INPUT_METHOD_SERVICE</td>\n<td style=\"text-align:center\">InputMethodManager</td>\n<td style=\"text-align:right\">输入法管理器</td>\n</tr>\n<tr>\n<td>TEXT_SERVICES_MANAGER_SERVICE</td>\n<td style=\"text-align:center\">TextServicesManager</td>\n<td style=\"text-align:right\">检查拼写管理器</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td style=\"text-align:center\">KeyguardManager</td>\n<td style=\"text-align:right\">屏保管理器</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td style=\"text-align:center\"><a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">LayoutInflater</a></td>\n<td style=\"text-align:right\">布局填充管理器 <a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>NETWORK_POLICY_SERVICE</td>\n<td style=\"text-align:center\">NetworkPolicyManager</td>\n<td style=\"text-align:right\">网络链接策略管理器</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td style=\"text-align:center\">NotificationManager</td>\n<td style=\"text-align:right\">通知管理器</td>\n</tr>\n<tr>\n<td>NSD_SERVICE</td>\n<td style=\"text-align:center\">NsdManager</td>\n<td style=\"text-align:right\">网络服务发现协议管理器</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td style=\"text-align:center\">PowerManager</td>\n<td style=\"text-align:right\">电源管理器</td>\n</tr>\n<tr>\n<td>RECOVERY_SERVICE</td>\n<td style=\"text-align:center\">RecoverySystem</td>\n<td style=\"text-align:right\">刷机相关的-恢复模式服务</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td style=\"text-align:center\">SearchManager</td>\n<td style=\"text-align:right\">搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索</td>\n</tr>\n<tr>\n<td>SENSOR_SERVICE</td>\n<td style=\"text-align:center\">SensorManager</td>\n<td style=\"text-align:right\">传感器管理器</td>\n</tr>\n<tr>\n<td>STATUS_BAR_SERVICE</td>\n<td style=\"text-align:center\">StatusBarManager</td>\n<td style=\"text-align:right\">状态栏管理器</td>\n</tr>\n<tr>\n<td>STORAGE_SERVICE</td>\n<td style=\"text-align:center\">StorageManager</td>\n<td style=\"text-align:right\">磁盘管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td style=\"text-align:center\">TelephonyManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SUBSCRIPTION_SERVICE</td>\n<td style=\"text-align:center\">SubscriptionManager</td>\n<td style=\"text-align:right\">SIM卡管理器</td>\n</tr>\n<tr>\n<td>CARRIER_CONFIG_SERVICE</td>\n<td style=\"text-align:center\">CarrierConfigManager</td>\n<td style=\"text-align:right\">提供对特定于运营商的电话配置值的访问</td>\n</tr>\n<tr>\n<td>TELECOM_SERVICE</td>\n<td style=\"text-align:center\">TelecomManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>UI_MODE_SERVICE</td>\n<td style=\"text-align:center\">UiModeManager</td>\n<td style=\"text-align:right\">夜间模式这样的切换</td>\n</tr>\n<tr>\n<td>USB_SERVICE</td>\n<td style=\"text-align:center\">UsbManager</td>\n<td style=\"text-align:right\">USB管理器</td>\n</tr>\n<tr>\n<td>SERIAL_SERVICE</td>\n<td style=\"text-align:center\">SerialManager</td>\n<td style=\"text-align:right\">端口管理器</td>\n</tr>\n<tr>\n<td>VIBRATOR_SERVICE</td>\n<td style=\"text-align:center\">Vibrator</td>\n<td style=\"text-align:right\">振动器管理器</td>\n</tr>\n<tr>\n<td>WALLPAPER_SERVICE</td>\n<td style=\"text-align:center\">WallpaperManager</td>\n<td style=\"text-align:right\">壁纸管理器</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td style=\"text-align:center\">WifiManager</td>\n<td style=\"text-align:right\">无线网络管理器</td>\n</tr>\n<tr>\n<td>WIFI_P2P_SERVICE</td>\n<td style=\"text-align:center\">WifiP2pManager</td>\n<td style=\"text-align:right\">点对点设备连接管理器，无需连接到网络</td>\n</tr>\n<tr>\n<td>WIFI_NAN_SERVICE</td>\n<td style=\"text-align:center\">WifiNanManager</td>\n<td style=\"text-align:right\">neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。</td>\n</tr>\n<tr>\n<td>WIFI_SCANNING_SERVICE</td>\n<td style=\"text-align:center\">WifiScanner</td>\n<td style=\"text-align:right\">wifi扫描管理器</td>\n</tr>\n<tr>\n<td>WIFI_RTT_SERVICE</td>\n<td style=\"text-align:center\">RttManager</td>\n<td style=\"text-align:right\">round-trip time (RTT)管理器</td>\n</tr>\n<tr>\n<td>ETHERNET_SERVICE</td>\n<td style=\"text-align:center\">EthernetManager</td>\n<td style=\"text-align:right\">以太网IP配置管理器</td>\n</tr>\n<tr>\n<td>WINDOW_SERVICE</td>\n<td style=\"text-align:center\">WindowManager</td>\n<td style=\"text-align:right\">窗口管理器</td>\n</tr>\n<tr>\n<td>USER_SERVICE</td>\n<td style=\"text-align:center\">UserManager</td>\n<td style=\"text-align:right\">多用户管理器</td>\n</tr>\n<tr>\n<td>APP_OPS_SERVICE</td>\n<td style=\"text-align:center\">AppOpsManager</td>\n<td style=\"text-align:right\">Application Operations权限管理器</td>\n</tr>\n<tr>\n<td>CAMERA_SERVICE</td>\n<td style=\"text-align:center\">CameraManager</td>\n<td style=\"text-align:right\">相机管理器</td>\n</tr>\n<tr>\n<td>LAUNCHER_APPS_SERVICE</td>\n<td style=\"text-align:center\">LauncherApps</td>\n<td style=\"text-align:right\">不同用户的不同package管理器</td>\n</tr>\n<tr>\n<td>RESTRICTIONS_SERVICE</td>\n<td style=\"text-align:center\">RestrictionsManager</td>\n<td style=\"text-align:right\">限制管理器</td>\n</tr>\n<tr>\n<td>PRINT_SERVICE</td>\n<td style=\"text-align:center\">PrintManager</td>\n<td style=\"text-align:right\">打印管理器</td>\n</tr>\n<tr>\n<td>CONSUMER_IR_SERVICE</td>\n<td style=\"text-align:center\">ConsumerIrManager</td>\n<td style=\"text-align:right\">红外发射管理器</td>\n</tr>\n<tr>\n<td>MEDIA_SESSION_SERVICE</td>\n<td style=\"text-align:center\">MediaSessionManager</td>\n<td style=\"text-align:right\">MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器</td>\n</tr>\n<tr>\n<td>TRUST_SERVICE</td>\n<td style=\"text-align:center\">TrustManager</td>\n<td style=\"text-align:right\">信任证书管理器</td>\n</tr>\n<tr>\n<td>FINGERPRINT_SERVICE</td>\n<td style=\"text-align:center\">FingerprintManager</td>\n<td style=\"text-align:right\">指纹管理器</td>\n</tr>\n<tr>\n<td>TV_INPUT_SERVICE</td>\n<td style=\"text-align:center\">TvInputManager</td>\n<td style=\"text-align:right\">电视管理器</td>\n</tr>\n<tr>\n<td>NETWORK_SCORE_SERVICE</td>\n<td style=\"text-align:center\">NetworkScoreManager</td>\n<td style=\"text-align:right\">网络子系统和网络记分器之间的通信管理器</td>\n</tr>\n<tr>\n<td>USAGE_STATS_SERVICE</td>\n<td style=\"text-align:center\">UsageStatsManager</td>\n<td style=\"text-align:right\">使用情况统计管理器</td>\n</tr>\n<tr>\n<td>NETWORK_STATS_SERVICE</td>\n<td style=\"text-align:center\">NetworkStatsManager</td>\n<td style=\"text-align:right\">流量统计管理器</td>\n</tr>\n<tr>\n<td>JOB_SCHEDULER_SERVICE</td>\n<td style=\"text-align:center\">JobScheduler</td>\n<td style=\"text-align:right\">定时任务管理器</td>\n</tr>\n<tr>\n<td>PERSISTENT_DATA_BLOCK_SERVICE</td>\n<td style=\"text-align:center\">PersistentDataBlockManager</td>\n<td style=\"text-align:right\">持久数据区管理器-出厂设置擦除数据相关</td>\n</tr>\n<tr>\n<td>MEDIA_PROJECTION_SERVICE</td>\n<td style=\"text-align:center\">MediaProjectionManager</td>\n<td style=\"text-align:right\">系统屏幕截图管理器</td>\n</tr>\n<tr>\n<td>APPWIDGET_SERVICE</td>\n<td style=\"text-align:center\">AppWidgetManager</td>\n<td style=\"text-align:right\">桌面组件管理器</td>\n</tr>\n<tr>\n<td>MIDI_SERVICE</td>\n<td style=\"text-align:center\">MidiManager</td>\n<td style=\"text-align:right\">（Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。</td>\n</tr>\n<tr>\n<td>RADIO_SERVICE</td>\n<td style=\"text-align:center\">RadioManager</td>\n<td style=\"text-align:right\">收音机管理器</td>\n</tr>\n<tr>\n<td>HARDWARE_PROPERTIES_SERVICE</td>\n<td style=\"text-align:center\">HardwarePropertiesManager</td>\n<td style=\"text-align:right\">硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度</td>\n</tr>\n<tr>\n<td>SOUND_TRIGGER_SERVICE</td>\n<td style=\"text-align:center\">SoundTriggerManager</td>\n<td style=\"text-align:right\">语音识别管理器</td>\n</tr>\n<tr>\n<td>SHORTCUT_SERVICE</td>\n<td style=\"text-align:center\">ShortcutManager</td>\n<td style=\"text-align:right\">App Shortcuts是指在桌面长按app图标而出现的快捷方式</td>\n</tr>\n<tr>\n<td>SYSTEM_HEALTH_SERVICE</td>\n<td style=\"text-align:center\">SystemHealthManager</td>\n<td style=\"text-align:right\">系统资源使用情况管理器</td>\n</tr>\n<tr>\n<td>CONTEXTHUB_SERVICE</td>\n<td style=\"text-align:center\">ContextHubManager</td>\n<td style=\"text-align:right\">上下文中心管理器</td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"单例设计模式(五) Android中单例的应用","date":"2017-02-21T00:00:00.000Z","_content":"\n \n\n\n#### 写在前面的关键点 ####\n\n我们知道，单例模式的特点：\n\n- 只有一个实例\n- 占用内存及资源较少，可防止对象不停的创建和销毁\n- 全局访问\n- 扩展性差\n- 与单一职责原则有冲突\n\n根据其特点，我们去看源码或者设计应用就可以做到有据可循了。\n\n#### Android系统源码中 ####\n\n##### 示例一【饿汉单例】：android.text.Editable.Factory.java #####\n\t\n\t   /**\n\t     * Factory used by TextView to create new Editables.  You can subclass\n\t     * it to provide something other than SpannableStringBuilder.\n\t     */\n\t    public static class Factory {\n\t        private static Editable.Factory sInstance = new Editable.Factory();\n\t      \n\t        public static Editable.Factory getInstance() {\n\t            return sInstance;\n\t        }\n\n\t        public Editable newEditable(CharSequence source) {\n\t            return new SpannableStringBuilder(source);\n\t        }\n\t    }\n\n> Editable 即 `android.widget.EditText#getText()` 返回的对象。最常用的大概是`et.getText().toString()`吧。\n\n然后从EditText-> TextView可以看到：\n\n    private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\n    private Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n\n然后考察其应用：\n\n\t private InputFilter[] mFilters = NO_FILTERS;\n\t private void setText(CharSequence text, BufferType type,\n\t                         boolean notifyBefore, int oldlen) {\n\t\t.\n\t\t.\n\t\t.\n\n\t\tEditable t = mEditableFactory.newEditable(text);\n        text = t;\n        setFilters(t, mFilters);\n\n\t\t.\n\t\t.\n\t\t.\n\t}\n\n得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。\n\n\n##### 示例二【懒汉单例】：ArrowKeyMovementMethod.java #####\n\n\tprivate static ArrowKeyMovementMethod sInstance;\t\n    public static MovementMethod getInstance() {\n        if (sInstance == null) {\n            sInstance = new ArrowKeyMovementMethod();\n        }\n\n        return sInstance;\n    }\n\n>看类名好像是光标移动相关的东东，跟进去看一下好了。<br/>\n>`initialize`初始化，把光标放在末尾位置；<br/>\n>`onTouchEvent`处理触摸拖拽事件；<br/>\n>`canSelectArbitrarily` 根据名字，是否可以任意选择，固定返回true；<br/>\n>`onTakeFocus` 获取焦点后的默认操作：光标放末尾\n\n\n\n\n##### 示例三【线程同步锁单例】：LocalBroadcastManager.java #####\n\n\n\tprivate static final Object mLock = new Object();\n    private static LocalBroadcastManager mInstance;\n\n    public static LocalBroadcastManager getInstance(Context context) {\n        synchronized (mLock) {\n            if (mInstance == null) {\n                mInstance = new LocalBroadcastManager(context.getApplicationContext());\n            }\n            return mInstance;\n        }\n    }\n\n>看类名是本地广播管理类，先看其类注释：<br/>\n\n>\n Helper to register for and send broadcasts of Intents to local objects\n within your process.  This has a number of advantages over sending\n global broadcasts with {@link android.content.Context#sendBroadcast}<br/>\n进程内帮助注册和发送广播给本地对象。相比于```Context#sendBroadcast```有巨大优势！<br/>\n\n优势有三：<br/>\n1. 应用内发送，不必担心私有数据泄露；<br/>\n2. 别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br/>\n3. 比通过系统发送广播更加有效。\n\n##### 示例四【线程同步锁单例】：InputMethodManager.java #####\n\n\tstatic InputMethodManager sInstance;\n\tpublic static InputMethodManager getInstance() {\n\t        synchronized (InputMethodManager.class) {\n\t            if (sInstance == null) {\n\t                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n\t                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n\t                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n\t            }\n\t            return sInstance;\n\t        }\n\t    }\n\n>用来控制显示和隐藏输入法面板。\n>\n##### 示例五【容器单例】：FocusFinder.java #####\n    \nFocusFinder.java\n\n\t    private static final ThreadLocal<FocusFinder> tlFocusFinder =\n            new ThreadLocal<FocusFinder>() {\n                @Override\n                protected FocusFinder initialValue() {\n                    return new FocusFinder();\n                }\n            };\n\n\t\tpublic static FocusFinder getInstance() {\n\t        return tlFocusFinder.get();\n\t    }\n\nThreadLocal.java\n\t\n\t    /**\n\t     * Returns the value in the current thread's copy of this\n\t     * thread-local variable.  If the variable has no value for the\n\t     * current thread, it is first initialized to the value returned\n\t     * by an invocation of the {@link #initialValue} method.\n\t     *\n\t     * @return the current thread's value of this thread-local\n\t     */\n\t    public T get() {\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null) {\n\t            ThreadLocalMap.Entry e = map.getEntry(this);\n\t            if (e != null)\n\t                return (T)e.value;\n\t        }\n\t        return setInitialValue();\n\t    }\n\t\n-\n\t\n\t    /**\n\t     * Variant of set() to establish initialValue. Used instead\n\t     * of set() in case user has overridden the set() method.\n\t     *\n\t     * @return the initial value\n\t     */\n\t    private T setInitialValue() {\n\t        T value = initialValue();\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null)\n\t            map.set(this, value);\n\t        else\n\t            createMap(t, value);\n\t        return value;\n\t    }\n\t\n\t    protected T initialValue() {\n\t        return null;\n\t    }\n\n> 一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：\n\n\n    private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n        View next = null;\n        if (focused != null) {\n            next = findNextUserSpecifiedFocus(root, focused, direction);\n        }\n        if (next != null) {\n            return next;\n        }\n        ArrayList<View> focusables = mTempList;\n        try {\n            focusables.clear();\n            root.addFocusables(focusables, direction);\n            if (!focusables.isEmpty()) {\n                next = findNextFocus(root, focused, focusedRect, direction, focusables);\n            }\n        } finally {\n            focusables.clear();\n        }\n        return next;\n    }\n\n##### 示例六【容器单例】：android.app.SystemServiceRegistry.java #####\n\n>\n该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。\n\n[源码地址](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java)。\n\n[服务说明在此](http://xusx1024.com/2017/02/22/android-system-service/)。\n\n##### 示例七【别样的单例】：BidiFormatter.java #####\n\n实例\n\t\n\t\tprivate static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n\t            false /* LTR context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\t\n\t    private static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n\t            true /* RTL context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\n构造\n\n\t   private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n\t        mIsRtlContext = isRtlContext;\n\t        mFlags = flags;\n\t        mDefaultTextDirectionHeuristic = heuristic;\n\t    }\n\n获取实例：\n\n    public static BidiFormatter getInstance() {\n        return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n    }\n \n    public static BidiFormatter getInstance(boolean rtlContext) {\n        return getDefaultInstanceFromContext(rtlContext);\n    }\n \n    public static BidiFormatter getInstance(Locale locale) {\n        return getDefaultInstanceFromContext(isRtlLocale(locale));\n    }\n\n>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br/>\n>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br/>\n>如果要开启，在Manifest.xml中，修改Application结点的属性`android:supportsRtl`为true<br/>\n>另外，我们在xml布局时，经常看到提示：使用`android:layout_marginStart`替代`android:layout_marginLeft`这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。\n\n注1：\n> 其中volatial修饰的实例没有找到，Enum实现的单例也没找到。\n\n\n\n注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：\n\n![Android 源码中常见单例 图一](/images/android-singleton-1.png)\n\n![Android 源码中常见单例 图二](/images/android-singleton-2.png)\n\n\n#### Android App开发中 ####\n\n分析上半部可得：\n\n- 内部类单例-饿汉式\n- 简单单例-懒汉式\n- 多线程调用-带线程锁的懒汉式\n- 多种单例-容器管理单例\n\n我负责的app中，整理了一下，大概有如下会需要到单例：\n1. Application\n2. 定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类\n3. 升级管理\n\n","source":"_posts/2017-02-21-design-patterns-singleton-5.md","raw":"---\nlayout: post\ntitle:  单例设计模式(五) Android中单例的应用\ndate:   2017-02-21\ncategories: work\ntag: 设计模式\n---\n\n \n\n\n#### 写在前面的关键点 ####\n\n我们知道，单例模式的特点：\n\n- 只有一个实例\n- 占用内存及资源较少，可防止对象不停的创建和销毁\n- 全局访问\n- 扩展性差\n- 与单一职责原则有冲突\n\n根据其特点，我们去看源码或者设计应用就可以做到有据可循了。\n\n#### Android系统源码中 ####\n\n##### 示例一【饿汉单例】：android.text.Editable.Factory.java #####\n\t\n\t   /**\n\t     * Factory used by TextView to create new Editables.  You can subclass\n\t     * it to provide something other than SpannableStringBuilder.\n\t     */\n\t    public static class Factory {\n\t        private static Editable.Factory sInstance = new Editable.Factory();\n\t      \n\t        public static Editable.Factory getInstance() {\n\t            return sInstance;\n\t        }\n\n\t        public Editable newEditable(CharSequence source) {\n\t            return new SpannableStringBuilder(source);\n\t        }\n\t    }\n\n> Editable 即 `android.widget.EditText#getText()` 返回的对象。最常用的大概是`et.getText().toString()`吧。\n\n然后从EditText-> TextView可以看到：\n\n    private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\n    private Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n\n然后考察其应用：\n\n\t private InputFilter[] mFilters = NO_FILTERS;\n\t private void setText(CharSequence text, BufferType type,\n\t                         boolean notifyBefore, int oldlen) {\n\t\t.\n\t\t.\n\t\t.\n\n\t\tEditable t = mEditableFactory.newEditable(text);\n        text = t;\n        setFilters(t, mFilters);\n\n\t\t.\n\t\t.\n\t\t.\n\t}\n\n得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。\n\n\n##### 示例二【懒汉单例】：ArrowKeyMovementMethod.java #####\n\n\tprivate static ArrowKeyMovementMethod sInstance;\t\n    public static MovementMethod getInstance() {\n        if (sInstance == null) {\n            sInstance = new ArrowKeyMovementMethod();\n        }\n\n        return sInstance;\n    }\n\n>看类名好像是光标移动相关的东东，跟进去看一下好了。<br/>\n>`initialize`初始化，把光标放在末尾位置；<br/>\n>`onTouchEvent`处理触摸拖拽事件；<br/>\n>`canSelectArbitrarily` 根据名字，是否可以任意选择，固定返回true；<br/>\n>`onTakeFocus` 获取焦点后的默认操作：光标放末尾\n\n\n\n\n##### 示例三【线程同步锁单例】：LocalBroadcastManager.java #####\n\n\n\tprivate static final Object mLock = new Object();\n    private static LocalBroadcastManager mInstance;\n\n    public static LocalBroadcastManager getInstance(Context context) {\n        synchronized (mLock) {\n            if (mInstance == null) {\n                mInstance = new LocalBroadcastManager(context.getApplicationContext());\n            }\n            return mInstance;\n        }\n    }\n\n>看类名是本地广播管理类，先看其类注释：<br/>\n\n>\n Helper to register for and send broadcasts of Intents to local objects\n within your process.  This has a number of advantages over sending\n global broadcasts with {@link android.content.Context#sendBroadcast}<br/>\n进程内帮助注册和发送广播给本地对象。相比于```Context#sendBroadcast```有巨大优势！<br/>\n\n优势有三：<br/>\n1. 应用内发送，不必担心私有数据泄露；<br/>\n2. 别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br/>\n3. 比通过系统发送广播更加有效。\n\n##### 示例四【线程同步锁单例】：InputMethodManager.java #####\n\n\tstatic InputMethodManager sInstance;\n\tpublic static InputMethodManager getInstance() {\n\t        synchronized (InputMethodManager.class) {\n\t            if (sInstance == null) {\n\t                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n\t                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n\t                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n\t            }\n\t            return sInstance;\n\t        }\n\t    }\n\n>用来控制显示和隐藏输入法面板。\n>\n##### 示例五【容器单例】：FocusFinder.java #####\n    \nFocusFinder.java\n\n\t    private static final ThreadLocal<FocusFinder> tlFocusFinder =\n            new ThreadLocal<FocusFinder>() {\n                @Override\n                protected FocusFinder initialValue() {\n                    return new FocusFinder();\n                }\n            };\n\n\t\tpublic static FocusFinder getInstance() {\n\t        return tlFocusFinder.get();\n\t    }\n\nThreadLocal.java\n\t\n\t    /**\n\t     * Returns the value in the current thread's copy of this\n\t     * thread-local variable.  If the variable has no value for the\n\t     * current thread, it is first initialized to the value returned\n\t     * by an invocation of the {@link #initialValue} method.\n\t     *\n\t     * @return the current thread's value of this thread-local\n\t     */\n\t    public T get() {\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null) {\n\t            ThreadLocalMap.Entry e = map.getEntry(this);\n\t            if (e != null)\n\t                return (T)e.value;\n\t        }\n\t        return setInitialValue();\n\t    }\n\t\n-\n\t\n\t    /**\n\t     * Variant of set() to establish initialValue. Used instead\n\t     * of set() in case user has overridden the set() method.\n\t     *\n\t     * @return the initial value\n\t     */\n\t    private T setInitialValue() {\n\t        T value = initialValue();\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null)\n\t            map.set(this, value);\n\t        else\n\t            createMap(t, value);\n\t        return value;\n\t    }\n\t\n\t    protected T initialValue() {\n\t        return null;\n\t    }\n\n> 一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：\n\n\n    private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n        View next = null;\n        if (focused != null) {\n            next = findNextUserSpecifiedFocus(root, focused, direction);\n        }\n        if (next != null) {\n            return next;\n        }\n        ArrayList<View> focusables = mTempList;\n        try {\n            focusables.clear();\n            root.addFocusables(focusables, direction);\n            if (!focusables.isEmpty()) {\n                next = findNextFocus(root, focused, focusedRect, direction, focusables);\n            }\n        } finally {\n            focusables.clear();\n        }\n        return next;\n    }\n\n##### 示例六【容器单例】：android.app.SystemServiceRegistry.java #####\n\n>\n该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。\n\n[源码地址](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java)。\n\n[服务说明在此](http://xusx1024.com/2017/02/22/android-system-service/)。\n\n##### 示例七【别样的单例】：BidiFormatter.java #####\n\n实例\n\t\n\t\tprivate static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n\t            false /* LTR context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\t\n\t    private static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n\t            true /* RTL context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\n构造\n\n\t   private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n\t        mIsRtlContext = isRtlContext;\n\t        mFlags = flags;\n\t        mDefaultTextDirectionHeuristic = heuristic;\n\t    }\n\n获取实例：\n\n    public static BidiFormatter getInstance() {\n        return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n    }\n \n    public static BidiFormatter getInstance(boolean rtlContext) {\n        return getDefaultInstanceFromContext(rtlContext);\n    }\n \n    public static BidiFormatter getInstance(Locale locale) {\n        return getDefaultInstanceFromContext(isRtlLocale(locale));\n    }\n\n>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br/>\n>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br/>\n>如果要开启，在Manifest.xml中，修改Application结点的属性`android:supportsRtl`为true<br/>\n>另外，我们在xml布局时，经常看到提示：使用`android:layout_marginStart`替代`android:layout_marginLeft`这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。\n\n注1：\n> 其中volatial修饰的实例没有找到，Enum实现的单例也没找到。\n\n\n\n注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：\n\n![Android 源码中常见单例 图一](/images/android-singleton-1.png)\n\n![Android 源码中常见单例 图二](/images/android-singleton-2.png)\n\n\n#### Android App开发中 ####\n\n分析上半部可得：\n\n- 内部类单例-饿汉式\n- 简单单例-懒汉式\n- 多线程调用-带线程锁的懒汉式\n- 多种单例-容器管理单例\n\n我负责的app中，整理了一下，大概有如下会需要到单例：\n1. Application\n2. 定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类\n3. 升级管理\n\n","slug":"design-patterns-singleton-5","published":1,"updated":"2017-06-01T07:37:10.884Z","comments":1,"photos":[],"link":"","_id":"cj3tijdix001ih8ivn4ofpl00","content":"<h4 id=\"写在前面的关键点\"><a href=\"#写在前面的关键点\" class=\"headerlink\" title=\"写在前面的关键点\"></a>写在前面的关键点</h4><p>我们知道，单例模式的特点：</p>\n<ul>\n<li>只有一个实例</li>\n<li>占用内存及资源较少，可防止对象不停的创建和销毁</li>\n<li>全局访问</li>\n<li>扩展性差</li>\n<li>与单一职责原则有冲突</li>\n</ul>\n<p>根据其特点，我们去看源码或者设计应用就可以做到有据可循了。</p>\n<h4 id=\"Android系统源码中\"><a href=\"#Android系统源码中\" class=\"headerlink\" title=\"Android系统源码中\"></a>Android系统源码中</h4><h5 id=\"示例一【饿汉单例】：android-text-Editable-Factory-java\"><a href=\"#示例一【饿汉单例】：android-text-Editable-Factory-java\" class=\"headerlink\" title=\"示例一【饿汉单例】：android.text.Editable.Factory.java\"></a>示例一【饿汉单例】：android.text.Editable.Factory.java</h5><pre><code>/**\n  * Factory used by TextView to create new Editables.  You can subclass\n  * it to provide something other than SpannableStringBuilder.\n  */\n public static class Factory {\n     private static Editable.Factory sInstance = new Editable.Factory();\n\n     public static Editable.Factory getInstance() {\n         return sInstance;\n     }\n\n     public Editable newEditable(CharSequence source) {\n         return new SpannableStringBuilder(source);\n     }\n }\n</code></pre><blockquote>\n<p>Editable 即 <code>android.widget.EditText#getText()</code> 返回的对象。最常用的大概是<code>et.getText().toString()</code>吧。</p>\n</blockquote>\n<p>然后从EditText-&gt; TextView可以看到：</p>\n<pre><code>private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\nprivate Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n</code></pre><p>然后考察其应用：</p>\n<pre><code> private InputFilter[] mFilters = NO_FILTERS;\n private void setText(CharSequence text, BufferType type,\n                         boolean notifyBefore, int oldlen) {\n    .\n    .\n    .\n\n    Editable t = mEditableFactory.newEditable(text);\n    text = t;\n    setFilters(t, mFilters);\n\n    .\n    .\n    .\n}\n</code></pre><p>得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。</p>\n<h5 id=\"示例二【懒汉单例】：ArrowKeyMovementMethod-java\"><a href=\"#示例二【懒汉单例】：ArrowKeyMovementMethod-java\" class=\"headerlink\" title=\"示例二【懒汉单例】：ArrowKeyMovementMethod.java\"></a>示例二【懒汉单例】：ArrowKeyMovementMethod.java</h5><pre><code>private static ArrowKeyMovementMethod sInstance;    \npublic static MovementMethod getInstance() {\n    if (sInstance == null) {\n        sInstance = new ArrowKeyMovementMethod();\n    }\n\n    return sInstance;\n}\n</code></pre><blockquote>\n<p>看类名好像是光标移动相关的东东，跟进去看一下好了。<br><br><code>initialize</code>初始化，把光标放在末尾位置；<br><br><code>onTouchEvent</code>处理触摸拖拽事件；<br><br><code>canSelectArbitrarily</code> 根据名字，是否可以任意选择，固定返回true；<br><br><code>onTakeFocus</code> 获取焦点后的默认操作：光标放末尾</p>\n</blockquote>\n<h5 id=\"示例三【线程同步锁单例】：LocalBroadcastManager-java\"><a href=\"#示例三【线程同步锁单例】：LocalBroadcastManager-java\" class=\"headerlink\" title=\"示例三【线程同步锁单例】：LocalBroadcastManager.java\"></a>示例三【线程同步锁单例】：LocalBroadcastManager.java</h5><pre><code>private static final Object mLock = new Object();\nprivate static LocalBroadcastManager mInstance;\n\npublic static LocalBroadcastManager getInstance(Context context) {\n    synchronized (mLock) {\n        if (mInstance == null) {\n            mInstance = new LocalBroadcastManager(context.getApplicationContext());\n        }\n        return mInstance;\n    }\n}\n</code></pre><blockquote>\n<p>看类名是本地广播管理类，先看其类注释：<br></p>\n</blockquote>\n<p>&gt;<br> Helper to register for and send broadcasts of Intents to local objects<br> within your process.  This has a number of advantages over sending<br> global broadcasts with {@link android.content.Context#sendBroadcast}<br><br>进程内帮助注册和发送广播给本地对象。相比于<code>Context#sendBroadcast</code>有巨大优势！<br></p>\n<p>优势有三：<br></p>\n<ol>\n<li>应用内发送，不必担心私有数据泄露；<br></li>\n<li>别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br></li>\n<li>比通过系统发送广播更加有效。</li>\n</ol>\n<h5 id=\"示例四【线程同步锁单例】：InputMethodManager-java\"><a href=\"#示例四【线程同步锁单例】：InputMethodManager-java\" class=\"headerlink\" title=\"示例四【线程同步锁单例】：InputMethodManager.java\"></a>示例四【线程同步锁单例】：InputMethodManager.java</h5><pre><code>static InputMethodManager sInstance;\npublic static InputMethodManager getInstance() {\n        synchronized (InputMethodManager.class) {\n            if (sInstance == null) {\n                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n            }\n            return sInstance;\n        }\n    }\n</code></pre><blockquote>\n<p>用来控制显示和隐藏输入法面板。</p>\n<h5 id=\"示例五【容器单例】：FocusFinder-java\"><a href=\"#示例五【容器单例】：FocusFinder-java\" class=\"headerlink\" title=\"示例五【容器单例】：FocusFinder.java\"></a>示例五【容器单例】：FocusFinder.java</h5></blockquote>\n<p>FocusFinder.java</p>\n<pre><code>private static final ThreadLocal&lt;FocusFinder&gt; tlFocusFinder =\n    new ThreadLocal&lt;FocusFinder&gt;() {\n        @Override\n        protected FocusFinder initialValue() {\n            return new FocusFinder();\n        }\n    };\n\npublic static FocusFinder getInstance() {\n    return tlFocusFinder.get();\n}\n</code></pre><p>ThreadLocal.java</p>\n<pre><code>/**\n * Returns the value in the current thread&apos;s copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread&apos;s value of this thread-local\n */\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>-</p>\n<pre><code>/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n</code></pre><blockquote>\n<p>一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：</p>\n</blockquote>\n<pre><code>private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n    View next = null;\n    if (focused != null) {\n        next = findNextUserSpecifiedFocus(root, focused, direction);\n    }\n    if (next != null) {\n        return next;\n    }\n    ArrayList&lt;View&gt; focusables = mTempList;\n    try {\n        focusables.clear();\n        root.addFocusables(focusables, direction);\n        if (!focusables.isEmpty()) {\n            next = findNextFocus(root, focused, focusedRect, direction, focusables);\n        }\n    } finally {\n        focusables.clear();\n    }\n    return next;\n}\n</code></pre><h5 id=\"示例六【容器单例】：android-app-SystemServiceRegistry-java\"><a href=\"#示例六【容器单例】：android-app-SystemServiceRegistry-java\" class=\"headerlink\" title=\"示例六【容器单例】：android.app.SystemServiceRegistry.java\"></a>示例六【容器单例】：android.app.SystemServiceRegistry.java</h5><p>&gt;<br>该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。</p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java\" target=\"_blank\" rel=\"external\">源码地址</a>。</p>\n<p><a href=\"http://xusx1024.com/2017/02/22/android-system-service/\" target=\"_blank\" rel=\"external\">服务说明在此</a>。</p>\n<h5 id=\"示例七【别样的单例】：BidiFormatter-java\"><a href=\"#示例七【别样的单例】：BidiFormatter-java\" class=\"headerlink\" title=\"示例七【别样的单例】：BidiFormatter.java\"></a>示例七【别样的单例】：BidiFormatter.java</h5><p>实例</p>\n<pre><code>private static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n        false /* LTR context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\nprivate static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n        true /* RTL context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n</code></pre><p>构造</p>\n<pre><code>private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n     mIsRtlContext = isRtlContext;\n     mFlags = flags;\n     mDefaultTextDirectionHeuristic = heuristic;\n }\n</code></pre><p>获取实例：</p>\n<pre><code>public static BidiFormatter getInstance() {\n    return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n}\n\npublic static BidiFormatter getInstance(boolean rtlContext) {\n    return getDefaultInstanceFromContext(rtlContext);\n}\n\npublic static BidiFormatter getInstance(Locale locale) {\n    return getDefaultInstanceFromContext(isRtlLocale(locale));\n}\n</code></pre><blockquote>\n<p>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br><br>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br><br>如果要开启，在Manifest.xml中，修改Application结点的属性<code>android:supportsRtl</code>为true<br><br>另外，我们在xml布局时，经常看到提示：使用<code>android:layout_marginStart</code>替代<code>android:layout_marginLeft</code>这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。</p>\n</blockquote>\n<p>注1：</p>\n<blockquote>\n<p>其中volatial修饰的实例没有找到，Enum实现的单例也没找到。</p>\n</blockquote>\n<p>注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：</p>\n<p><img src=\"/images/android-singleton-1.png\" alt=\"Android 源码中常见单例 图一\"></p>\n<p><img src=\"/images/android-singleton-2.png\" alt=\"Android 源码中常见单例 图二\"></p>\n<h4 id=\"Android-App开发中\"><a href=\"#Android-App开发中\" class=\"headerlink\" title=\"Android App开发中\"></a>Android App开发中</h4><p>分析上半部可得：</p>\n<ul>\n<li>内部类单例-饿汉式</li>\n<li>简单单例-懒汉式</li>\n<li>多线程调用-带线程锁的懒汉式</li>\n<li>多种单例-容器管理单例</li>\n</ul>\n<p>我负责的app中，整理了一下，大概有如下会需要到单例：</p>\n<ol>\n<li>Application</li>\n<li>定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类</li>\n<li>升级管理</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"写在前面的关键点\"><a href=\"#写在前面的关键点\" class=\"headerlink\" title=\"写在前面的关键点\"></a>写在前面的关键点</h4><p>我们知道，单例模式的特点：</p>\n<ul>\n<li>只有一个实例</li>\n<li>占用内存及资源较少，可防止对象不停的创建和销毁</li>\n<li>全局访问</li>\n<li>扩展性差</li>\n<li>与单一职责原则有冲突</li>\n</ul>\n<p>根据其特点，我们去看源码或者设计应用就可以做到有据可循了。</p>\n<h4 id=\"Android系统源码中\"><a href=\"#Android系统源码中\" class=\"headerlink\" title=\"Android系统源码中\"></a>Android系统源码中</h4><h5 id=\"示例一【饿汉单例】：android-text-Editable-Factory-java\"><a href=\"#示例一【饿汉单例】：android-text-Editable-Factory-java\" class=\"headerlink\" title=\"示例一【饿汉单例】：android.text.Editable.Factory.java\"></a>示例一【饿汉单例】：android.text.Editable.Factory.java</h5><pre><code>/**\n  * Factory used by TextView to create new Editables.  You can subclass\n  * it to provide something other than SpannableStringBuilder.\n  */\n public static class Factory {\n     private static Editable.Factory sInstance = new Editable.Factory();\n\n     public static Editable.Factory getInstance() {\n         return sInstance;\n     }\n\n     public Editable newEditable(CharSequence source) {\n         return new SpannableStringBuilder(source);\n     }\n }\n</code></pre><blockquote>\n<p>Editable 即 <code>android.widget.EditText#getText()</code> 返回的对象。最常用的大概是<code>et.getText().toString()</code>吧。</p>\n</blockquote>\n<p>然后从EditText-&gt; TextView可以看到：</p>\n<pre><code>private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\nprivate Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n</code></pre><p>然后考察其应用：</p>\n<pre><code> private InputFilter[] mFilters = NO_FILTERS;\n private void setText(CharSequence text, BufferType type,\n                         boolean notifyBefore, int oldlen) {\n    .\n    .\n    .\n\n    Editable t = mEditableFactory.newEditable(text);\n    text = t;\n    setFilters(t, mFilters);\n\n    .\n    .\n    .\n}\n</code></pre><p>得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。</p>\n<h5 id=\"示例二【懒汉单例】：ArrowKeyMovementMethod-java\"><a href=\"#示例二【懒汉单例】：ArrowKeyMovementMethod-java\" class=\"headerlink\" title=\"示例二【懒汉单例】：ArrowKeyMovementMethod.java\"></a>示例二【懒汉单例】：ArrowKeyMovementMethod.java</h5><pre><code>private static ArrowKeyMovementMethod sInstance;    \npublic static MovementMethod getInstance() {\n    if (sInstance == null) {\n        sInstance = new ArrowKeyMovementMethod();\n    }\n\n    return sInstance;\n}\n</code></pre><blockquote>\n<p>看类名好像是光标移动相关的东东，跟进去看一下好了。<br><br><code>initialize</code>初始化，把光标放在末尾位置；<br><br><code>onTouchEvent</code>处理触摸拖拽事件；<br><br><code>canSelectArbitrarily</code> 根据名字，是否可以任意选择，固定返回true；<br><br><code>onTakeFocus</code> 获取焦点后的默认操作：光标放末尾</p>\n</blockquote>\n<h5 id=\"示例三【线程同步锁单例】：LocalBroadcastManager-java\"><a href=\"#示例三【线程同步锁单例】：LocalBroadcastManager-java\" class=\"headerlink\" title=\"示例三【线程同步锁单例】：LocalBroadcastManager.java\"></a>示例三【线程同步锁单例】：LocalBroadcastManager.java</h5><pre><code>private static final Object mLock = new Object();\nprivate static LocalBroadcastManager mInstance;\n\npublic static LocalBroadcastManager getInstance(Context context) {\n    synchronized (mLock) {\n        if (mInstance == null) {\n            mInstance = new LocalBroadcastManager(context.getApplicationContext());\n        }\n        return mInstance;\n    }\n}\n</code></pre><blockquote>\n<p>看类名是本地广播管理类，先看其类注释：<br></p>\n</blockquote>\n<p>&gt;<br> Helper to register for and send broadcasts of Intents to local objects<br> within your process.  This has a number of advantages over sending<br> global broadcasts with {@link android.content.Context#sendBroadcast}<br><br>进程内帮助注册和发送广播给本地对象。相比于<code>Context#sendBroadcast</code>有巨大优势！<br></p>\n<p>优势有三：<br></p>\n<ol>\n<li>应用内发送，不必担心私有数据泄露；<br></li>\n<li>别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br></li>\n<li>比通过系统发送广播更加有效。</li>\n</ol>\n<h5 id=\"示例四【线程同步锁单例】：InputMethodManager-java\"><a href=\"#示例四【线程同步锁单例】：InputMethodManager-java\" class=\"headerlink\" title=\"示例四【线程同步锁单例】：InputMethodManager.java\"></a>示例四【线程同步锁单例】：InputMethodManager.java</h5><pre><code>static InputMethodManager sInstance;\npublic static InputMethodManager getInstance() {\n        synchronized (InputMethodManager.class) {\n            if (sInstance == null) {\n                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n            }\n            return sInstance;\n        }\n    }\n</code></pre><blockquote>\n<p>用来控制显示和隐藏输入法面板。</p>\n<h5 id=\"示例五【容器单例】：FocusFinder-java\"><a href=\"#示例五【容器单例】：FocusFinder-java\" class=\"headerlink\" title=\"示例五【容器单例】：FocusFinder.java\"></a>示例五【容器单例】：FocusFinder.java</h5></blockquote>\n<p>FocusFinder.java</p>\n<pre><code>private static final ThreadLocal&lt;FocusFinder&gt; tlFocusFinder =\n    new ThreadLocal&lt;FocusFinder&gt;() {\n        @Override\n        protected FocusFinder initialValue() {\n            return new FocusFinder();\n        }\n    };\n\npublic static FocusFinder getInstance() {\n    return tlFocusFinder.get();\n}\n</code></pre><p>ThreadLocal.java</p>\n<pre><code>/**\n * Returns the value in the current thread&apos;s copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread&apos;s value of this thread-local\n */\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>-</p>\n<pre><code>/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n</code></pre><blockquote>\n<p>一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：</p>\n</blockquote>\n<pre><code>private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n    View next = null;\n    if (focused != null) {\n        next = findNextUserSpecifiedFocus(root, focused, direction);\n    }\n    if (next != null) {\n        return next;\n    }\n    ArrayList&lt;View&gt; focusables = mTempList;\n    try {\n        focusables.clear();\n        root.addFocusables(focusables, direction);\n        if (!focusables.isEmpty()) {\n            next = findNextFocus(root, focused, focusedRect, direction, focusables);\n        }\n    } finally {\n        focusables.clear();\n    }\n    return next;\n}\n</code></pre><h5 id=\"示例六【容器单例】：android-app-SystemServiceRegistry-java\"><a href=\"#示例六【容器单例】：android-app-SystemServiceRegistry-java\" class=\"headerlink\" title=\"示例六【容器单例】：android.app.SystemServiceRegistry.java\"></a>示例六【容器单例】：android.app.SystemServiceRegistry.java</h5><p>&gt;<br>该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。</p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java\" target=\"_blank\" rel=\"external\">源码地址</a>。</p>\n<p><a href=\"http://xusx1024.com/2017/02/22/android-system-service/\" target=\"_blank\" rel=\"external\">服务说明在此</a>。</p>\n<h5 id=\"示例七【别样的单例】：BidiFormatter-java\"><a href=\"#示例七【别样的单例】：BidiFormatter-java\" class=\"headerlink\" title=\"示例七【别样的单例】：BidiFormatter.java\"></a>示例七【别样的单例】：BidiFormatter.java</h5><p>实例</p>\n<pre><code>private static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n        false /* LTR context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\nprivate static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n        true /* RTL context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n</code></pre><p>构造</p>\n<pre><code>private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n     mIsRtlContext = isRtlContext;\n     mFlags = flags;\n     mDefaultTextDirectionHeuristic = heuristic;\n }\n</code></pre><p>获取实例：</p>\n<pre><code>public static BidiFormatter getInstance() {\n    return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n}\n\npublic static BidiFormatter getInstance(boolean rtlContext) {\n    return getDefaultInstanceFromContext(rtlContext);\n}\n\npublic static BidiFormatter getInstance(Locale locale) {\n    return getDefaultInstanceFromContext(isRtlLocale(locale));\n}\n</code></pre><blockquote>\n<p>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br><br>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br><br>如果要开启，在Manifest.xml中，修改Application结点的属性<code>android:supportsRtl</code>为true<br><br>另外，我们在xml布局时，经常看到提示：使用<code>android:layout_marginStart</code>替代<code>android:layout_marginLeft</code>这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。</p>\n</blockquote>\n<p>注1：</p>\n<blockquote>\n<p>其中volatial修饰的实例没有找到，Enum实现的单例也没找到。</p>\n</blockquote>\n<p>注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：</p>\n<p><img src=\"/images/android-singleton-1.png\" alt=\"Android 源码中常见单例 图一\"></p>\n<p><img src=\"/images/android-singleton-2.png\" alt=\"Android 源码中常见单例 图二\"></p>\n<h4 id=\"Android-App开发中\"><a href=\"#Android-App开发中\" class=\"headerlink\" title=\"Android App开发中\"></a>Android App开发中</h4><p>分析上半部可得：</p>\n<ul>\n<li>内部类单例-饿汉式</li>\n<li>简单单例-懒汉式</li>\n<li>多线程调用-带线程锁的懒汉式</li>\n<li>多种单例-容器管理单例</li>\n</ul>\n<p>我负责的app中，整理了一下，大概有如下会需要到单例：</p>\n<ol>\n<li>Application</li>\n<li>定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类</li>\n<li>升级管理</li>\n</ol>\n"},{"layout":"post","title":"Java并发中的关键字：volatile","date":"2017-02-23T00:00:00.000Z","_content":" \n\n \n#### 基础知识 ####\n\n第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br/>\n\n##### 为什么需要锁 #####\n\n![为什么需要锁](/images/why_need_lock.jpg)\n\n由上图，两颗CPU都在修改内存的变量，导致其计数有误。\n\n##### 锁(lock) #####\n锁是用来做并发最简单的方式，当然其代价也是最高的。`内核态的锁`的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。`用户态的锁`避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br/>\n\nJDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用`独占的方式`来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。\n\n###### 悲观锁 ######\n\n独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。\n\n###### 乐观锁 ######\n\n比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。\nCAS乐观锁算法如图：\nCAS比较与交换的伪代码可以表示为：\n\n\tdo{\n\t备份旧数据\n\t基于旧数据构造新数据\n\t}while(!CAS(内存地址，备份的旧数据，新数据))\n\n![CAS乐观锁](/images/cas.png)\n\n##### 原子操作(atomic operations) #####\n\n- 所有的原始类型的赋值，long和double除外；\n- 所有引用的赋值；\n- 所有java.concurrent.Atomic*中类中的操作\n- 所有volatile修饰的long和double\n\n为什么long型赋值不是原子操作呢？\n\n事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：\n\t\n\tprivate volatile long foo;\n\n因为volatile内部已经做了synchronized.\n\n\n##### 线程与内存的交互 #####\n\n每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：\n\n![线程与内存的交互](/images/thread-read-write.jpg)\n其中use and assign 可以多次出现\n\n\n##### volatile #####\n\nvolatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br/>\nvolatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br/>\nvolatile能替代简单的锁，却不能保证原子性。<br/>\n\n##### 内存屏障-Memory Barrier #####\n\n内存屏障是一个CPU指令。\n1.  确保一些特定操作执行的顺序；\n2.  影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。\n\n<br/>\n\n如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br/>\n\n由`线程和内存交互的图`，可得：\n\n\t[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n \n可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说`volatile不能保证原子性。`这同时说明：`volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的`。\n\n#### voaltile 使用场景及模式 ####\n\t\n\t要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\t \n\tAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n\n##### 模式1：状态标志 #####\n\n也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。\n\t\n\tvolatile boolean shutdownRequested;\n\t\n\t...\n\t\n\tpublic void shutdown() { shutdownRequested = true; }\n\t\n\tpublic void doWork() { \n\t    while (!shutdownRequested) { \n\t        // do stuff\n\t    }\n\t}\n\n这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。\n\n\n##### 模式2：一次性安全发布(one time safe publication) #####\n\n缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。\n\n实现安全发布对象的一种技术就是将对象引用定义为volatile类型。\n\t\n\tpublic class BackgroundFloobleLoader {\n\t    public volatile Flooble theFlooble;\n\t    public void initInBackground() {\n\t        // do lots of stuff\n\t        theFlooble = new Flooble();  // this is the only write to theFlooble\n\t    }\n\t}\n\t\n\tpublic class SomeOtherClass {\n\t    public void doWork() {\n\t        while (true) { \n\t            // do some stuff...\n\t            // use the Flooble, but only if it is ready\n\t            if (floobleLoader.theFlooble != null) \n\t                doSomething(floobleLoader.theFlooble);\n\t        }\n\t    }\n\t}\n\n\n该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。\n\n\n##### 模式3：独立观察(independent observation) #####\n\n安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。\n\t\n\tpublic class UserManager {\n\t    public volatile String lastUser;\n\t\n\t    public boolean authenticate(String user, String password) {\n\t        boolean valid = passwordIsValid(user, password);\n\t        if (valid) {\n\t            User u = new User();\n\t            activeUsers.add(u);\n\t            lastUser = user;\n\t        }\n\t        return valid;\n\t    }\n\t}\n\n该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。\n\n##### 模式4：volatile bean 模式 #####\n\nvolatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br/>\n在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。\n\n\t@ThreadSafe\n\tpublic class Person {\n\t    private volatile String firstName;\n\t    private volatile String lastName;\n\t    private volatile int age;\n\t\n\t    public String getFirstName() { return firstName; }\n\t    public String getLastName() { return lastName; }\n\t    public int getAge() { return age; }\n\t\n\t    public void setFirstName(String firstName) { \n\t        this.firstName = firstName;\n\t    }\n\t\n\t    public void setLastName(String lastName) { \n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public void setAge(int age) { \n\t        this.age = age;\n\t    }\n\t}\n\n##### 模式5：volatile 高级模式，开销较低的读-写锁策略 #####\n\n如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。\n\n\t@ThreadSafe\n\tpublic class CheesyCounter {\n\t    // Employs the cheap read-write lock trick\n\t    // All mutative operations MUST be done with the 'this' lock held\n\t    @GuardedBy(\"this\") private volatile int value;\n\t\n\t    public int getValue() { return value; }\n\t\n\t    public synchronized int increment() {\n\t        return value++;\n\t    }\n\t}\n\n上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。\n\n\n#### voaltile 与 static ####\n\nvolatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；\n\nstatic，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。\n\n ","source":"_posts/2017-02-23-java-volatile.md","raw":"---\nlayout: post\ntitle:  Java并发中的关键字：volatile\ndate:   2017-02-23\ncategories: work\ntag: 杂项\n---\n \n\n \n#### 基础知识 ####\n\n第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br/>\n\n##### 为什么需要锁 #####\n\n![为什么需要锁](/images/why_need_lock.jpg)\n\n由上图，两颗CPU都在修改内存的变量，导致其计数有误。\n\n##### 锁(lock) #####\n锁是用来做并发最简单的方式，当然其代价也是最高的。`内核态的锁`的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。`用户态的锁`避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br/>\n\nJDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用`独占的方式`来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。\n\n###### 悲观锁 ######\n\n独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。\n\n###### 乐观锁 ######\n\n比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。\nCAS乐观锁算法如图：\nCAS比较与交换的伪代码可以表示为：\n\n\tdo{\n\t备份旧数据\n\t基于旧数据构造新数据\n\t}while(!CAS(内存地址，备份的旧数据，新数据))\n\n![CAS乐观锁](/images/cas.png)\n\n##### 原子操作(atomic operations) #####\n\n- 所有的原始类型的赋值，long和double除外；\n- 所有引用的赋值；\n- 所有java.concurrent.Atomic*中类中的操作\n- 所有volatile修饰的long和double\n\n为什么long型赋值不是原子操作呢？\n\n事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：\n\t\n\tprivate volatile long foo;\n\n因为volatile内部已经做了synchronized.\n\n\n##### 线程与内存的交互 #####\n\n每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：\n\n![线程与内存的交互](/images/thread-read-write.jpg)\n其中use and assign 可以多次出现\n\n\n##### volatile #####\n\nvolatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br/>\nvolatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br/>\nvolatile能替代简单的锁，却不能保证原子性。<br/>\n\n##### 内存屏障-Memory Barrier #####\n\n内存屏障是一个CPU指令。\n1.  确保一些特定操作执行的顺序；\n2.  影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。\n\n<br/>\n\n如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br/>\n\n由`线程和内存交互的图`，可得：\n\n\t[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n \n可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说`volatile不能保证原子性。`这同时说明：`volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的`。\n\n#### voaltile 使用场景及模式 ####\n\t\n\t要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\t \n\tAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n\n##### 模式1：状态标志 #####\n\n也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。\n\t\n\tvolatile boolean shutdownRequested;\n\t\n\t...\n\t\n\tpublic void shutdown() { shutdownRequested = true; }\n\t\n\tpublic void doWork() { \n\t    while (!shutdownRequested) { \n\t        // do stuff\n\t    }\n\t}\n\n这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。\n\n\n##### 模式2：一次性安全发布(one time safe publication) #####\n\n缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。\n\n实现安全发布对象的一种技术就是将对象引用定义为volatile类型。\n\t\n\tpublic class BackgroundFloobleLoader {\n\t    public volatile Flooble theFlooble;\n\t    public void initInBackground() {\n\t        // do lots of stuff\n\t        theFlooble = new Flooble();  // this is the only write to theFlooble\n\t    }\n\t}\n\t\n\tpublic class SomeOtherClass {\n\t    public void doWork() {\n\t        while (true) { \n\t            // do some stuff...\n\t            // use the Flooble, but only if it is ready\n\t            if (floobleLoader.theFlooble != null) \n\t                doSomething(floobleLoader.theFlooble);\n\t        }\n\t    }\n\t}\n\n\n该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。\n\n\n##### 模式3：独立观察(independent observation) #####\n\n安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。\n\t\n\tpublic class UserManager {\n\t    public volatile String lastUser;\n\t\n\t    public boolean authenticate(String user, String password) {\n\t        boolean valid = passwordIsValid(user, password);\n\t        if (valid) {\n\t            User u = new User();\n\t            activeUsers.add(u);\n\t            lastUser = user;\n\t        }\n\t        return valid;\n\t    }\n\t}\n\n该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。\n\n##### 模式4：volatile bean 模式 #####\n\nvolatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br/>\n在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。\n\n\t@ThreadSafe\n\tpublic class Person {\n\t    private volatile String firstName;\n\t    private volatile String lastName;\n\t    private volatile int age;\n\t\n\t    public String getFirstName() { return firstName; }\n\t    public String getLastName() { return lastName; }\n\t    public int getAge() { return age; }\n\t\n\t    public void setFirstName(String firstName) { \n\t        this.firstName = firstName;\n\t    }\n\t\n\t    public void setLastName(String lastName) { \n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public void setAge(int age) { \n\t        this.age = age;\n\t    }\n\t}\n\n##### 模式5：volatile 高级模式，开销较低的读-写锁策略 #####\n\n如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。\n\n\t@ThreadSafe\n\tpublic class CheesyCounter {\n\t    // Employs the cheap read-write lock trick\n\t    // All mutative operations MUST be done with the 'this' lock held\n\t    @GuardedBy(\"this\") private volatile int value;\n\t\n\t    public int getValue() { return value; }\n\t\n\t    public synchronized int increment() {\n\t        return value++;\n\t    }\n\t}\n\n上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。\n\n\n#### voaltile 与 static ####\n\nvolatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；\n\nstatic，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。\n\n ","slug":"java-volatile","published":1,"updated":"2017-06-01T07:32:27.884Z","comments":1,"photos":[],"link":"","_id":"cj3tijdj1001mh8ivr35ghav1","content":"<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br></p>\n<h5 id=\"为什么需要锁\"><a href=\"#为什么需要锁\" class=\"headerlink\" title=\"为什么需要锁\"></a>为什么需要锁</h5><p><img src=\"/images/why_need_lock.jpg\" alt=\"为什么需要锁\"></p>\n<p>由上图，两颗CPU都在修改内存的变量，导致其计数有误。</p>\n<h5 id=\"锁-lock\"><a href=\"#锁-lock\" class=\"headerlink\" title=\"锁(lock)\"></a>锁(lock)</h5><p>锁是用来做并发最简单的方式，当然其代价也是最高的。<code>内核态的锁</code>的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。<code>用户态的锁</code>避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br></p>\n<p>JDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用<code>独占的方式</code>来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。</p>\n<h6 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h6><p>独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p>\n<h6 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h6><p>比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。<br>CAS乐观锁算法如图：<br>CAS比较与交换的伪代码可以表示为：</p>\n<pre><code>do{\n备份旧数据\n基于旧数据构造新数据\n}while(!CAS(内存地址，备份的旧数据，新数据))\n</code></pre><p><img src=\"/images/cas.png\" alt=\"CAS乐观锁\"></p>\n<h5 id=\"原子操作-atomic-operations\"><a href=\"#原子操作-atomic-operations\" class=\"headerlink\" title=\"原子操作(atomic operations)\"></a>原子操作(atomic operations)</h5><ul>\n<li>所有的原始类型的赋值，long和double除外；</li>\n<li>所有引用的赋值；</li>\n<li>所有java.concurrent.Atomic*中类中的操作</li>\n<li>所有volatile修饰的long和double</li>\n</ul>\n<p>为什么long型赋值不是原子操作呢？</p>\n<p>事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：</p>\n<pre><code>private volatile long foo;\n</code></pre><p>因为volatile内部已经做了synchronized.</p>\n<h5 id=\"线程与内存的交互\"><a href=\"#线程与内存的交互\" class=\"headerlink\" title=\"线程与内存的交互\"></a>线程与内存的交互</h5><p>每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：</p>\n<p><img src=\"/images/thread-read-write.jpg\" alt=\"线程与内存的交互\"><br>其中use and assign 可以多次出现</p>\n<h5 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h5><p>volatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br><br>volatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br><br>volatile能替代简单的锁，却不能保证原子性。<br></p>\n<h5 id=\"内存屏障-Memory-Barrier\"><a href=\"#内存屏障-Memory-Barrier\" class=\"headerlink\" title=\"内存屏障-Memory Barrier\"></a>内存屏障-Memory Barrier</h5><p>内存屏障是一个CPU指令。</p>\n<ol>\n<li>确保一些特定操作执行的顺序；</li>\n<li>影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。</li>\n</ol>\n<p><br></p>\n<p>如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br></p>\n<p>由<code>线程和内存交互的图</code>，可得：</p>\n<pre><code>[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n</code></pre><p>可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说<code>volatile不能保证原子性。</code>这同时说明：<code>volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的</code>。</p>\n<h4 id=\"voaltile-使用场景及模式\"><a href=\"#voaltile-使用场景及模式\" class=\"headerlink\" title=\"voaltile 使用场景及模式\"></a>voaltile 使用场景及模式</h4><pre><code>要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\nAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n</code></pre><h5 id=\"模式1：状态标志\"><a href=\"#模式1：状态标志\" class=\"headerlink\" title=\"模式1：状态标志\"></a>模式1：状态标志</h5><p>也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。</p>\n<pre><code>volatile boolean shutdownRequested;\n\n...\n\npublic void shutdown() { shutdownRequested = true; }\n\npublic void doWork() { \n    while (!shutdownRequested) { \n        // do stuff\n    }\n}\n</code></pre><p>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。</p>\n<h5 id=\"模式2：一次性安全发布-one-time-safe-publication\"><a href=\"#模式2：一次性安全发布-one-time-safe-publication\" class=\"headerlink\" title=\"模式2：一次性安全发布(one time safe publication)\"></a>模式2：一次性安全发布(one time safe publication)</h5><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。</p>\n<p>实现安全发布对象的一种技术就是将对象引用定义为volatile类型。</p>\n<pre><code>public class BackgroundFloobleLoader {\n    public volatile Flooble theFlooble;\n    public void initInBackground() {\n        // do lots of stuff\n        theFlooble = new Flooble();  // this is the only write to theFlooble\n    }\n}\n\npublic class SomeOtherClass {\n    public void doWork() {\n        while (true) { \n            // do some stuff...\n            // use the Flooble, but only if it is ready\n            if (floobleLoader.theFlooble != null) \n                doSomething(floobleLoader.theFlooble);\n        }\n    }\n}\n</code></pre><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>\n<h5 id=\"模式3：独立观察-independent-observation\"><a href=\"#模式3：独立观察-independent-observation\" class=\"headerlink\" title=\"模式3：独立观察(independent observation)\"></a>模式3：独立观察(independent observation)</h5><p>安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>\n<pre><code>public class UserManager {\n    public volatile String lastUser;\n\n    public boolean authenticate(String user, String password) {\n        boolean valid = passwordIsValid(user, password);\n        if (valid) {\n            User u = new User();\n            activeUsers.add(u);\n            lastUser = user;\n        }\n        return valid;\n    }\n}\n</code></pre><p>该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。</p>\n<h5 id=\"模式4：volatile-bean-模式\"><a href=\"#模式4：volatile-bean-模式\" class=\"headerlink\" title=\"模式4：volatile bean 模式\"></a>模式4：volatile bean 模式</h5><p>volatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br><br>在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。</p>\n<pre><code>@ThreadSafe\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n\n    public void setFirstName(String firstName) { \n        this.firstName = firstName;\n    }\n\n    public void setLastName(String lastName) { \n        this.lastName = lastName;\n    }\n\n    public void setAge(int age) { \n        this.age = age;\n    }\n}\n</code></pre><h5 id=\"模式5：volatile-高级模式，开销较低的读-写锁策略\"><a href=\"#模式5：volatile-高级模式，开销较低的读-写锁策略\" class=\"headerlink\" title=\"模式5：volatile 高级模式，开销较低的读-写锁策略\"></a>模式5：volatile 高级模式，开销较低的读-写锁策略</h5><p>如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。</p>\n<pre><code>@ThreadSafe\npublic class CheesyCounter {\n    // Employs the cheap read-write lock trick\n    // All mutative operations MUST be done with the &apos;this&apos; lock held\n    @GuardedBy(&quot;this&quot;) private volatile int value;\n\n    public int getValue() { return value; }\n\n    public synchronized int increment() {\n        return value++;\n    }\n}\n</code></pre><p>上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。</p>\n<h4 id=\"voaltile-与-static\"><a href=\"#voaltile-与-static\" class=\"headerlink\" title=\"voaltile 与 static\"></a>voaltile 与 static</h4><p>volatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；</p>\n<p>static，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br></p>\n<h5 id=\"为什么需要锁\"><a href=\"#为什么需要锁\" class=\"headerlink\" title=\"为什么需要锁\"></a>为什么需要锁</h5><p><img src=\"/images/why_need_lock.jpg\" alt=\"为什么需要锁\"></p>\n<p>由上图，两颗CPU都在修改内存的变量，导致其计数有误。</p>\n<h5 id=\"锁-lock\"><a href=\"#锁-lock\" class=\"headerlink\" title=\"锁(lock)\"></a>锁(lock)</h5><p>锁是用来做并发最简单的方式，当然其代价也是最高的。<code>内核态的锁</code>的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。<code>用户态的锁</code>避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br></p>\n<p>JDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用<code>独占的方式</code>来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。</p>\n<h6 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h6><p>独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p>\n<h6 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h6><p>比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。<br>CAS乐观锁算法如图：<br>CAS比较与交换的伪代码可以表示为：</p>\n<pre><code>do{\n备份旧数据\n基于旧数据构造新数据\n}while(!CAS(内存地址，备份的旧数据，新数据))\n</code></pre><p><img src=\"/images/cas.png\" alt=\"CAS乐观锁\"></p>\n<h5 id=\"原子操作-atomic-operations\"><a href=\"#原子操作-atomic-operations\" class=\"headerlink\" title=\"原子操作(atomic operations)\"></a>原子操作(atomic operations)</h5><ul>\n<li>所有的原始类型的赋值，long和double除外；</li>\n<li>所有引用的赋值；</li>\n<li>所有java.concurrent.Atomic*中类中的操作</li>\n<li>所有volatile修饰的long和double</li>\n</ul>\n<p>为什么long型赋值不是原子操作呢？</p>\n<p>事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：</p>\n<pre><code>private volatile long foo;\n</code></pre><p>因为volatile内部已经做了synchronized.</p>\n<h5 id=\"线程与内存的交互\"><a href=\"#线程与内存的交互\" class=\"headerlink\" title=\"线程与内存的交互\"></a>线程与内存的交互</h5><p>每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：</p>\n<p><img src=\"/images/thread-read-write.jpg\" alt=\"线程与内存的交互\"><br>其中use and assign 可以多次出现</p>\n<h5 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h5><p>volatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br><br>volatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br><br>volatile能替代简单的锁，却不能保证原子性。<br></p>\n<h5 id=\"内存屏障-Memory-Barrier\"><a href=\"#内存屏障-Memory-Barrier\" class=\"headerlink\" title=\"内存屏障-Memory Barrier\"></a>内存屏障-Memory Barrier</h5><p>内存屏障是一个CPU指令。</p>\n<ol>\n<li>确保一些特定操作执行的顺序；</li>\n<li>影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。</li>\n</ol>\n<p><br></p>\n<p>如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br></p>\n<p>由<code>线程和内存交互的图</code>，可得：</p>\n<pre><code>[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n</code></pre><p>可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说<code>volatile不能保证原子性。</code>这同时说明：<code>volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的</code>。</p>\n<h4 id=\"voaltile-使用场景及模式\"><a href=\"#voaltile-使用场景及模式\" class=\"headerlink\" title=\"voaltile 使用场景及模式\"></a>voaltile 使用场景及模式</h4><pre><code>要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\nAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n</code></pre><h5 id=\"模式1：状态标志\"><a href=\"#模式1：状态标志\" class=\"headerlink\" title=\"模式1：状态标志\"></a>模式1：状态标志</h5><p>也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。</p>\n<pre><code>volatile boolean shutdownRequested;\n\n...\n\npublic void shutdown() { shutdownRequested = true; }\n\npublic void doWork() { \n    while (!shutdownRequested) { \n        // do stuff\n    }\n}\n</code></pre><p>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。</p>\n<h5 id=\"模式2：一次性安全发布-one-time-safe-publication\"><a href=\"#模式2：一次性安全发布-one-time-safe-publication\" class=\"headerlink\" title=\"模式2：一次性安全发布(one time safe publication)\"></a>模式2：一次性安全发布(one time safe publication)</h5><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。</p>\n<p>实现安全发布对象的一种技术就是将对象引用定义为volatile类型。</p>\n<pre><code>public class BackgroundFloobleLoader {\n    public volatile Flooble theFlooble;\n    public void initInBackground() {\n        // do lots of stuff\n        theFlooble = new Flooble();  // this is the only write to theFlooble\n    }\n}\n\npublic class SomeOtherClass {\n    public void doWork() {\n        while (true) { \n            // do some stuff...\n            // use the Flooble, but only if it is ready\n            if (floobleLoader.theFlooble != null) \n                doSomething(floobleLoader.theFlooble);\n        }\n    }\n}\n</code></pre><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>\n<h5 id=\"模式3：独立观察-independent-observation\"><a href=\"#模式3：独立观察-independent-observation\" class=\"headerlink\" title=\"模式3：独立观察(independent observation)\"></a>模式3：独立观察(independent observation)</h5><p>安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>\n<pre><code>public class UserManager {\n    public volatile String lastUser;\n\n    public boolean authenticate(String user, String password) {\n        boolean valid = passwordIsValid(user, password);\n        if (valid) {\n            User u = new User();\n            activeUsers.add(u);\n            lastUser = user;\n        }\n        return valid;\n    }\n}\n</code></pre><p>该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。</p>\n<h5 id=\"模式4：volatile-bean-模式\"><a href=\"#模式4：volatile-bean-模式\" class=\"headerlink\" title=\"模式4：volatile bean 模式\"></a>模式4：volatile bean 模式</h5><p>volatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br><br>在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。</p>\n<pre><code>@ThreadSafe\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n\n    public void setFirstName(String firstName) { \n        this.firstName = firstName;\n    }\n\n    public void setLastName(String lastName) { \n        this.lastName = lastName;\n    }\n\n    public void setAge(int age) { \n        this.age = age;\n    }\n}\n</code></pre><h5 id=\"模式5：volatile-高级模式，开销较低的读-写锁策略\"><a href=\"#模式5：volatile-高级模式，开销较低的读-写锁策略\" class=\"headerlink\" title=\"模式5：volatile 高级模式，开销较低的读-写锁策略\"></a>模式5：volatile 高级模式，开销较低的读-写锁策略</h5><p>如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。</p>\n<pre><code>@ThreadSafe\npublic class CheesyCounter {\n    // Employs the cheap read-write lock trick\n    // All mutative operations MUST be done with the &apos;this&apos; lock held\n    @GuardedBy(&quot;this&quot;) private volatile int value;\n\n    public int getValue() { return value; }\n\n    public synchronized int increment() {\n        return value++;\n    }\n}\n</code></pre><p>上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。</p>\n<h4 id=\"voaltile-与-static\"><a href=\"#voaltile-与-static\" class=\"headerlink\" title=\"voaltile 与 static\"></a>voaltile 与 static</h4><p>volatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；</p>\n<p>static，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。</p>\n"},{"layout":"post","title":"建造者设计模式(一) 基础知识","date":"2017-03-03T00:00:00.000Z","_content":" \n\n#### what ####\n\n一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。\n<br/>\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n#### 使用场景 ####\n\n1. 相同的方法，不同的执行顺序，产生不同的事件结果时；\n2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n3. 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n记住一句话:`遇到多个构造器参数时要考虑用构建器。`\n\n\n#### 为什么是builder模式 ####\n\n在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：\n\n1. 重叠构造器-telescoping constructor\n2. JavaBeans模式\n3. 构造器模式\n\n##### 重叠构造器 #####\n\n- 随着参数数目的增加，很难控制\n- 代码很难编写，难以阅读\n- 如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。\n\t\n\t\t\n\t\t/**\n\t\t * 重叠构造器Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class TeleScopDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tpublic TeleScopDemo(int param1) {\n\t\t\t\tthis(param1, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2) {\n\t\t\t\tthis(param1, param2, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3) {\n\t\t\t\tthis(param1, param2, param3, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4) {\n\t\t\t\tthis(param1, param2, param3, param4, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4,\n\t\t\t\t\tint param5) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t\tthis.param2 = param2;\n\t\t\t\tthis.param3 = param3;\n\t\t\t\tthis.param4 = param4;\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n##### JavaBeans #####\n\n由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 \n\t\t\n\t\t/**\n\t\t * JavaBeans模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class JavaBeansDemo {\n\t\t\n\t\t\tprivate int param1;\n\t\t\tprivate int param2;\n\t\t\tprivate int param3;\n\t\t\tprivate int param4;\n\t\t\tprivate int param5;\n\t\t\n\t\t\tpublic JavaBeansDemo() {\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam1(int param1) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam2(int param2) {\n\t\t\t\tthis.param2 = param2;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam3(int param3) {\n\t\t\t\tthis.param3 = param3;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam4(int param4) {\n\t\t\t\tthis.param4 = param4;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam5(int param5) {\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n\n\n##### Builder模式 #####\n\t\t\n既有重叠构造器的安全性，也有JavaBeans的可读性。\n \n\t\t/**\n\t\t * 构建器模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class BuilderPatternDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tprivate BuilderPatternDemo(Builder builder) {\n\t\t\t\tparam1 = builder.param1;\n\t\t\t\tparam2 = builder.param2;\n\t\t\t\tparam3 = builder.param3;\n\t\t\t\tparam4 = builder.param4;\n\t\t\t\tparam5 = builder.param5;\n\t\t\t}\n\t\t\n\t\t\tpublic static class Builder {\n\t\t\t\t// 必需的参数\n\t\t\t\tprivate final int param1;\n\t\t\n\t\t\t\t// 可选的参数，带有初始值\n\t\t\t\tprivate int param2 = 0;\n\t\t\t\tprivate int param3 = 0;\n\t\t\t\tprivate int param4 = 0;\n\t\t\t\tprivate int param5 = 0;\n\t\t\n\t\t\t\tpublic Builder(int param1) {\n\t\t\t\t\tthis.param1 = param1;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param2(int val) {\n\t\t\t\t\tparam2 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param3(int val) {\n\t\t\t\t\tparam3 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param4(int val) {\n\t\t\t\t\tparam4 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param5(int val) {\n\t\t\t\t\tparam5 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic BuilderPatternDemo build(){\n\t\t\t\t\treturn new BuilderPatternDemo(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t","source":"_posts/2017-03-03-design-patterns-builder-1.md","raw":"---\nlayout: post\ntitle:  建造者设计模式(一) 基础知识\ndate:   2017-03-03\ncategories: work\ntag: 设计模式\n---\n \n\n#### what ####\n\n一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。\n<br/>\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n#### 使用场景 ####\n\n1. 相同的方法，不同的执行顺序，产生不同的事件结果时；\n2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n3. 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n记住一句话:`遇到多个构造器参数时要考虑用构建器。`\n\n\n#### 为什么是builder模式 ####\n\n在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：\n\n1. 重叠构造器-telescoping constructor\n2. JavaBeans模式\n3. 构造器模式\n\n##### 重叠构造器 #####\n\n- 随着参数数目的增加，很难控制\n- 代码很难编写，难以阅读\n- 如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。\n\t\n\t\t\n\t\t/**\n\t\t * 重叠构造器Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class TeleScopDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tpublic TeleScopDemo(int param1) {\n\t\t\t\tthis(param1, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2) {\n\t\t\t\tthis(param1, param2, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3) {\n\t\t\t\tthis(param1, param2, param3, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4) {\n\t\t\t\tthis(param1, param2, param3, param4, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4,\n\t\t\t\t\tint param5) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t\tthis.param2 = param2;\n\t\t\t\tthis.param3 = param3;\n\t\t\t\tthis.param4 = param4;\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n##### JavaBeans #####\n\n由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 \n\t\t\n\t\t/**\n\t\t * JavaBeans模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class JavaBeansDemo {\n\t\t\n\t\t\tprivate int param1;\n\t\t\tprivate int param2;\n\t\t\tprivate int param3;\n\t\t\tprivate int param4;\n\t\t\tprivate int param5;\n\t\t\n\t\t\tpublic JavaBeansDemo() {\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam1(int param1) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam2(int param2) {\n\t\t\t\tthis.param2 = param2;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam3(int param3) {\n\t\t\t\tthis.param3 = param3;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam4(int param4) {\n\t\t\t\tthis.param4 = param4;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam5(int param5) {\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n\n\n##### Builder模式 #####\n\t\t\n既有重叠构造器的安全性，也有JavaBeans的可读性。\n \n\t\t/**\n\t\t * 构建器模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class BuilderPatternDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tprivate BuilderPatternDemo(Builder builder) {\n\t\t\t\tparam1 = builder.param1;\n\t\t\t\tparam2 = builder.param2;\n\t\t\t\tparam3 = builder.param3;\n\t\t\t\tparam4 = builder.param4;\n\t\t\t\tparam5 = builder.param5;\n\t\t\t}\n\t\t\n\t\t\tpublic static class Builder {\n\t\t\t\t// 必需的参数\n\t\t\t\tprivate final int param1;\n\t\t\n\t\t\t\t// 可选的参数，带有初始值\n\t\t\t\tprivate int param2 = 0;\n\t\t\t\tprivate int param3 = 0;\n\t\t\t\tprivate int param4 = 0;\n\t\t\t\tprivate int param5 = 0;\n\t\t\n\t\t\t\tpublic Builder(int param1) {\n\t\t\t\t\tthis.param1 = param1;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param2(int val) {\n\t\t\t\t\tparam2 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param3(int val) {\n\t\t\t\t\tparam3 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param4(int val) {\n\t\t\t\t\tparam4 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param5(int val) {\n\t\t\t\t\tparam5 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic BuilderPatternDemo build(){\n\t\t\t\t\treturn new BuilderPatternDemo(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t","slug":"design-patterns-builder-1","published":1,"updated":"2017-06-01T07:27:57.013Z","comments":1,"photos":[],"link":"","_id":"cj3tijdj4001ph8ivn67c7fp7","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。<br><br></p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li>相同的方法，不同的执行顺序，产生不同的事件结果时；</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；</li>\n<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。</li>\n</ol>\n<p>记住一句话:<code>遇到多个构造器参数时要考虑用构建器。</code></p>\n<h4 id=\"为什么是builder模式\"><a href=\"#为什么是builder模式\" class=\"headerlink\" title=\"为什么是builder模式\"></a>为什么是builder模式</h4><p>在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：</p>\n<ol>\n<li>重叠构造器-telescoping constructor</li>\n<li>JavaBeans模式</li>\n<li>构造器模式</li>\n</ol>\n<h5 id=\"重叠构造器\"><a href=\"#重叠构造器\" class=\"headerlink\" title=\"重叠构造器\"></a>重叠构造器</h5><ul>\n<li>随着参数数目的增加，很难控制</li>\n<li>代码很难编写，难以阅读</li>\n<li>如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。</li>\n</ul>\n<pre><code>/**\n * 重叠构造器Demo\n * \n * @author Administrator\n * \n */\npublic class TeleScopDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    public TeleScopDemo(int param1) {\n        this(param1, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2) {\n        this(param1, param2, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3) {\n        this(param1, param2, param3, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4) {\n        this(param1, param2, param3, param4, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4,\n            int param5) {\n        this.param1 = param1;\n        this.param2 = param2;\n        this.param3 = param3;\n        this.param4 = param4;\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"JavaBeans\"><a href=\"#JavaBeans\" class=\"headerlink\" title=\"JavaBeans\"></a>JavaBeans</h5><p>由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 </p>\n<pre><code>/**\n * JavaBeans模式Demo\n * \n * @author Administrator\n * \n */\npublic class JavaBeansDemo {\n\n    private int param1;\n    private int param2;\n    private int param3;\n    private int param4;\n    private int param5;\n\n    public JavaBeansDemo() {\n    }\n\n    public void setParam1(int param1) {\n        this.param1 = param1;\n    }\n\n    public void setParam2(int param2) {\n        this.param2 = param2;\n    }\n\n    public void setParam3(int param3) {\n        this.param3 = param3;\n    }\n\n    public void setParam4(int param4) {\n        this.param4 = param4;\n    }\n\n    public void setParam5(int param5) {\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"Builder模式\"><a href=\"#Builder模式\" class=\"headerlink\" title=\"Builder模式\"></a>Builder模式</h5><p>既有重叠构造器的安全性，也有JavaBeans的可读性。</p>\n<pre><code>/**\n * 构建器模式Demo\n * \n * @author Administrator\n * \n */\npublic class BuilderPatternDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    private BuilderPatternDemo(Builder builder) {\n        param1 = builder.param1;\n        param2 = builder.param2;\n        param3 = builder.param3;\n        param4 = builder.param4;\n        param5 = builder.param5;\n    }\n\n    public static class Builder {\n        // 必需的参数\n        private final int param1;\n\n        // 可选的参数，带有初始值\n        private int param2 = 0;\n        private int param3 = 0;\n        private int param4 = 0;\n        private int param5 = 0;\n\n        public Builder(int param1) {\n            this.param1 = param1;\n        }\n\n        public Builder param2(int val) {\n            param2 = val;\n            return this;\n        }\n\n        public Builder param3(int val) {\n            param3 = val;\n            return this;\n        }\n\n        public Builder param4(int val) {\n            param4 = val;\n            return this;\n        }\n\n        public Builder param5(int val) {\n            param5 = val;\n            return this;\n        }\n\n        public BuilderPatternDemo build(){\n            return new BuilderPatternDemo(this);\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。<br><br></p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li>相同的方法，不同的执行顺序，产生不同的事件结果时；</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；</li>\n<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。</li>\n</ol>\n<p>记住一句话:<code>遇到多个构造器参数时要考虑用构建器。</code></p>\n<h4 id=\"为什么是builder模式\"><a href=\"#为什么是builder模式\" class=\"headerlink\" title=\"为什么是builder模式\"></a>为什么是builder模式</h4><p>在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：</p>\n<ol>\n<li>重叠构造器-telescoping constructor</li>\n<li>JavaBeans模式</li>\n<li>构造器模式</li>\n</ol>\n<h5 id=\"重叠构造器\"><a href=\"#重叠构造器\" class=\"headerlink\" title=\"重叠构造器\"></a>重叠构造器</h5><ul>\n<li>随着参数数目的增加，很难控制</li>\n<li>代码很难编写，难以阅读</li>\n<li>如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。</li>\n</ul>\n<pre><code>/**\n * 重叠构造器Demo\n * \n * @author Administrator\n * \n */\npublic class TeleScopDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    public TeleScopDemo(int param1) {\n        this(param1, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2) {\n        this(param1, param2, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3) {\n        this(param1, param2, param3, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4) {\n        this(param1, param2, param3, param4, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4,\n            int param5) {\n        this.param1 = param1;\n        this.param2 = param2;\n        this.param3 = param3;\n        this.param4 = param4;\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"JavaBeans\"><a href=\"#JavaBeans\" class=\"headerlink\" title=\"JavaBeans\"></a>JavaBeans</h5><p>由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 </p>\n<pre><code>/**\n * JavaBeans模式Demo\n * \n * @author Administrator\n * \n */\npublic class JavaBeansDemo {\n\n    private int param1;\n    private int param2;\n    private int param3;\n    private int param4;\n    private int param5;\n\n    public JavaBeansDemo() {\n    }\n\n    public void setParam1(int param1) {\n        this.param1 = param1;\n    }\n\n    public void setParam2(int param2) {\n        this.param2 = param2;\n    }\n\n    public void setParam3(int param3) {\n        this.param3 = param3;\n    }\n\n    public void setParam4(int param4) {\n        this.param4 = param4;\n    }\n\n    public void setParam5(int param5) {\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"Builder模式\"><a href=\"#Builder模式\" class=\"headerlink\" title=\"Builder模式\"></a>Builder模式</h5><p>既有重叠构造器的安全性，也有JavaBeans的可读性。</p>\n<pre><code>/**\n * 构建器模式Demo\n * \n * @author Administrator\n * \n */\npublic class BuilderPatternDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    private BuilderPatternDemo(Builder builder) {\n        param1 = builder.param1;\n        param2 = builder.param2;\n        param3 = builder.param3;\n        param4 = builder.param4;\n        param5 = builder.param5;\n    }\n\n    public static class Builder {\n        // 必需的参数\n        private final int param1;\n\n        // 可选的参数，带有初始值\n        private int param2 = 0;\n        private int param3 = 0;\n        private int param4 = 0;\n        private int param5 = 0;\n\n        public Builder(int param1) {\n            this.param1 = param1;\n        }\n\n        public Builder param2(int val) {\n            param2 = val;\n            return this;\n        }\n\n        public Builder param3(int val) {\n            param3 = val;\n            return this;\n        }\n\n        public Builder param4(int val) {\n            param4 = val;\n            return this;\n        }\n\n        public Builder param5(int val) {\n            param5 = val;\n            return this;\n        }\n\n        public BuilderPatternDemo build(){\n            return new BuilderPatternDemo(this);\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"Android系统服务：WindowManager","date":"2017-03-02T00:00:00.000Z","_content":" \n\n#### 开发中使用 ####\n\n- 获取屏幕宽高\n- 代码设置全屏显示\n- 保持屏幕常亮\n- 悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)\n\n#### 需要的类 ####\n\n- `com.android.server.wm.WindowManagerService`\n- `android.view.WindowManager`\n- `android.view.Window`\n \n \n  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。 \nWindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。\n\nWindow的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。\n\n#### flag 参数 ####\nFlags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。\nFLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。\nFLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。\nFLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。\n\n#### type 参数 ####\n   \nType参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：\nmLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;\n同时声明权限：\n\n\t<uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n \n选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。\n实现的Window的demo，应该有两种类型。\n \nFramework定义了三种窗口类型，三种类型的定义在WindowManager类中。\n第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。\n第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。\n第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。\n\n<br/>\n注意：MIUI系统需要在设置->其他应用管理->应用信息->权限管理,中打开“显示悬浮窗”才能显示。\n\n\n<br/>\n\nwindow 诱导用户输入QQ号及密码：https://yq.aliyun.com/ziliao/160722\n\n<br/>\n视图是如何附加在Window上的,Window有是如何管理这些视图的.\n\n\n\nhttp://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=555\n\n\n\n\n\n\n","source":"_posts/2017-03-02-android-system-service-window-manager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：WindowManager\ndate:   2017-03-02\ncategories: work\ntag: android\n---\n \n\n#### 开发中使用 ####\n\n- 获取屏幕宽高\n- 代码设置全屏显示\n- 保持屏幕常亮\n- 悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)\n\n#### 需要的类 ####\n\n- `com.android.server.wm.WindowManagerService`\n- `android.view.WindowManager`\n- `android.view.Window`\n \n \n  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。 \nWindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。\n\nWindow的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。\n\n#### flag 参数 ####\nFlags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。\nFLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。\nFLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。\nFLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。\n\n#### type 参数 ####\n   \nType参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：\nmLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;\n同时声明权限：\n\n\t<uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n \n选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。\n实现的Window的demo，应该有两种类型。\n \nFramework定义了三种窗口类型，三种类型的定义在WindowManager类中。\n第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。\n第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。\n第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。\n\n<br/>\n注意：MIUI系统需要在设置->其他应用管理->应用信息->权限管理,中打开“显示悬浮窗”才能显示。\n\n\n<br/>\n\nwindow 诱导用户输入QQ号及密码：https://yq.aliyun.com/ziliao/160722\n\n<br/>\n视图是如何附加在Window上的,Window有是如何管理这些视图的.\n\n\n\nhttp://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=555\n\n\n\n\n\n\n","slug":"android-system-service-window-manager","published":1,"updated":"2017-06-01T07:29:30.196Z","comments":1,"photos":[],"link":"","_id":"cj3tijdj6001sh8ivs9g6nzbf","content":"<h4 id=\"开发中使用\"><a href=\"#开发中使用\" class=\"headerlink\" title=\"开发中使用\"></a>开发中使用</h4><ul>\n<li>获取屏幕宽高</li>\n<li>代码设置全屏显示</li>\n<li>保持屏幕常亮</li>\n<li>悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)</li>\n</ul>\n<h4 id=\"需要的类\"><a href=\"#需要的类\" class=\"headerlink\" title=\"需要的类\"></a>需要的类</h4><ul>\n<li><code>com.android.server.wm.WindowManagerService</code></li>\n<li><code>android.view.WindowManager</code></li>\n<li><code>android.view.Window</code></li>\n</ul>\n<p>  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。<br>WindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。</p>\n<p>Window的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。</p>\n<h4 id=\"flag-参数\"><a href=\"#flag-参数\" class=\"headerlink\" title=\"flag 参数\"></a>flag 参数</h4><p>Flags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。<br>FLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。<br>FLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。<br>FLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。</p>\n<h4 id=\"type-参数\"><a href=\"#type-参数\" class=\"headerlink\" title=\"type 参数\"></a>type 参数</h4><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：<br>mLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;<br>同时声明权限：</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;\n</code></pre><p>选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。<br>实现的Window的demo，应该有两种类型。</p>\n<p>Framework定义了三种窗口类型，三种类型的定义在WindowManager类中。<br>第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。<br>第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。<br>第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。</p>\n<p><br><br>注意：MIUI系统需要在设置-&gt;其他应用管理-&gt;应用信息-&gt;权限管理,中打开“显示悬浮窗”才能显示。</p>\n<p><br></p>\n<p>window 诱导用户输入QQ号及密码：<a href=\"https://yq.aliyun.com/ziliao/160722\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/ziliao/160722</a></p>\n<p><br><br>视图是如何附加在Window上的,Window有是如何管理这些视图的.</p>\n<p><a href=\"http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555\" target=\"_blank\" rel=\"external\">http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"开发中使用\"><a href=\"#开发中使用\" class=\"headerlink\" title=\"开发中使用\"></a>开发中使用</h4><ul>\n<li>获取屏幕宽高</li>\n<li>代码设置全屏显示</li>\n<li>保持屏幕常亮</li>\n<li>悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)</li>\n</ul>\n<h4 id=\"需要的类\"><a href=\"#需要的类\" class=\"headerlink\" title=\"需要的类\"></a>需要的类</h4><ul>\n<li><code>com.android.server.wm.WindowManagerService</code></li>\n<li><code>android.view.WindowManager</code></li>\n<li><code>android.view.Window</code></li>\n</ul>\n<p>  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。<br>WindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。</p>\n<p>Window的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。</p>\n<h4 id=\"flag-参数\"><a href=\"#flag-参数\" class=\"headerlink\" title=\"flag 参数\"></a>flag 参数</h4><p>Flags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。<br>FLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。<br>FLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。<br>FLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。</p>\n<h4 id=\"type-参数\"><a href=\"#type-参数\" class=\"headerlink\" title=\"type 参数\"></a>type 参数</h4><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：<br>mLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;<br>同时声明权限：</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;\n</code></pre><p>选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。<br>实现的Window的demo，应该有两种类型。</p>\n<p>Framework定义了三种窗口类型，三种类型的定义在WindowManager类中。<br>第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。<br>第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。<br>第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。</p>\n<p><br><br>注意：MIUI系统需要在设置-&gt;其他应用管理-&gt;应用信息-&gt;权限管理,中打开“显示悬浮窗”才能显示。</p>\n<p><br></p>\n<p>window 诱导用户输入QQ号及密码：<a href=\"https://yq.aliyun.com/ziliao/160722\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/ziliao/160722</a></p>\n<p><br><br>视图是如何附加在Window上的,Window有是如何管理这些视图的.</p>\n<p><a href=\"http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555\" target=\"_blank\" rel=\"external\">http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555</a></p>\n"},{"layout":"post","title":"Android系统服务：LayoutInflater","date":"2017-02-23T00:00:00.000Z","_content":" \n\n#### 起源 ####\n \nactivity是android中最常用的UI容器。把写好的xml布局通过`setContentView(int ResId)`，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务`LayoutInflater`的工作了。\n\n##### 追踪android.app.Activity #####\n  \nActivity源码中有3个`setContentView`的重载方法。\n\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n        initWindowDecorActionBar();\n    }\n\n可以看到，调用当前Activity的window的`setContentView`来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：\n\n![activity、window层级关系图](/images/activity-window-layer.jpg)\n\n其中`com.android.internal.policy.PhoneWindow`是`android.view.Window`的子类。<br/>\nDecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br/>\nTitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br/>\nContentView即需要展示在UI上的xml布局文件。<br/>\n\n继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br/>\n`initWindowDecorActionBar();`里面主要是设置ActionBar。\n\n \n##### 追踪com.android.internal.policy.PhoneWindow #####\n\n先简后繁，看一下现成的view如何添加到ContentView的：\n\t\n\t\t @Override\n\t\t    public void setContentView(View view) {\n\t\t        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\t\t    }\n\t\n\t \t@Override\n\t    public void setContentView(View view, ViewGroup.LayoutParams params) {\n\t        \n\t\t\t...\n\t\n\t\t\tmContentParent.addView(view, params);\n\t\n\t\t\t...\n\t\n\t     }\n\n把已有的view设置进入`ContentView`，只需要调用`ViewGroup.addView(View view)`添加到DecorView即可。<br/>\n这里提一句：view都是要添加到父view上的。 \n\n\tpublic static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n\n这个ID对应的ViewGroup，即xml布局的父view。其源码注释：\n\n>    This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.\n>    这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。\n\n总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。\n     \n\n下面，来看一下xml文件如何变成view的：\n\n\n\t@Override\n\t    public void setContentView(int layoutResID) {\n\t        \n\t\t...\n\n\t            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n\t\t...\n\t        \n\t    }\n\n一目了然，调用系统服务LayoutInflater的inflate方法。\n\n#### 追踪LayoutInflater源码 ####\n\n关键方法：\n\n- inflate * n\n- rInflate\n- createViewFromTag\n- createView\n\n\n\n##### inflate #####\n\n    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n        final Resources res = getContext().getResources();\n        if (DEBUG) {\n            Log.d(TAG, \"INFLATING from resource: \\\"\" + res.getResourceName(resource) + \"\\\" (\"\n                    + Integer.toHexString(resource) + \")\");\n        }\n\n        final XmlResourceParser parser = res.getLayout(resource);\n        try {\n            return inflate(parser, root, attachToRoot);\n        } finally {\n            parser.close();\n        }\n    }\n\n获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。\n\n\t\n\t    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n\t        synchronized (mConstructorArgs) {\n\t\n\t\t...\n\t\t\n\t\t final String name = parser.getName();\n\t\t if (TAG_MERGE.equals(name)) {\n\t\t                    \n\t\t...\n\t\t\n\t    rInflate(parser, root, inflaterContext, attrs, false);\n\t\n\t\t...\n\t\n\t    } else {\n\t\n\t\t...\n\t\n\t \trInflateChildren(parser, temp, attrs, true);\n\t\n\t\t...\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n由于merge标签，只能作为xml根标签使用，所以分开处理。\n\n\n##### rInflate #####\n\n\t void rInflate(XmlPullParser parser, View parent, Context context,\n\t            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\t\n\t        final int depth = parser.getDepth();\n\t        int type;\n\t\n\t        while (((type = parser.next()) != XmlPullParser.END_TAG ||\n\t                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n\t\n\t            if (type != XmlPullParser.START_TAG) {\n\t                continue;\n\t            }\n\t\n\t            final String name = parser.getName();\n\t            \n\t            if (TAG_REQUEST_FOCUS.equals(name)) {\n\t                parseRequestFocus(parser, parent);\n\t            } else if (TAG_TAG.equals(name)) {\n\t                parseViewTag(parser, parent, attrs);\n\t            } else if (TAG_INCLUDE.equals(name)) {\n\t                if (parser.getDepth() == 0) {\n\t                    throw new InflateException(\"<include /> cannot be the root element\");\n\t                }\n\t                parseInclude(parser, context, parent, attrs);\n\t            } else if (TAG_MERGE.equals(name)) {\n\t                throw new InflateException(\"<merge /> must be the root element\");\n\t            } else {\n\t                final View view = createViewFromTag(parent, name, context, attrs);\n\t                final ViewGroup viewGroup = (ViewGroup) parent;\n\t                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n\t                rInflateChildren(parser, view, attrs, true);\n\t                viewGroup.addView(view, params);\n\t            }\n\t        }\n\t\n\t        if (finishInflate) {\n\t            parent.onFinishInflate();\n\t        }\n\t    }\n\n深度优先遍历xml树，判断标签类型，循环递归直至`XmlPullParser.END_DOCUMENT`。\n\n##### createViewFromTag #####\n\t\t\n\t\tView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n\t\t            boolean ignoreThemeAttr) {\n\t\t        if (name.equals(\"view\")) {\n\t\t            name = attrs.getAttributeValue(null, \"class\");\n\t\t        }\n\t\t\n\t\t...\n\t\n\t  \t\t\t\tif (name.equals(TAG_1995)) {\n\t            // Let's party like it's 1995!\n\t            return new BlinkLayout(context, attrs);\n\t        }\n\t\n\t\t...\n\n\ttry {\n            View view;\n            if (mFactory2 != null) {\n                view = mFactory2.onCreateView(parent, name, context, attrs);\n            } else if (mFactory != null) {\n                view = mFactory.onCreateView(name, context, attrs);\n            } else {\n                view = null;\n            }\n\n            if (view == null && mPrivateFactory != null) {\n                view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n            }\n\n            if (view == null) {\n                final Object lastContext = mConstructorArgs[0];\n                mConstructorArgs[0] = context;\n                try {\n                    if (-1 == name.indexOf('.')) {\n                        view = onCreateView(parent, name, attrs);\n                    } else {\n                        view = createView(name, null, attrs);\n                    }\n                } finally {\n                    mConstructorArgs[0] = lastContext;\n                }\n            }\n\n            return view;\n        } \n\n\t...\n\n\t}\n\n如果view为属性标签，那么name就是属性的值。<br/>\n如果TAG_1995，做出来的布局会一闪一闪的。<br/>\n如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br/>\n如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如`android.widget`。<br/>\n\n##### createView #####\n\n    public final View createView(String name, String prefix, AttributeSet attrs)\n            throws ClassNotFoundException, InflateException {\n        Constructor<? extends View> constructor = sConstructorMap.get(name);\n        if (constructor != null && !verifyClassLoader(constructor)) {\n            constructor = null;\n            sConstructorMap.remove(name);\n        }\n        Class<? extends View> clazz = null;\n\n        try {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n            if (constructor == null) {\n                // Class not found in the cache, see if it's real, and try to add it\n                clazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \n                if (mFilter != null && clazz != null) {\n                    boolean allowed = mFilter.onLoadClass(clazz);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n                constructor = clazz.getConstructor(mConstructorSignature);\n                constructor.setAccessible(true);\n                sConstructorMap.put(name, constructor);\n            } else {\n                // If we have a filter, apply it to cached constructor\n                if (mFilter != null) {\n                    // Have we seen this name before?\n                    Boolean allowedState = mFilterMap.get(name);\n                    if (allowedState == null) {\n                        // New class -- remember whether it is allowed\n                        clazz = mContext.getClassLoader().loadClass(\n                                prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                        \n                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                        mFilterMap.put(name, allowed);\n                        if (!allowed) {\n                            failNotAllowed(name, prefix, attrs);\n                        }\n                    } else if (allowedState.equals(Boolean.FALSE)) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n            }\n\n            Object[] args = mConstructorArgs;\n            args[1] = attrs;\n\n            final View view = constructor.newInstance(args);\n            if (view instanceof ViewStub) {\n                // Use the same context when inflating ViewStub later.\n                final ViewStub viewStub = (ViewStub) view;\n                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n            }\n            return view;\n\n        } \n    }\n\n- 根据view的名字，缓存的构造器map中是否存在；\n- 如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；\n- 通过其构造生成view。\n\n\n\n\n\n\n\n\n \n\n \n ","source":"_posts/2017-02-23-android-system-service-LayoutInflater.md","raw":"---\nlayout: post\ntitle:  Android系统服务：LayoutInflater\ndate:   2017-02-23\ncategories: work\ntag: android\n---\n \n\n#### 起源 ####\n \nactivity是android中最常用的UI容器。把写好的xml布局通过`setContentView(int ResId)`，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务`LayoutInflater`的工作了。\n\n##### 追踪android.app.Activity #####\n  \nActivity源码中有3个`setContentView`的重载方法。\n\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n        initWindowDecorActionBar();\n    }\n\n可以看到，调用当前Activity的window的`setContentView`来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：\n\n![activity、window层级关系图](/images/activity-window-layer.jpg)\n\n其中`com.android.internal.policy.PhoneWindow`是`android.view.Window`的子类。<br/>\nDecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br/>\nTitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br/>\nContentView即需要展示在UI上的xml布局文件。<br/>\n\n继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br/>\n`initWindowDecorActionBar();`里面主要是设置ActionBar。\n\n \n##### 追踪com.android.internal.policy.PhoneWindow #####\n\n先简后繁，看一下现成的view如何添加到ContentView的：\n\t\n\t\t @Override\n\t\t    public void setContentView(View view) {\n\t\t        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\t\t    }\n\t\n\t \t@Override\n\t    public void setContentView(View view, ViewGroup.LayoutParams params) {\n\t        \n\t\t\t...\n\t\n\t\t\tmContentParent.addView(view, params);\n\t\n\t\t\t...\n\t\n\t     }\n\n把已有的view设置进入`ContentView`，只需要调用`ViewGroup.addView(View view)`添加到DecorView即可。<br/>\n这里提一句：view都是要添加到父view上的。 \n\n\tpublic static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n\n这个ID对应的ViewGroup，即xml布局的父view。其源码注释：\n\n>    This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.\n>    这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。\n\n总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。\n     \n\n下面，来看一下xml文件如何变成view的：\n\n\n\t@Override\n\t    public void setContentView(int layoutResID) {\n\t        \n\t\t...\n\n\t            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n\t\t...\n\t        \n\t    }\n\n一目了然，调用系统服务LayoutInflater的inflate方法。\n\n#### 追踪LayoutInflater源码 ####\n\n关键方法：\n\n- inflate * n\n- rInflate\n- createViewFromTag\n- createView\n\n\n\n##### inflate #####\n\n    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n        final Resources res = getContext().getResources();\n        if (DEBUG) {\n            Log.d(TAG, \"INFLATING from resource: \\\"\" + res.getResourceName(resource) + \"\\\" (\"\n                    + Integer.toHexString(resource) + \")\");\n        }\n\n        final XmlResourceParser parser = res.getLayout(resource);\n        try {\n            return inflate(parser, root, attachToRoot);\n        } finally {\n            parser.close();\n        }\n    }\n\n获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。\n\n\t\n\t    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n\t        synchronized (mConstructorArgs) {\n\t\n\t\t...\n\t\t\n\t\t final String name = parser.getName();\n\t\t if (TAG_MERGE.equals(name)) {\n\t\t                    \n\t\t...\n\t\t\n\t    rInflate(parser, root, inflaterContext, attrs, false);\n\t\n\t\t...\n\t\n\t    } else {\n\t\n\t\t...\n\t\n\t \trInflateChildren(parser, temp, attrs, true);\n\t\n\t\t...\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n由于merge标签，只能作为xml根标签使用，所以分开处理。\n\n\n##### rInflate #####\n\n\t void rInflate(XmlPullParser parser, View parent, Context context,\n\t            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\t\n\t        final int depth = parser.getDepth();\n\t        int type;\n\t\n\t        while (((type = parser.next()) != XmlPullParser.END_TAG ||\n\t                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n\t\n\t            if (type != XmlPullParser.START_TAG) {\n\t                continue;\n\t            }\n\t\n\t            final String name = parser.getName();\n\t            \n\t            if (TAG_REQUEST_FOCUS.equals(name)) {\n\t                parseRequestFocus(parser, parent);\n\t            } else if (TAG_TAG.equals(name)) {\n\t                parseViewTag(parser, parent, attrs);\n\t            } else if (TAG_INCLUDE.equals(name)) {\n\t                if (parser.getDepth() == 0) {\n\t                    throw new InflateException(\"<include /> cannot be the root element\");\n\t                }\n\t                parseInclude(parser, context, parent, attrs);\n\t            } else if (TAG_MERGE.equals(name)) {\n\t                throw new InflateException(\"<merge /> must be the root element\");\n\t            } else {\n\t                final View view = createViewFromTag(parent, name, context, attrs);\n\t                final ViewGroup viewGroup = (ViewGroup) parent;\n\t                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n\t                rInflateChildren(parser, view, attrs, true);\n\t                viewGroup.addView(view, params);\n\t            }\n\t        }\n\t\n\t        if (finishInflate) {\n\t            parent.onFinishInflate();\n\t        }\n\t    }\n\n深度优先遍历xml树，判断标签类型，循环递归直至`XmlPullParser.END_DOCUMENT`。\n\n##### createViewFromTag #####\n\t\t\n\t\tView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n\t\t            boolean ignoreThemeAttr) {\n\t\t        if (name.equals(\"view\")) {\n\t\t            name = attrs.getAttributeValue(null, \"class\");\n\t\t        }\n\t\t\n\t\t...\n\t\n\t  \t\t\t\tif (name.equals(TAG_1995)) {\n\t            // Let's party like it's 1995!\n\t            return new BlinkLayout(context, attrs);\n\t        }\n\t\n\t\t...\n\n\ttry {\n            View view;\n            if (mFactory2 != null) {\n                view = mFactory2.onCreateView(parent, name, context, attrs);\n            } else if (mFactory != null) {\n                view = mFactory.onCreateView(name, context, attrs);\n            } else {\n                view = null;\n            }\n\n            if (view == null && mPrivateFactory != null) {\n                view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n            }\n\n            if (view == null) {\n                final Object lastContext = mConstructorArgs[0];\n                mConstructorArgs[0] = context;\n                try {\n                    if (-1 == name.indexOf('.')) {\n                        view = onCreateView(parent, name, attrs);\n                    } else {\n                        view = createView(name, null, attrs);\n                    }\n                } finally {\n                    mConstructorArgs[0] = lastContext;\n                }\n            }\n\n            return view;\n        } \n\n\t...\n\n\t}\n\n如果view为属性标签，那么name就是属性的值。<br/>\n如果TAG_1995，做出来的布局会一闪一闪的。<br/>\n如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br/>\n如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如`android.widget`。<br/>\n\n##### createView #####\n\n    public final View createView(String name, String prefix, AttributeSet attrs)\n            throws ClassNotFoundException, InflateException {\n        Constructor<? extends View> constructor = sConstructorMap.get(name);\n        if (constructor != null && !verifyClassLoader(constructor)) {\n            constructor = null;\n            sConstructorMap.remove(name);\n        }\n        Class<? extends View> clazz = null;\n\n        try {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n            if (constructor == null) {\n                // Class not found in the cache, see if it's real, and try to add it\n                clazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \n                if (mFilter != null && clazz != null) {\n                    boolean allowed = mFilter.onLoadClass(clazz);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n                constructor = clazz.getConstructor(mConstructorSignature);\n                constructor.setAccessible(true);\n                sConstructorMap.put(name, constructor);\n            } else {\n                // If we have a filter, apply it to cached constructor\n                if (mFilter != null) {\n                    // Have we seen this name before?\n                    Boolean allowedState = mFilterMap.get(name);\n                    if (allowedState == null) {\n                        // New class -- remember whether it is allowed\n                        clazz = mContext.getClassLoader().loadClass(\n                                prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                        \n                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                        mFilterMap.put(name, allowed);\n                        if (!allowed) {\n                            failNotAllowed(name, prefix, attrs);\n                        }\n                    } else if (allowedState.equals(Boolean.FALSE)) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n            }\n\n            Object[] args = mConstructorArgs;\n            args[1] = attrs;\n\n            final View view = constructor.newInstance(args);\n            if (view instanceof ViewStub) {\n                // Use the same context when inflating ViewStub later.\n                final ViewStub viewStub = (ViewStub) view;\n                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n            }\n            return view;\n\n        } \n    }\n\n- 根据view的名字，缓存的构造器map中是否存在；\n- 如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；\n- 通过其构造生成view。\n\n\n\n\n\n\n\n\n \n\n \n ","slug":"android-system-service-LayoutInflater","published":1,"updated":"2017-06-01T07:33:45.116Z","comments":1,"photos":[],"link":"","_id":"cj3tijdj9001vh8ivnw9kcn0l","content":"<h4 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h4><p>activity是android中最常用的UI容器。把写好的xml布局通过<code>setContentView(int ResId)</code>，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务<code>LayoutInflater</code>的工作了。</p>\n<h5 id=\"追踪android-app-Activity\"><a href=\"#追踪android-app-Activity\" class=\"headerlink\" title=\"追踪android.app.Activity\"></a>追踪android.app.Activity</h5><p>Activity源码中有3个<code>setContentView</code>的重载方法。</p>\n<pre><code>public void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view) {\n    getWindow().setContentView(view);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n    getWindow().setContentView(view, params);\n    initWindowDecorActionBar();\n}\n</code></pre><p>可以看到，调用当前Activity的window的<code>setContentView</code>来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：</p>\n<p><img src=\"/images/activity-window-layer.jpg\" alt=\"activity、window层级关系图\"></p>\n<p>其中<code>com.android.internal.policy.PhoneWindow</code>是<code>android.view.Window</code>的子类。<br><br>DecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br><br>TitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br><br>ContentView即需要展示在UI上的xml布局文件。<br></p>\n<p>继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br><br><code>initWindowDecorActionBar();</code>里面主要是设置ActionBar。</p>\n<h5 id=\"追踪com-android-internal-policy-PhoneWindow\"><a href=\"#追踪com-android-internal-policy-PhoneWindow\" class=\"headerlink\" title=\"追踪com.android.internal.policy.PhoneWindow\"></a>追踪com.android.internal.policy.PhoneWindow</h5><p>先简后繁，看一下现成的view如何添加到ContentView的：</p>\n<pre><code> @Override\n    public void setContentView(View view) {\n        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n    }\n\n @Override\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n\n    ...\n\n    mContentParent.addView(view, params);\n\n    ...\n\n }\n</code></pre><p>把已有的view设置进入<code>ContentView</code>，只需要调用<code>ViewGroup.addView(View view)</code>添加到DecorView即可。<br><br>这里提一句：view都是要添加到父view上的。 </p>\n<pre><code>public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n</code></pre><p>这个ID对应的ViewGroup，即xml布局的父view。其源码注释：</p>\n<blockquote>\n<p>   This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.<br>   这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。</p>\n</blockquote>\n<p>总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。</p>\n<p>下面，来看一下xml文件如何变成view的：</p>\n<pre><code>@Override\n    public void setContentView(int layoutResID) {\n\n    ...\n\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n    ...\n\n    }\n</code></pre><p>一目了然，调用系统服务LayoutInflater的inflate方法。</p>\n<h4 id=\"追踪LayoutInflater源码\"><a href=\"#追踪LayoutInflater源码\" class=\"headerlink\" title=\"追踪LayoutInflater源码\"></a>追踪LayoutInflater源码</h4><p>关键方法：</p>\n<ul>\n<li>inflate * n</li>\n<li>rInflate</li>\n<li>createViewFromTag</li>\n<li>createView</li>\n</ul>\n<h5 id=\"inflate\"><a href=\"#inflate\" class=\"headerlink\" title=\"inflate\"></a>inflate</h5><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    if (DEBUG) {\n        Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;\n                + Integer.toHexString(resource) + &quot;)&quot;);\n    }\n\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n</code></pre><p>获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。</p>\n<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n\n...\n\n final String name = parser.getName();\n if (TAG_MERGE.equals(name)) {\n\n...\n\nrInflate(parser, root, inflaterContext, attrs, false);\n\n...\n\n} else {\n\n...\n\n rInflateChildren(parser, temp, attrs, true);\n\n...\n\n        }\n    }\n}\n</code></pre><p>由于merge标签，只能作为xml根标签使用，所以分开处理。</p>\n<h5 id=\"rInflate\"><a href=\"#rInflate\" class=\"headerlink\" title=\"rInflate\"></a>rInflate</h5><pre><code>void rInflate(XmlPullParser parser, View parent, Context context,\n           AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\n       final int depth = parser.getDepth();\n       int type;\n\n       while (((type = parser.next()) != XmlPullParser.END_TAG ||\n               parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {\n\n           if (type != XmlPullParser.START_TAG) {\n               continue;\n           }\n\n           final String name = parser.getName();\n\n           if (TAG_REQUEST_FOCUS.equals(name)) {\n               parseRequestFocus(parser, parent);\n           } else if (TAG_TAG.equals(name)) {\n               parseViewTag(parser, parent, attrs);\n           } else if (TAG_INCLUDE.equals(name)) {\n               if (parser.getDepth() == 0) {\n                   throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);\n               }\n               parseInclude(parser, context, parent, attrs);\n           } else if (TAG_MERGE.equals(name)) {\n               throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);\n           } else {\n               final View view = createViewFromTag(parent, name, context, attrs);\n               final ViewGroup viewGroup = (ViewGroup) parent;\n               final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n               rInflateChildren(parser, view, attrs, true);\n               viewGroup.addView(view, params);\n           }\n       }\n\n       if (finishInflate) {\n           parent.onFinishInflate();\n       }\n   }\n</code></pre><p>深度优先遍历xml树，判断标签类型，循环递归直至<code>XmlPullParser.END_DOCUMENT</code>。</p>\n<h5 id=\"createViewFromTag\"><a href=\"#createViewFromTag\" class=\"headerlink\" title=\"createViewFromTag\"></a>createViewFromTag</h5><pre><code>    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n                boolean ignoreThemeAttr) {\n            if (name.equals(&quot;view&quot;)) {\n                name = attrs.getAttributeValue(null, &quot;class&quot;);\n            }\n\n    ...\n\n                  if (name.equals(TAG_1995)) {\n            // Let&apos;s party like it&apos;s 1995!\n            return new BlinkLayout(context, attrs);\n        }\n\n    ...\n\ntry {\n        View view;\n        if (mFactory2 != null) {\n            view = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n\n        if (view == null &amp;&amp; mPrivateFactory != null) {\n            view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n\n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf(&apos;.&apos;)) {\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n\n        return view;\n    } \n\n...\n\n}\n</code></pre><p>如果view为属性标签，那么name就是属性的值。<br><br>如果TAG_1995，做出来的布局会一闪一闪的。<br><br>如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br><br>如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如<code>android.widget</code>。<br></p>\n<h5 id=\"createView\"><a href=\"#createView\" class=\"headerlink\" title=\"createView\"></a>createView</h5><pre><code>public final View createView(String name, String prefix, AttributeSet attrs)\n        throws ClassNotFoundException, InflateException {\n    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);\n    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class&lt;? extends View&gt; clazz = null;\n\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n        if (constructor == null) {\n            // Class not found in the cache, see if it&apos;s real, and try to add it\n            clazz = mContext.getClassLoader().loadClass(\n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n            if (mFilter != null &amp;&amp; clazz != null) {\n                boolean allowed = mFilter.onLoadClass(clazz);\n                if (!allowed) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            // If we have a filter, apply it to cached constructor\n            if (mFilter != null) {\n                // Have we seen this name before?\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // New class -- remember whether it is allowed\n                    clazz = mContext.getClassLoader().loadClass(\n                            prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);\n                    mFilterMap.put(name, allowed);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n        }\n\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n\n        final View view = constructor.newInstance(args);\n        if (view instanceof ViewStub) {\n            // Use the same context when inflating ViewStub later.\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        return view;\n\n    } \n}\n</code></pre><ul>\n<li>根据view的名字，缓存的构造器map中是否存在；</li>\n<li>如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；</li>\n<li>通过其构造生成view。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h4><p>activity是android中最常用的UI容器。把写好的xml布局通过<code>setContentView(int ResId)</code>，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务<code>LayoutInflater</code>的工作了。</p>\n<h5 id=\"追踪android-app-Activity\"><a href=\"#追踪android-app-Activity\" class=\"headerlink\" title=\"追踪android.app.Activity\"></a>追踪android.app.Activity</h5><p>Activity源码中有3个<code>setContentView</code>的重载方法。</p>\n<pre><code>public void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view) {\n    getWindow().setContentView(view);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n    getWindow().setContentView(view, params);\n    initWindowDecorActionBar();\n}\n</code></pre><p>可以看到，调用当前Activity的window的<code>setContentView</code>来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：</p>\n<p><img src=\"/images/activity-window-layer.jpg\" alt=\"activity、window层级关系图\"></p>\n<p>其中<code>com.android.internal.policy.PhoneWindow</code>是<code>android.view.Window</code>的子类。<br><br>DecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br><br>TitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br><br>ContentView即需要展示在UI上的xml布局文件。<br></p>\n<p>继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br><br><code>initWindowDecorActionBar();</code>里面主要是设置ActionBar。</p>\n<h5 id=\"追踪com-android-internal-policy-PhoneWindow\"><a href=\"#追踪com-android-internal-policy-PhoneWindow\" class=\"headerlink\" title=\"追踪com.android.internal.policy.PhoneWindow\"></a>追踪com.android.internal.policy.PhoneWindow</h5><p>先简后繁，看一下现成的view如何添加到ContentView的：</p>\n<pre><code> @Override\n    public void setContentView(View view) {\n        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n    }\n\n @Override\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n\n    ...\n\n    mContentParent.addView(view, params);\n\n    ...\n\n }\n</code></pre><p>把已有的view设置进入<code>ContentView</code>，只需要调用<code>ViewGroup.addView(View view)</code>添加到DecorView即可。<br><br>这里提一句：view都是要添加到父view上的。 </p>\n<pre><code>public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n</code></pre><p>这个ID对应的ViewGroup，即xml布局的父view。其源码注释：</p>\n<blockquote>\n<p>   This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.<br>   这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。</p>\n</blockquote>\n<p>总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。</p>\n<p>下面，来看一下xml文件如何变成view的：</p>\n<pre><code>@Override\n    public void setContentView(int layoutResID) {\n\n    ...\n\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n    ...\n\n    }\n</code></pre><p>一目了然，调用系统服务LayoutInflater的inflate方法。</p>\n<h4 id=\"追踪LayoutInflater源码\"><a href=\"#追踪LayoutInflater源码\" class=\"headerlink\" title=\"追踪LayoutInflater源码\"></a>追踪LayoutInflater源码</h4><p>关键方法：</p>\n<ul>\n<li>inflate * n</li>\n<li>rInflate</li>\n<li>createViewFromTag</li>\n<li>createView</li>\n</ul>\n<h5 id=\"inflate\"><a href=\"#inflate\" class=\"headerlink\" title=\"inflate\"></a>inflate</h5><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    if (DEBUG) {\n        Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;\n                + Integer.toHexString(resource) + &quot;)&quot;);\n    }\n\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n</code></pre><p>获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。</p>\n<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n\n...\n\n final String name = parser.getName();\n if (TAG_MERGE.equals(name)) {\n\n...\n\nrInflate(parser, root, inflaterContext, attrs, false);\n\n...\n\n} else {\n\n...\n\n rInflateChildren(parser, temp, attrs, true);\n\n...\n\n        }\n    }\n}\n</code></pre><p>由于merge标签，只能作为xml根标签使用，所以分开处理。</p>\n<h5 id=\"rInflate\"><a href=\"#rInflate\" class=\"headerlink\" title=\"rInflate\"></a>rInflate</h5><pre><code>void rInflate(XmlPullParser parser, View parent, Context context,\n           AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\n       final int depth = parser.getDepth();\n       int type;\n\n       while (((type = parser.next()) != XmlPullParser.END_TAG ||\n               parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {\n\n           if (type != XmlPullParser.START_TAG) {\n               continue;\n           }\n\n           final String name = parser.getName();\n\n           if (TAG_REQUEST_FOCUS.equals(name)) {\n               parseRequestFocus(parser, parent);\n           } else if (TAG_TAG.equals(name)) {\n               parseViewTag(parser, parent, attrs);\n           } else if (TAG_INCLUDE.equals(name)) {\n               if (parser.getDepth() == 0) {\n                   throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);\n               }\n               parseInclude(parser, context, parent, attrs);\n           } else if (TAG_MERGE.equals(name)) {\n               throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);\n           } else {\n               final View view = createViewFromTag(parent, name, context, attrs);\n               final ViewGroup viewGroup = (ViewGroup) parent;\n               final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n               rInflateChildren(parser, view, attrs, true);\n               viewGroup.addView(view, params);\n           }\n       }\n\n       if (finishInflate) {\n           parent.onFinishInflate();\n       }\n   }\n</code></pre><p>深度优先遍历xml树，判断标签类型，循环递归直至<code>XmlPullParser.END_DOCUMENT</code>。</p>\n<h5 id=\"createViewFromTag\"><a href=\"#createViewFromTag\" class=\"headerlink\" title=\"createViewFromTag\"></a>createViewFromTag</h5><pre><code>    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n                boolean ignoreThemeAttr) {\n            if (name.equals(&quot;view&quot;)) {\n                name = attrs.getAttributeValue(null, &quot;class&quot;);\n            }\n\n    ...\n\n                  if (name.equals(TAG_1995)) {\n            // Let&apos;s party like it&apos;s 1995!\n            return new BlinkLayout(context, attrs);\n        }\n\n    ...\n\ntry {\n        View view;\n        if (mFactory2 != null) {\n            view = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n\n        if (view == null &amp;&amp; mPrivateFactory != null) {\n            view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n\n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf(&apos;.&apos;)) {\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n\n        return view;\n    } \n\n...\n\n}\n</code></pre><p>如果view为属性标签，那么name就是属性的值。<br><br>如果TAG_1995，做出来的布局会一闪一闪的。<br><br>如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br><br>如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如<code>android.widget</code>。<br></p>\n<h5 id=\"createView\"><a href=\"#createView\" class=\"headerlink\" title=\"createView\"></a>createView</h5><pre><code>public final View createView(String name, String prefix, AttributeSet attrs)\n        throws ClassNotFoundException, InflateException {\n    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);\n    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class&lt;? extends View&gt; clazz = null;\n\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n        if (constructor == null) {\n            // Class not found in the cache, see if it&apos;s real, and try to add it\n            clazz = mContext.getClassLoader().loadClass(\n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n            if (mFilter != null &amp;&amp; clazz != null) {\n                boolean allowed = mFilter.onLoadClass(clazz);\n                if (!allowed) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            // If we have a filter, apply it to cached constructor\n            if (mFilter != null) {\n                // Have we seen this name before?\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // New class -- remember whether it is allowed\n                    clazz = mContext.getClassLoader().loadClass(\n                            prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);\n                    mFilterMap.put(name, allowed);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n        }\n\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n\n        final View view = constructor.newInstance(args);\n        if (view instanceof ViewStub) {\n            // Use the same context when inflating ViewStub later.\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        return view;\n\n    } \n}\n</code></pre><ul>\n<li>根据view的名字，缓存的构造器map中是否存在；</li>\n<li>如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；</li>\n<li>通过其构造生成view。</li>\n</ul>\n"},{"layout":"post","title":"建造者设计模式(二) Android中的应用","date":"2017-03-03T00:00:00.000Z","_content":"\n\n#### AlertDialog.Builder ####\n\n如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br/>\n那么AlertDialog中的参数，如何传递？<br/>\n\nAlertDialog 中有一个AlertController的实例。<br/>\nAlertController中有个AlertParams的静态类。<br/>\n在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br/>\nBuilder中的方法都把属性传入了AlertParams。<br/>\n在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br/>\n\n示意图如下：\n\n![示例图](/images/alertDialog.png)\n#### Uri.Builder ####\n\n\n\nUri.Builder; \nNotification.Builder;\nContentProviderOperation.Builder;\n ","source":"_posts/2017-03-03-design-patterns-builder-2.md","raw":"---\nlayout: post\ntitle:  建造者设计模式(二) Android中的应用\ndate:   2017-03-03\ncategories: work\ntag: 设计模式\n---\n\n\n#### AlertDialog.Builder ####\n\n如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br/>\n那么AlertDialog中的参数，如何传递？<br/>\n\nAlertDialog 中有一个AlertController的实例。<br/>\nAlertController中有个AlertParams的静态类。<br/>\n在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br/>\nBuilder中的方法都把属性传入了AlertParams。<br/>\n在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br/>\n\n示意图如下：\n\n![示例图](/images/alertDialog.png)\n#### Uri.Builder ####\n\n\n\nUri.Builder; \nNotification.Builder;\nContentProviderOperation.Builder;\n ","slug":"design-patterns-builder-2","published":1,"updated":"2017-06-01T07:27:10.773Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjc001yh8ivvtdluupy","content":"<h4 id=\"AlertDialog-Builder\"><a href=\"#AlertDialog-Builder\" class=\"headerlink\" title=\"AlertDialog.Builder\"></a>AlertDialog.Builder</h4><p>如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br><br>那么AlertDialog中的参数，如何传递？<br></p>\n<p>AlertDialog 中有一个AlertController的实例。<br><br>AlertController中有个AlertParams的静态类。<br><br>在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br><br>Builder中的方法都把属性传入了AlertParams。<br><br>在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br></p>\n<p>示意图如下：</p>\n<p><img src=\"/images/alertDialog.png\" alt=\"示例图\"></p>\n<h4 id=\"Uri-Builder\"><a href=\"#Uri-Builder\" class=\"headerlink\" title=\"Uri.Builder\"></a>Uri.Builder</h4><p>Uri.Builder;<br>Notification.Builder;<br>ContentProviderOperation.Builder;</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"AlertDialog-Builder\"><a href=\"#AlertDialog-Builder\" class=\"headerlink\" title=\"AlertDialog.Builder\"></a>AlertDialog.Builder</h4><p>如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br><br>那么AlertDialog中的参数，如何传递？<br></p>\n<p>AlertDialog 中有一个AlertController的实例。<br><br>AlertController中有个AlertParams的静态类。<br><br>在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br><br>Builder中的方法都把属性传入了AlertParams。<br><br>在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br></p>\n<p>示意图如下：</p>\n<p><img src=\"/images/alertDialog.png\" alt=\"示例图\"></p>\n<h4 id=\"Uri-Builder\"><a href=\"#Uri-Builder\" class=\"headerlink\" title=\"Uri.Builder\"></a>Uri.Builder</h4><p>Uri.Builder;<br>Notification.Builder;<br>ContentProviderOperation.Builder;</p>\n"},{"layout":"post","title":"设计模式开篇","date":"2017-03-18T00:00:00.000Z","_content":" \n\n#### 设计模式 ####\n\n设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br/>\n\n软件模式包括：\n\n- 设计模式\n- 架构模式\n- 分析模式\n- 过程模式\n\n\n#### 学习设计模式的层次 ####\n- 能在白纸上画出所有的模式结构和时序图\n- 能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用\n- 灵活运用至项目中\n\n在线画图工具安利：[https://www.processon.com/diagrams](https://www.processon.com/diagrams)\n\n\n#### 设计模式分类 ####\n\n- 创建型模式(5)\n\t- [单例模式](http://xusx1024.com/2017/02/11/design-patterns-singleton-1/)\n\t- [建造者模式](http://xusx1024.com/2017/03/03/design-patterns-builder-1/)\n\t- [原型模式](http://xusx1024.com/2017/03/18/design-patterns-prototype-1/)\n\t- [工厂方法模式](http://xusx1024.com/2017/05/24/design-patterns-factory-method/)\n\t- [抽象工厂模式](http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/)\n- 结构型模式(7)\n\t- 适配器模式\n\t- 桥接模式\n\t- 装饰模式\n\t- 外观模式\n\t- 享元模式\n\t- 代理模式\n\t- 组合模式\n- 行为型模式(11)\n\t- [策略模式](http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/)\n\t- 模版方法模式\n\t- 观察者模式\n\t- 迭代子模式\n\t- [责任链模式](http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/)\n\t- 命令模式\n\t- 备忘录模式\n\t- [状态模式](http://xusx1024.com/2017/05/26/design-patterns-state-pattern/)\n\t- 访问者模式\n\t- 中介者模式\n\t- 解释器模式\n\n ","source":"_posts/2017-03-18-design-patterns-start.md","raw":"---\nlayout: post\ntitle:  设计模式开篇\ndate:   2017-03-18\ncategories: work\ntag: 设计模式\n---\n \n\n#### 设计模式 ####\n\n设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br/>\n\n软件模式包括：\n\n- 设计模式\n- 架构模式\n- 分析模式\n- 过程模式\n\n\n#### 学习设计模式的层次 ####\n- 能在白纸上画出所有的模式结构和时序图\n- 能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用\n- 灵活运用至项目中\n\n在线画图工具安利：[https://www.processon.com/diagrams](https://www.processon.com/diagrams)\n\n\n#### 设计模式分类 ####\n\n- 创建型模式(5)\n\t- [单例模式](http://xusx1024.com/2017/02/11/design-patterns-singleton-1/)\n\t- [建造者模式](http://xusx1024.com/2017/03/03/design-patterns-builder-1/)\n\t- [原型模式](http://xusx1024.com/2017/03/18/design-patterns-prototype-1/)\n\t- [工厂方法模式](http://xusx1024.com/2017/05/24/design-patterns-factory-method/)\n\t- [抽象工厂模式](http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/)\n- 结构型模式(7)\n\t- 适配器模式\n\t- 桥接模式\n\t- 装饰模式\n\t- 外观模式\n\t- 享元模式\n\t- 代理模式\n\t- 组合模式\n- 行为型模式(11)\n\t- [策略模式](http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/)\n\t- 模版方法模式\n\t- 观察者模式\n\t- 迭代子模式\n\t- [责任链模式](http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/)\n\t- 命令模式\n\t- 备忘录模式\n\t- [状态模式](http://xusx1024.com/2017/05/26/design-patterns-state-pattern/)\n\t- 访问者模式\n\t- 中介者模式\n\t- 解释器模式\n\n ","slug":"design-patterns-start","published":1,"updated":"2017-06-02T00:37:55.361Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjg0021h8ivuxy50xng","content":"<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><p>设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br></p>\n<p>软件模式包括：</p>\n<ul>\n<li>设计模式</li>\n<li>架构模式</li>\n<li>分析模式</li>\n<li>过程模式</li>\n</ul>\n<h4 id=\"学习设计模式的层次\"><a href=\"#学习设计模式的层次\" class=\"headerlink\" title=\"学习设计模式的层次\"></a>学习设计模式的层次</h4><ul>\n<li>能在白纸上画出所有的模式结构和时序图</li>\n<li>能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用</li>\n<li>灵活运用至项目中</li>\n</ul>\n<p>在线画图工具安利：<a href=\"https://www.processon.com/diagrams\" target=\"_blank\" rel=\"external\">https://www.processon.com/diagrams</a></p>\n<h4 id=\"设计模式分类\"><a href=\"#设计模式分类\" class=\"headerlink\" title=\"设计模式分类\"></a>设计模式分类</h4><ul>\n<li>创建型模式(5)<ul>\n<li><a href=\"http://xusx1024.com/2017/02/11/design-patterns-singleton-1/\" target=\"_blank\" rel=\"external\">单例模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/03/design-patterns-builder-1/\" target=\"_blank\" rel=\"external\">建造者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/18/design-patterns-prototype-1/\" target=\"_blank\" rel=\"external\">原型模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/24/design-patterns-factory-method/\" target=\"_blank\" rel=\"external\">工厂方法模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/\" target=\"_blank\" rel=\"external\">抽象工厂模式</a></li>\n</ul>\n</li>\n<li>结构型模式(7)<ul>\n<li>适配器模式</li>\n<li>桥接模式</li>\n<li>装饰模式</li>\n<li>外观模式</li>\n<li>享元模式</li>\n<li>代理模式</li>\n<li>组合模式</li>\n</ul>\n</li>\n<li>行为型模式(11)<ul>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/\" target=\"_blank\" rel=\"external\">策略模式</a></li>\n<li>模版方法模式</li>\n<li>观察者模式</li>\n<li>迭代子模式</li>\n<li><a href=\"http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/\" target=\"_blank\" rel=\"external\">责任链模式</a></li>\n<li>命令模式</li>\n<li>备忘录模式</li>\n<li><a href=\"http://xusx1024.com/2017/05/26/design-patterns-state-pattern/\" target=\"_blank\" rel=\"external\">状态模式</a></li>\n<li>访问者模式</li>\n<li>中介者模式</li>\n<li>解释器模式</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><p>设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br></p>\n<p>软件模式包括：</p>\n<ul>\n<li>设计模式</li>\n<li>架构模式</li>\n<li>分析模式</li>\n<li>过程模式</li>\n</ul>\n<h4 id=\"学习设计模式的层次\"><a href=\"#学习设计模式的层次\" class=\"headerlink\" title=\"学习设计模式的层次\"></a>学习设计模式的层次</h4><ul>\n<li>能在白纸上画出所有的模式结构和时序图</li>\n<li>能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用</li>\n<li>灵活运用至项目中</li>\n</ul>\n<p>在线画图工具安利：<a href=\"https://www.processon.com/diagrams\" target=\"_blank\" rel=\"external\">https://www.processon.com/diagrams</a></p>\n<h4 id=\"设计模式分类\"><a href=\"#设计模式分类\" class=\"headerlink\" title=\"设计模式分类\"></a>设计模式分类</h4><ul>\n<li>创建型模式(5)<ul>\n<li><a href=\"http://xusx1024.com/2017/02/11/design-patterns-singleton-1/\" target=\"_blank\" rel=\"external\">单例模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/03/design-patterns-builder-1/\" target=\"_blank\" rel=\"external\">建造者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/18/design-patterns-prototype-1/\" target=\"_blank\" rel=\"external\">原型模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/24/design-patterns-factory-method/\" target=\"_blank\" rel=\"external\">工厂方法模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/\" target=\"_blank\" rel=\"external\">抽象工厂模式</a></li>\n</ul>\n</li>\n<li>结构型模式(7)<ul>\n<li>适配器模式</li>\n<li>桥接模式</li>\n<li>装饰模式</li>\n<li>外观模式</li>\n<li>享元模式</li>\n<li>代理模式</li>\n<li>组合模式</li>\n</ul>\n</li>\n<li>行为型模式(11)<ul>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/\" target=\"_blank\" rel=\"external\">策略模式</a></li>\n<li>模版方法模式</li>\n<li>观察者模式</li>\n<li>迭代子模式</li>\n<li><a href=\"http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/\" target=\"_blank\" rel=\"external\">责任链模式</a></li>\n<li>命令模式</li>\n<li>备忘录模式</li>\n<li><a href=\"http://xusx1024.com/2017/05/26/design-patterns-state-pattern/\" target=\"_blank\" rel=\"external\">状态模式</a></li>\n<li>访问者模式</li>\n<li>中介者模式</li>\n<li>解释器模式</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"Linux基础知识：内核空间和用户空间","date":"2017-03-27T00:00:00.000Z","_content":" \n \n1. 内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间\n2. 内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表\n3. 用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干\n \n\n\n操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。\n\n在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br/>\n- 首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；\n- 然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；\n\n\n虚拟空间读取数据伪代码：\n\t\n\tif(数据在物理内存中) \n\t        {        虚拟地址转换成物理地址 \n\t                 读数据 } \n\t        else \n\t        {     if(数据在磁盘中) \n\t              { \n\t                     if(物理内存还有空闲) \n\t                     {          把数据从磁盘中读到物理内存 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t                     else \n\t                     {          把物理内存中某页的数据存入磁盘 \n\t                                 把要读的数据从磁盘读到该页的物理内存中 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t              } \n\t              else \n\t              {     报错        } }\n\t\n\t    ","source":"_posts/2017-03-27-kernel-user-space.md","raw":"---\nlayout: post\ntitle:  Linux基础知识：内核空间和用户空间\ndate:   2017-03-27\ncategories: work\ntag: 杂项\n---\n \n \n1. 内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间\n2. 内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表\n3. 用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干\n \n\n\n操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。\n\n在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br/>\n- 首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；\n- 然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；\n\n\n虚拟空间读取数据伪代码：\n\t\n\tif(数据在物理内存中) \n\t        {        虚拟地址转换成物理地址 \n\t                 读数据 } \n\t        else \n\t        {     if(数据在磁盘中) \n\t              { \n\t                     if(物理内存还有空闲) \n\t                     {          把数据从磁盘中读到物理内存 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t                     else \n\t                     {          把物理内存中某页的数据存入磁盘 \n\t                                 把要读的数据从磁盘读到该页的物理内存中 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t              } \n\t              else \n\t              {     报错        } }\n\t\n\t    ","slug":"kernel-user-space","published":1,"updated":"2017-06-01T07:23:29.481Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjj0024h8ivx402ma18","content":"<ol>\n<li>内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间</li>\n<li>内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表</li>\n<li>用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干</li>\n</ol>\n<p>操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。</p>\n<p>在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br></p>\n<ul>\n<li>首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；</li>\n<li>然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；</li>\n</ul>\n<p>虚拟空间读取数据伪代码：</p>\n<pre><code>if(数据在物理内存中) \n        {        虚拟地址转换成物理地址 \n                 读数据 } \n        else \n        {     if(数据在磁盘中) \n              { \n                     if(物理内存还有空闲) \n                     {          把数据从磁盘中读到物理内存 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n                     else \n                     {          把物理内存中某页的数据存入磁盘 \n                                 把要读的数据从磁盘读到该页的物理内存中 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n              } \n              else \n              {     报错        } }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间</li>\n<li>内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表</li>\n<li>用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干</li>\n</ol>\n<p>操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。</p>\n<p>在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br></p>\n<ul>\n<li>首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；</li>\n<li>然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；</li>\n</ul>\n<p>虚拟空间读取数据伪代码：</p>\n<pre><code>if(数据在物理内存中) \n        {        虚拟地址转换成物理地址 \n                 读数据 } \n        else \n        {     if(数据在磁盘中) \n              { \n                     if(物理内存还有空闲) \n                     {          把数据从磁盘中读到物理内存 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n                     else \n                     {          把物理内存中某页的数据存入磁盘 \n                                 把要读的数据从磁盘读到该页的物理内存中 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n              } \n              else \n              {     报错        } }\n</code></pre>"},{"layout":"post","title":"原型设计模式(二) Android中的应用","date":"2017-03-19T00:00:00.000Z","_content":" \n\n#### Intent/Bundle ####\n \n\n    /**\n     * Copy constructor.\n     */\n    public Intent(Intent o) {\n        this.mAction = o.mAction;\n        this.mData = o.mData;\n        this.mType = o.mType;\n        this.mPackage = o.mPackage;\n        this.mComponent = o.mComponent;\n        this.mFlags = o.mFlags;\n        this.mContentUserHint = o.mContentUserHint;\n        if (o.mCategories != null) {\n            this.mCategories = new ArraySet<String>(o.mCategories);\n        }\n        if (o.mExtras != null) {\n            this.mExtras = new Bundle(o.mExtras);\n        }\n        if (o.mSourceBounds != null) {\n            this.mSourceBounds = new Rect(o.mSourceBounds);\n        }\n        if (o.mSelector != null) {\n            this.mSelector = new Intent(o.mSelector);\n        }\n        if (o.mClipData != null) {\n            this.mClipData = new ClipData(o.mClipData);\n        }\n    }\n\n    @Override\n    public Object clone() {\n        return new Intent(this);\n    }\n\n发现并没有调用`super.clone()`，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。\n\n\n\n","source":"_posts/2017-03-19-design-patterns-prototype-2.md","raw":"---\nlayout: post\ntitle:  原型设计模式(二) Android中的应用\ndate:   2017-03-19\ncategories: work\ntag: 设计模式\n---\n \n\n#### Intent/Bundle ####\n \n\n    /**\n     * Copy constructor.\n     */\n    public Intent(Intent o) {\n        this.mAction = o.mAction;\n        this.mData = o.mData;\n        this.mType = o.mType;\n        this.mPackage = o.mPackage;\n        this.mComponent = o.mComponent;\n        this.mFlags = o.mFlags;\n        this.mContentUserHint = o.mContentUserHint;\n        if (o.mCategories != null) {\n            this.mCategories = new ArraySet<String>(o.mCategories);\n        }\n        if (o.mExtras != null) {\n            this.mExtras = new Bundle(o.mExtras);\n        }\n        if (o.mSourceBounds != null) {\n            this.mSourceBounds = new Rect(o.mSourceBounds);\n        }\n        if (o.mSelector != null) {\n            this.mSelector = new Intent(o.mSelector);\n        }\n        if (o.mClipData != null) {\n            this.mClipData = new ClipData(o.mClipData);\n        }\n    }\n\n    @Override\n    public Object clone() {\n        return new Intent(this);\n    }\n\n发现并没有调用`super.clone()`，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。\n\n\n\n","slug":"design-patterns-prototype-2","published":1,"updated":"2017-06-01T07:23:52.697Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjl0027h8iv3jtr5lia","content":"<h4 id=\"Intent-Bundle\"><a href=\"#Intent-Bundle\" class=\"headerlink\" title=\"Intent/Bundle\"></a>Intent/Bundle</h4><pre><code>/**\n * Copy constructor.\n */\npublic Intent(Intent o) {\n    this.mAction = o.mAction;\n    this.mData = o.mData;\n    this.mType = o.mType;\n    this.mPackage = o.mPackage;\n    this.mComponent = o.mComponent;\n    this.mFlags = o.mFlags;\n    this.mContentUserHint = o.mContentUserHint;\n    if (o.mCategories != null) {\n        this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);\n    }\n    if (o.mExtras != null) {\n        this.mExtras = new Bundle(o.mExtras);\n    }\n    if (o.mSourceBounds != null) {\n        this.mSourceBounds = new Rect(o.mSourceBounds);\n    }\n    if (o.mSelector != null) {\n        this.mSelector = new Intent(o.mSelector);\n    }\n    if (o.mClipData != null) {\n        this.mClipData = new ClipData(o.mClipData);\n    }\n}\n\n@Override\npublic Object clone() {\n    return new Intent(this);\n}\n</code></pre><p>发现并没有调用<code>super.clone()</code>，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Intent-Bundle\"><a href=\"#Intent-Bundle\" class=\"headerlink\" title=\"Intent/Bundle\"></a>Intent/Bundle</h4><pre><code>/**\n * Copy constructor.\n */\npublic Intent(Intent o) {\n    this.mAction = o.mAction;\n    this.mData = o.mData;\n    this.mType = o.mType;\n    this.mPackage = o.mPackage;\n    this.mComponent = o.mComponent;\n    this.mFlags = o.mFlags;\n    this.mContentUserHint = o.mContentUserHint;\n    if (o.mCategories != null) {\n        this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);\n    }\n    if (o.mExtras != null) {\n        this.mExtras = new Bundle(o.mExtras);\n    }\n    if (o.mSourceBounds != null) {\n        this.mSourceBounds = new Rect(o.mSourceBounds);\n    }\n    if (o.mSelector != null) {\n        this.mSelector = new Intent(o.mSelector);\n    }\n    if (o.mClipData != null) {\n        this.mClipData = new ClipData(o.mClipData);\n    }\n}\n\n@Override\npublic Object clone() {\n    return new Intent(this);\n}\n</code></pre><p>发现并没有调用<code>super.clone()</code>，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。</p>\n"},{"layout":"post","title":"Tinker学习(二)标准java虚拟机动态加载代码示例","date":"2017-03-30T00:00:00.000Z","_content":" \n\n虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br/>\n \n自定义classLoader类：\n\n\timport java.io.ByteArrayOutputStream;\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.nio.ByteBuffer;\n\timport java.nio.channels.FileChannel;\n\t\n\tpublic class MyClassLoader extends ClassLoader {\n\t\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\n\t\t\tString classPath = MyClassLoader.class.getResource(\"/\").getPath();\n\t\t\tString fileName = name.replace(\".\", \"/\") + \".class\";\n\t\t\tFile classFile = new File(classPath, fileName);\n\t\n\t\t\tif (!classFile.exists()) {\n\t\t\t\tthrow new ClassNotFoundException(classFile.getPath() + \" 不存在\");\n\t\t\t}\n\t\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tByteBuffer bf = ByteBuffer.allocate(1024);\n\t\t\tFileInputStream fis = null;\n\t\t\tFileChannel fc = null;\n\t\n\t\t\ttry {\n\t\t\t\tfis = new FileInputStream(classFile);\n\t\t\t\tfc = fis.getChannel();\n\t\t\t\twhile (fc.read(bf) > 0) {\n\t\t\t\t\tbf.flip();\n\t\t\t\t\tbos.write(bf.array(), 0, bf.limit());\n\t\t\t\t\tbf.clear();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tfis.close();\n\t\t\t\t\tfc.close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t\t// TODO: handle exception\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n\t\t}\n\t\n\t}\n\n改变的类：\n\t\n\tpublic class Person {\n\t\n\t\tpublic void sayHello() {\n\t\t\tSystem.out.println(\"hello world!\");\n\t\t}\n\t}\n\n\n测试的类：\n\t \n\timport java.lang.reflect.Method;\n\t\n\tpublic class StartUp {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i = 0;\n\t\n\t\t\twhile (true) {\n\t\t\t\tMyClassLoader mcl = new MyClassLoader();\n\t\t\t\tSystem.out.println(mcl.getParent());\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> personClass = mcl.findClass(\"Person\");\n\t\n\t\t\t\t\tObject person = personClass.newInstance();\n\t\t\t\t\tMethod sayHelloMethod = personClass.getMethod(\"sayHello\");\n\t\t\t\t\tsayHelloMethod.invoke(person);\n\t\t\t\t\tSystem.out.println(i++);\n\t\n\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。","source":"_posts/2017-03-30-tinker-source-code-2.md","raw":"---\nlayout: post\ntitle:  Tinker学习(二)标准java虚拟机动态加载代码示例\ndate:   2017-03-30\ncategories: work\ntag: android\n---\n \n\n虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br/>\n \n自定义classLoader类：\n\n\timport java.io.ByteArrayOutputStream;\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.nio.ByteBuffer;\n\timport java.nio.channels.FileChannel;\n\t\n\tpublic class MyClassLoader extends ClassLoader {\n\t\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\n\t\t\tString classPath = MyClassLoader.class.getResource(\"/\").getPath();\n\t\t\tString fileName = name.replace(\".\", \"/\") + \".class\";\n\t\t\tFile classFile = new File(classPath, fileName);\n\t\n\t\t\tif (!classFile.exists()) {\n\t\t\t\tthrow new ClassNotFoundException(classFile.getPath() + \" 不存在\");\n\t\t\t}\n\t\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tByteBuffer bf = ByteBuffer.allocate(1024);\n\t\t\tFileInputStream fis = null;\n\t\t\tFileChannel fc = null;\n\t\n\t\t\ttry {\n\t\t\t\tfis = new FileInputStream(classFile);\n\t\t\t\tfc = fis.getChannel();\n\t\t\t\twhile (fc.read(bf) > 0) {\n\t\t\t\t\tbf.flip();\n\t\t\t\t\tbos.write(bf.array(), 0, bf.limit());\n\t\t\t\t\tbf.clear();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tfis.close();\n\t\t\t\t\tfc.close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t\t// TODO: handle exception\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n\t\t}\n\t\n\t}\n\n改变的类：\n\t\n\tpublic class Person {\n\t\n\t\tpublic void sayHello() {\n\t\t\tSystem.out.println(\"hello world!\");\n\t\t}\n\t}\n\n\n测试的类：\n\t \n\timport java.lang.reflect.Method;\n\t\n\tpublic class StartUp {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i = 0;\n\t\n\t\t\twhile (true) {\n\t\t\t\tMyClassLoader mcl = new MyClassLoader();\n\t\t\t\tSystem.out.println(mcl.getParent());\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> personClass = mcl.findClass(\"Person\");\n\t\n\t\t\t\t\tObject person = personClass.newInstance();\n\t\t\t\t\tMethod sayHelloMethod = personClass.getMethod(\"sayHello\");\n\t\t\t\t\tsayHelloMethod.invoke(person);\n\t\t\t\t\tSystem.out.println(i++);\n\t\n\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。","slug":"tinker-source-code-2","published":1,"updated":"2017-06-01T07:22:33.755Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjo002ah8ivlgbzgzb1","content":"<p>虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br></p>\n<p>自定义classLoader类：</p>\n<pre><code>import java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class MyClassLoader extends ClassLoader {\n\n    @SuppressWarnings(&quot;deprecation&quot;)\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {\n\n        String classPath = MyClassLoader.class.getResource(&quot;/&quot;).getPath();\n        String fileName = name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;\n        File classFile = new File(classPath, fileName);\n\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(classFile.getPath() + &quot; 不存在&quot;);\n        }\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ByteBuffer bf = ByteBuffer.allocate(1024);\n        FileInputStream fis = null;\n        FileChannel fc = null;\n\n        try {\n            fis = new FileInputStream(classFile);\n            fc = fis.getChannel();\n            while (fc.read(bf) &gt; 0) {\n                bf.flip();\n                bos.write(bf.array(), 0, bf.limit());\n                bf.clear();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fis.close();\n                fc.close();\n            } catch (Exception e2) {\n                // TODO: handle exception\n            }\n\n        }\n\n        return defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n    }\n\n}\n</code></pre><p>改变的类：</p>\n<pre><code>public class Person {\n\n    public void sayHello() {\n        System.out.println(&quot;hello world!&quot;);\n    }\n}\n</code></pre><p>测试的类：</p>\n<pre><code>import java.lang.reflect.Method;\n\npublic class StartUp {\n\n    public static void main(String[] args) {\n        int i = 0;\n\n        while (true) {\n            MyClassLoader mcl = new MyClassLoader();\n            System.out.println(mcl.getParent());\n            try {\n                Class&lt;?&gt; personClass = mcl.findClass(&quot;Person&quot;);\n\n                Object person = personClass.newInstance();\n                Method sayHelloMethod = personClass.getMethod(&quot;sayHello&quot;);\n                sayHelloMethod.invoke(person);\n                System.out.println(i++);\n\n                Thread.sleep(3000);\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br></p>\n<p>自定义classLoader类：</p>\n<pre><code>import java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class MyClassLoader extends ClassLoader {\n\n    @SuppressWarnings(&quot;deprecation&quot;)\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {\n\n        String classPath = MyClassLoader.class.getResource(&quot;/&quot;).getPath();\n        String fileName = name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;\n        File classFile = new File(classPath, fileName);\n\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(classFile.getPath() + &quot; 不存在&quot;);\n        }\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ByteBuffer bf = ByteBuffer.allocate(1024);\n        FileInputStream fis = null;\n        FileChannel fc = null;\n\n        try {\n            fis = new FileInputStream(classFile);\n            fc = fis.getChannel();\n            while (fc.read(bf) &gt; 0) {\n                bf.flip();\n                bos.write(bf.array(), 0, bf.limit());\n                bf.clear();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fis.close();\n                fc.close();\n            } catch (Exception e2) {\n                // TODO: handle exception\n            }\n\n        }\n\n        return defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n    }\n\n}\n</code></pre><p>改变的类：</p>\n<pre><code>public class Person {\n\n    public void sayHello() {\n        System.out.println(&quot;hello world!&quot;);\n    }\n}\n</code></pre><p>测试的类：</p>\n<pre><code>import java.lang.reflect.Method;\n\npublic class StartUp {\n\n    public static void main(String[] args) {\n        int i = 0;\n\n        while (true) {\n            MyClassLoader mcl = new MyClassLoader();\n            System.out.println(mcl.getParent());\n            try {\n                Class&lt;?&gt; personClass = mcl.findClass(&quot;Person&quot;);\n\n                Object person = personClass.newInstance();\n                Method sayHelloMethod = personClass.getMethod(&quot;sayHello&quot;);\n                sayHelloMethod.invoke(person);\n                System.out.println(i++);\n\n                Thread.sleep(3000);\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。</p>\n"},{"layout":"post","title":"Tinker学习(三) 核心的算法BSDiff、BSPatch","date":"2017-03-30T00:00:00.000Z","_content":" \n\n#### 简介 ####\n\nBSDiff，用于服务端比较二进制文件并生成差异补丁；<br>\nBSPatch，将旧文件和补丁文件合并生成新的文件。\n\n比较差异使用的算法是`suffix sort`后缀排序算法。其中：<br>\n\n- C实现可以参照：[Colin Percival](https://github.com/cperciva)的[bsdiff](https://github.com/cperciva/bsdiff)\n- Java实现可以参照：[Joe Desbonnet](https://github.com/jdesbonnet)的[jbdiff](https://github.com/jdesbonnet/jbdiff)<br>\n\nTinker的`com.tencent.tinker.bsdiff`实现基本上和Joe Desbonnet的实现并无两样。\n\n\n#### BSDiff基本步骤 ####\n\n1. 将old文件中所有子字符串形成一个字典 \n2. 对比old文件和new文件，产生diff string 和 extra string\n3. 将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。\n \n所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br>\n关于后缀数组概念，需要懂得非比较排序算法：<br>\n\n- [非比较排序之计数排序](http://xusx1024.com/2017/04/11/counting-sort/)\n- [非比较排序之桶/箱排序](http://xusx1024.com/2017/04/10/bucket-sort/)\n- [非比较排序之基数排序](http://xusx1024.com/2017/04/10/radix-sort/)\n\n需要懂得生成后缀数组算法：<br>\n\n- [基于倍增算法实现后缀数组](http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/)\n- [基于DC3算法实现后缀数组](http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/)","source":"_posts/2017-03-30-tinker-source-code-3.md","raw":"---\nlayout: post\ntitle:  Tinker学习(三) 核心的算法BSDiff、BSPatch\ndate:   2017-03-30\ncategories: work\ntag: [android,算法]\n---\n \n\n#### 简介 ####\n\nBSDiff，用于服务端比较二进制文件并生成差异补丁；<br>\nBSPatch，将旧文件和补丁文件合并生成新的文件。\n\n比较差异使用的算法是`suffix sort`后缀排序算法。其中：<br>\n\n- C实现可以参照：[Colin Percival](https://github.com/cperciva)的[bsdiff](https://github.com/cperciva/bsdiff)\n- Java实现可以参照：[Joe Desbonnet](https://github.com/jdesbonnet)的[jbdiff](https://github.com/jdesbonnet/jbdiff)<br>\n\nTinker的`com.tencent.tinker.bsdiff`实现基本上和Joe Desbonnet的实现并无两样。\n\n\n#### BSDiff基本步骤 ####\n\n1. 将old文件中所有子字符串形成一个字典 \n2. 对比old文件和new文件，产生diff string 和 extra string\n3. 将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。\n \n所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br>\n关于后缀数组概念，需要懂得非比较排序算法：<br>\n\n- [非比较排序之计数排序](http://xusx1024.com/2017/04/11/counting-sort/)\n- [非比较排序之桶/箱排序](http://xusx1024.com/2017/04/10/bucket-sort/)\n- [非比较排序之基数排序](http://xusx1024.com/2017/04/10/radix-sort/)\n\n需要懂得生成后缀数组算法：<br>\n\n- [基于倍增算法实现后缀数组](http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/)\n- [基于DC3算法实现后缀数组](http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/)","slug":"tinker-source-code-3","published":1,"updated":"2017-06-01T07:22:11.042Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjq002dh8ivusdaiwe1","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>BSDiff，用于服务端比较二进制文件并生成差异补丁；<br><br>BSPatch，将旧文件和补丁文件合并生成新的文件。</p>\n<p>比较差异使用的算法是<code>suffix sort</code>后缀排序算法。其中：<br></p>\n<ul>\n<li>C实现可以参照：<a href=\"https://github.com/cperciva\" target=\"_blank\" rel=\"external\">Colin Percival</a>的<a href=\"https://github.com/cperciva/bsdiff\" target=\"_blank\" rel=\"external\">bsdiff</a></li>\n<li>Java实现可以参照：<a href=\"https://github.com/jdesbonnet\" target=\"_blank\" rel=\"external\">Joe Desbonnet</a>的<a href=\"https://github.com/jdesbonnet/jbdiff\" target=\"_blank\" rel=\"external\">jbdiff</a><br></li>\n</ul>\n<p>Tinker的<code>com.tencent.tinker.bsdiff</code>实现基本上和Joe Desbonnet的实现并无两样。</p>\n<h4 id=\"BSDiff基本步骤\"><a href=\"#BSDiff基本步骤\" class=\"headerlink\" title=\"BSDiff基本步骤\"></a>BSDiff基本步骤</h4><ol>\n<li>将old文件中所有子字符串形成一个字典 </li>\n<li>对比old文件和new文件，产生diff string 和 extra string</li>\n<li>将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。</li>\n</ol>\n<p>所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br><br>关于后缀数组概念，需要懂得非比较排序算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">非比较排序之计数排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">非比较排序之桶/箱排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">非比较排序之基数排序</a></li>\n</ul>\n<p>需要懂得生成后缀数组算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/\" target=\"_blank\" rel=\"external\">基于倍增算法实现后缀数组</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/\" target=\"_blank\" rel=\"external\">基于DC3算法实现后缀数组</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>BSDiff，用于服务端比较二进制文件并生成差异补丁；<br><br>BSPatch，将旧文件和补丁文件合并生成新的文件。</p>\n<p>比较差异使用的算法是<code>suffix sort</code>后缀排序算法。其中：<br></p>\n<ul>\n<li>C实现可以参照：<a href=\"https://github.com/cperciva\" target=\"_blank\" rel=\"external\">Colin Percival</a>的<a href=\"https://github.com/cperciva/bsdiff\" target=\"_blank\" rel=\"external\">bsdiff</a></li>\n<li>Java实现可以参照：<a href=\"https://github.com/jdesbonnet\" target=\"_blank\" rel=\"external\">Joe Desbonnet</a>的<a href=\"https://github.com/jdesbonnet/jbdiff\" target=\"_blank\" rel=\"external\">jbdiff</a><br></li>\n</ul>\n<p>Tinker的<code>com.tencent.tinker.bsdiff</code>实现基本上和Joe Desbonnet的实现并无两样。</p>\n<h4 id=\"BSDiff基本步骤\"><a href=\"#BSDiff基本步骤\" class=\"headerlink\" title=\"BSDiff基本步骤\"></a>BSDiff基本步骤</h4><ol>\n<li>将old文件中所有子字符串形成一个字典 </li>\n<li>对比old文件和new文件，产生diff string 和 extra string</li>\n<li>将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。</li>\n</ol>\n<p>所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br><br>关于后缀数组概念，需要懂得非比较排序算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">非比较排序之计数排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">非比较排序之桶/箱排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">非比较排序之基数排序</a></li>\n</ul>\n<p>需要懂得生成后缀数组算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/\" target=\"_blank\" rel=\"external\">基于倍增算法实现后缀数组</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/\" target=\"_blank\" rel=\"external\">基于DC3算法实现后缀数组</a></li>\n</ul>\n"},{"layout":"post","title":"由两个栈组成的队列","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 由两个栈组成的队列 #####\n\n\n\t编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n\t具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n\t根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n\n##### 注意事项 #####\n\t\t\n\t1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n\t2. 如果stackPop要接收数据，必须保证stackPop为空。\n\n##### stackPush压入stackPop的操作时机 #####\n\t\n\t调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\t\n\tpublic class TwoStackQueue {\n\n\t\tpublic Stack<Integer> stackPush;\n\t\tpublic Stack<Integer> stackPop;\n\t\n\t\tpublic TwoStackQueue() {\n\t\t\tstackPop = new Stack<>();\n\t\t\tstackPush = new Stack<>();\n\t\t}\n\t\n\t\tpublic void add(int pushInt) {\n\t\t\tstackPush.push(pushInt);\n\t\t}\n\t\n\t\tpublic int poll() {\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.pop();\n\t\t}\n\t\t\n\t\tpublic int peek(){\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.peek();\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-11-two-stacks-makeup-queue.md","raw":"---\nlayout: post\ntitle:  由两个栈组成的队列\ndate:   2017-02-11\ncategories: work\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 由两个栈组成的队列 #####\n\n\n\t编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n\t具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n\t根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n\n##### 注意事项 #####\n\t\t\n\t1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n\t2. 如果stackPop要接收数据，必须保证stackPop为空。\n\n##### stackPush压入stackPop的操作时机 #####\n\t\n\t调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\t\n\tpublic class TwoStackQueue {\n\n\t\tpublic Stack<Integer> stackPush;\n\t\tpublic Stack<Integer> stackPop;\n\t\n\t\tpublic TwoStackQueue() {\n\t\t\tstackPop = new Stack<>();\n\t\t\tstackPush = new Stack<>();\n\t\t}\n\t\n\t\tpublic void add(int pushInt) {\n\t\t\tstackPush.push(pushInt);\n\t\t}\n\t\n\t\tpublic int poll() {\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.pop();\n\t\t}\n\t\t\n\t\tpublic int peek(){\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.peek();\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"two-stacks-makeup-queue","published":1,"updated":"2017-06-01T07:45:13.396Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjs002gh8ivlx7pnm2d","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"由两个栈组成的队列\"><a href=\"#由两个栈组成的队列\" class=\"headerlink\" title=\"由两个栈组成的队列\"></a>由两个栈组成的队列</h5><pre><code>编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n</code></pre><h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><pre><code>1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n2. 如果stackPop要接收数据，必须保证stackPop为空。\n</code></pre><h5 id=\"stackPush压入stackPop的操作时机\"><a href=\"#stackPush压入stackPop的操作时机\" class=\"headerlink\" title=\"stackPush压入stackPop的操作时机\"></a>stackPush压入stackPop的操作时机</h5><pre><code>调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class TwoStackQueue {\n\n    public Stack&lt;Integer&gt; stackPush;\n    public Stack&lt;Integer&gt; stackPop;\n\n    public TwoStackQueue() {\n        stackPop = new Stack&lt;&gt;();\n        stackPush = new Stack&lt;&gt;();\n    }\n\n    public void add(int pushInt) {\n        stackPush.push(pushInt);\n    }\n\n    public int poll() {\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n\n    public int peek(){\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"由两个栈组成的队列\"><a href=\"#由两个栈组成的队列\" class=\"headerlink\" title=\"由两个栈组成的队列\"></a>由两个栈组成的队列</h5><pre><code>编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n</code></pre><h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><pre><code>1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n2. 如果stackPop要接收数据，必须保证stackPop为空。\n</code></pre><h5 id=\"stackPush压入stackPop的操作时机\"><a href=\"#stackPush压入stackPop的操作时机\" class=\"headerlink\" title=\"stackPush压入stackPop的操作时机\"></a>stackPush压入stackPop的操作时机</h5><pre><code>调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class TwoStackQueue {\n\n    public Stack&lt;Integer&gt; stackPush;\n    public Stack&lt;Integer&gt; stackPop;\n\n    public TwoStackQueue() {\n        stackPop = new Stack&lt;&gt;();\n        stackPush = new Stack&lt;&gt;();\n    }\n\n    public void add(int pushInt) {\n        stackPush.push(pushInt);\n    }\n\n    public int poll() {\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n\n    public int peek(){\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n}\n</code></pre>"},{"layout":"post","title":"kotlin在实际使用中的一些问题解决","date":"2017-03-01T00:00:00.000Z","_content":" \n\n#### 引起build false ####\n\n##### 提示信息 #####\n>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can't find referenced method 'int getThemeResId()' in library class android.view.ContextThemeWrapper\n\n##### 原因&解决 #####\n\n>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.\n\n\n>解决：compile 'org.jetbrains.anko:anko-common:0.9.1' \n\n\n注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。[传送](https://github.com/Kotlin/anko/issues/206)。\n\n<br/>\n<br/>\n\n\n#### fragment中没有使用findViewById，报null异常 ####\n\n##### 提示信息 #####\n\n>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.View android.view.View.findViewById(int)' on a null object reference\n\n##### 原因&解决 #####\n\n>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.\n\n[传送。](http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments)\n\n#### companion object ####\n\ncompanion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.\n\n#### 对一个可能为null对象的处理 ####\n\n- surround with null check: `if (item != null)`\n- Add non-null asserted:`obj!!`\n- replace with safe  (?.) call:`obj?`\n\n对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。\n\n\n#### kotlin中的操作符重载 ####\n\n[官方传送](https://kotlinlang.org/docs/reference/basic-types.html) <br/>\n[优秀blog传送](http://blog.csdn.net/io_field/article/details/52817471)\n\n要用到的是java中的&操作，在kotlin中是and方法。\n\n#### 一个对象在改变属性时，可能为null的提示 ####  \n\n>Smart cast to 'Drawable' is impossible , because 'goldSwBean' is a mutable property that could have been change by this time\n\n在每一步build的时候，都加上确认对象不会为空的判定,如下：<br/>\nAdd non-null asserted:`obj!!`\n\n#### instanceof  ####\n\ninstanceof 使用is替代了  \n\n#### 类型强制转换  ####\n\n使用as。` (view as TextView)`\n\n#### 集合操作  ####\n\n[官方传送](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)<br/>\n[民间传送](http://www.cnblogs.com/figozhg/p/5031398.html)<br/>\n很多封装，方便。<br/>\n注意`map``foreach`，好用的。\n\n#### swithc-case的default ####\n \n已知switch-case被when取代了，那么default是啥？如下：\n\t\n\twhen (x) {\n\t    1 -> print(\"x == 1\")\n\t    2 -> print(\"x == 2\")\n\t    else -> { // Note the block\n\t        print(\"x is neither 1 nor 2\")\n\t    }\n\t}\n\n\n#### adapter中的getView问题 ####\n\n>Parameter specified as non-null is null\n\n语义比较明白：检测到非空参数为空。\n<br/>\n \n事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。\n\n[kotlin空安全扩展](http://kotlinlang.org/docs/reference/null-safety.html)\n\n#### name  shadowed 警告 ####\n\n>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning -- but it is allowed.\n\n#### 开启子线程 ####\n\n如果需要UI线程之外做些事情：\n\t\n\t doAsync {\n                Thread.sleep(1000)\n                uiThread {  }//回到UI线程\n\t          }\n\n\n#### xml or text declaration not at start ####\n\n这个是kotlin无关的问题，仅做记录:\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n这行代码在xml中，不要多不要少就要一行，放在首行。\n\n#### open class ####\n\nKotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。\n\n#### return null ####\n有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：\n\n\tfun method():String ? {\n            return null\n        }\n\n#### 可变参数使用关键字：vararg ####\n\n    fun demo(vararg texts : String){\n\n     }\n\n#### 究极快速方法 ####\n如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。\n\n#### Unresolved reference: rem ####\n1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br/>\n1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(\"DEPRECATION\")\n\n#### for 循环 ####\n##### 循环遍历对象 ####\n\tfor (item in collection) {\n    print(item)\n}\n\n##### 循环计数 #####\n\tfor (index in 0..viewGroup.getChildCount() - 1) {\n    val view = viewGroup.getChildAt(index)\n    view.visibility = View.VISIBLE\n}\n\n##### 循环遍历对象数组 #####\n\n\tfor (i in array.indices)\n    print(array[i])\n\n#### 延时执行任务 ####\njava<br/>\n\n\t mHandler.postDelayed(new Runnable() {\n\t                    @Override\n\t                    public void run() {\n\t                       //do something\n\t                    }\n\t                }, 3000);\n\nkotlin<br/>\n\n\tmHandler.postDelayed(Runnable { //do something }, 3000)\n\n#### lambda ####\n\n##### android提示框 #####\n\t\n\tbuilder.setPositiveButton(\"同意\", object : DialogInterface.OnClickListener {\n\t            override fun onClick(dialog: DialogInterface?, which: Int) {\n\t\n\t            }\n\t\n\t        })\n    builder.setPositiveButton(\"同意\") { dialog, which ->\n        \n    }\n\n#### 覆盖父类的方法 ####\n\n>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final","source":"_posts/2017-03-01-kotlin-in-project.md","raw":"---\nlayout: post\ntitle:  kotlin在实际使用中的一些问题解决\ndate:   2017-03-01\ncategories: work\ntag: 杂项\n---\n \n\n#### 引起build false ####\n\n##### 提示信息 #####\n>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can't find referenced method 'int getThemeResId()' in library class android.view.ContextThemeWrapper\n\n##### 原因&解决 #####\n\n>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.\n\n\n>解决：compile 'org.jetbrains.anko:anko-common:0.9.1' \n\n\n注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。[传送](https://github.com/Kotlin/anko/issues/206)。\n\n<br/>\n<br/>\n\n\n#### fragment中没有使用findViewById，报null异常 ####\n\n##### 提示信息 #####\n\n>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.View android.view.View.findViewById(int)' on a null object reference\n\n##### 原因&解决 #####\n\n>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.\n\n[传送。](http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments)\n\n#### companion object ####\n\ncompanion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.\n\n#### 对一个可能为null对象的处理 ####\n\n- surround with null check: `if (item != null)`\n- Add non-null asserted:`obj!!`\n- replace with safe  (?.) call:`obj?`\n\n对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。\n\n\n#### kotlin中的操作符重载 ####\n\n[官方传送](https://kotlinlang.org/docs/reference/basic-types.html) <br/>\n[优秀blog传送](http://blog.csdn.net/io_field/article/details/52817471)\n\n要用到的是java中的&操作，在kotlin中是and方法。\n\n#### 一个对象在改变属性时，可能为null的提示 ####  \n\n>Smart cast to 'Drawable' is impossible , because 'goldSwBean' is a mutable property that could have been change by this time\n\n在每一步build的时候，都加上确认对象不会为空的判定,如下：<br/>\nAdd non-null asserted:`obj!!`\n\n#### instanceof  ####\n\ninstanceof 使用is替代了  \n\n#### 类型强制转换  ####\n\n使用as。` (view as TextView)`\n\n#### 集合操作  ####\n\n[官方传送](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)<br/>\n[民间传送](http://www.cnblogs.com/figozhg/p/5031398.html)<br/>\n很多封装，方便。<br/>\n注意`map``foreach`，好用的。\n\n#### swithc-case的default ####\n \n已知switch-case被when取代了，那么default是啥？如下：\n\t\n\twhen (x) {\n\t    1 -> print(\"x == 1\")\n\t    2 -> print(\"x == 2\")\n\t    else -> { // Note the block\n\t        print(\"x is neither 1 nor 2\")\n\t    }\n\t}\n\n\n#### adapter中的getView问题 ####\n\n>Parameter specified as non-null is null\n\n语义比较明白：检测到非空参数为空。\n<br/>\n \n事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。\n\n[kotlin空安全扩展](http://kotlinlang.org/docs/reference/null-safety.html)\n\n#### name  shadowed 警告 ####\n\n>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning -- but it is allowed.\n\n#### 开启子线程 ####\n\n如果需要UI线程之外做些事情：\n\t\n\t doAsync {\n                Thread.sleep(1000)\n                uiThread {  }//回到UI线程\n\t          }\n\n\n#### xml or text declaration not at start ####\n\n这个是kotlin无关的问题，仅做记录:\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n这行代码在xml中，不要多不要少就要一行，放在首行。\n\n#### open class ####\n\nKotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。\n\n#### return null ####\n有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：\n\n\tfun method():String ? {\n            return null\n        }\n\n#### 可变参数使用关键字：vararg ####\n\n    fun demo(vararg texts : String){\n\n     }\n\n#### 究极快速方法 ####\n如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。\n\n#### Unresolved reference: rem ####\n1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br/>\n1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(\"DEPRECATION\")\n\n#### for 循环 ####\n##### 循环遍历对象 ####\n\tfor (item in collection) {\n    print(item)\n}\n\n##### 循环计数 #####\n\tfor (index in 0..viewGroup.getChildCount() - 1) {\n    val view = viewGroup.getChildAt(index)\n    view.visibility = View.VISIBLE\n}\n\n##### 循环遍历对象数组 #####\n\n\tfor (i in array.indices)\n    print(array[i])\n\n#### 延时执行任务 ####\njava<br/>\n\n\t mHandler.postDelayed(new Runnable() {\n\t                    @Override\n\t                    public void run() {\n\t                       //do something\n\t                    }\n\t                }, 3000);\n\nkotlin<br/>\n\n\tmHandler.postDelayed(Runnable { //do something }, 3000)\n\n#### lambda ####\n\n##### android提示框 #####\n\t\n\tbuilder.setPositiveButton(\"同意\", object : DialogInterface.OnClickListener {\n\t            override fun onClick(dialog: DialogInterface?, which: Int) {\n\t\n\t            }\n\t\n\t        })\n    builder.setPositiveButton(\"同意\") { dialog, which ->\n        \n    }\n\n#### 覆盖父类的方法 ####\n\n>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final","slug":"kotlin-in-project","published":1,"updated":"2017-06-01T07:30:06.822Z","comments":1,"photos":[],"link":"","_id":"cj3tijdjw002jh8ivzrupo9y0","content":"<h4 id=\"引起build-false\"><a href=\"#引起build-false\" class=\"headerlink\" title=\"引起build false\"></a>引起build false</h4><h5 id=\"提示信息\"><a href=\"#提示信息\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can’t find referenced method ‘int getThemeResId()’ in library class android.view.ContextThemeWrapper</p>\n</blockquote>\n<h5 id=\"原因-amp-解决\"><a href=\"#原因-amp-解决\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.</p>\n<p>解决：compile ‘org.jetbrains.anko:anko-common:0.9.1’ </p>\n</blockquote>\n<p>注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。<a href=\"https://github.com/Kotlin/anko/issues/206\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p><br><br><br></p>\n<h4 id=\"fragment中没有使用findViewById，报null异常\"><a href=\"#fragment中没有使用findViewById，报null异常\" class=\"headerlink\" title=\"fragment中没有使用findViewById，报null异常\"></a>fragment中没有使用findViewById，报null异常</h4><h5 id=\"提示信息-1\"><a href=\"#提示信息-1\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method ‘android.view.View android.view.View.findViewById(int)’ on a null object reference</p>\n</blockquote>\n<h5 id=\"原因-amp-解决-1\"><a href=\"#原因-amp-解决-1\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.</p>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments\" target=\"_blank\" rel=\"external\">传送。</a></p>\n<h4 id=\"companion-object\"><a href=\"#companion-object\" class=\"headerlink\" title=\"companion object\"></a>companion object</h4><p>companion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.</p>\n<h4 id=\"对一个可能为null对象的处理\"><a href=\"#对一个可能为null对象的处理\" class=\"headerlink\" title=\"对一个可能为null对象的处理\"></a>对一个可能为null对象的处理</h4><ul>\n<li>surround with null check: <code>if (item != null)</code></li>\n<li>Add non-null asserted:<code>obj!!</code></li>\n<li>replace with safe  (?.) call:<code>obj?</code></li>\n</ul>\n<p>对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。</p>\n<h4 id=\"kotlin中的操作符重载\"><a href=\"#kotlin中的操作符重载\" class=\"headerlink\" title=\"kotlin中的操作符重载\"></a>kotlin中的操作符重载</h4><p><a href=\"https://kotlinlang.org/docs/reference/basic-types.html\" target=\"_blank\" rel=\"external\">官方传送</a> <br><br><a href=\"http://blog.csdn.net/io_field/article/details/52817471\" target=\"_blank\" rel=\"external\">优秀blog传送</a></p>\n<p>要用到的是java中的&amp;操作，在kotlin中是and方法。</p>\n<h4 id=\"一个对象在改变属性时，可能为null的提示\"><a href=\"#一个对象在改变属性时，可能为null的提示\" class=\"headerlink\" title=\"一个对象在改变属性时，可能为null的提示\"></a>一个对象在改变属性时，可能为null的提示</h4><blockquote>\n<p>Smart cast to ‘Drawable’ is impossible , because ‘goldSwBean’ is a mutable property that could have been change by this time</p>\n</blockquote>\n<p>在每一步build的时候，都加上确认对象不会为空的判定,如下：<br><br>Add non-null asserted:<code>obj!!</code></p>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><p>instanceof 使用is替代了  </p>\n<h4 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h4><p>使用as。<code>(view as TextView)</code></p>\n<h4 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h4><p><a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html\" target=\"_blank\" rel=\"external\">官方传送</a><br><br><a href=\"http://www.cnblogs.com/figozhg/p/5031398.html\" target=\"_blank\" rel=\"external\">民间传送</a><br><br>很多封装，方便。<br><br>注意<code>map``foreach</code>，好用的。</p>\n<h4 id=\"swithc-case的default\"><a href=\"#swithc-case的default\" class=\"headerlink\" title=\"swithc-case的default\"></a>swithc-case的default</h4><p>已知switch-case被when取代了，那么default是啥？如下：</p>\n<pre><code>when (x) {\n    1 -&gt; print(&quot;x == 1&quot;)\n    2 -&gt; print(&quot;x == 2&quot;)\n    else -&gt; { // Note the block\n        print(&quot;x is neither 1 nor 2&quot;)\n    }\n}\n</code></pre><h4 id=\"adapter中的getView问题\"><a href=\"#adapter中的getView问题\" class=\"headerlink\" title=\"adapter中的getView问题\"></a>adapter中的getView问题</h4><blockquote>\n<p>Parameter specified as non-null is null</p>\n</blockquote>\n<p>语义比较明白：检测到非空参数为空。<br><br></p>\n<p>事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。</p>\n<p><a href=\"http://kotlinlang.org/docs/reference/null-safety.html\" target=\"_blank\" rel=\"external\">kotlin空安全扩展</a></p>\n<h4 id=\"name-shadowed-警告\"><a href=\"#name-shadowed-警告\" class=\"headerlink\" title=\"name  shadowed 警告\"></a>name  shadowed 警告</h4><blockquote>\n<p>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning – but it is allowed.</p>\n</blockquote>\n<h4 id=\"开启子线程\"><a href=\"#开启子线程\" class=\"headerlink\" title=\"开启子线程\"></a>开启子线程</h4><p>如果需要UI线程之外做些事情：</p>\n<pre><code>doAsync {\n           Thread.sleep(1000)\n           uiThread {  }//回到UI线程\n         }\n</code></pre><h4 id=\"xml-or-text-declaration-not-at-start\"><a href=\"#xml-or-text-declaration-not-at-start\" class=\"headerlink\" title=\"xml or text declaration not at start\"></a>xml or text declaration not at start</h4><p>这个是kotlin无关的问题，仅做记录:</p>\n<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>\n<p>这行代码在xml中，不要多不要少就要一行，放在首行。</p>\n<h4 id=\"open-class\"><a href=\"#open-class\" class=\"headerlink\" title=\"open class\"></a>open class</h4><p>Kotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。</p>\n<h4 id=\"return-null\"><a href=\"#return-null\" class=\"headerlink\" title=\"return null\"></a>return null</h4><p>有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：</p>\n<pre><code>fun method():String ? {\n        return null\n    }\n</code></pre><h4 id=\"可变参数使用关键字：vararg\"><a href=\"#可变参数使用关键字：vararg\" class=\"headerlink\" title=\"可变参数使用关键字：vararg\"></a>可变参数使用关键字：vararg</h4><pre><code>fun demo(vararg texts : String){\n\n }\n</code></pre><h4 id=\"究极快速方法\"><a href=\"#究极快速方法\" class=\"headerlink\" title=\"究极快速方法\"></a>究极快速方法</h4><p>如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。</p>\n<h4 id=\"Unresolved-reference-rem\"><a href=\"#Unresolved-reference-rem\" class=\"headerlink\" title=\"Unresolved reference: rem\"></a>Unresolved reference: rem</h4><p>1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br><br>1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(“DEPRECATION”)</p>\n<h4 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h4><h5 id=\"循环遍历对象\"><a href=\"#循环遍历对象\" class=\"headerlink\" title=\"循环遍历对象\"></a>循环遍历对象</h5><pre><code>for (item in collection) {\nprint(item)\n</code></pre><p>}</p>\n<h5 id=\"循环计数\"><a href=\"#循环计数\" class=\"headerlink\" title=\"循环计数\"></a>循环计数</h5><pre><code>for (index in 0..viewGroup.getChildCount() - 1) {\nval view = viewGroup.getChildAt(index)\nview.visibility = View.VISIBLE\n</code></pre><p>}</p>\n<h5 id=\"循环遍历对象数组\"><a href=\"#循环遍历对象数组\" class=\"headerlink\" title=\"循环遍历对象数组\"></a>循环遍历对象数组</h5><pre><code>for (i in array.indices)\nprint(array[i])\n</code></pre><h4 id=\"延时执行任务\"><a href=\"#延时执行任务\" class=\"headerlink\" title=\"延时执行任务\"></a>延时执行任务</h4><p>java<br></p>\n<pre><code>mHandler.postDelayed(new Runnable() {\n                   @Override\n                   public void run() {\n                      //do something\n                   }\n               }, 3000);\n</code></pre><p>kotlin<br></p>\n<pre><code>mHandler.postDelayed(Runnable { //do something }, 3000)\n</code></pre><h4 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h4><h5 id=\"android提示框\"><a href=\"#android提示框\" class=\"headerlink\" title=\"android提示框\"></a>android提示框</h5><pre><code>builder.setPositiveButton(&quot;同意&quot;, object : DialogInterface.OnClickListener {\n            override fun onClick(dialog: DialogInterface?, which: Int) {\n\n            }\n\n        })\nbuilder.setPositiveButton(&quot;同意&quot;) { dialog, which -&gt;\n\n}\n</code></pre><h4 id=\"覆盖父类的方法\"><a href=\"#覆盖父类的方法\" class=\"headerlink\" title=\"覆盖父类的方法\"></a>覆盖父类的方法</h4><blockquote>\n<p>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引起build-false\"><a href=\"#引起build-false\" class=\"headerlink\" title=\"引起build false\"></a>引起build false</h4><h5 id=\"提示信息\"><a href=\"#提示信息\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can’t find referenced method ‘int getThemeResId()’ in library class android.view.ContextThemeWrapper</p>\n</blockquote>\n<h5 id=\"原因-amp-解决\"><a href=\"#原因-amp-解决\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.</p>\n<p>解决：compile ‘org.jetbrains.anko:anko-common:0.9.1’ </p>\n</blockquote>\n<p>注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。<a href=\"https://github.com/Kotlin/anko/issues/206\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p><br><br><br></p>\n<h4 id=\"fragment中没有使用findViewById，报null异常\"><a href=\"#fragment中没有使用findViewById，报null异常\" class=\"headerlink\" title=\"fragment中没有使用findViewById，报null异常\"></a>fragment中没有使用findViewById，报null异常</h4><h5 id=\"提示信息-1\"><a href=\"#提示信息-1\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method ‘android.view.View android.view.View.findViewById(int)’ on a null object reference</p>\n</blockquote>\n<h5 id=\"原因-amp-解决-1\"><a href=\"#原因-amp-解决-1\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.</p>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments\" target=\"_blank\" rel=\"external\">传送。</a></p>\n<h4 id=\"companion-object\"><a href=\"#companion-object\" class=\"headerlink\" title=\"companion object\"></a>companion object</h4><p>companion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.</p>\n<h4 id=\"对一个可能为null对象的处理\"><a href=\"#对一个可能为null对象的处理\" class=\"headerlink\" title=\"对一个可能为null对象的处理\"></a>对一个可能为null对象的处理</h4><ul>\n<li>surround with null check: <code>if (item != null)</code></li>\n<li>Add non-null asserted:<code>obj!!</code></li>\n<li>replace with safe  (?.) call:<code>obj?</code></li>\n</ul>\n<p>对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。</p>\n<h4 id=\"kotlin中的操作符重载\"><a href=\"#kotlin中的操作符重载\" class=\"headerlink\" title=\"kotlin中的操作符重载\"></a>kotlin中的操作符重载</h4><p><a href=\"https://kotlinlang.org/docs/reference/basic-types.html\" target=\"_blank\" rel=\"external\">官方传送</a> <br><br><a href=\"http://blog.csdn.net/io_field/article/details/52817471\" target=\"_blank\" rel=\"external\">优秀blog传送</a></p>\n<p>要用到的是java中的&amp;操作，在kotlin中是and方法。</p>\n<h4 id=\"一个对象在改变属性时，可能为null的提示\"><a href=\"#一个对象在改变属性时，可能为null的提示\" class=\"headerlink\" title=\"一个对象在改变属性时，可能为null的提示\"></a>一个对象在改变属性时，可能为null的提示</h4><blockquote>\n<p>Smart cast to ‘Drawable’ is impossible , because ‘goldSwBean’ is a mutable property that could have been change by this time</p>\n</blockquote>\n<p>在每一步build的时候，都加上确认对象不会为空的判定,如下：<br><br>Add non-null asserted:<code>obj!!</code></p>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><p>instanceof 使用is替代了  </p>\n<h4 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h4><p>使用as。<code>(view as TextView)</code></p>\n<h4 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h4><p><a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html\" target=\"_blank\" rel=\"external\">官方传送</a><br><br><a href=\"http://www.cnblogs.com/figozhg/p/5031398.html\" target=\"_blank\" rel=\"external\">民间传送</a><br><br>很多封装，方便。<br><br>注意<code>map``foreach</code>，好用的。</p>\n<h4 id=\"swithc-case的default\"><a href=\"#swithc-case的default\" class=\"headerlink\" title=\"swithc-case的default\"></a>swithc-case的default</h4><p>已知switch-case被when取代了，那么default是啥？如下：</p>\n<pre><code>when (x) {\n    1 -&gt; print(&quot;x == 1&quot;)\n    2 -&gt; print(&quot;x == 2&quot;)\n    else -&gt; { // Note the block\n        print(&quot;x is neither 1 nor 2&quot;)\n    }\n}\n</code></pre><h4 id=\"adapter中的getView问题\"><a href=\"#adapter中的getView问题\" class=\"headerlink\" title=\"adapter中的getView问题\"></a>adapter中的getView问题</h4><blockquote>\n<p>Parameter specified as non-null is null</p>\n</blockquote>\n<p>语义比较明白：检测到非空参数为空。<br><br></p>\n<p>事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。</p>\n<p><a href=\"http://kotlinlang.org/docs/reference/null-safety.html\" target=\"_blank\" rel=\"external\">kotlin空安全扩展</a></p>\n<h4 id=\"name-shadowed-警告\"><a href=\"#name-shadowed-警告\" class=\"headerlink\" title=\"name  shadowed 警告\"></a>name  shadowed 警告</h4><blockquote>\n<p>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning – but it is allowed.</p>\n</blockquote>\n<h4 id=\"开启子线程\"><a href=\"#开启子线程\" class=\"headerlink\" title=\"开启子线程\"></a>开启子线程</h4><p>如果需要UI线程之外做些事情：</p>\n<pre><code>doAsync {\n           Thread.sleep(1000)\n           uiThread {  }//回到UI线程\n         }\n</code></pre><h4 id=\"xml-or-text-declaration-not-at-start\"><a href=\"#xml-or-text-declaration-not-at-start\" class=\"headerlink\" title=\"xml or text declaration not at start\"></a>xml or text declaration not at start</h4><p>这个是kotlin无关的问题，仅做记录:</p>\n<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>\n<p>这行代码在xml中，不要多不要少就要一行，放在首行。</p>\n<h4 id=\"open-class\"><a href=\"#open-class\" class=\"headerlink\" title=\"open class\"></a>open class</h4><p>Kotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。</p>\n<h4 id=\"return-null\"><a href=\"#return-null\" class=\"headerlink\" title=\"return null\"></a>return null</h4><p>有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：</p>\n<pre><code>fun method():String ? {\n        return null\n    }\n</code></pre><h4 id=\"可变参数使用关键字：vararg\"><a href=\"#可变参数使用关键字：vararg\" class=\"headerlink\" title=\"可变参数使用关键字：vararg\"></a>可变参数使用关键字：vararg</h4><pre><code>fun demo(vararg texts : String){\n\n }\n</code></pre><h4 id=\"究极快速方法\"><a href=\"#究极快速方法\" class=\"headerlink\" title=\"究极快速方法\"></a>究极快速方法</h4><p>如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。</p>\n<h4 id=\"Unresolved-reference-rem\"><a href=\"#Unresolved-reference-rem\" class=\"headerlink\" title=\"Unresolved reference: rem\"></a>Unresolved reference: rem</h4><p>1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br><br>1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(“DEPRECATION”)</p>\n<h4 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h4><h5 id=\"循环遍历对象\"><a href=\"#循环遍历对象\" class=\"headerlink\" title=\"循环遍历对象\"></a>循环遍历对象</h5><pre><code>for (item in collection) {\nprint(item)\n</code></pre><p>}</p>\n<h5 id=\"循环计数\"><a href=\"#循环计数\" class=\"headerlink\" title=\"循环计数\"></a>循环计数</h5><pre><code>for (index in 0..viewGroup.getChildCount() - 1) {\nval view = viewGroup.getChildAt(index)\nview.visibility = View.VISIBLE\n</code></pre><p>}</p>\n<h5 id=\"循环遍历对象数组\"><a href=\"#循环遍历对象数组\" class=\"headerlink\" title=\"循环遍历对象数组\"></a>循环遍历对象数组</h5><pre><code>for (i in array.indices)\nprint(array[i])\n</code></pre><h4 id=\"延时执行任务\"><a href=\"#延时执行任务\" class=\"headerlink\" title=\"延时执行任务\"></a>延时执行任务</h4><p>java<br></p>\n<pre><code>mHandler.postDelayed(new Runnable() {\n                   @Override\n                   public void run() {\n                      //do something\n                   }\n               }, 3000);\n</code></pre><p>kotlin<br></p>\n<pre><code>mHandler.postDelayed(Runnable { //do something }, 3000)\n</code></pre><h4 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h4><h5 id=\"android提示框\"><a href=\"#android提示框\" class=\"headerlink\" title=\"android提示框\"></a>android提示框</h5><pre><code>builder.setPositiveButton(&quot;同意&quot;, object : DialogInterface.OnClickListener {\n            override fun onClick(dialog: DialogInterface?, which: Int) {\n\n            }\n\n        })\nbuilder.setPositiveButton(&quot;同意&quot;) { dialog, which -&gt;\n\n}\n</code></pre><h4 id=\"覆盖父类的方法\"><a href=\"#覆盖父类的方法\" class=\"headerlink\" title=\"覆盖父类的方法\"></a>覆盖父类的方法</h4><blockquote>\n<p>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final</p>\n</blockquote>\n"},{"layout":"post","title":"原型设计模式(一) 基础知识","date":"2017-03-18T00:00:00.000Z","_content":"\n* content\n{:toc}\n\n#### 定义 ####\n\n创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。\n\n>《设计模式》：<br/> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。\n\n\n\n#### 使用场景 ####\n\n-  创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限\n-  一个对象多个修改者-浅拷贝\n-  一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值\n-  在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者\n-  如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好\n\n\n#### 类图 ####\n\n![类图](/images/prototype_class_uml.png)\n\n#### 时序图 ####\n\n![时序图](/images/prototype_sequence_uml.png)\n\n#### 优点/缺点 ####\n\n- clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升\n- 逃避构造函数的约束(既是优点也是缺点)\n- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候\n- 必须实现cloneable接口(java)\n\n\n\n \n#### 深/浅复制 ####\n 浅复制：<br/>\n复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。\n<br/>\n深复制：<br/>\n对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br/>\n被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n \n\n#### 来自《effective java》的建议 ####\n\n>第11条：谨慎地覆盖clone\n\n克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。\n\n建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br/>\n\n\n","source":"_posts/2017-03-18-design-patterns-prototype-1.md","raw":"---\nlayout: post\ntitle:  原型设计模式(一) 基础知识\ndate:   2017-03-18\ncategories: work\ntag: 设计模式\n---\n\n* content\n{:toc}\n\n#### 定义 ####\n\n创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。\n\n>《设计模式》：<br/> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。\n\n\n\n#### 使用场景 ####\n\n-  创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限\n-  一个对象多个修改者-浅拷贝\n-  一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值\n-  在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者\n-  如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好\n\n\n#### 类图 ####\n\n![类图](/images/prototype_class_uml.png)\n\n#### 时序图 ####\n\n![时序图](/images/prototype_sequence_uml.png)\n\n#### 优点/缺点 ####\n\n- clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升\n- 逃避构造函数的约束(既是优点也是缺点)\n- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候\n- 必须实现cloneable接口(java)\n\n\n\n \n#### 深/浅复制 ####\n 浅复制：<br/>\n复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。\n<br/>\n深复制：<br/>\n对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br/>\n被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n \n\n#### 来自《effective java》的建议 ####\n\n>第11条：谨慎地覆盖clone\n\n克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。\n\n建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br/>\n\n\n","slug":"design-patterns-prototype-1","published":1,"updated":"2017-06-02T00:47:35.047Z","comments":1,"photos":[],"link":"","_id":"cj3tijdk0002mh8ivxuuygcn6","content":"<ul>\n<li>content<br>{:toc}</li>\n</ul>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。</p>\n<blockquote>\n<p>《设计模式》：<br> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p>\n</blockquote>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限</li>\n<li>一个对象多个修改者-浅拷贝</li>\n<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值</li>\n<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</li>\n<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好</li>\n</ul>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><p><img src=\"/images/prototype_class_uml.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/prototype_sequence_uml.png\" alt=\"时序图\"></p>\n<h4 id=\"优点-缺点\"><a href=\"#优点-缺点\" class=\"headerlink\" title=\"优点/缺点\"></a>优点/缺点</h4><ul>\n<li>clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升</li>\n<li>逃避构造函数的约束(既是优点也是缺点)</li>\n<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候</li>\n<li>必须实现cloneable接口(java)</li>\n</ul>\n<h4 id=\"深-浅复制\"><a href=\"#深-浅复制\" class=\"headerlink\" title=\"深/浅复制\"></a>深/浅复制</h4><p> 浅复制：<br><br>复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。<br><br><br>深复制：<br><br>对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br><br>被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>\n<h4 id=\"来自《effective-java》的建议\"><a href=\"#来自《effective-java》的建议\" class=\"headerlink\" title=\"来自《effective java》的建议\"></a>来自《effective java》的建议</h4><blockquote>\n<p>第11条：谨慎地覆盖clone</p>\n</blockquote>\n<p>克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。</p>\n<p>建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>content<br>{:toc}</li>\n</ul>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。</p>\n<blockquote>\n<p>《设计模式》：<br> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p>\n</blockquote>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限</li>\n<li>一个对象多个修改者-浅拷贝</li>\n<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值</li>\n<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</li>\n<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好</li>\n</ul>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><p><img src=\"/images/prototype_class_uml.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/prototype_sequence_uml.png\" alt=\"时序图\"></p>\n<h4 id=\"优点-缺点\"><a href=\"#优点-缺点\" class=\"headerlink\" title=\"优点/缺点\"></a>优点/缺点</h4><ul>\n<li>clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升</li>\n<li>逃避构造函数的约束(既是优点也是缺点)</li>\n<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候</li>\n<li>必须实现cloneable接口(java)</li>\n</ul>\n<h4 id=\"深-浅复制\"><a href=\"#深-浅复制\" class=\"headerlink\" title=\"深/浅复制\"></a>深/浅复制</h4><p> 浅复制：<br><br>复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。<br><br><br>深复制：<br><br>对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br><br>被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>\n<h4 id=\"来自《effective-java》的建议\"><a href=\"#来自《effective-java》的建议\" class=\"headerlink\" title=\"来自《effective java》的建议\"></a>来自《effective java》的建议</h4><blockquote>\n<p>第11条：谨慎地覆盖clone</p>\n</blockquote>\n<p>克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。</p>\n<p>建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br></p>\n"},{"layout":"post","title":"FindBugs常见错误提示及解决","date":"2017-04-01T00:00:00.000Z","_content":" \n\n\n#### ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD ####\n>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\n>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。\n\n\n原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。\n<br/>\n\n解决：通过get/set方法提供操作。\n\n#### DM_BOXED_PRIMITIVE_FOR_PARSING ####\n>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.\n>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。\n\n原因：\n\n- static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。\n- static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。\n- static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。\n\n解决：parseXXX方法代替valueOf\n\n#### SS_SHOULD_BE_STATIC ####\n>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.\n>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。\n\n解决方法：final的字段可以定义为static类型\n\n#### DLS_DEAD_LOCAL_STORE ####\n>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br/>\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\n该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br/>\n请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。\n\n解决方法：注释掉。\n\n\n#### SF_SWITCH_NO_DEFAULT ####\n>This method contains a switch statement where default case is missing. Usually you need to provide a default case.\nBecause the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn't contain break statements for other cases.\n此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。\n<br/>\n因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。\n\n解决方法：加上default。\n\n\n#### RV_RETURN_VALUE_IGNORED_BAD_PRACTICE ####\n\n>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the `File.delete()` method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an a typical return value. \n>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，`File.dlete()`方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。\n\n\n#### DC_DOUBLECHECK ####\n\n>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.\n\nsee more:[双重检查锁定与延迟初始化](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#)\n\n#### NM_METHOD_NAMING_CONVENTION ####\n\n>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.\n>方法名开头要小写。","source":"_posts/2017-04-01-findbug-notes.md","raw":"---\nlayout: post\ntitle:  FindBugs常见错误提示及解决\ndate:   2017-04-01\ncategories: work\ntag: 杂项\n---\n \n\n\n#### ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD ####\n>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\n>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。\n\n\n原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。\n<br/>\n\n解决：通过get/set方法提供操作。\n\n#### DM_BOXED_PRIMITIVE_FOR_PARSING ####\n>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.\n>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。\n\n原因：\n\n- static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。\n- static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。\n- static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。\n\n解决：parseXXX方法代替valueOf\n\n#### SS_SHOULD_BE_STATIC ####\n>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.\n>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。\n\n解决方法：final的字段可以定义为static类型\n\n#### DLS_DEAD_LOCAL_STORE ####\n>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br/>\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\n该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br/>\n请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。\n\n解决方法：注释掉。\n\n\n#### SF_SWITCH_NO_DEFAULT ####\n>This method contains a switch statement where default case is missing. Usually you need to provide a default case.\nBecause the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn't contain break statements for other cases.\n此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。\n<br/>\n因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。\n\n解决方法：加上default。\n\n\n#### RV_RETURN_VALUE_IGNORED_BAD_PRACTICE ####\n\n>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the `File.delete()` method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an a typical return value. \n>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，`File.dlete()`方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。\n\n\n#### DC_DOUBLECHECK ####\n\n>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.\n\nsee more:[双重检查锁定与延迟初始化](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#)\n\n#### NM_METHOD_NAMING_CONVENTION ####\n\n>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.\n>方法名开头要小写。","slug":"findbug-notes","published":1,"updated":"2017-06-01T07:21:04.950Z","comments":1,"photos":[],"link":"","_id":"cj3tijdk3002ph8iva6cyv54y","content":"<h4 id=\"ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\"><a href=\"#ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\" class=\"headerlink\" title=\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"></a>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><blockquote>\n<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。</p>\n</blockquote>\n<p>原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。<br><br></p>\n<p>解决：通过get/set方法提供操作。</p>\n<h4 id=\"DM-BOXED-PRIMITIVE-FOR-PARSING\"><a href=\"#DM-BOXED-PRIMITIVE-FOR-PARSING\" class=\"headerlink\" title=\"DM_BOXED_PRIMITIVE_FOR_PARSING\"></a>DM_BOXED_PRIMITIVE_FOR_PARSING</h4><blockquote>\n<p>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.<br>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。</p>\n</blockquote>\n<p>原因：</p>\n<ul>\n<li>static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。</li>\n<li>static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。</li>\n<li>static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。</li>\n</ul>\n<p>解决：parseXXX方法代替valueOf</p>\n<h4 id=\"SS-SHOULD-BE-STATIC\"><a href=\"#SS-SHOULD-BE-STATIC\" class=\"headerlink\" title=\"SS_SHOULD_BE_STATIC\"></a>SS_SHOULD_BE_STATIC</h4><blockquote>\n<p>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.<br>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。</p>\n</blockquote>\n<p>解决方法：final的字段可以定义为static类型</p>\n<h4 id=\"DLS-DEAD-LOCAL-STORE\"><a href=\"#DLS-DEAD-LOCAL-STORE\" class=\"headerlink\" title=\"DLS_DEAD_LOCAL_STORE\"></a>DLS_DEAD_LOCAL_STORE</h4><blockquote>\n<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br><br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br><br>请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。</p>\n</blockquote>\n<p>解决方法：注释掉。</p>\n<h4 id=\"SF-SWITCH-NO-DEFAULT\"><a href=\"#SF-SWITCH-NO-DEFAULT\" class=\"headerlink\" title=\"SF_SWITCH_NO_DEFAULT\"></a>SF_SWITCH_NO_DEFAULT</h4><blockquote>\n<p>This method contains a switch statement where default case is missing. Usually you need to provide a default case.<br>Because the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn’t contain break statements for other cases.<br>此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。<br><br><br>因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。</p>\n</blockquote>\n<p>解决方法：加上default。</p>\n<h4 id=\"RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\"><a href=\"#RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\" class=\"headerlink\" title=\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\"></a>RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><blockquote>\n<p>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the <code>File.delete()</code> method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an a typical return value.<br>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，<code>File.dlete()</code>方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。</p>\n</blockquote>\n<h4 id=\"DC-DOUBLECHECK\"><a href=\"#DC-DOUBLECHECK\" class=\"headerlink\" title=\"DC_DOUBLECHECK\"></a>DC_DOUBLECHECK</h4><blockquote>\n<p>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.</p>\n</blockquote>\n<p>see more:<a href=\"http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#\" target=\"_blank\" rel=\"external\">双重检查锁定与延迟初始化</a></p>\n<h4 id=\"NM-METHOD-NAMING-CONVENTION\"><a href=\"#NM-METHOD-NAMING-CONVENTION\" class=\"headerlink\" title=\"NM_METHOD_NAMING_CONVENTION\"></a>NM_METHOD_NAMING_CONVENTION</h4><blockquote>\n<p>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.<br>方法名开头要小写。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\"><a href=\"#ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\" class=\"headerlink\" title=\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"></a>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><blockquote>\n<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。</p>\n</blockquote>\n<p>原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。<br><br></p>\n<p>解决：通过get/set方法提供操作。</p>\n<h4 id=\"DM-BOXED-PRIMITIVE-FOR-PARSING\"><a href=\"#DM-BOXED-PRIMITIVE-FOR-PARSING\" class=\"headerlink\" title=\"DM_BOXED_PRIMITIVE_FOR_PARSING\"></a>DM_BOXED_PRIMITIVE_FOR_PARSING</h4><blockquote>\n<p>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.<br>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。</p>\n</blockquote>\n<p>原因：</p>\n<ul>\n<li>static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。</li>\n<li>static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。</li>\n<li>static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。</li>\n</ul>\n<p>解决：parseXXX方法代替valueOf</p>\n<h4 id=\"SS-SHOULD-BE-STATIC\"><a href=\"#SS-SHOULD-BE-STATIC\" class=\"headerlink\" title=\"SS_SHOULD_BE_STATIC\"></a>SS_SHOULD_BE_STATIC</h4><blockquote>\n<p>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.<br>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。</p>\n</blockquote>\n<p>解决方法：final的字段可以定义为static类型</p>\n<h4 id=\"DLS-DEAD-LOCAL-STORE\"><a href=\"#DLS-DEAD-LOCAL-STORE\" class=\"headerlink\" title=\"DLS_DEAD_LOCAL_STORE\"></a>DLS_DEAD_LOCAL_STORE</h4><blockquote>\n<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br><br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br><br>请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。</p>\n</blockquote>\n<p>解决方法：注释掉。</p>\n<h4 id=\"SF-SWITCH-NO-DEFAULT\"><a href=\"#SF-SWITCH-NO-DEFAULT\" class=\"headerlink\" title=\"SF_SWITCH_NO_DEFAULT\"></a>SF_SWITCH_NO_DEFAULT</h4><blockquote>\n<p>This method contains a switch statement where default case is missing. Usually you need to provide a default case.<br>Because the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn’t contain break statements for other cases.<br>此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。<br><br><br>因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。</p>\n</blockquote>\n<p>解决方法：加上default。</p>\n<h4 id=\"RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\"><a href=\"#RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\" class=\"headerlink\" title=\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\"></a>RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><blockquote>\n<p>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the <code>File.delete()</code> method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an a typical return value.<br>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，<code>File.dlete()</code>方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。</p>\n</blockquote>\n<h4 id=\"DC-DOUBLECHECK\"><a href=\"#DC-DOUBLECHECK\" class=\"headerlink\" title=\"DC_DOUBLECHECK\"></a>DC_DOUBLECHECK</h4><blockquote>\n<p>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.</p>\n</blockquote>\n<p>see more:<a href=\"http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#\" target=\"_blank\" rel=\"external\">双重检查锁定与延迟初始化</a></p>\n<h4 id=\"NM-METHOD-NAMING-CONVENTION\"><a href=\"#NM-METHOD-NAMING-CONVENTION\" class=\"headerlink\" title=\"NM_METHOD_NAMING_CONVENTION\"></a>NM_METHOD_NAMING_CONVENTION</h4><blockquote>\n<p>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.<br>方法名开头要小写。</p>\n</blockquote>\n"},{"layout":"post","title":"非比较排序之基数排序","date":"2017-04-10T00:00:00.000Z","_content":"\n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对`基数排序`有一定的理解 T.T。<br>\n好，言归正传。基数排序是[桶排序](http://xusx1024.com/2017/04/10/bucket-sort/)的一种特例。 \n\n#### 比较和非比较的区别 ####\n\n常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。\n\n在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。\n\n比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n\n计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。\n\n非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。\n\n非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。\n\n#### 算法原理 ####\n>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。\n<br>\n\n排序过程：<br>\n将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br>\n\n基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/RadixSort.html)。\n\n<br>\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n#### 效率 ####\n\n基数排序的时间复杂度是 **O(k·n)**，其中**n**是排序元素个数， **k**是数字位数。注意这不是说这个时间复杂度一定优于 **O(n·log(n))**， **k**的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； **k**决定了进行多少轮处理，而 **n**是每轮处理的操作数目。\n\n\n#### 实例分析 ####\n\n对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：\n\n![示例图](/images/radix_sort.png)\nJava代码如下：\n\t\n\tpackage RadixSort;\n\t\n\t/**\n\t * 基数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class RadixSort {\n\t\n\t\tprivate static int getMax(int[] array) {\n\t\t\tint max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tmax = i > max ? i : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t\n\t\tpublic static void radixSort(int[] array) {\n\t\t\tint exp = 1;// 个、十、百、千。。。位\n\t\t\tint max = getMax(array);\n\t\n\t\t\tfor (exp = 1; max / exp > 0; exp *= 10)\n\t\t\t\tcountSort(array, exp);\n\t\t}\n\t\n\t\tprivate static void countSort(int[] array, int exp) {\n\t\n\t\t\tint[] outputs = new int[array.length];\n\t\t\tint[] buckets = new int[10];// 0-9\n\t\n\t\t\t//统计array中对应位数的元素的个数\n\t\t\tfor (int i : array) {\n\t\t\t\tbuckets[(i / exp) % 10]++;\n\t\t\t}\n\t\t\t//统计array中，小于该位的元素的个数，相当于排序\n\t\t\tfor (int i = 1; i < buckets.length; i++) {\n\t\t\t\tbuckets[i] += buckets[i - 1];\n\t\t\t}\n\t\t\t//赋值\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\toutputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n\t\t\t\tbuckets[(array[i] / exp) % 10]--;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < outputs.length; i++) {\n\t\t\t\tarray[i] = outputs[i];\n\t\t\t}\n\t\t\toutputs = null;\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tprivate static void radixSort(int[] array, int d) {\n\t\t\tint n = 1;// 个、十、百、千。。。位\n\t\t\tint k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n\t\t\tint length = array.length;\n\t\t\tint[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n\t\t\tint[] order = new int[length];// 用于保存每个桶里有多少个数字\n\t\t\twhile (n < d) {\n\t\t\t\tfor (int num : array) // 将数组array里的每个数字放在相应的桶里\n\t\t\t\t{\n\t\t\t\t\tint digit = (num / n) % 10;\n\t\t\t\t\tbucket[digit][order[digit]] = num;\n\t\t\t\t\torder[digit]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n\t\t\t\t{\n\t\t\t\t\tif (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = 0; j < order[i]; j++) {\n\t\t\t\t\t\t\tarray[k] = bucket[i][j];\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\torder[i] = 0;// 将桶里计数器置0，用于下一次位排序\n\t\t\t\t}\n\t\t\t\tn *= 10;\n\t\t\t\tk = 0;// 将k置0，用于下一轮保存位排序结果\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"before===================================after\");\n\t\t\tradixSort(array);\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tint[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tradixSort(A, 100);\n\t\t\tSystem.out.println(\"\");\n\t\t\tfor (int i : A) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t}\n\t}\n","source":"_posts/2017-04-10-radix-sort.md","raw":"---\nlayout: post\ntitle:  非比较排序之基数排序\ndate:   2017-04-10\ncategories: work\ntag: 算法\n---\n\n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对`基数排序`有一定的理解 T.T。<br>\n好，言归正传。基数排序是[桶排序](http://xusx1024.com/2017/04/10/bucket-sort/)的一种特例。 \n\n#### 比较和非比较的区别 ####\n\n常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。\n\n在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。\n\n比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n\n计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。\n\n非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。\n\n非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。\n\n#### 算法原理 ####\n>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。\n<br>\n\n排序过程：<br>\n将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br>\n\n基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/RadixSort.html)。\n\n<br>\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n#### 效率 ####\n\n基数排序的时间复杂度是 **O(k·n)**，其中**n**是排序元素个数， **k**是数字位数。注意这不是说这个时间复杂度一定优于 **O(n·log(n))**， **k**的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； **k**决定了进行多少轮处理，而 **n**是每轮处理的操作数目。\n\n\n#### 实例分析 ####\n\n对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：\n\n![示例图](/images/radix_sort.png)\nJava代码如下：\n\t\n\tpackage RadixSort;\n\t\n\t/**\n\t * 基数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class RadixSort {\n\t\n\t\tprivate static int getMax(int[] array) {\n\t\t\tint max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tmax = i > max ? i : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t\n\t\tpublic static void radixSort(int[] array) {\n\t\t\tint exp = 1;// 个、十、百、千。。。位\n\t\t\tint max = getMax(array);\n\t\n\t\t\tfor (exp = 1; max / exp > 0; exp *= 10)\n\t\t\t\tcountSort(array, exp);\n\t\t}\n\t\n\t\tprivate static void countSort(int[] array, int exp) {\n\t\n\t\t\tint[] outputs = new int[array.length];\n\t\t\tint[] buckets = new int[10];// 0-9\n\t\n\t\t\t//统计array中对应位数的元素的个数\n\t\t\tfor (int i : array) {\n\t\t\t\tbuckets[(i / exp) % 10]++;\n\t\t\t}\n\t\t\t//统计array中，小于该位的元素的个数，相当于排序\n\t\t\tfor (int i = 1; i < buckets.length; i++) {\n\t\t\t\tbuckets[i] += buckets[i - 1];\n\t\t\t}\n\t\t\t//赋值\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\toutputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n\t\t\t\tbuckets[(array[i] / exp) % 10]--;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < outputs.length; i++) {\n\t\t\t\tarray[i] = outputs[i];\n\t\t\t}\n\t\t\toutputs = null;\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tprivate static void radixSort(int[] array, int d) {\n\t\t\tint n = 1;// 个、十、百、千。。。位\n\t\t\tint k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n\t\t\tint length = array.length;\n\t\t\tint[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n\t\t\tint[] order = new int[length];// 用于保存每个桶里有多少个数字\n\t\t\twhile (n < d) {\n\t\t\t\tfor (int num : array) // 将数组array里的每个数字放在相应的桶里\n\t\t\t\t{\n\t\t\t\t\tint digit = (num / n) % 10;\n\t\t\t\t\tbucket[digit][order[digit]] = num;\n\t\t\t\t\torder[digit]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n\t\t\t\t{\n\t\t\t\t\tif (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = 0; j < order[i]; j++) {\n\t\t\t\t\t\t\tarray[k] = bucket[i][j];\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\torder[i] = 0;// 将桶里计数器置0，用于下一次位排序\n\t\t\t\t}\n\t\t\t\tn *= 10;\n\t\t\t\tk = 0;// 将k置0，用于下一轮保存位排序结果\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"before===================================after\");\n\t\t\tradixSort(array);\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tint[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tradixSort(A, 100);\n\t\t\tSystem.out.println(\"\");\n\t\t\tfor (int i : A) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t}\n\t}\n","slug":"radix-sort","published":1,"updated":"2017-06-01T07:18:35.942Z","comments":1,"photos":[],"link":"","_id":"cj3tijdk6002sh8ivdzzosa13","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<code>基数排序</code>有一定的理解 T.T。<br><br>好，言归正传。基数排序是<a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">桶排序</a>的一种特例。 </p>\n<h4 id=\"比较和非比较的区别\"><a href=\"#比较和非比较的区别\" class=\"headerlink\" title=\"比较和非比较的区别\"></a>比较和非比较的区别</h4><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</p>\n<p>在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。</p>\n<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p>\n<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。</p>\n<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。<br><br></p>\n</blockquote>\n<p>排序过程：<br><br>将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br></p>\n<p>基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/RadixSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a>。</p>\n<p><br><br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<h4 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h4><p>基数排序的时间复杂度是 <strong>O(k·n)</strong>，其中<strong>n</strong>是排序元素个数， <strong>k</strong>是数字位数。注意这不是说这个时间复杂度一定优于 <strong>O(n·log(n))</strong>， <strong>k</strong>的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； <strong>k</strong>决定了进行多少轮处理，而 <strong>n</strong>是每轮处理的操作数目。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>\n<p><img src=\"/images/radix_sort.png\" alt=\"示例图\"><br>Java代码如下：</p>\n<pre><code>package RadixSort;\n\n/**\n * 基数排序\n * \n * @author sxx.xu\n *\n */\npublic class RadixSort {\n\n    private static int getMax(int[] array) {\n        int max = array[0];\n        for (int i : array) {\n            max = i &gt; max ? i : max;\n        }\n        return max;\n    }\n\n    public static void radixSort(int[] array) {\n        int exp = 1;// 个、十、百、千。。。位\n        int max = getMax(array);\n\n        for (exp = 1; max / exp &gt; 0; exp *= 10)\n            countSort(array, exp);\n    }\n\n    private static void countSort(int[] array, int exp) {\n\n        int[] outputs = new int[array.length];\n        int[] buckets = new int[10];// 0-9\n\n        //统计array中对应位数的元素的个数\n        for (int i : array) {\n            buckets[(i / exp) % 10]++;\n        }\n        //统计array中，小于该位的元素的个数，相当于排序\n        for (int i = 1; i &lt; buckets.length; i++) {\n            buckets[i] += buckets[i - 1];\n        }\n        //赋值\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            outputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n            buckets[(array[i] / exp) % 10]--;\n        }\n\n        for (int i = 0; i &lt; outputs.length; i++) {\n            array[i] = outputs[i];\n        }\n        outputs = null;\n        buckets = null;\n    }\n\n    private static void radixSort(int[] array, int d) {\n        int n = 1;// 个、十、百、千。。。位\n        int k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n        int length = array.length;\n        int[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n        int[] order = new int[length];// 用于保存每个桶里有多少个数字\n        while (n &lt; d) {\n            for (int num : array) // 将数组array里的每个数字放在相应的桶里\n            {\n                int digit = (num / n) % 10;\n                bucket[digit][order[digit]] = num;\n                order[digit]++;\n            }\n            for (int i = 0; i &lt; length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            {\n                if (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                {\n                    for (int j = 0; j &lt; order[i]; j++) {\n                        array[k] = bucket[i][j];\n                        k++;\n                    }\n                }\n                order[i] = 0;// 将桶里计数器置0，用于下一次位排序\n            }\n            n *= 10;\n            k = 0;// 将k置0，用于下一轮保存位排序结果\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        System.out.println(&quot;&quot;);\n        System.out.println(&quot;before===================================after&quot;);\n        radixSort(array);\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        int[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        radixSort(A, 100);\n        System.out.println(&quot;&quot;);\n        for (int i : A) {\n            System.out.print(i + &quot;  &quot;);\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<code>基数排序</code>有一定的理解 T.T。<br><br>好，言归正传。基数排序是<a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">桶排序</a>的一种特例。 </p>\n<h4 id=\"比较和非比较的区别\"><a href=\"#比较和非比较的区别\" class=\"headerlink\" title=\"比较和非比较的区别\"></a>比较和非比较的区别</h4><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</p>\n<p>在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。</p>\n<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p>\n<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。</p>\n<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。<br><br></p>\n</blockquote>\n<p>排序过程：<br><br>将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br></p>\n<p>基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/RadixSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a>。</p>\n<p><br><br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<h4 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h4><p>基数排序的时间复杂度是 <strong>O(k·n)</strong>，其中<strong>n</strong>是排序元素个数， <strong>k</strong>是数字位数。注意这不是说这个时间复杂度一定优于 <strong>O(n·log(n))</strong>， <strong>k</strong>的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； <strong>k</strong>决定了进行多少轮处理，而 <strong>n</strong>是每轮处理的操作数目。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>\n<p><img src=\"/images/radix_sort.png\" alt=\"示例图\"><br>Java代码如下：</p>\n<pre><code>package RadixSort;\n\n/**\n * 基数排序\n * \n * @author sxx.xu\n *\n */\npublic class RadixSort {\n\n    private static int getMax(int[] array) {\n        int max = array[0];\n        for (int i : array) {\n            max = i &gt; max ? i : max;\n        }\n        return max;\n    }\n\n    public static void radixSort(int[] array) {\n        int exp = 1;// 个、十、百、千。。。位\n        int max = getMax(array);\n\n        for (exp = 1; max / exp &gt; 0; exp *= 10)\n            countSort(array, exp);\n    }\n\n    private static void countSort(int[] array, int exp) {\n\n        int[] outputs = new int[array.length];\n        int[] buckets = new int[10];// 0-9\n\n        //统计array中对应位数的元素的个数\n        for (int i : array) {\n            buckets[(i / exp) % 10]++;\n        }\n        //统计array中，小于该位的元素的个数，相当于排序\n        for (int i = 1; i &lt; buckets.length; i++) {\n            buckets[i] += buckets[i - 1];\n        }\n        //赋值\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            outputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n            buckets[(array[i] / exp) % 10]--;\n        }\n\n        for (int i = 0; i &lt; outputs.length; i++) {\n            array[i] = outputs[i];\n        }\n        outputs = null;\n        buckets = null;\n    }\n\n    private static void radixSort(int[] array, int d) {\n        int n = 1;// 个、十、百、千。。。位\n        int k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n        int length = array.length;\n        int[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n        int[] order = new int[length];// 用于保存每个桶里有多少个数字\n        while (n &lt; d) {\n            for (int num : array) // 将数组array里的每个数字放在相应的桶里\n            {\n                int digit = (num / n) % 10;\n                bucket[digit][order[digit]] = num;\n                order[digit]++;\n            }\n            for (int i = 0; i &lt; length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            {\n                if (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                {\n                    for (int j = 0; j &lt; order[i]; j++) {\n                        array[k] = bucket[i][j];\n                        k++;\n                    }\n                }\n                order[i] = 0;// 将桶里计数器置0，用于下一次位排序\n            }\n            n *= 10;\n            k = 0;// 将k置0，用于下一轮保存位排序结果\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        System.out.println(&quot;&quot;);\n        System.out.println(&quot;before===================================after&quot;);\n        radixSort(array);\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        int[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        radixSort(A, 100);\n        System.out.println(&quot;&quot;);\n        for (int i : A) {\n            System.out.print(i + &quot;  &quot;);\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"非比较排序之桶/箱排序","date":"2017-04-10T00:00:00.000Z","_content":" \n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对[基数排序](http://xusx1024.com/2017/04/10/radix-sort/)有一定的理解 T.T，而基数排序是`桶排序`的一种特例。<br>\n\n#### 算法原理 ####\n\n>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：\n>\n>![示例图](/images/buckets_sort.png)\n>\n当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。\n\n<br>\n\n桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br>\n1. 将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。\n2. 分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。\n3. 对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。\n4. 按顺序从每个桶输出数据,排序完成。\n\n[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/BucketSort.html) 提供了一个桶排序的分步动画演示。\n\n#### 实例分析 ####\n设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：\n\n![示例图](/images/bucket-sort-1.png)\n\n然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：\n\n![示例图](/images/bucket-sort-2.png)\n\n\n#### 示例代码 ####\n\t\n\tpackage BuketsSort;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 桶排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class BuketsSort {\n\t\n\t\t/*\n\t\t * 桶排序\n\t\t *\n\t\t * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n\t\t */\n\t\tpublic static void bucketSort(int[] a, int max) {\n\t\t\tint[] buckets;\n\t\n\t\t\tif (a == null || max < 1)\n\t\t\t\treturn;\n\t\n\t\t\t// 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n\t\t\tbuckets = new int[max];\n\t\n\t\t\t// 1. 计数\n\t\t\tfor (int i = 0; i < a.length; i++)\n\t\t\t\tbuckets[a[i]]++;\n\t\n\t\t\t// 2. 排序\n\t\t\tfor (int i = 0, j = 0; i < max; i++) {\n\t\t\t\twhile ((buckets[i]--) > 0) {\n\t\t\t\t\ta[j++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tpublic static void bucketSort(int[] arr) {\n\t\t\t// 分桶，这里采用映射函数f(x)=x/10。\n\t\t\t// 输入数据为0~99之间的数字\n\t\t\tint bucketCount = 10;\n\t\t\tInteger[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tint quotient = arr[i] / 10; // 这里即是使用f(x)\n\t\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\t\tif (bucket[quotient][j] == null) {\n\t\t\t\t\t\tbucket[quotient][j] = arr[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 小桶排序\n\t\t\tfor (int i = 0; i < bucket.length; i++) {\n\t\t\t\t// insertion sort\n\t\t\t\tfor (int j = 1; j < bucket[i].length; ++j) {\n\t\t\t\t\tif (bucket[i][j] == null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint value = bucket[i][j];\n\t\t\t\t\tint position = j;\n\t\t\t\t\twhile (position > 0 && bucket[i][position - 1] > value) {\n\t\t\t\t\t\tbucket[i][position] = bucket[i][position - 1];\n\t\t\t\t\t\tposition--;\n\t\t\t\t\t}\n\t\t\t\t\tbucket[i][position] = value;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t// 输出\n\t\t\tfor (int i = 0, index = 0; i < bucket.length; i++) {\n\t\t\t\tfor (int j = 0; j < bucket[i].length; j++) {\n\t\t\t\t\tif (bucket[i][j] != null) {\n\t\t\t\t\t\tarr[index] = bucket[i][j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t public static void bucketSort2(int [] arr){  \n\t        //寻找数组中min，max，用于建桶  \n\t        int min = 0, max = 0;  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            if(arr[i] < min){  \n\t                min = arr[i];  \n\t            }  \n\t            if(arr[i] > max){  \n\t                max = arr[i];  \n\t            }  \n\t        }  \n\t        //开始建桶，注意桶的数量等于max - min + 1  \n\t        int bucketCount = max - min + 1;  \n\t        int[] bucket = new int[bucketCount];  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            bucket[arr[i] - min]++;  \n\t        }  \n\t        for(int i = 1; i < bucketCount; i++){  \n\t            bucket[i] = bucket[i] + bucket[i - 1];  \n\t        }  \n\t        //开始排序  \n\t        int [] copy = new int[arr.length];  \n\t        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\t          \n\t        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n\t        for(int i = arr.length - 1; i >= 0; i--){  \n\t            arr[--bucket[copy[i] - min]] = copy[i];  \n\t        }  \n\t        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n\t//      for(int i = 0; i <= arr.length - 1; i++){  \n\t//          arr[--bucket[copy[i] - min]] = copy[i];  \n\t//      }  \n\t    }  \n\t\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i;\n\t\t\tint a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\n\t\t\tSystem.out.printf(\"before sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\n\t//\t\tbucketSort(a, 10); // 桶排序\n\t//\t\tbucketSort(a); // 桶排序\n\t\t\tbucketSort2(a); // 桶排序\n\t\n\t\t\tSystem.out.printf(\"after  sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\t}\n\t}\n","source":"_posts/2017-04-10-bucket-sort.md","raw":"---\nlayout: post\ntitle:  非比较排序之桶/箱排序\ndate:   2017-04-10\ncategories: work\ntag: 算法\n---\n \n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对[基数排序](http://xusx1024.com/2017/04/10/radix-sort/)有一定的理解 T.T，而基数排序是`桶排序`的一种特例。<br>\n\n#### 算法原理 ####\n\n>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：\n>\n>![示例图](/images/buckets_sort.png)\n>\n当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。\n\n<br>\n\n桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br>\n1. 将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。\n2. 分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。\n3. 对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。\n4. 按顺序从每个桶输出数据,排序完成。\n\n[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/BucketSort.html) 提供了一个桶排序的分步动画演示。\n\n#### 实例分析 ####\n设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：\n\n![示例图](/images/bucket-sort-1.png)\n\n然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：\n\n![示例图](/images/bucket-sort-2.png)\n\n\n#### 示例代码 ####\n\t\n\tpackage BuketsSort;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 桶排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class BuketsSort {\n\t\n\t\t/*\n\t\t * 桶排序\n\t\t *\n\t\t * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n\t\t */\n\t\tpublic static void bucketSort(int[] a, int max) {\n\t\t\tint[] buckets;\n\t\n\t\t\tif (a == null || max < 1)\n\t\t\t\treturn;\n\t\n\t\t\t// 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n\t\t\tbuckets = new int[max];\n\t\n\t\t\t// 1. 计数\n\t\t\tfor (int i = 0; i < a.length; i++)\n\t\t\t\tbuckets[a[i]]++;\n\t\n\t\t\t// 2. 排序\n\t\t\tfor (int i = 0, j = 0; i < max; i++) {\n\t\t\t\twhile ((buckets[i]--) > 0) {\n\t\t\t\t\ta[j++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tpublic static void bucketSort(int[] arr) {\n\t\t\t// 分桶，这里采用映射函数f(x)=x/10。\n\t\t\t// 输入数据为0~99之间的数字\n\t\t\tint bucketCount = 10;\n\t\t\tInteger[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tint quotient = arr[i] / 10; // 这里即是使用f(x)\n\t\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\t\tif (bucket[quotient][j] == null) {\n\t\t\t\t\t\tbucket[quotient][j] = arr[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 小桶排序\n\t\t\tfor (int i = 0; i < bucket.length; i++) {\n\t\t\t\t// insertion sort\n\t\t\t\tfor (int j = 1; j < bucket[i].length; ++j) {\n\t\t\t\t\tif (bucket[i][j] == null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint value = bucket[i][j];\n\t\t\t\t\tint position = j;\n\t\t\t\t\twhile (position > 0 && bucket[i][position - 1] > value) {\n\t\t\t\t\t\tbucket[i][position] = bucket[i][position - 1];\n\t\t\t\t\t\tposition--;\n\t\t\t\t\t}\n\t\t\t\t\tbucket[i][position] = value;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t// 输出\n\t\t\tfor (int i = 0, index = 0; i < bucket.length; i++) {\n\t\t\t\tfor (int j = 0; j < bucket[i].length; j++) {\n\t\t\t\t\tif (bucket[i][j] != null) {\n\t\t\t\t\t\tarr[index] = bucket[i][j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t public static void bucketSort2(int [] arr){  \n\t        //寻找数组中min，max，用于建桶  \n\t        int min = 0, max = 0;  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            if(arr[i] < min){  \n\t                min = arr[i];  \n\t            }  \n\t            if(arr[i] > max){  \n\t                max = arr[i];  \n\t            }  \n\t        }  \n\t        //开始建桶，注意桶的数量等于max - min + 1  \n\t        int bucketCount = max - min + 1;  \n\t        int[] bucket = new int[bucketCount];  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            bucket[arr[i] - min]++;  \n\t        }  \n\t        for(int i = 1; i < bucketCount; i++){  \n\t            bucket[i] = bucket[i] + bucket[i - 1];  \n\t        }  \n\t        //开始排序  \n\t        int [] copy = new int[arr.length];  \n\t        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\t          \n\t        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n\t        for(int i = arr.length - 1; i >= 0; i--){  \n\t            arr[--bucket[copy[i] - min]] = copy[i];  \n\t        }  \n\t        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n\t//      for(int i = 0; i <= arr.length - 1; i++){  \n\t//          arr[--bucket[copy[i] - min]] = copy[i];  \n\t//      }  \n\t    }  \n\t\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i;\n\t\t\tint a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\n\t\t\tSystem.out.printf(\"before sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\n\t//\t\tbucketSort(a, 10); // 桶排序\n\t//\t\tbucketSort(a); // 桶排序\n\t\t\tbucketSort2(a); // 桶排序\n\t\n\t\t\tSystem.out.printf(\"after  sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\t}\n\t}\n","slug":"bucket-sort","published":1,"updated":"2017-06-01T07:20:15.911Z","comments":1,"photos":[],"link":"","_id":"cj3tijdk8002vh8ivwfe7kdvw","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序</a>有一定的理解 T.T，而基数排序是<code>桶排序</code>的一种特例。<br></p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：</p>\n<p><img src=\"/images/buckets_sort.png\" alt=\"示例图\"></p>\n<p>当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。</p>\n</blockquote>\n<p><br></p>\n<p>桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br></p>\n<ol>\n<li>将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。</li>\n<li>分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。</li>\n<li>对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。</li>\n<li>按顺序从每个桶输出数据,排序完成。</li>\n</ol>\n<p><a href=\"http://www.cs.usfca.edu/~galles/visualization/BucketSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p>\n<p><img src=\"/images/bucket-sort-1.png\" alt=\"示例图\"></p>\n<p>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p>\n<p><img src=\"/images/bucket-sort-2.png\" alt=\"示例图\"></p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre><code>package BuketsSort;\n\nimport java.util.Arrays;\n\n/**\n * 桶排序\n * \n * @author sxx.xu\n *\n */\npublic class BuketsSort {\n\n    /*\n     * 桶排序\n     *\n     * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n     */\n    public static void bucketSort(int[] a, int max) {\n        int[] buckets;\n\n        if (a == null || max &lt; 1)\n            return;\n\n        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n        buckets = new int[max];\n\n        // 1. 计数\n        for (int i = 0; i &lt; a.length; i++)\n            buckets[a[i]]++;\n\n        // 2. 排序\n        for (int i = 0, j = 0; i &lt; max; i++) {\n            while ((buckets[i]--) &gt; 0) {\n                a[j++] = i;\n            }\n        }\n\n        buckets = null;\n    }\n\n    public static void bucketSort(int[] arr) {\n        // 分桶，这里采用映射函数f(x)=x/10。\n        // 输入数据为0~99之间的数字\n        int bucketCount = 10;\n        Integer[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n        for (int i = 0; i &lt; arr.length; i++) {\n            int quotient = arr[i] / 10; // 这里即是使用f(x)\n            for (int j = 0; j &lt; arr.length; j++) {\n                if (bucket[quotient][j] == null) {\n                    bucket[quotient][j] = arr[i];\n                    break;\n                }\n            }\n        }\n        // 小桶排序\n        for (int i = 0; i &lt; bucket.length; i++) {\n            // insertion sort\n            for (int j = 1; j &lt; bucket[i].length; ++j) {\n                if (bucket[i][j] == null) {\n                    break;\n                }\n                int value = bucket[i][j];\n                int position = j;\n                while (position &gt; 0 &amp;&amp; bucket[i][position - 1] &gt; value) {\n                    bucket[i][position] = bucket[i][position - 1];\n                    position--;\n                }\n                bucket[i][position] = value;\n            }\n\n        }\n        // 输出\n        for (int i = 0, index = 0; i &lt; bucket.length; i++) {\n            for (int j = 0; j &lt; bucket[i].length; j++) {\n                if (bucket[i][j] != null) {\n                    arr[index] = bucket[i][j];\n                    index++;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n public static void bucketSort2(int [] arr){  \n        //寻找数组中min，max，用于建桶  \n        int min = 0, max = 0;  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            if(arr[i] &lt; min){  \n                min = arr[i];  \n            }  \n            if(arr[i] &gt; max){  \n                max = arr[i];  \n            }  \n        }  \n        //开始建桶，注意桶的数量等于max - min + 1  \n        int bucketCount = max - min + 1;  \n        int[] bucket = new int[bucketCount];  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            bucket[arr[i] - min]++;  \n        }  \n        for(int i = 1; i &lt; bucketCount; i++){  \n            bucket[i] = bucket[i] + bucket[i - 1];  \n        }  \n        //开始排序  \n        int [] copy = new int[arr.length];  \n        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\n        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n        for(int i = arr.length - 1; i &gt;= 0; i--){  \n            arr[--bucket[copy[i] - min]] = copy[i];  \n        }  \n        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n//      for(int i = 0; i &lt;= arr.length - 1; i++){  \n//          arr[--bucket[copy[i] - min]] = copy[i];  \n//      }  \n    }  \n\n\n    public static void main(String[] args) {\n        int i;\n        int a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\n        System.out.printf(&quot;before sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n\n//        bucketSort(a, 10); // 桶排序\n//        bucketSort(a); // 桶排序\n        bucketSort2(a); // 桶排序\n\n        System.out.printf(&quot;after  sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序</a>有一定的理解 T.T，而基数排序是<code>桶排序</code>的一种特例。<br></p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：</p>\n<p><img src=\"/images/buckets_sort.png\" alt=\"示例图\"></p>\n<p>当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。</p>\n</blockquote>\n<p><br></p>\n<p>桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br></p>\n<ol>\n<li>将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。</li>\n<li>分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。</li>\n<li>对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。</li>\n<li>按顺序从每个桶输出数据,排序完成。</li>\n</ol>\n<p><a href=\"http://www.cs.usfca.edu/~galles/visualization/BucketSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p>\n<p><img src=\"/images/bucket-sort-1.png\" alt=\"示例图\"></p>\n<p>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p>\n<p><img src=\"/images/bucket-sort-2.png\" alt=\"示例图\"></p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre><code>package BuketsSort;\n\nimport java.util.Arrays;\n\n/**\n * 桶排序\n * \n * @author sxx.xu\n *\n */\npublic class BuketsSort {\n\n    /*\n     * 桶排序\n     *\n     * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n     */\n    public static void bucketSort(int[] a, int max) {\n        int[] buckets;\n\n        if (a == null || max &lt; 1)\n            return;\n\n        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n        buckets = new int[max];\n\n        // 1. 计数\n        for (int i = 0; i &lt; a.length; i++)\n            buckets[a[i]]++;\n\n        // 2. 排序\n        for (int i = 0, j = 0; i &lt; max; i++) {\n            while ((buckets[i]--) &gt; 0) {\n                a[j++] = i;\n            }\n        }\n\n        buckets = null;\n    }\n\n    public static void bucketSort(int[] arr) {\n        // 分桶，这里采用映射函数f(x)=x/10。\n        // 输入数据为0~99之间的数字\n        int bucketCount = 10;\n        Integer[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n        for (int i = 0; i &lt; arr.length; i++) {\n            int quotient = arr[i] / 10; // 这里即是使用f(x)\n            for (int j = 0; j &lt; arr.length; j++) {\n                if (bucket[quotient][j] == null) {\n                    bucket[quotient][j] = arr[i];\n                    break;\n                }\n            }\n        }\n        // 小桶排序\n        for (int i = 0; i &lt; bucket.length; i++) {\n            // insertion sort\n            for (int j = 1; j &lt; bucket[i].length; ++j) {\n                if (bucket[i][j] == null) {\n                    break;\n                }\n                int value = bucket[i][j];\n                int position = j;\n                while (position &gt; 0 &amp;&amp; bucket[i][position - 1] &gt; value) {\n                    bucket[i][position] = bucket[i][position - 1];\n                    position--;\n                }\n                bucket[i][position] = value;\n            }\n\n        }\n        // 输出\n        for (int i = 0, index = 0; i &lt; bucket.length; i++) {\n            for (int j = 0; j &lt; bucket[i].length; j++) {\n                if (bucket[i][j] != null) {\n                    arr[index] = bucket[i][j];\n                    index++;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n public static void bucketSort2(int [] arr){  \n        //寻找数组中min，max，用于建桶  \n        int min = 0, max = 0;  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            if(arr[i] &lt; min){  \n                min = arr[i];  \n            }  \n            if(arr[i] &gt; max){  \n                max = arr[i];  \n            }  \n        }  \n        //开始建桶，注意桶的数量等于max - min + 1  \n        int bucketCount = max - min + 1;  \n        int[] bucket = new int[bucketCount];  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            bucket[arr[i] - min]++;  \n        }  \n        for(int i = 1; i &lt; bucketCount; i++){  \n            bucket[i] = bucket[i] + bucket[i - 1];  \n        }  \n        //开始排序  \n        int [] copy = new int[arr.length];  \n        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\n        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n        for(int i = arr.length - 1; i &gt;= 0; i--){  \n            arr[--bucket[copy[i] - min]] = copy[i];  \n        }  \n        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n//      for(int i = 0; i &lt;= arr.length - 1; i++){  \n//          arr[--bucket[copy[i] - min]] = copy[i];  \n//      }  \n    }  \n\n\n    public static void main(String[] args) {\n        int i;\n        int a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\n        System.out.printf(&quot;before sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n\n//        bucketSort(a, 10); // 桶排序\n//        bucketSort(a); // 桶排序\n        bucketSort2(a); // 桶排序\n\n        System.out.printf(&quot;after  sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n    }\n}\n</code></pre>"},{"layout":"post","title":"非比较排序之计数排序","date":"2017-04-11T00:00:00.000Z","_content":" \n\n\n#### 简介 ####\n\n[计数排序wiki](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F) <br>\n\n- 计数排序是用来排序0到100之间的数字的最好的算法\n- 计数排序可以用在基数排序中的算法来排序数据范围很大的数组\n- 计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序\n- 计数排序的优势是对已知数量范围的数组进行排序\n- 基于比较的排序算法是不能突破O(NlogN)\n\n\n \n\n#### 算法原理 ####\n \n1. 找出待排序的数组中最大和最小的元素\n1. 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项\n1. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n1. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n\n\n#### 实例分析 ####\n\n具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/CountingSort.html)\n\n<br>\n对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：\n \n![示例图](/images/counting_sort_1.png)<br>\n![示例图](/images/counting_sort_2.png)\n\n\n#### 代码 ####\n\tpackage CountingSort;\n\t\n\t/**\n\t * 计数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class CountingSort {\n\t \n\t\tprivate static void countingSort(int[] array) {\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i];\n\t\t\t\tint index = countArray[elem] - 1;\n\t\t\t\tcountResult[index] = elem;\n\t\t\t\tSystem.out.println(\"当前元素为：\" + elem + \";在排序数组中的位置是：\" + index);\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\n\t\t\t// 桶排序\n\t\t\t// int[][] resultArray = new int[countArray.length][countArray.length];\n\t\t\t// for (int i = 0; i < countArray.length; i++) {\n\t\t\t// for (int j = 0; j < countArray[i]; j++) {\n\t\t\t// resultArray[i][j] = i;\n\t\t\t// }\n\t\t\t// }\n\t\t\t//\n\t\t\t// for (int i = 0; i < resultArray.length; i++) {\n\t\t\t// for (int j = 0; j < resultArray[i].length; j++) {\n\t\t\t// if (resultArray[i][j] != 0)\n\t\t\t// System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\t\n\t\t/**\n\t\t * 优化后的，减少中间数组大小\n\t\t * @param array\n\t\t */\n\t\tprivate static void countingSort2(int[] array) {\n\t\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max - min + 1];\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i - min]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i] - min;\n\t\t\t\tint index = countArray[array[i] - min] - 1;\n\t\t\t\tcountResult[index] = array[i];\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\t\tint[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n\t\t\tcountingSort(array);\n\t\t\tcountingSort2(array);\n\t\t}\n\t}\n","source":"_posts/2017-04-11-counting-sort.md","raw":"---\nlayout: post\ntitle:  非比较排序之计数排序\ndate:   2017-04-11\ncategories: work\ntag: 算法\n---\n \n\n\n#### 简介 ####\n\n[计数排序wiki](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F) <br>\n\n- 计数排序是用来排序0到100之间的数字的最好的算法\n- 计数排序可以用在基数排序中的算法来排序数据范围很大的数组\n- 计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序\n- 计数排序的优势是对已知数量范围的数组进行排序\n- 基于比较的排序算法是不能突破O(NlogN)\n\n\n \n\n#### 算法原理 ####\n \n1. 找出待排序的数组中最大和最小的元素\n1. 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项\n1. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n1. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n\n\n#### 实例分析 ####\n\n具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/CountingSort.html)\n\n<br>\n对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：\n \n![示例图](/images/counting_sort_1.png)<br>\n![示例图](/images/counting_sort_2.png)\n\n\n#### 代码 ####\n\tpackage CountingSort;\n\t\n\t/**\n\t * 计数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class CountingSort {\n\t \n\t\tprivate static void countingSort(int[] array) {\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i];\n\t\t\t\tint index = countArray[elem] - 1;\n\t\t\t\tcountResult[index] = elem;\n\t\t\t\tSystem.out.println(\"当前元素为：\" + elem + \";在排序数组中的位置是：\" + index);\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\n\t\t\t// 桶排序\n\t\t\t// int[][] resultArray = new int[countArray.length][countArray.length];\n\t\t\t// for (int i = 0; i < countArray.length; i++) {\n\t\t\t// for (int j = 0; j < countArray[i]; j++) {\n\t\t\t// resultArray[i][j] = i;\n\t\t\t// }\n\t\t\t// }\n\t\t\t//\n\t\t\t// for (int i = 0; i < resultArray.length; i++) {\n\t\t\t// for (int j = 0; j < resultArray[i].length; j++) {\n\t\t\t// if (resultArray[i][j] != 0)\n\t\t\t// System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\t\n\t\t/**\n\t\t * 优化后的，减少中间数组大小\n\t\t * @param array\n\t\t */\n\t\tprivate static void countingSort2(int[] array) {\n\t\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max - min + 1];\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i - min]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i] - min;\n\t\t\t\tint index = countArray[array[i] - min] - 1;\n\t\t\t\tcountResult[index] = array[i];\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\t\tint[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n\t\t\tcountingSort(array);\n\t\t\tcountingSort2(array);\n\t\t}\n\t}\n","slug":"counting-sort","published":1,"updated":"2017-06-01T07:17:18.448Z","comments":1,"photos":[],"link":"","_id":"cj3tijdka002yh8ivokg4q7jc","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"external\">计数排序wiki</a> <br></p>\n<ul>\n<li>计数排序是用来排序0到100之间的数字的最好的算法</li>\n<li>计数排序可以用在基数排序中的算法来排序数据范围很大的数组</li>\n<li>计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序</li>\n<li>计数排序的优势是对已知数量范围的数组进行排序</li>\n<li>基于比较的排序算法是不能突破O(NlogN)</li>\n</ul>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>找出待排序的数组中最大和最小的元素</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>\n</ol>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/CountingSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a></p>\n<p><br><br>对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：</p>\n<p><img src=\"/images/counting_sort_1.png\" alt=\"示例图\"><br><br><img src=\"/images/counting_sort_2.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package CountingSort;\n\n/**\n * 计数排序\n * \n * @author sxx.xu\n *\n */\npublic class CountingSort {\n\n    private static void countingSort(int[] array) {\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i];\n            int index = countArray[elem] - 1;\n            countResult[index] = elem;\n            System.out.println(&quot;当前元素为：&quot; + elem + &quot;;在排序数组中的位置是：&quot; + index);\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n\n        // 桶排序\n        // int[][] resultArray = new int[countArray.length][countArray.length];\n        // for (int i = 0; i &lt; countArray.length; i++) {\n        // for (int j = 0; j &lt; countArray[i]; j++) {\n        // resultArray[i][j] = i;\n        // }\n        // }\n        //\n        // for (int i = 0; i &lt; resultArray.length; i++) {\n        // for (int j = 0; j &lt; resultArray[i].length; j++) {\n        // if (resultArray[i][j] != 0)\n        // System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n        // }\n        // }\n    }\n\n    /**\n     * 优化后的，减少中间数组大小\n     * @param array\n     */\n    private static void countingSort2(int[] array) {\n\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max - min + 1];\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i - min]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i] - min;\n            int index = countArray[array[i] - min] - 1;\n            countResult[index] = array[i];\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n        int[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n        countingSort(array);\n        countingSort2(array);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"external\">计数排序wiki</a> <br></p>\n<ul>\n<li>计数排序是用来排序0到100之间的数字的最好的算法</li>\n<li>计数排序可以用在基数排序中的算法来排序数据范围很大的数组</li>\n<li>计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序</li>\n<li>计数排序的优势是对已知数量范围的数组进行排序</li>\n<li>基于比较的排序算法是不能突破O(NlogN)</li>\n</ul>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>找出待排序的数组中最大和最小的元素</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>\n</ol>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/CountingSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a></p>\n<p><br><br>对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：</p>\n<p><img src=\"/images/counting_sort_1.png\" alt=\"示例图\"><br><br><img src=\"/images/counting_sort_2.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package CountingSort;\n\n/**\n * 计数排序\n * \n * @author sxx.xu\n *\n */\npublic class CountingSort {\n\n    private static void countingSort(int[] array) {\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i];\n            int index = countArray[elem] - 1;\n            countResult[index] = elem;\n            System.out.println(&quot;当前元素为：&quot; + elem + &quot;;在排序数组中的位置是：&quot; + index);\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n\n        // 桶排序\n        // int[][] resultArray = new int[countArray.length][countArray.length];\n        // for (int i = 0; i &lt; countArray.length; i++) {\n        // for (int j = 0; j &lt; countArray[i]; j++) {\n        // resultArray[i][j] = i;\n        // }\n        // }\n        //\n        // for (int i = 0; i &lt; resultArray.length; i++) {\n        // for (int j = 0; j &lt; resultArray[i].length; j++) {\n        // if (resultArray[i][j] != 0)\n        // System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n        // }\n        // }\n    }\n\n    /**\n     * 优化后的，减少中间数组大小\n     * @param array\n     */\n    private static void countingSort2(int[] array) {\n\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max - min + 1];\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i - min]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i] - min;\n            int index = countArray[array[i] - min] - 1;\n            countResult[index] = array[i];\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n        int[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n        countingSort(array);\n        countingSort2(array);\n    }\n}\n</code></pre>"},{"layout":"post","title":"Tinker学习(一)热修复基础知识","date":"2017-03-15T00:00:00.000Z","_content":"  \n\n#### Dalvik ####\n \nDalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的`文件执行格式dex（dalvik executable）`，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。\n\n通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如[Apktool](https://ibotpeaches.github.io/Apktool/install/)或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。\n\n当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。\n\n但是在早期的 Android 系统中，DexOpt 有两个问题。<br/>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br/>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。\n<br/>\n#### ART ####\n\n即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.\n\n- 系统性能大幅提升\n- App启动、运行更快\n- 减少每次启动的编译增加电池续航\n- 存储占用更大\n- 安装时间更长\n\n还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。\n<br/>\n#### Dalvik vs ART ####\n\nDalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。\n\n在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。\n\nART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。\n \n![示例图](/images/dalvik&art.png)\n\n<br/>\n#### dex（dalvik executable） ####\n\nDex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br/>\n\n\n.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br/>\n\nodex（optimised dex）,优化后的dex。\n\n#### 主流修复方案：Native hook ####\n\n以[AndFix](https://github.com/alibaba/AndFix)最著名。原理如下图：\n \n![示例图](/images/andfix-yuanli.png)\n\n其修复过程如图：\n \n![示例图](/images/andfix-guocheng.png)\n\n这套方案直接使用`dalvik_replaceMethod`替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。\n\n#### 主流修复方案：基于android dex分包 ####\n\n详细原理介绍[传送](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a)。\n\n我用自己的话总结一下：<br/>\n1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br/>\n2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加`CLASS_ISPREVERIFIED`标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br/>\n3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。\n\n#### 主流修复方案：基于Instant Run的冷插拔原理的Dex替换 ####\n\n- 热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；\n- 温插拔：需要重建页面，典型代表：修改了Resource文件；\n- 冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。\n\n\nTinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。","source":"_posts/2017-03-15-tinker-source-code-1.md","raw":"---\nlayout: post\ntitle:  Tinker学习(一)热修复基础知识\ndate:   2017-03-15\ncategories: work\ntag: android\n---\n  \n\n#### Dalvik ####\n \nDalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的`文件执行格式dex（dalvik executable）`，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。\n\n通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如[Apktool](https://ibotpeaches.github.io/Apktool/install/)或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。\n\n当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。\n\n但是在早期的 Android 系统中，DexOpt 有两个问题。<br/>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br/>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。\n<br/>\n#### ART ####\n\n即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.\n\n- 系统性能大幅提升\n- App启动、运行更快\n- 减少每次启动的编译增加电池续航\n- 存储占用更大\n- 安装时间更长\n\n还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。\n<br/>\n#### Dalvik vs ART ####\n\nDalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。\n\n在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。\n\nART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。\n \n![示例图](/images/dalvik&art.png)\n\n<br/>\n#### dex（dalvik executable） ####\n\nDex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br/>\n\n\n.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br/>\n\nodex（optimised dex）,优化后的dex。\n\n#### 主流修复方案：Native hook ####\n\n以[AndFix](https://github.com/alibaba/AndFix)最著名。原理如下图：\n \n![示例图](/images/andfix-yuanli.png)\n\n其修复过程如图：\n \n![示例图](/images/andfix-guocheng.png)\n\n这套方案直接使用`dalvik_replaceMethod`替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。\n\n#### 主流修复方案：基于android dex分包 ####\n\n详细原理介绍[传送](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a)。\n\n我用自己的话总结一下：<br/>\n1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br/>\n2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加`CLASS_ISPREVERIFIED`标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br/>\n3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。\n\n#### 主流修复方案：基于Instant Run的冷插拔原理的Dex替换 ####\n\n- 热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；\n- 温插拔：需要重建页面，典型代表：修改了Resource文件；\n- 冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。\n\n\nTinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。","slug":"tinker-source-code-1","published":1,"updated":"2017-06-01T07:26:06.132Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkc0031h8iv7uki82ui","content":"<h4 id=\"Dalvik\"><a href=\"#Dalvik\" class=\"headerlink\" title=\"Dalvik\"></a>Dalvik</h4><p>Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的<code>文件执行格式dex（dalvik executable）</code>，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p>\n<p>通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如<a href=\"https://ibotpeaches.github.io/Apktool/install/\" target=\"_blank\" rel=\"external\">Apktool</a>或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。</p>\n<p>当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。</p>\n<p>但是在早期的 Android 系统中，DexOpt 有两个问题。<br>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。<br><br></p>\n<h4 id=\"ART\"><a href=\"#ART\" class=\"headerlink\" title=\"ART\"></a>ART</h4><p>即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.</p>\n<ul>\n<li>系统性能大幅提升</li>\n<li>App启动、运行更快</li>\n<li>减少每次启动的编译增加电池续航</li>\n<li>存储占用更大</li>\n<li>安装时间更长</li>\n</ul>\n<p>还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。<br><br></p>\n<h4 id=\"Dalvik-vs-ART\"><a href=\"#Dalvik-vs-ART\" class=\"headerlink\" title=\"Dalvik vs ART\"></a>Dalvik vs ART</h4><p>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>\n<p>在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。</p>\n<p>ART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。</p>\n<p><img src=\"/images/dalvik&amp;art.png\" alt=\"示例图\"></p>\n<p><br></p>\n<h4 id=\"dex（dalvik-executable）\"><a href=\"#dex（dalvik-executable）\" class=\"headerlink\" title=\"dex（dalvik executable）\"></a>dex（dalvik executable）</h4><p>Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br></p>\n<p>.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br></p>\n<p>odex（optimised dex）,优化后的dex。</p>\n<h4 id=\"主流修复方案：Native-hook\"><a href=\"#主流修复方案：Native-hook\" class=\"headerlink\" title=\"主流修复方案：Native hook\"></a>主流修复方案：Native hook</h4><p>以<a href=\"https://github.com/alibaba/AndFix\" target=\"_blank\" rel=\"external\">AndFix</a>最著名。原理如下图：</p>\n<p><img src=\"/images/andfix-yuanli.png\" alt=\"示例图\"></p>\n<p>其修复过程如图：</p>\n<p><img src=\"/images/andfix-guocheng.png\" alt=\"示例图\"></p>\n<p>这套方案直接使用<code>dalvik_replaceMethod</code>替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。</p>\n<h4 id=\"主流修复方案：基于android-dex分包\"><a href=\"#主流修复方案：基于android-dex分包\" class=\"headerlink\" title=\"主流修复方案：基于android dex分包\"></a>主流修复方案：基于android dex分包</h4><p>详细原理介绍<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p>我用自己的话总结一下：<br><br>1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br><br>2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加<code>CLASS_ISPREVERIFIED</code>标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br><br>3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。</p>\n<h4 id=\"主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\"><a href=\"#主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\" class=\"headerlink\" title=\"主流修复方案：基于Instant Run的冷插拔原理的Dex替换\"></a>主流修复方案：基于Instant Run的冷插拔原理的Dex替换</h4><ul>\n<li>热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；</li>\n<li>温插拔：需要重建页面，典型代表：修改了Resource文件；</li>\n<li>冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。</li>\n</ul>\n<p>Tinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Dalvik\"><a href=\"#Dalvik\" class=\"headerlink\" title=\"Dalvik\"></a>Dalvik</h4><p>Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的<code>文件执行格式dex（dalvik executable）</code>，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p>\n<p>通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如<a href=\"https://ibotpeaches.github.io/Apktool/install/\" target=\"_blank\" rel=\"external\">Apktool</a>或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。</p>\n<p>当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。</p>\n<p>但是在早期的 Android 系统中，DexOpt 有两个问题。<br>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。<br><br></p>\n<h4 id=\"ART\"><a href=\"#ART\" class=\"headerlink\" title=\"ART\"></a>ART</h4><p>即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.</p>\n<ul>\n<li>系统性能大幅提升</li>\n<li>App启动、运行更快</li>\n<li>减少每次启动的编译增加电池续航</li>\n<li>存储占用更大</li>\n<li>安装时间更长</li>\n</ul>\n<p>还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。<br><br></p>\n<h4 id=\"Dalvik-vs-ART\"><a href=\"#Dalvik-vs-ART\" class=\"headerlink\" title=\"Dalvik vs ART\"></a>Dalvik vs ART</h4><p>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>\n<p>在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。</p>\n<p>ART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。</p>\n<p><img src=\"/images/dalvik&amp;art.png\" alt=\"示例图\"></p>\n<p><br></p>\n<h4 id=\"dex（dalvik-executable）\"><a href=\"#dex（dalvik-executable）\" class=\"headerlink\" title=\"dex（dalvik executable）\"></a>dex（dalvik executable）</h4><p>Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br></p>\n<p>.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br></p>\n<p>odex（optimised dex）,优化后的dex。</p>\n<h4 id=\"主流修复方案：Native-hook\"><a href=\"#主流修复方案：Native-hook\" class=\"headerlink\" title=\"主流修复方案：Native hook\"></a>主流修复方案：Native hook</h4><p>以<a href=\"https://github.com/alibaba/AndFix\" target=\"_blank\" rel=\"external\">AndFix</a>最著名。原理如下图：</p>\n<p><img src=\"/images/andfix-yuanli.png\" alt=\"示例图\"></p>\n<p>其修复过程如图：</p>\n<p><img src=\"/images/andfix-guocheng.png\" alt=\"示例图\"></p>\n<p>这套方案直接使用<code>dalvik_replaceMethod</code>替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。</p>\n<h4 id=\"主流修复方案：基于android-dex分包\"><a href=\"#主流修复方案：基于android-dex分包\" class=\"headerlink\" title=\"主流修复方案：基于android dex分包\"></a>主流修复方案：基于android dex分包</h4><p>详细原理介绍<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p>我用自己的话总结一下：<br><br>1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br><br>2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加<code>CLASS_ISPREVERIFIED</code>标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br><br>3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。</p>\n<h4 id=\"主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\"><a href=\"#主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\" class=\"headerlink\" title=\"主流修复方案：基于Instant Run的冷插拔原理的Dex替换\"></a>主流修复方案：基于Instant Run的冷插拔原理的Dex替换</h4><ul>\n<li>热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；</li>\n<li>温插拔：需要重建页面，典型代表：修改了Resource文件；</li>\n<li>冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。</li>\n</ul>\n<p>Tinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。</p>\n"},{"layout":"post","title":"基于(前缀)倍增算法实现后缀数组","date":"2017-04-11T00:00:00.000Z","_content":" \n\n#### 简介 ####\n有几个基本概念需要知道。<br>\n\n>\n1. **子串：**字符串S的子串r[i...j],i <= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],...,r[j]形成的字符串;\n2. **后缀：**从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i...len(r)];<br>\n3. **大小比较：**关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]>v[i]则认为u>v，反之则认为u<v，比较结束。如果i>len(u)或者i>len(v)仍比较不出结果，那么若len(u)>len(v)，则认为u>v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。\n4. **后缀数组：**后缀数组SA是一个一维数组，它保存1...n的某个排列SA[1],SA[2],...,SA[n],并且保证suffix(SA[i])<suffix(SA[i+1]), 1 <= i < n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。\n5. **名次数组：**名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。\n6. **height数组：**定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀\n7. **LCP(i,j):**对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。\n\n#### 算法原理 ####\n\n Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用[基数排序(radix sort)](http://xusx1024.com/2017/04/10/radix-sort/)算法，先后对两位数字排序，可以采用[计数排序算法(counting sort)](http://xusx1024.com/2017/04/11/counting-sort/)对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。\n\n#### 实例分析 ####\n\n![示例图](/images/prefix_doubleing_demo_1.png)\n<br> \n \n![示例图](/images/SA&rank.png)\n\n#### 代码 ####\njava语言实现：<br>\n\n\tpackage PrefixDoubling;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 倍增算法实现后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class PrefixDoubling {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\t/**\n\t\t * sa中第i个后缀：SA[rank[i]-1];<br>\n\t\t * i是rank数组的下标;<br>\n\t\t * 串S的第i个后缀是S[i...n],n=S.length-1.\n\t\t * \n\t\t * @author sxx.xu\n\t\t *\n\t\t */\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int suffix, int[] digits) {\n\t\t\t\tthis.iSuffix = suffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i : C)\n\t\t\t\ti = 0;\n\t\n\t\t\tfor (int j = 0; j < tA.length; j++) {\n\t\t\t\tC[tA[j].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++)\n\t\t\t\tC[i] += C[i - 1];\n\t\n\t\t\tfor (int j = tA.length - 1; j >= 0; j--) {\n\t\n\t\t\t\ttB[--C[tA[j].digits[d]]] = tA[j];\n\t\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int d = digitsTotalLen - 1, j = 0; j < digitsLen; d--, j++) {\n\t\t\t\tthis.countingSort(d, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\ttA[i] = tB[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len];\n\t\t\tint r = 1;\n\t\t\trank[tB[0].iSuffix] = r;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix();\n\t\t\tsuffix.rank = rank;\n\t\t\tsuffix.sa = sa;\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic Suffix solve(String text) {\n\t\t\tif (text == null)\n\t\t\t\treturn null;\n\t\t\tint len = text.length();\n\t\t\tif (len == 0)\n\t\t\t\treturn null;\n\t\n\t\t\tint k = 1;\n\t\t\tchar base = text.charAt(len - 1);\n\t\t\tTuple[] tA = new Tuple[len];\n\t\t\tTuple[] tB = new Tuple[len];\n\t\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\ttA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n\t\t\t}\n\t\n\t\t\tSuffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n\t\t\twhile (!suffix.done) {\n\t\t\t\tk <<= 1;\n\t\t\t\tint offset = k >> 1;\n\t\t\t\tfor (int i = 0, j = i + offset; i < len; i++, j++) {\n\t\t\t\t\ttA[i].iSuffix = i;\n\t\t\t\t\ttA[i].digits = new int[] { suffix.rank[i], (j < len) ? suffix.rank[i + offset] : 0 };\n\t\t\t\t}\n\t\t\t\tint max = suffix.rank[suffix.sa[len - 1]];\n\t\t\t\tsuffix = rank(tA, tB, max, 2);\n\t\t\t}\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic void report(Suffix suffix) {\n\t\t\tint[] sa = suffix.sa;\n\t\t\tint[] rank = suffix.rank;\n\t\t\tint len = sa.length;\n\t\t\tSystem.out.println(\"suffix array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", sa[i]);\n\t\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"rank array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", rank[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t/*\n\t\t\t * //plain counting sort test:\n\t\t\t * \n\t\t\t * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n\t\t\t * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n\t\t\t * i=0;i<B.length;i++) System.out.format(\" %d\", B[i]);\n\t\t\t * System.out.println();\n\t\t\t */\n\t\n\t\t\tString text = \"GACCCACCACC#\";\n\t\t\tPrefixDoubling pd = new PrefixDoubling();\n\t\t\tSuffix suffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"mississippi#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"abcdefghijklmmnopqrstuvwxyz#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"yabbadabbado#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t}\n\t\n\t}\n","source":"_posts/2017-04-11-suffix-sort-baseon-prefix-doubleing.md","raw":"---\nlayout: post\ntitle:  基于(前缀)倍增算法实现后缀数组\ndate:   2017-04-11\ncategories: work\ntag: 算法\n---\n \n\n#### 简介 ####\n有几个基本概念需要知道。<br>\n\n>\n1. **子串：**字符串S的子串r[i...j],i <= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],...,r[j]形成的字符串;\n2. **后缀：**从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i...len(r)];<br>\n3. **大小比较：**关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]>v[i]则认为u>v，反之则认为u<v，比较结束。如果i>len(u)或者i>len(v)仍比较不出结果，那么若len(u)>len(v)，则认为u>v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。\n4. **后缀数组：**后缀数组SA是一个一维数组，它保存1...n的某个排列SA[1],SA[2],...,SA[n],并且保证suffix(SA[i])<suffix(SA[i+1]), 1 <= i < n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。\n5. **名次数组：**名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。\n6. **height数组：**定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀\n7. **LCP(i,j):**对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。\n\n#### 算法原理 ####\n\n Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用[基数排序(radix sort)](http://xusx1024.com/2017/04/10/radix-sort/)算法，先后对两位数字排序，可以采用[计数排序算法(counting sort)](http://xusx1024.com/2017/04/11/counting-sort/)对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。\n\n#### 实例分析 ####\n\n![示例图](/images/prefix_doubleing_demo_1.png)\n<br> \n \n![示例图](/images/SA&rank.png)\n\n#### 代码 ####\njava语言实现：<br>\n\n\tpackage PrefixDoubling;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 倍增算法实现后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class PrefixDoubling {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\t/**\n\t\t * sa中第i个后缀：SA[rank[i]-1];<br>\n\t\t * i是rank数组的下标;<br>\n\t\t * 串S的第i个后缀是S[i...n],n=S.length-1.\n\t\t * \n\t\t * @author sxx.xu\n\t\t *\n\t\t */\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int suffix, int[] digits) {\n\t\t\t\tthis.iSuffix = suffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i : C)\n\t\t\t\ti = 0;\n\t\n\t\t\tfor (int j = 0; j < tA.length; j++) {\n\t\t\t\tC[tA[j].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++)\n\t\t\t\tC[i] += C[i - 1];\n\t\n\t\t\tfor (int j = tA.length - 1; j >= 0; j--) {\n\t\n\t\t\t\ttB[--C[tA[j].digits[d]]] = tA[j];\n\t\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int d = digitsTotalLen - 1, j = 0; j < digitsLen; d--, j++) {\n\t\t\t\tthis.countingSort(d, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\ttA[i] = tB[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len];\n\t\t\tint r = 1;\n\t\t\trank[tB[0].iSuffix] = r;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix();\n\t\t\tsuffix.rank = rank;\n\t\t\tsuffix.sa = sa;\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic Suffix solve(String text) {\n\t\t\tif (text == null)\n\t\t\t\treturn null;\n\t\t\tint len = text.length();\n\t\t\tif (len == 0)\n\t\t\t\treturn null;\n\t\n\t\t\tint k = 1;\n\t\t\tchar base = text.charAt(len - 1);\n\t\t\tTuple[] tA = new Tuple[len];\n\t\t\tTuple[] tB = new Tuple[len];\n\t\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\ttA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n\t\t\t}\n\t\n\t\t\tSuffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n\t\t\twhile (!suffix.done) {\n\t\t\t\tk <<= 1;\n\t\t\t\tint offset = k >> 1;\n\t\t\t\tfor (int i = 0, j = i + offset; i < len; i++, j++) {\n\t\t\t\t\ttA[i].iSuffix = i;\n\t\t\t\t\ttA[i].digits = new int[] { suffix.rank[i], (j < len) ? suffix.rank[i + offset] : 0 };\n\t\t\t\t}\n\t\t\t\tint max = suffix.rank[suffix.sa[len - 1]];\n\t\t\t\tsuffix = rank(tA, tB, max, 2);\n\t\t\t}\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic void report(Suffix suffix) {\n\t\t\tint[] sa = suffix.sa;\n\t\t\tint[] rank = suffix.rank;\n\t\t\tint len = sa.length;\n\t\t\tSystem.out.println(\"suffix array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", sa[i]);\n\t\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"rank array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", rank[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t/*\n\t\t\t * //plain counting sort test:\n\t\t\t * \n\t\t\t * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n\t\t\t * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n\t\t\t * i=0;i<B.length;i++) System.out.format(\" %d\", B[i]);\n\t\t\t * System.out.println();\n\t\t\t */\n\t\n\t\t\tString text = \"GACCCACCACC#\";\n\t\t\tPrefixDoubling pd = new PrefixDoubling();\n\t\t\tSuffix suffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"mississippi#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"abcdefghijklmmnopqrstuvwxyz#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"yabbadabbado#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t}\n\t\n\t}\n","slug":"suffix-sort-baseon-prefix-doubleing","published":1,"updated":"2017-06-01T07:15:55.886Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkf0034h8ivl6ypfz98","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>有几个基本概念需要知道。<br></p>\n<p>&gt;</p>\n<ol>\n<li><strong>子串：</strong>字符串S的子串r[i…j],i &lt;= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],…,r[j]形成的字符串;</li>\n<li><strong>后缀：</strong>从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i…len(r)];<br></li>\n<li><strong>大小比较：</strong>关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]&gt;v[i]则认为u&gt;v，反之则认为u<v，比较结束。如果i>len(u)或者i&gt;len(v)仍比较不出结果，那么若len(u)&gt;len(v)，则认为u&gt;v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。</v.<br></v，比较结束。如果i></li>\n<li><strong>后缀数组：</strong>后缀数组SA是一个一维数组，它保存1…n的某个排列SA[1],SA[2],…,SA[n],并且保证suffix(SA[i])&lt;suffix(SA[i+1]), 1 &lt;= i &lt; n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。</li>\n<li><strong>名次数组：</strong>名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。</li>\n<li><strong>height数组：</strong>定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀</li>\n<li><strong>LCP(i,j):</strong>对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。</li>\n</ol>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><p> Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序(radix sort)</a>算法，先后对两位数字排序，可以采用<a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">计数排序算法(counting sort)</a>对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p><img src=\"/images/prefix_doubleing_demo_1.png\" alt=\"示例图\"><br><br> </p>\n<p><img src=\"/images/SA&amp;rank.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>java语言实现：<br></p>\n<pre><code>package PrefixDoubling;\n\nimport java.util.Arrays;\n\n/**\n * 倍增算法实现后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class PrefixDoubling {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    /**\n     * sa中第i个后缀：SA[rank[i]-1];&lt;br&gt;\n     * i是rank数组的下标;&lt;br&gt;\n     * 串S的第i个后缀是S[i...n],n=S.length-1.\n     * \n     * @author sxx.xu\n     *\n     */\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int suffix, int[] digits) {\n            this.iSuffix = suffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n        int[] C = new int[max + 1];\n        for (int i : C)\n            i = 0;\n\n        for (int j = 0; j &lt; tA.length; j++) {\n            C[tA[j].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++)\n            C[i] += C[i - 1];\n\n        for (int j = tA.length - 1; j &gt;= 0; j--) {\n\n            tB[--C[tA[j].digits[d]]] = tA[j];\n\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int d = digitsTotalLen - 1, j = 0; j &lt; digitsLen; d--, j++) {\n            this.countingSort(d, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int i = 0; i &lt; len; i++) {\n                    tA[i] = tB[i];\n                }\n            }\n        }\n\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len];\n        int r = 1;\n        rank[tB[0].iSuffix] = r;\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast) {\n                r++;\n            }\n            rank[tB[i].iSuffix] = r;\n        }\n\n        Suffix suffix = new Suffix();\n        suffix.rank = rank;\n        suffix.sa = sa;\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    public Suffix solve(String text) {\n        if (text == null)\n            return null;\n        int len = text.length();\n        if (len == 0)\n            return null;\n\n        int k = 1;\n        char base = text.charAt(len - 1);\n        Tuple[] tA = new Tuple[len];\n        Tuple[] tB = new Tuple[len];\n\n        for (int i = 0; i &lt; len; i++) {\n            tA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n        }\n\n        Suffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n        while (!suffix.done) {\n            k &lt;&lt;= 1;\n            int offset = k &gt;&gt; 1;\n            for (int i = 0, j = i + offset; i &lt; len; i++, j++) {\n                tA[i].iSuffix = i;\n                tA[i].digits = new int[] { suffix.rank[i], (j &lt; len) ? suffix.rank[i + offset] : 0 };\n            }\n            int max = suffix.rank[suffix.sa[len - 1]];\n            suffix = rank(tA, tB, max, 2);\n        }\n        return suffix;\n    }\n\n    public void report(Suffix suffix) {\n        int[] sa = suffix.sa;\n        int[] rank = suffix.rank;\n        int len = sa.length;\n        System.out.println(&quot;suffix array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, sa[i]);\n\n        System.out.println();\n        System.out.println(&quot;rank array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, rank[i]);\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        /*\n         * //plain counting sort test:\n         * \n         * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n         * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n         * i=0;i&lt;B.length;i++) System.out.format(&quot; %d&quot;, B[i]);\n         * System.out.println();\n         */\n\n        String text = &quot;GACCCACCACC#&quot;;\n        PrefixDoubling pd = new PrefixDoubling();\n        Suffix suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;mississippi#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;yabbadabbado#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>有几个基本概念需要知道。<br></p>\n<p>&gt;</p>\n<ol>\n<li><strong>子串：</strong>字符串S的子串r[i…j],i &lt;= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],…,r[j]形成的字符串;</li>\n<li><strong>后缀：</strong>从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i…len(r)];<br></li>\n<li><strong>大小比较：</strong>关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]&gt;v[i]则认为u&gt;v，反之则认为u<v，比较结束。如果i>len(u)或者i&gt;len(v)仍比较不出结果，那么若len(u)&gt;len(v)，则认为u&gt;v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。</v.<br></v，比较结束。如果i></li>\n<li><strong>后缀数组：</strong>后缀数组SA是一个一维数组，它保存1…n的某个排列SA[1],SA[2],…,SA[n],并且保证suffix(SA[i])&lt;suffix(SA[i+1]), 1 &lt;= i &lt; n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。</li>\n<li><strong>名次数组：</strong>名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。</li>\n<li><strong>height数组：</strong>定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀</li>\n<li><strong>LCP(i,j):</strong>对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。</li>\n</ol>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><p> Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序(radix sort)</a>算法，先后对两位数字排序，可以采用<a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">计数排序算法(counting sort)</a>对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p><img src=\"/images/prefix_doubleing_demo_1.png\" alt=\"示例图\"><br><br> </p>\n<p><img src=\"/images/SA&amp;rank.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>java语言实现：<br></p>\n<pre><code>package PrefixDoubling;\n\nimport java.util.Arrays;\n\n/**\n * 倍增算法实现后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class PrefixDoubling {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    /**\n     * sa中第i个后缀：SA[rank[i]-1];&lt;br&gt;\n     * i是rank数组的下标;&lt;br&gt;\n     * 串S的第i个后缀是S[i...n],n=S.length-1.\n     * \n     * @author sxx.xu\n     *\n     */\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int suffix, int[] digits) {\n            this.iSuffix = suffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n        int[] C = new int[max + 1];\n        for (int i : C)\n            i = 0;\n\n        for (int j = 0; j &lt; tA.length; j++) {\n            C[tA[j].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++)\n            C[i] += C[i - 1];\n\n        for (int j = tA.length - 1; j &gt;= 0; j--) {\n\n            tB[--C[tA[j].digits[d]]] = tA[j];\n\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int d = digitsTotalLen - 1, j = 0; j &lt; digitsLen; d--, j++) {\n            this.countingSort(d, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int i = 0; i &lt; len; i++) {\n                    tA[i] = tB[i];\n                }\n            }\n        }\n\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len];\n        int r = 1;\n        rank[tB[0].iSuffix] = r;\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast) {\n                r++;\n            }\n            rank[tB[i].iSuffix] = r;\n        }\n\n        Suffix suffix = new Suffix();\n        suffix.rank = rank;\n        suffix.sa = sa;\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    public Suffix solve(String text) {\n        if (text == null)\n            return null;\n        int len = text.length();\n        if (len == 0)\n            return null;\n\n        int k = 1;\n        char base = text.charAt(len - 1);\n        Tuple[] tA = new Tuple[len];\n        Tuple[] tB = new Tuple[len];\n\n        for (int i = 0; i &lt; len; i++) {\n            tA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n        }\n\n        Suffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n        while (!suffix.done) {\n            k &lt;&lt;= 1;\n            int offset = k &gt;&gt; 1;\n            for (int i = 0, j = i + offset; i &lt; len; i++, j++) {\n                tA[i].iSuffix = i;\n                tA[i].digits = new int[] { suffix.rank[i], (j &lt; len) ? suffix.rank[i + offset] : 0 };\n            }\n            int max = suffix.rank[suffix.sa[len - 1]];\n            suffix = rank(tA, tB, max, 2);\n        }\n        return suffix;\n    }\n\n    public void report(Suffix suffix) {\n        int[] sa = suffix.sa;\n        int[] rank = suffix.rank;\n        int len = sa.length;\n        System.out.println(&quot;suffix array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, sa[i]);\n\n        System.out.println();\n        System.out.println(&quot;rank array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, rank[i]);\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        /*\n         * //plain counting sort test:\n         * \n         * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n         * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n         * i=0;i&lt;B.length;i++) System.out.format(&quot; %d&quot;, B[i]);\n         * System.out.println();\n         */\n\n        String text = &quot;GACCCACCACC#&quot;;\n        PrefixDoubling pd = new PrefixDoubling();\n        Suffix suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;mississippi#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;yabbadabbado#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"AndroidSDK开发注意事项","date":"2017-05-09T00:00:00.000Z","_content":"\n \n\n#### SDK的实现目标  ####\n \n- 简洁易用\n- 稳定\n- 高效\n\n不应该对宿主应用有过多的代码侵入<br>\n不应该有复杂频繁的接入工作[一行代码接入]<br>\n</br>\n在不影响宿主稳定的前提下，足够高效；<br>\n更少的内存占用；<br>\n更少的电量消耗；<br>\n更少的流量消耗；<br>\n \n\n#### 架构设计 ####\n\n- 模块化开发\n\t>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合\n- 组件化开发\n\t>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK\n- 插件化开发\n\t>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。\n- SDK初始化\n- 云更新控制\n\t>可以通过服务端的云控服务，关闭某些SDK功能。\n- 安全\n\t- appId + appSecret\n\t- 核心逻辑采用C/C++\n\t- 通讯加密\n\t\t- https\n\t\t- 对称加密\n\t\t- 非对称加密\n\t- 设备安全[一些开发者会用虚拟机来刷广告]\n- 减少传输数据的大小\n\t- 如果对传输的数据大小有要求，建议对数据压缩\n\t- 可采用json/xml/protobuf等协议，也可自定义二进制协议\n- 选择支持最低系统版本\n- 权限管理\n\t- 最小权限原则\n\t- 动态权限申请\n- 日志服务\n\t- 日志要在关键位置上打点，记录有效信息\n\t- 上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生\n\t- 要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响\n\n#### API的设计 ####\n\t1.  方法名能够表明其用途\n\t2.  参数的合法性检验\n\t\t- 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n\t\t- 对于私有方法，通过断言的方式来检查参数的合法\n\t\t- 检查构造参数的合法性，以使对象处在统一状态\n\t\t- 如果检查的代价太大，需要综合考量\n\t3. 方法要明确其单一的功能-单一职责原则\n\t4. 方法异常问题\n\t\t>对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n\t5. 方法权限控制\n\t\t>需从安全和业务的角度考虑，方法是公开、非公开、静态\n\t6. 避免过长参数\n\t\t- Builder模式\n\t\t- 通过静态内部类\n\t\t- 将参数封装成对象\n\t\t- 将参数拆解为多个方法\n\t7. 谨慎使用方法重载\n\t8. 谨慎使用变长参数\n\t9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n\t10. 必要时进行保护性拷贝\n\n#### SDK版本管理策略 ####\n\n- 版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号\n\t> V1_0_0_108_170515_alpha\n\t\n\t希腊字母版本号说明：\n\t- alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放\n\t- beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug\n\t- rc：该版本已相当成熟，与正式版相差无几\n\t- release：最终交付或公开发布版本，该版本发布时，以符号R来代替release\n\n\n- 版本号修改规则\n\t- 主版本号：功能模块有较大变化或整体架构发生变化\n\t- 子版本号：功能有一定变化\n\t- 阶段版本号：bug修复或较小变动\n\t- 日期版本号：用于记录修改项目的当前日期\n\t- 希腊字母版本号：标注软件所处的开发阶段\n- API 版本管理\n\t1. 原则上SDK API一旦发布不可变\n\t2. 特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭\n\t3. 优先选择添加新方法并尽量兼容原始方法\n\t4. 需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)\n\n- API 文档\n\t- 分为内部版和公开版\n\t- 与SDK的改变要同步更新\n\n\n\n \n \n ","source":"_posts/2017-05-09-android-develop-sdk-tips.md","raw":"---\nlayout: post\ntitle:  AndroidSDK开发注意事项\ndate:   2017-05-09\ncategories: work\ntag: android\n---\n\n \n\n#### SDK的实现目标  ####\n \n- 简洁易用\n- 稳定\n- 高效\n\n不应该对宿主应用有过多的代码侵入<br>\n不应该有复杂频繁的接入工作[一行代码接入]<br>\n</br>\n在不影响宿主稳定的前提下，足够高效；<br>\n更少的内存占用；<br>\n更少的电量消耗；<br>\n更少的流量消耗；<br>\n \n\n#### 架构设计 ####\n\n- 模块化开发\n\t>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合\n- 组件化开发\n\t>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK\n- 插件化开发\n\t>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。\n- SDK初始化\n- 云更新控制\n\t>可以通过服务端的云控服务，关闭某些SDK功能。\n- 安全\n\t- appId + appSecret\n\t- 核心逻辑采用C/C++\n\t- 通讯加密\n\t\t- https\n\t\t- 对称加密\n\t\t- 非对称加密\n\t- 设备安全[一些开发者会用虚拟机来刷广告]\n- 减少传输数据的大小\n\t- 如果对传输的数据大小有要求，建议对数据压缩\n\t- 可采用json/xml/protobuf等协议，也可自定义二进制协议\n- 选择支持最低系统版本\n- 权限管理\n\t- 最小权限原则\n\t- 动态权限申请\n- 日志服务\n\t- 日志要在关键位置上打点，记录有效信息\n\t- 上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生\n\t- 要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响\n\n#### API的设计 ####\n\t1.  方法名能够表明其用途\n\t2.  参数的合法性检验\n\t\t- 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n\t\t- 对于私有方法，通过断言的方式来检查参数的合法\n\t\t- 检查构造参数的合法性，以使对象处在统一状态\n\t\t- 如果检查的代价太大，需要综合考量\n\t3. 方法要明确其单一的功能-单一职责原则\n\t4. 方法异常问题\n\t\t>对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n\t5. 方法权限控制\n\t\t>需从安全和业务的角度考虑，方法是公开、非公开、静态\n\t6. 避免过长参数\n\t\t- Builder模式\n\t\t- 通过静态内部类\n\t\t- 将参数封装成对象\n\t\t- 将参数拆解为多个方法\n\t7. 谨慎使用方法重载\n\t8. 谨慎使用变长参数\n\t9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n\t10. 必要时进行保护性拷贝\n\n#### SDK版本管理策略 ####\n\n- 版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号\n\t> V1_0_0_108_170515_alpha\n\t\n\t希腊字母版本号说明：\n\t- alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放\n\t- beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug\n\t- rc：该版本已相当成熟，与正式版相差无几\n\t- release：最终交付或公开发布版本，该版本发布时，以符号R来代替release\n\n\n- 版本号修改规则\n\t- 主版本号：功能模块有较大变化或整体架构发生变化\n\t- 子版本号：功能有一定变化\n\t- 阶段版本号：bug修复或较小变动\n\t- 日期版本号：用于记录修改项目的当前日期\n\t- 希腊字母版本号：标注软件所处的开发阶段\n- API 版本管理\n\t1. 原则上SDK API一旦发布不可变\n\t2. 特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭\n\t3. 优先选择添加新方法并尽量兼容原始方法\n\t4. 需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)\n\n- API 文档\n\t- 分为内部版和公开版\n\t- 与SDK的改变要同步更新\n\n\n\n \n \n ","slug":"android-develop-sdk-tips","published":1,"updated":"2017-06-01T07:08:42.885Z","comments":1,"photos":[],"link":"","_id":"cj3tijdki0037h8ivhegjo6ai","content":"<h4 id=\"SDK的实现目标\"><a href=\"#SDK的实现目标\" class=\"headerlink\" title=\"SDK的实现目标\"></a>SDK的实现目标</h4><ul>\n<li>简洁易用</li>\n<li>稳定</li>\n<li>高效</li>\n</ul>\n<p>不应该对宿主应用有过多的代码侵入<br><br>不应该有复杂频繁的接入工作[一行代码接入]<br><br><br><br>在不影响宿主稳定的前提下，足够高效；<br><br>更少的内存占用；<br><br>更少的电量消耗；<br><br>更少的流量消耗；<br></p>\n<h4 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h4><ul>\n<li>模块化开发<blockquote>\n<p>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合</p>\n</blockquote>\n</li>\n<li>组件化开发<blockquote>\n<p>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK</p>\n</blockquote>\n</li>\n<li>插件化开发<blockquote>\n<p>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。</p>\n</blockquote>\n</li>\n<li>SDK初始化</li>\n<li>云更新控制<blockquote>\n<p>可以通过服务端的云控服务，关闭某些SDK功能。</p>\n</blockquote>\n</li>\n<li>安全<ul>\n<li>appId + appSecret</li>\n<li>核心逻辑采用C/C++</li>\n<li>通讯加密<ul>\n<li>https</li>\n<li>对称加密</li>\n<li>非对称加密</li>\n</ul>\n</li>\n<li>设备安全[一些开发者会用虚拟机来刷广告]</li>\n</ul>\n</li>\n<li>减少传输数据的大小<ul>\n<li>如果对传输的数据大小有要求，建议对数据压缩</li>\n<li>可采用json/xml/protobuf等协议，也可自定义二进制协议</li>\n</ul>\n</li>\n<li>选择支持最低系统版本</li>\n<li>权限管理<ul>\n<li>最小权限原则</li>\n<li>动态权限申请</li>\n</ul>\n</li>\n<li>日志服务<ul>\n<li>日志要在关键位置上打点，记录有效信息</li>\n<li>上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生</li>\n<li>要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"API的设计\"><a href=\"#API的设计\" class=\"headerlink\" title=\"API的设计\"></a>API的设计</h4><pre><code>1.  方法名能够表明其用途\n2.  参数的合法性检验\n    - 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n    - 对于私有方法，通过断言的方式来检查参数的合法\n    - 检查构造参数的合法性，以使对象处在统一状态\n    - 如果检查的代价太大，需要综合考量\n3. 方法要明确其单一的功能-单一职责原则\n4. 方法异常问题\n    &gt;对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n5. 方法权限控制\n    &gt;需从安全和业务的角度考虑，方法是公开、非公开、静态\n6. 避免过长参数\n    - Builder模式\n    - 通过静态内部类\n    - 将参数封装成对象\n    - 将参数拆解为多个方法\n7. 谨慎使用方法重载\n8. 谨慎使用变长参数\n9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n10. 必要时进行保护性拷贝\n</code></pre><h4 id=\"SDK版本管理策略\"><a href=\"#SDK版本管理策略\" class=\"headerlink\" title=\"SDK版本管理策略\"></a>SDK版本管理策略</h4><ul>\n<li><p>版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号</p>\n<blockquote>\n<p>V1_0_0_108_170515_alpha</p>\n</blockquote>\n<p>  希腊字母版本号说明：</p>\n<ul>\n<li>alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放</li>\n<li>beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug</li>\n<li>rc：该版本已相当成熟，与正式版相差无几</li>\n<li>release：最终交付或公开发布版本，该版本发布时，以符号R来代替release</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>版本号修改规则<ul>\n<li>主版本号：功能模块有较大变化或整体架构发生变化</li>\n<li>子版本号：功能有一定变化</li>\n<li>阶段版本号：bug修复或较小变动</li>\n<li>日期版本号：用于记录修改项目的当前日期</li>\n<li>希腊字母版本号：标注软件所处的开发阶段</li>\n</ul>\n</li>\n<li><p>API 版本管理</p>\n<ol>\n<li>原则上SDK API一旦发布不可变</li>\n<li>特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭</li>\n<li>优先选择添加新方法并尽量兼容原始方法</li>\n<li>需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)</li>\n</ol>\n</li>\n<li><p>API 文档</p>\n<ul>\n<li>分为内部版和公开版</li>\n<li>与SDK的改变要同步更新</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"SDK的实现目标\"><a href=\"#SDK的实现目标\" class=\"headerlink\" title=\"SDK的实现目标\"></a>SDK的实现目标</h4><ul>\n<li>简洁易用</li>\n<li>稳定</li>\n<li>高效</li>\n</ul>\n<p>不应该对宿主应用有过多的代码侵入<br><br>不应该有复杂频繁的接入工作[一行代码接入]<br><br><br><br>在不影响宿主稳定的前提下，足够高效；<br><br>更少的内存占用；<br><br>更少的电量消耗；<br><br>更少的流量消耗；<br></p>\n<h4 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h4><ul>\n<li>模块化开发<blockquote>\n<p>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合</p>\n</blockquote>\n</li>\n<li>组件化开发<blockquote>\n<p>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK</p>\n</blockquote>\n</li>\n<li>插件化开发<blockquote>\n<p>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。</p>\n</blockquote>\n</li>\n<li>SDK初始化</li>\n<li>云更新控制<blockquote>\n<p>可以通过服务端的云控服务，关闭某些SDK功能。</p>\n</blockquote>\n</li>\n<li>安全<ul>\n<li>appId + appSecret</li>\n<li>核心逻辑采用C/C++</li>\n<li>通讯加密<ul>\n<li>https</li>\n<li>对称加密</li>\n<li>非对称加密</li>\n</ul>\n</li>\n<li>设备安全[一些开发者会用虚拟机来刷广告]</li>\n</ul>\n</li>\n<li>减少传输数据的大小<ul>\n<li>如果对传输的数据大小有要求，建议对数据压缩</li>\n<li>可采用json/xml/protobuf等协议，也可自定义二进制协议</li>\n</ul>\n</li>\n<li>选择支持最低系统版本</li>\n<li>权限管理<ul>\n<li>最小权限原则</li>\n<li>动态权限申请</li>\n</ul>\n</li>\n<li>日志服务<ul>\n<li>日志要在关键位置上打点，记录有效信息</li>\n<li>上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生</li>\n<li>要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"API的设计\"><a href=\"#API的设计\" class=\"headerlink\" title=\"API的设计\"></a>API的设计</h4><pre><code>1.  方法名能够表明其用途\n2.  参数的合法性检验\n    - 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n    - 对于私有方法，通过断言的方式来检查参数的合法\n    - 检查构造参数的合法性，以使对象处在统一状态\n    - 如果检查的代价太大，需要综合考量\n3. 方法要明确其单一的功能-单一职责原则\n4. 方法异常问题\n    &gt;对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n5. 方法权限控制\n    &gt;需从安全和业务的角度考虑，方法是公开、非公开、静态\n6. 避免过长参数\n    - Builder模式\n    - 通过静态内部类\n    - 将参数封装成对象\n    - 将参数拆解为多个方法\n7. 谨慎使用方法重载\n8. 谨慎使用变长参数\n9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n10. 必要时进行保护性拷贝\n</code></pre><h4 id=\"SDK版本管理策略\"><a href=\"#SDK版本管理策略\" class=\"headerlink\" title=\"SDK版本管理策略\"></a>SDK版本管理策略</h4><ul>\n<li><p>版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号</p>\n<blockquote>\n<p>V1_0_0_108_170515_alpha</p>\n</blockquote>\n<p>  希腊字母版本号说明：</p>\n<ul>\n<li>alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放</li>\n<li>beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug</li>\n<li>rc：该版本已相当成熟，与正式版相差无几</li>\n<li>release：最终交付或公开发布版本，该版本发布时，以符号R来代替release</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>版本号修改规则<ul>\n<li>主版本号：功能模块有较大变化或整体架构发生变化</li>\n<li>子版本号：功能有一定变化</li>\n<li>阶段版本号：bug修复或较小变动</li>\n<li>日期版本号：用于记录修改项目的当前日期</li>\n<li>希腊字母版本号：标注软件所处的开发阶段</li>\n</ul>\n</li>\n<li><p>API 版本管理</p>\n<ol>\n<li>原则上SDK API一旦发布不可变</li>\n<li>特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭</li>\n<li>优先选择添加新方法并尽量兼容原始方法</li>\n<li>需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)</li>\n</ol>\n</li>\n<li><p>API 文档</p>\n<ul>\n<li>分为内部版和公开版</li>\n<li>与SDK的改变要同步更新</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"基于DC3算法实现后缀数组","date":"2017-04-13T00:00:00.000Z","_content":" \n\n\n#### 简介 ####\n\n DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 \"Simple Linear Work Suffix Array Construction\"中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法\n\n#### 算法原理 ####\n \n1. 先将后缀分成两部分，然后对第一部分的后缀排序;\n2. 利用1的结果，对第二部分的后缀排序;\n3. 将1和2的结果合并，即完成对所有后缀排序;\n\n \n#### 代码 ####\n\t \n\tpackage DC3;\n\t\n\t/**\n\t * DC3算法构建后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class DC3 {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\n\t\t\tpublic Suffix(int[] sa, int[] rank) {\n\t\t\t\tthis.sa = sa;\n\t\t\t\tthis.rank = rank;\n\t\t\t}\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int iSuffix, int[] digits) {\n\t\t\t\tthis.iSuffix = iSuffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i = 0; i <= max; i++) {\n\t\t\t\tC[i] = 0;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < tA.length; i++) {\n\t\t\t\tC[tA[i].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tC[i] += C[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = tA.length - 1; i >= 0; i--) {\n\t\t\t\ttB[--C[tA[i].digits[d]]] = tA[i];\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int i = digitsTotalLen - 1, j = 0; j < digitsLen; i--, j++) {\n\t\t\t\tthis.countingSort(i, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\t\ttA[k] = tB[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len + 2];\n\t\t\trank[len] = 1;\n\t\t\trank[len + 1] = 1;\n\t\n\t\t\tint r = 1;\n\t\n\t\t\trank[tB[0].iSuffix] = r;\n\t\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast)\n\t\t\t\t\tr++;\n\t\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix(sa, rank);\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tprivate int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\t\tint[] sa = new int[len];\n\t\t\tfor (int i = 0; i < sa.length; i++)\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\tpublic Suffix reduce(int[] rank, int max) {\n\t\n\t\t\tint len = rank.length - 2;\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tint n2 = len / 3;\n\t\n\t\t\tTuple[] tA = new Tuple[n1 + n2];\n\t\t\tTuple[] tB = new Tuple[n1 + n2];\n\t\n\t\t\tfor (int i = 0, j = 1; i < n1; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\tfor (int i = n1, j = 2; i < n1 + n2; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\treturn rank(tA, tB, max, 3);\n\t\t}\n\t\n\t\tpublic int[] skew(int[] rank, int max) {\n\t\t\tint len = rank.length - 2;\n\t\n\t\t\tSuffix suffixT12 = reduce(rank, max);\n\t\n\t\t\tint[] sa12 = null;\n\t\n\t\t\t// 1.caculate sa12\n\t\t\tif (!suffixT12.done) {\n\t\t\t\tint[] rankT12 = suffixT12.rank;\n\t\t\t\tint maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n\t\t\t\tsa12 = skew(rankT12, maxT12);\n\t\t\t} else {\n\t\t\t\tsa12 = suffixT12.sa;\n\t\t\t}\n\t\n\t\t\t// index conversion for sa12\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\tif (sa12[i] < n1) {\n\t\t\t\t\tsa12[i] = 1 + 3 * sa12[i];\n\t\t\t\t} else {\n\t\t\t\t\tsa12[i] = 2 + 3 * (sa12[i]-n1);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// recaculate rank for sa12\n\t\t\tint[] rank12 = new int[len + 2];\n\t\n\t\t\trank12[len] = 1;\n\t\t\trank12[len + 1] = 1;\n\t\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\trank12[sa12[i]] = i + 1;\n\t\t\t}\n\t\n\t\t\t// 2.caculate sa0\n\t\n\t\t\tint n0 = (len + 2) / 3;\n\t\t\tTuple[] tA = new Tuple[n0];\n\t\t\tTuple[] tB = new Tuple[n0];\n\t\n\t\t\tfor (int i = 0, j = 0; i < n0; i++, j += 3) {\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank12[j + 1];\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2 });\n\t\t\t}\n\t\n\t\t\tint max12 = rank12[sa12[sa12.length - 1]];\n\t\t\tint[] sa0 = orderSuffix(tA, tB, max < max12 ? max12 : max, 2);\n\t\n\t\t\tfor (int i = 0; i < n0; i++) {\n\t\t\t\tsa0[i] = 3 * sa0[i];\n\t\t\t}\n\t\n\t\t\t// 3.merge sa12 and sa0\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tint i = 0, j = 0, k = 0;\n\t\n\t\t\twhile (i < sa12.length && j < sa0.length) {\n\t\t\t\tint p = sa12[i];\n\t\t\t\tint q = sa0[j];\n\t\n\t\t\t\tif (p % 3 == 1) {\n\t\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank12[p + 1] < rank12[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank[p + 1] < rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else if (rank[p + 1] > rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rank12[p + 2] < rank12[q + 2]) {\n\t\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = i; m < sa12.length; m++) {\n\t\t\t\tsa[k++] = sa12[m];\n\t\t\t}\n\t\t\tfor (int m = j; m < sa0.length; m++) {\n\t\t\t\tsa[k++] = sa0[m];\n\t\t\t}\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\t public Suffix solve(String text){  \n\t\t        if(text == null)return null;  \n\t\t        int len = text.length();  \n\t\t        if(len == 0) return null;  \n\t\t          \n\t\t        char base = text.charAt(len-1); //the smallest char  \n\t\t        Tuple[] tA = new Tuple[len];  \n\t\t        Tuple[] tB = new Tuple[len]; //placeholder  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n\t\t        }  \n\t\t        Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\t\t           \n\t\t        int max = suffix.rank[suffix.sa[len-1]];  \n\t\t        int[] sa  = skew(suffix.rank,max);  \n\t\t          \n\t\t        //caculate rank for result suffix array  \n\t\t        int[] r = new int[len];       \n\t\t        for(int k=0;k<sa.length;k++){  \n\t\t            r[sa[k]] = k+1;  \n\t\t        }  \n\t\t        return new Suffix(sa,r);  \n\t\t          \n\t\t    }  \n\t\t    public void report(Suffix suffix){  \n\t\t        int[] sa = suffix.sa;  \n\t\t        int[] rank = suffix.rank;  \n\t\t        int len = sa.length;  \n\t\t          \n\t\t        System.out.println(\"suffix array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", sa[i]);              \n\t\t        }  \n\t\t        System.out.println();  \n\t\t        System.out.println(\"rank array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", rank[i]);            \n\t\t        }         \n\t\t        System.out.println();  \n\t\t    }  \n\t\t    public static void main(String[] args) {  \n\t\t        String text = \"GACCCACCACC#\";  \n\t\t        DC3 dc3 = new DC3();  \n\t\t        Suffix suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"mississippi#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"abcdefghijklmmnopqrstuvwxyz#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"yabbadabbado#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t    }  \n\t}\n","source":"_posts/2017-04-13-suffix-sort-baseon-dc3.md","raw":"---\nlayout: post\ntitle:  基于DC3算法实现后缀数组\ndate:   2017-04-13\ncategories: work\ntag: 算法\n---\n \n\n\n#### 简介 ####\n\n DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 \"Simple Linear Work Suffix Array Construction\"中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法\n\n#### 算法原理 ####\n \n1. 先将后缀分成两部分，然后对第一部分的后缀排序;\n2. 利用1的结果，对第二部分的后缀排序;\n3. 将1和2的结果合并，即完成对所有后缀排序;\n\n \n#### 代码 ####\n\t \n\tpackage DC3;\n\t\n\t/**\n\t * DC3算法构建后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class DC3 {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\n\t\t\tpublic Suffix(int[] sa, int[] rank) {\n\t\t\t\tthis.sa = sa;\n\t\t\t\tthis.rank = rank;\n\t\t\t}\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int iSuffix, int[] digits) {\n\t\t\t\tthis.iSuffix = iSuffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i = 0; i <= max; i++) {\n\t\t\t\tC[i] = 0;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < tA.length; i++) {\n\t\t\t\tC[tA[i].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tC[i] += C[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = tA.length - 1; i >= 0; i--) {\n\t\t\t\ttB[--C[tA[i].digits[d]]] = tA[i];\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int i = digitsTotalLen - 1, j = 0; j < digitsLen; i--, j++) {\n\t\t\t\tthis.countingSort(i, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\t\ttA[k] = tB[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len + 2];\n\t\t\trank[len] = 1;\n\t\t\trank[len + 1] = 1;\n\t\n\t\t\tint r = 1;\n\t\n\t\t\trank[tB[0].iSuffix] = r;\n\t\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast)\n\t\t\t\t\tr++;\n\t\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix(sa, rank);\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tprivate int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\t\tint[] sa = new int[len];\n\t\t\tfor (int i = 0; i < sa.length; i++)\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\tpublic Suffix reduce(int[] rank, int max) {\n\t\n\t\t\tint len = rank.length - 2;\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tint n2 = len / 3;\n\t\n\t\t\tTuple[] tA = new Tuple[n1 + n2];\n\t\t\tTuple[] tB = new Tuple[n1 + n2];\n\t\n\t\t\tfor (int i = 0, j = 1; i < n1; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\tfor (int i = n1, j = 2; i < n1 + n2; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\treturn rank(tA, tB, max, 3);\n\t\t}\n\t\n\t\tpublic int[] skew(int[] rank, int max) {\n\t\t\tint len = rank.length - 2;\n\t\n\t\t\tSuffix suffixT12 = reduce(rank, max);\n\t\n\t\t\tint[] sa12 = null;\n\t\n\t\t\t// 1.caculate sa12\n\t\t\tif (!suffixT12.done) {\n\t\t\t\tint[] rankT12 = suffixT12.rank;\n\t\t\t\tint maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n\t\t\t\tsa12 = skew(rankT12, maxT12);\n\t\t\t} else {\n\t\t\t\tsa12 = suffixT12.sa;\n\t\t\t}\n\t\n\t\t\t// index conversion for sa12\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\tif (sa12[i] < n1) {\n\t\t\t\t\tsa12[i] = 1 + 3 * sa12[i];\n\t\t\t\t} else {\n\t\t\t\t\tsa12[i] = 2 + 3 * (sa12[i]-n1);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// recaculate rank for sa12\n\t\t\tint[] rank12 = new int[len + 2];\n\t\n\t\t\trank12[len] = 1;\n\t\t\trank12[len + 1] = 1;\n\t\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\trank12[sa12[i]] = i + 1;\n\t\t\t}\n\t\n\t\t\t// 2.caculate sa0\n\t\n\t\t\tint n0 = (len + 2) / 3;\n\t\t\tTuple[] tA = new Tuple[n0];\n\t\t\tTuple[] tB = new Tuple[n0];\n\t\n\t\t\tfor (int i = 0, j = 0; i < n0; i++, j += 3) {\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank12[j + 1];\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2 });\n\t\t\t}\n\t\n\t\t\tint max12 = rank12[sa12[sa12.length - 1]];\n\t\t\tint[] sa0 = orderSuffix(tA, tB, max < max12 ? max12 : max, 2);\n\t\n\t\t\tfor (int i = 0; i < n0; i++) {\n\t\t\t\tsa0[i] = 3 * sa0[i];\n\t\t\t}\n\t\n\t\t\t// 3.merge sa12 and sa0\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tint i = 0, j = 0, k = 0;\n\t\n\t\t\twhile (i < sa12.length && j < sa0.length) {\n\t\t\t\tint p = sa12[i];\n\t\t\t\tint q = sa0[j];\n\t\n\t\t\t\tif (p % 3 == 1) {\n\t\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank12[p + 1] < rank12[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank[p + 1] < rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else if (rank[p + 1] > rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rank12[p + 2] < rank12[q + 2]) {\n\t\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = i; m < sa12.length; m++) {\n\t\t\t\tsa[k++] = sa12[m];\n\t\t\t}\n\t\t\tfor (int m = j; m < sa0.length; m++) {\n\t\t\t\tsa[k++] = sa0[m];\n\t\t\t}\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\t public Suffix solve(String text){  \n\t\t        if(text == null)return null;  \n\t\t        int len = text.length();  \n\t\t        if(len == 0) return null;  \n\t\t          \n\t\t        char base = text.charAt(len-1); //the smallest char  \n\t\t        Tuple[] tA = new Tuple[len];  \n\t\t        Tuple[] tB = new Tuple[len]; //placeholder  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n\t\t        }  \n\t\t        Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\t\t           \n\t\t        int max = suffix.rank[suffix.sa[len-1]];  \n\t\t        int[] sa  = skew(suffix.rank,max);  \n\t\t          \n\t\t        //caculate rank for result suffix array  \n\t\t        int[] r = new int[len];       \n\t\t        for(int k=0;k<sa.length;k++){  \n\t\t            r[sa[k]] = k+1;  \n\t\t        }  \n\t\t        return new Suffix(sa,r);  \n\t\t          \n\t\t    }  \n\t\t    public void report(Suffix suffix){  \n\t\t        int[] sa = suffix.sa;  \n\t\t        int[] rank = suffix.rank;  \n\t\t        int len = sa.length;  \n\t\t          \n\t\t        System.out.println(\"suffix array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", sa[i]);              \n\t\t        }  \n\t\t        System.out.println();  \n\t\t        System.out.println(\"rank array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", rank[i]);            \n\t\t        }         \n\t\t        System.out.println();  \n\t\t    }  \n\t\t    public static void main(String[] args) {  \n\t\t        String text = \"GACCCACCACC#\";  \n\t\t        DC3 dc3 = new DC3();  \n\t\t        Suffix suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"mississippi#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"abcdefghijklmmnopqrstuvwxyz#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"yabbadabbado#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t    }  \n\t}\n","slug":"suffix-sort-baseon-dc3","published":1,"updated":"2017-06-01T07:13:27.115Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkn003ah8iv5g8yc5q1","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p> DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 “Simple Linear Work Suffix Array Construction”中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>先将后缀分成两部分，然后对第一部分的后缀排序;</li>\n<li>利用1的结果，对第二部分的后缀排序;</li>\n<li>将1和2的结果合并，即完成对所有后缀排序;</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package DC3;\n\n/**\n * DC3算法构建后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class DC3 {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n\n        public Suffix(int[] sa, int[] rank) {\n            this.sa = sa;\n            this.rank = rank;\n        }\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int iSuffix, int[] digits) {\n            this.iSuffix = iSuffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\n        int[] C = new int[max + 1];\n        for (int i = 0; i &lt;= max; i++) {\n            C[i] = 0;\n        }\n\n        for (int i = 0; i &lt; tA.length; i++) {\n            C[tA[i].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++) {\n            C[i] += C[i - 1];\n        }\n\n        for (int i = tA.length - 1; i &gt;= 0; i--) {\n            tB[--C[tA[i].digits[d]]] = tA[i];\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int i = digitsTotalLen - 1, j = 0; j &lt; digitsLen; i--, j++) {\n            this.countingSort(i, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int k = 0; k &lt; len; k++) {\n                    tA[k] = tB[k];\n                }\n            }\n        }\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len + 2];\n        rank[len] = 1;\n        rank[len + 1] = 1;\n\n        int r = 1;\n\n        rank[tB[0].iSuffix] = r;\n\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast)\n                r++;\n\n            rank[tB[i].iSuffix] = r;\n\n        }\n\n        Suffix suffix = new Suffix(sa, rank);\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    private int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n        int[] sa = new int[len];\n        for (int i = 0; i &lt; sa.length; i++)\n            sa[i] = tB[i].iSuffix;\n\n        return sa;\n\n    }\n\n    public Suffix reduce(int[] rank, int max) {\n\n        int len = rank.length - 2;\n        int n1 = (len + 1) / 3;\n        int n2 = len / 3;\n\n        Tuple[] tA = new Tuple[n1 + n2];\n        Tuple[] tB = new Tuple[n1 + n2];\n\n        for (int i = 0, j = 1; i &lt; n1; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        for (int i = n1, j = 2; i &lt; n1 + n2; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        return rank(tA, tB, max, 3);\n    }\n\n    public int[] skew(int[] rank, int max) {\n        int len = rank.length - 2;\n\n        Suffix suffixT12 = reduce(rank, max);\n\n        int[] sa12 = null;\n\n        // 1.caculate sa12\n        if (!suffixT12.done) {\n            int[] rankT12 = suffixT12.rank;\n            int maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n            sa12 = skew(rankT12, maxT12);\n        } else {\n            sa12 = suffixT12.sa;\n        }\n\n        // index conversion for sa12\n        int n1 = (len + 1) / 3;\n        for (int i = 0; i &lt; sa12.length; i++) {\n            if (sa12[i] &lt; n1) {\n                sa12[i] = 1 + 3 * sa12[i];\n            } else {\n                sa12[i] = 2 + 3 * (sa12[i]-n1);\n            }\n        }\n\n        // recaculate rank for sa12\n        int[] rank12 = new int[len + 2];\n\n        rank12[len] = 1;\n        rank12[len + 1] = 1;\n\n        for (int i = 0; i &lt; sa12.length; i++) {\n            rank12[sa12[i]] = i + 1;\n        }\n\n        // 2.caculate sa0\n\n        int n0 = (len + 2) / 3;\n        Tuple[] tA = new Tuple[n0];\n        Tuple[] tB = new Tuple[n0];\n\n        for (int i = 0, j = 0; i &lt; n0; i++, j += 3) {\n            int r1 = rank[j];\n            int r2 = rank12[j + 1];\n            tA[i] = new Tuple(i, new int[] { r1, r2 });\n        }\n\n        int max12 = rank12[sa12[sa12.length - 1]];\n        int[] sa0 = orderSuffix(tA, tB, max &lt; max12 ? max12 : max, 2);\n\n        for (int i = 0; i &lt; n0; i++) {\n            sa0[i] = 3 * sa0[i];\n        }\n\n        // 3.merge sa12 and sa0\n\n        int[] sa = new int[len];\n        int i = 0, j = 0, k = 0;\n\n        while (i &lt; sa12.length &amp;&amp; j &lt; sa0.length) {\n            int p = sa12[i];\n            int q = sa0[j];\n\n            if (p % 3 == 1) {\n\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank12[p + 1] &lt; rank12[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else {\n                        sa[k++] = q;\n                        j++;\n                    }\n                }\n            } else {\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank[p + 1] &lt; rank[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else if (rank[p + 1] &gt; rank[q + 1]) {\n                        sa[k++] = q;\n                        j++;\n                    } else {\n                        if (rank12[p + 2] &lt; rank12[q + 2]) {\n                            sa[k++] = p;\n                            i++;\n                        } else {\n                            sa[k++] = q;\n                            j++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int m = i; m &lt; sa12.length; m++) {\n            sa[k++] = sa12[m];\n        }\n        for (int m = j; m &lt; sa0.length; m++) {\n            sa[k++] = sa0[m];\n        }\n        return sa;\n\n    }\n\n     public Suffix solve(String text){  \n            if(text == null)return null;  \n            int len = text.length();  \n            if(len == 0) return null;  \n\n            char base = text.charAt(len-1); //the smallest char  \n            Tuple[] tA = new Tuple[len];  \n            Tuple[] tB = new Tuple[len]; //placeholder  \n            for(int i=0;i&lt;len;i++){  \n                tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n            }  \n            Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\n            int max = suffix.rank[suffix.sa[len-1]];  \n            int[] sa  = skew(suffix.rank,max);  \n\n            //caculate rank for result suffix array  \n            int[] r = new int[len];       \n            for(int k=0;k&lt;sa.length;k++){  \n                r[sa[k]] = k+1;  \n            }  \n            return new Suffix(sa,r);  \n\n        }  \n        public void report(Suffix suffix){  \n            int[] sa = suffix.sa;  \n            int[] rank = suffix.rank;  \n            int len = sa.length;  \n\n            System.out.println(&quot;suffix array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, sa[i]);              \n            }  \n            System.out.println();  \n            System.out.println(&quot;rank array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, rank[i]);            \n            }         \n            System.out.println();  \n        }  \n        public static void main(String[] args) {  \n            String text = &quot;GACCCACCACC#&quot;;  \n            DC3 dc3 = new DC3();  \n            Suffix suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;mississippi#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;yabbadabbado#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n        }  \n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p> DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 “Simple Linear Work Suffix Array Construction”中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>先将后缀分成两部分，然后对第一部分的后缀排序;</li>\n<li>利用1的结果，对第二部分的后缀排序;</li>\n<li>将1和2的结果合并，即完成对所有后缀排序;</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package DC3;\n\n/**\n * DC3算法构建后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class DC3 {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n\n        public Suffix(int[] sa, int[] rank) {\n            this.sa = sa;\n            this.rank = rank;\n        }\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int iSuffix, int[] digits) {\n            this.iSuffix = iSuffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\n        int[] C = new int[max + 1];\n        for (int i = 0; i &lt;= max; i++) {\n            C[i] = 0;\n        }\n\n        for (int i = 0; i &lt; tA.length; i++) {\n            C[tA[i].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++) {\n            C[i] += C[i - 1];\n        }\n\n        for (int i = tA.length - 1; i &gt;= 0; i--) {\n            tB[--C[tA[i].digits[d]]] = tA[i];\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int i = digitsTotalLen - 1, j = 0; j &lt; digitsLen; i--, j++) {\n            this.countingSort(i, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int k = 0; k &lt; len; k++) {\n                    tA[k] = tB[k];\n                }\n            }\n        }\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len + 2];\n        rank[len] = 1;\n        rank[len + 1] = 1;\n\n        int r = 1;\n\n        rank[tB[0].iSuffix] = r;\n\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast)\n                r++;\n\n            rank[tB[i].iSuffix] = r;\n\n        }\n\n        Suffix suffix = new Suffix(sa, rank);\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    private int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n        int[] sa = new int[len];\n        for (int i = 0; i &lt; sa.length; i++)\n            sa[i] = tB[i].iSuffix;\n\n        return sa;\n\n    }\n\n    public Suffix reduce(int[] rank, int max) {\n\n        int len = rank.length - 2;\n        int n1 = (len + 1) / 3;\n        int n2 = len / 3;\n\n        Tuple[] tA = new Tuple[n1 + n2];\n        Tuple[] tB = new Tuple[n1 + n2];\n\n        for (int i = 0, j = 1; i &lt; n1; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        for (int i = n1, j = 2; i &lt; n1 + n2; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        return rank(tA, tB, max, 3);\n    }\n\n    public int[] skew(int[] rank, int max) {\n        int len = rank.length - 2;\n\n        Suffix suffixT12 = reduce(rank, max);\n\n        int[] sa12 = null;\n\n        // 1.caculate sa12\n        if (!suffixT12.done) {\n            int[] rankT12 = suffixT12.rank;\n            int maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n            sa12 = skew(rankT12, maxT12);\n        } else {\n            sa12 = suffixT12.sa;\n        }\n\n        // index conversion for sa12\n        int n1 = (len + 1) / 3;\n        for (int i = 0; i &lt; sa12.length; i++) {\n            if (sa12[i] &lt; n1) {\n                sa12[i] = 1 + 3 * sa12[i];\n            } else {\n                sa12[i] = 2 + 3 * (sa12[i]-n1);\n            }\n        }\n\n        // recaculate rank for sa12\n        int[] rank12 = new int[len + 2];\n\n        rank12[len] = 1;\n        rank12[len + 1] = 1;\n\n        for (int i = 0; i &lt; sa12.length; i++) {\n            rank12[sa12[i]] = i + 1;\n        }\n\n        // 2.caculate sa0\n\n        int n0 = (len + 2) / 3;\n        Tuple[] tA = new Tuple[n0];\n        Tuple[] tB = new Tuple[n0];\n\n        for (int i = 0, j = 0; i &lt; n0; i++, j += 3) {\n            int r1 = rank[j];\n            int r2 = rank12[j + 1];\n            tA[i] = new Tuple(i, new int[] { r1, r2 });\n        }\n\n        int max12 = rank12[sa12[sa12.length - 1]];\n        int[] sa0 = orderSuffix(tA, tB, max &lt; max12 ? max12 : max, 2);\n\n        for (int i = 0; i &lt; n0; i++) {\n            sa0[i] = 3 * sa0[i];\n        }\n\n        // 3.merge sa12 and sa0\n\n        int[] sa = new int[len];\n        int i = 0, j = 0, k = 0;\n\n        while (i &lt; sa12.length &amp;&amp; j &lt; sa0.length) {\n            int p = sa12[i];\n            int q = sa0[j];\n\n            if (p % 3 == 1) {\n\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank12[p + 1] &lt; rank12[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else {\n                        sa[k++] = q;\n                        j++;\n                    }\n                }\n            } else {\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank[p + 1] &lt; rank[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else if (rank[p + 1] &gt; rank[q + 1]) {\n                        sa[k++] = q;\n                        j++;\n                    } else {\n                        if (rank12[p + 2] &lt; rank12[q + 2]) {\n                            sa[k++] = p;\n                            i++;\n                        } else {\n                            sa[k++] = q;\n                            j++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int m = i; m &lt; sa12.length; m++) {\n            sa[k++] = sa12[m];\n        }\n        for (int m = j; m &lt; sa0.length; m++) {\n            sa[k++] = sa0[m];\n        }\n        return sa;\n\n    }\n\n     public Suffix solve(String text){  \n            if(text == null)return null;  \n            int len = text.length();  \n            if(len == 0) return null;  \n\n            char base = text.charAt(len-1); //the smallest char  \n            Tuple[] tA = new Tuple[len];  \n            Tuple[] tB = new Tuple[len]; //placeholder  \n            for(int i=0;i&lt;len;i++){  \n                tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n            }  \n            Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\n            int max = suffix.rank[suffix.sa[len-1]];  \n            int[] sa  = skew(suffix.rank,max);  \n\n            //caculate rank for result suffix array  \n            int[] r = new int[len];       \n            for(int k=0;k&lt;sa.length;k++){  \n                r[sa[k]] = k+1;  \n            }  \n            return new Suffix(sa,r);  \n\n        }  \n        public void report(Suffix suffix){  \n            int[] sa = suffix.sa;  \n            int[] rank = suffix.rank;  \n            int len = sa.length;  \n\n            System.out.println(&quot;suffix array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, sa[i]);              \n            }  \n            System.out.println();  \n            System.out.println(&quot;rank array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, rank[i]);            \n            }         \n            System.out.println();  \n        }  \n        public static void main(String[] args) {  \n            String text = &quot;GACCCACCACC#&quot;;  \n            DC3 dc3 = new DC3();  \n            Suffix suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;mississippi#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;yabbadabbado#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n        }  \n}\n</code></pre>"},{"layout":"post","title":"JavaEE学习路线图","date":"2017-05-17T00:00:00.000Z","_content":" \n \n![来自传智播客](/images/java_web_study_path.png)\n","source":"_posts/2017-05-15-javaee-tips.md","raw":"---\nlayout: post\ntitle:  JavaEE学习路线图\ndate:   2017-05-17\ncategories: work\ntag: 杂项\n---\n \n \n![来自传智播客](/images/java_web_study_path.png)\n","slug":"javaee-tips","published":1,"updated":"2017-06-01T07:08:04.006Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkq003dh8ivte4j6mi3","content":"<p><img src=\"/images/java_web_study_path.png\" alt=\"来自传智播客\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java_web_study_path.png\" alt=\"来自传智播客\"></p>\n"},{"layout":"post","title":"Android系统服务：CaptioningManager","date":"2017-05-18T00:00:00.000Z","_content":" \n#### CaptioningManager是什么 ####\n \n- 看名字：字幕管理\n- [Android开发无障碍指南](http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm):\n\t>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。\n\n#### 设备如何设置 ####\n\n[google 官方说明](https://support.google.com/accessibility/android/answer/6006554)\n\n **字幕** \n\n您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。\n\n开启字幕功能<br>\n打开设备的“设置”应用<br>\n点按`无障碍`，然后点按`字幕`<br>\n点按顶部的`开启/关闭`开关<br> \n<br> \n**更改字幕设置**<br>\n开启字幕功能后，您可以在`设置` > `无障碍` > `字幕`中调整以下设置。<br>\n \n- 语言：选择您想要以何种语言显示字幕 \n- 文字大小：选择字幕文字大小 \n- 字幕样式：为字幕文字和背景选择样式和颜色 \n <br>\n\n您的字幕设置可能不适用于某些应用。<br>\n \n#### 官方文档 ####\n\n[简介](https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn)\n\n官方文档称之为：隐藏式字幕。4.4版本释出。<br>\n\n现在播放HTTP Live Steam(HLS)视频时，`VideoView`支持`WebVTT`字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br>\n您也可以使用`addSubtitleSource()`方法为`VideoView`提供`WebVTT`字幕跟踪。此方法接受一个`InputStream`,其携带字幕数据和指定该字幕数据格式的`MediaFormat`对象，您可以使用`createSubtitleFormat()`指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br>\n如果您不使用`VideoView`显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的`CaptioningManager API`允许您查询用户的隐藏式字幕首选项，包括`CaptioningManager.CaptionStyle`定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个`CaptioningManager.CaptioningChangeListener`实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br>\n\n[WebVTT 及 HTML5 <track> 元素简介](https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/)<br>\n[WebVTT与srt格式转换](https://www.zhihu.com/question/29789259)\n\n\n#### 题外话：视频弹幕 ####\n\n\n[基础原理](http://blog.csdn.net/zhangphil/article/details/52021055)<br>\n\n[简单封装](https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java)<br>\n\n[成熟的B站](https://github.com/Bilibili/DanmakuFlameMaster)<br>","source":"_posts/2017-05-18-android-system-service-CaptioningManager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：CaptioningManager\ndate:   2017-05-18\ncategories: work\ntags: android\n---\n \n#### CaptioningManager是什么 ####\n \n- 看名字：字幕管理\n- [Android开发无障碍指南](http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm):\n\t>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。\n\n#### 设备如何设置 ####\n\n[google 官方说明](https://support.google.com/accessibility/android/answer/6006554)\n\n **字幕** \n\n您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。\n\n开启字幕功能<br>\n打开设备的“设置”应用<br>\n点按`无障碍`，然后点按`字幕`<br>\n点按顶部的`开启/关闭`开关<br> \n<br> \n**更改字幕设置**<br>\n开启字幕功能后，您可以在`设置` > `无障碍` > `字幕`中调整以下设置。<br>\n \n- 语言：选择您想要以何种语言显示字幕 \n- 文字大小：选择字幕文字大小 \n- 字幕样式：为字幕文字和背景选择样式和颜色 \n <br>\n\n您的字幕设置可能不适用于某些应用。<br>\n \n#### 官方文档 ####\n\n[简介](https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn)\n\n官方文档称之为：隐藏式字幕。4.4版本释出。<br>\n\n现在播放HTTP Live Steam(HLS)视频时，`VideoView`支持`WebVTT`字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br>\n您也可以使用`addSubtitleSource()`方法为`VideoView`提供`WebVTT`字幕跟踪。此方法接受一个`InputStream`,其携带字幕数据和指定该字幕数据格式的`MediaFormat`对象，您可以使用`createSubtitleFormat()`指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br>\n如果您不使用`VideoView`显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的`CaptioningManager API`允许您查询用户的隐藏式字幕首选项，包括`CaptioningManager.CaptionStyle`定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个`CaptioningManager.CaptioningChangeListener`实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br>\n\n[WebVTT 及 HTML5 <track> 元素简介](https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/)<br>\n[WebVTT与srt格式转换](https://www.zhihu.com/question/29789259)\n\n\n#### 题外话：视频弹幕 ####\n\n\n[基础原理](http://blog.csdn.net/zhangphil/article/details/52021055)<br>\n\n[简单封装](https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java)<br>\n\n[成熟的B站](https://github.com/Bilibili/DanmakuFlameMaster)<br>","slug":"android-system-service-CaptioningManager","published":1,"updated":"2017-06-01T06:53:18.813Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkt003gh8ivl1qgak34","content":"<h4 id=\"CaptioningManager是什么\"><a href=\"#CaptioningManager是什么\" class=\"headerlink\" title=\"CaptioningManager是什么\"></a>CaptioningManager是什么</h4><ul>\n<li>看名字：字幕管理</li>\n<li><a href=\"http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm\" target=\"_blank\" rel=\"external\">Android开发无障碍指南</a>:<blockquote>\n<p>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"设备如何设置\"><a href=\"#设备如何设置\" class=\"headerlink\" title=\"设备如何设置\"></a>设备如何设置</h4><p><a href=\"https://support.google.com/accessibility/android/answer/6006554\" target=\"_blank\" rel=\"external\">google 官方说明</a></p>\n<p> <strong>字幕</strong> </p>\n<p>您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。</p>\n<p>开启字幕功能<br><br>打开设备的“设置”应用<br><br>点按<code>无障碍</code>，然后点按<code>字幕</code><br><br>点按顶部的<code>开启/关闭</code>开关<br><br><br><br><strong>更改字幕设置</strong><br><br>开启字幕功能后，您可以在<code>设置</code> &gt; <code>无障碍</code> &gt; <code>字幕</code>中调整以下设置。<br></p>\n<ul>\n<li>语言：选择您想要以何种语言显示字幕 </li>\n<li>文字大小：选择字幕文字大小 </li>\n<li>字幕样式：为字幕文字和背景选择样式和颜色<br><br></li>\n</ul>\n<p>您的字幕设置可能不适用于某些应用。<br></p>\n<h4 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h4><p><a href=\"https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn\" target=\"_blank\" rel=\"external\">简介</a></p>\n<p>官方文档称之为：隐藏式字幕。4.4版本释出。<br></p>\n<p>现在播放HTTP Live Steam(HLS)视频时，<code>VideoView</code>支持<code>WebVTT</code>字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br><br>您也可以使用<code>addSubtitleSource()</code>方法为<code>VideoView</code>提供<code>WebVTT</code>字幕跟踪。此方法接受一个<code>InputStream</code>,其携带字幕数据和指定该字幕数据格式的<code>MediaFormat</code>对象，您可以使用<code>createSubtitleFormat()</code>指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br><br>如果您不使用<code>VideoView</code>显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的<code>CaptioningManager API</code>允许您查询用户的隐藏式字幕首选项，包括<code>CaptioningManager.CaptionStyle</code>定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个<code>CaptioningManager.CaptioningChangeListener</code>实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br></p>\n<p><a href=\"https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/\" target=\"_blank\" rel=\"external\">WebVTT 及 HTML5 <track> 元素简介</a><br><br><a href=\"https://www.zhihu.com/question/29789259\" target=\"_blank\" rel=\"external\">WebVTT与srt格式转换</a></p>\n<h4 id=\"题外话：视频弹幕\"><a href=\"#题外话：视频弹幕\" class=\"headerlink\" title=\"题外话：视频弹幕\"></a>题外话：视频弹幕</h4><p><a href=\"http://blog.csdn.net/zhangphil/article/details/52021055\" target=\"_blank\" rel=\"external\">基础原理</a><br></p>\n<p><a href=\"https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java\" target=\"_blank\" rel=\"external\">简单封装</a><br></p>\n<p><a href=\"https://github.com/Bilibili/DanmakuFlameMaster\" target=\"_blank\" rel=\"external\">成熟的B站</a><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"CaptioningManager是什么\"><a href=\"#CaptioningManager是什么\" class=\"headerlink\" title=\"CaptioningManager是什么\"></a>CaptioningManager是什么</h4><ul>\n<li>看名字：字幕管理</li>\n<li><a href=\"http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm\" target=\"_blank\" rel=\"external\">Android开发无障碍指南</a>:<blockquote>\n<p>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"设备如何设置\"><a href=\"#设备如何设置\" class=\"headerlink\" title=\"设备如何设置\"></a>设备如何设置</h4><p><a href=\"https://support.google.com/accessibility/android/answer/6006554\" target=\"_blank\" rel=\"external\">google 官方说明</a></p>\n<p> <strong>字幕</strong> </p>\n<p>您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。</p>\n<p>开启字幕功能<br><br>打开设备的“设置”应用<br><br>点按<code>无障碍</code>，然后点按<code>字幕</code><br><br>点按顶部的<code>开启/关闭</code>开关<br><br><br><br><strong>更改字幕设置</strong><br><br>开启字幕功能后，您可以在<code>设置</code> &gt; <code>无障碍</code> &gt; <code>字幕</code>中调整以下设置。<br></p>\n<ul>\n<li>语言：选择您想要以何种语言显示字幕 </li>\n<li>文字大小：选择字幕文字大小 </li>\n<li>字幕样式：为字幕文字和背景选择样式和颜色<br><br></li>\n</ul>\n<p>您的字幕设置可能不适用于某些应用。<br></p>\n<h4 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h4><p><a href=\"https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn\" target=\"_blank\" rel=\"external\">简介</a></p>\n<p>官方文档称之为：隐藏式字幕。4.4版本释出。<br></p>\n<p>现在播放HTTP Live Steam(HLS)视频时，<code>VideoView</code>支持<code>WebVTT</code>字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br><br>您也可以使用<code>addSubtitleSource()</code>方法为<code>VideoView</code>提供<code>WebVTT</code>字幕跟踪。此方法接受一个<code>InputStream</code>,其携带字幕数据和指定该字幕数据格式的<code>MediaFormat</code>对象，您可以使用<code>createSubtitleFormat()</code>指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br><br>如果您不使用<code>VideoView</code>显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的<code>CaptioningManager API</code>允许您查询用户的隐藏式字幕首选项，包括<code>CaptioningManager.CaptionStyle</code>定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个<code>CaptioningManager.CaptioningChangeListener</code>实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br></p>\n<p><a href=\"https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/\" target=\"_blank\" rel=\"external\">WebVTT 及 HTML5 <track> 元素简介</a><br><br><a href=\"https://www.zhihu.com/question/29789259\" target=\"_blank\" rel=\"external\">WebVTT与srt格式转换</a></p>\n<h4 id=\"题外话：视频弹幕\"><a href=\"#题外话：视频弹幕\" class=\"headerlink\" title=\"题外话：视频弹幕\"></a>题外话：视频弹幕</h4><p><a href=\"http://blog.csdn.net/zhangphil/article/details/52021055\" target=\"_blank\" rel=\"external\">基础原理</a><br></p>\n<p><a href=\"https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java\" target=\"_blank\" rel=\"external\">简单封装</a><br></p>\n<p><a href=\"https://github.com/Bilibili/DanmakuFlameMaster\" target=\"_blank\" rel=\"external\">成熟的B站</a><br></p>\n"},{"layout":"post","title":"Android开发中特别的api","date":"2017-04-21T00:00:00.000Z","_content":" \n#### 前言 ####\n android库很大，开发中会遇到一些不常用的api，记录在此。\n \n\n#### ActionBar相关 ####\n\n- setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击\n- actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP\n- actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME\n- actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM\n- actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示\n\n\n#### 判断Activity是否仍在运行 ####\n\n\tif (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n        return;\n    }\n\n#### 开关使用ToggleButton或者Switch ####\n\n\n \n\n \n ","source":"_posts/2017-04-21-android-special-api.md","raw":"---\nlayout: post\ntitle:  Android开发中特别的api\ndate:   2017-04-21\ncategories: work\ntag: android\n---\n \n#### 前言 ####\n android库很大，开发中会遇到一些不常用的api，记录在此。\n \n\n#### ActionBar相关 ####\n\n- setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击\n- actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP\n- actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME\n- actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM\n- actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示\n\n\n#### 判断Activity是否仍在运行 ####\n\n\tif (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n        return;\n    }\n\n#### 开关使用ToggleButton或者Switch ####\n\n\n \n\n \n ","slug":"android-special-api","published":1,"updated":"2017-06-01T07:09:18.071Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkv003jh8ivc48k2ptt","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p> android库很大，开发中会遇到一些不常用的api，记录在此。</p>\n<h4 id=\"ActionBar相关\"><a href=\"#ActionBar相关\" class=\"headerlink\" title=\"ActionBar相关\"></a>ActionBar相关</h4><ul>\n<li>setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击</li>\n<li>actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP</li>\n<li>actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME</li>\n<li>actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM</li>\n<li>actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示</li>\n</ul>\n<h4 id=\"判断Activity是否仍在运行\"><a href=\"#判断Activity是否仍在运行\" class=\"headerlink\" title=\"判断Activity是否仍在运行\"></a>判断Activity是否仍在运行</h4><pre><code>if (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n    return;\n}\n</code></pre><h4 id=\"开关使用ToggleButton或者Switch\"><a href=\"#开关使用ToggleButton或者Switch\" class=\"headerlink\" title=\"开关使用ToggleButton或者Switch\"></a>开关使用ToggleButton或者Switch</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p> android库很大，开发中会遇到一些不常用的api，记录在此。</p>\n<h4 id=\"ActionBar相关\"><a href=\"#ActionBar相关\" class=\"headerlink\" title=\"ActionBar相关\"></a>ActionBar相关</h4><ul>\n<li>setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击</li>\n<li>actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP</li>\n<li>actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME</li>\n<li>actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM</li>\n<li>actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示</li>\n</ul>\n<h4 id=\"判断Activity是否仍在运行\"><a href=\"#判断Activity是否仍在运行\" class=\"headerlink\" title=\"判断Activity是否仍在运行\"></a>判断Activity是否仍在运行</h4><pre><code>if (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n    return;\n}\n</code></pre><h4 id=\"开关使用ToggleButton或者Switch\"><a href=\"#开关使用ToggleButton或者Switch\" class=\"headerlink\" title=\"开关使用ToggleButton或者Switch\"></a>开关使用ToggleButton或者Switch</h4>"},{"layout":"post","title":"Android系统服务：AccessibilityManager","date":"2017-04-20T00:00:00.000Z","_content":" \n\n#### 能做什么 ####\n \n- 抢红包\n- 自动安装apk(偷装流氓软件)\n- UI自动化测试\n- 监听短信内容\n- 帮助有障碍人士(...)\n\n#### 重要的类 ####\n\n`android.accessibilityservice.AccessibilityService`\n##### 重要的方法 #####\n\n`onAccessibilityEvent`<br/>\n`onInterrupt`\n\n#### 清单文件固定配置 ####\n\n        <service\n            android:name=\".SnatchRedEnvelopeService\"\n            android:enabled=\"true\"\n            android:exported=\"true\"\n            android:label=\"@string/service_name\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.accessibilityservice\"\n                android:resource=\"@xml/snatch_red_envelope_service_config\"/>\n        </service>\n\n##### 4.0之后配置服务参数 meta-data #####\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/accessibility_description\"\n    android:accessibilityEventTypes=\"typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged\"\n    android:packageNames=\"com.tencent.mm,com.tencent.mobileqq\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:notificationTimeout=\"100\"\n    android:accessibilityFlags=\"flagDefault\"\n    android:canRetrieveWindowContent=\"true\"/>\n\n此处相当于配置一个`AccessibilityServiceInfo`,代码如下：<br/>\n\n\t@Override\n    protected void onServiceConnected() {\n        AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n        serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n        serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n        serviceInfo.packageNames = new String[]{\"com.tencent.mm\",\"com.tencent.mobileqq\"}; \n        serviceInfo.notificationTimeout=100;\n        setServiceInfo(serviceInfo);\n    }\n\n\n#### 示例 ####\n\n[Github:SnatchRedEnvelope](https://github.com/xusx1024/SnatchRedEnvelope)\n","source":"_posts/2017-04-20-android-system-service-AccessibilityManager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：AccessibilityManager\ndate:   2017-04-20\ncategories: work\ntag: android\n---\n \n\n#### 能做什么 ####\n \n- 抢红包\n- 自动安装apk(偷装流氓软件)\n- UI自动化测试\n- 监听短信内容\n- 帮助有障碍人士(...)\n\n#### 重要的类 ####\n\n`android.accessibilityservice.AccessibilityService`\n##### 重要的方法 #####\n\n`onAccessibilityEvent`<br/>\n`onInterrupt`\n\n#### 清单文件固定配置 ####\n\n        <service\n            android:name=\".SnatchRedEnvelopeService\"\n            android:enabled=\"true\"\n            android:exported=\"true\"\n            android:label=\"@string/service_name\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.accessibilityservice\"\n                android:resource=\"@xml/snatch_red_envelope_service_config\"/>\n        </service>\n\n##### 4.0之后配置服务参数 meta-data #####\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/accessibility_description\"\n    android:accessibilityEventTypes=\"typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged\"\n    android:packageNames=\"com.tencent.mm,com.tencent.mobileqq\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:notificationTimeout=\"100\"\n    android:accessibilityFlags=\"flagDefault\"\n    android:canRetrieveWindowContent=\"true\"/>\n\n此处相当于配置一个`AccessibilityServiceInfo`,代码如下：<br/>\n\n\t@Override\n    protected void onServiceConnected() {\n        AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n        serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n        serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n        serviceInfo.packageNames = new String[]{\"com.tencent.mm\",\"com.tencent.mobileqq\"}; \n        serviceInfo.notificationTimeout=100;\n        setServiceInfo(serviceInfo);\n    }\n\n\n#### 示例 ####\n\n[Github:SnatchRedEnvelope](https://github.com/xusx1024/SnatchRedEnvelope)\n","slug":"android-system-service-AccessibilityManager","published":1,"updated":"2017-06-01T07:13:05.458Z","comments":1,"photos":[],"link":"","_id":"cj3tijdkx003mh8ivd3sz36lc","content":"<h4 id=\"能做什么\"><a href=\"#能做什么\" class=\"headerlink\" title=\"能做什么\"></a>能做什么</h4><ul>\n<li>抢红包</li>\n<li>自动安装apk(偷装流氓软件)</li>\n<li>UI自动化测试</li>\n<li>监听短信内容</li>\n<li>帮助有障碍人士(…)</li>\n</ul>\n<h4 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h4><p><code>android.accessibilityservice.AccessibilityService</code></p>\n<h5 id=\"重要的方法\"><a href=\"#重要的方法\" class=\"headerlink\" title=\"重要的方法\"></a>重要的方法</h5><p><code>onAccessibilityEvent</code><br><br><code>onInterrupt</code></p>\n<h4 id=\"清单文件固定配置\"><a href=\"#清单文件固定配置\" class=\"headerlink\" title=\"清单文件固定配置\"></a>清单文件固定配置</h4><pre><code>&lt;service\n    android:name=&quot;.SnatchRedEnvelopeService&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;\n    android:label=&quot;@string/service_name&quot;\n    android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;\n    &lt;/intent-filter&gt;\n\n    &lt;meta-data\n        android:name=&quot;android.accessibilityservice&quot;\n        android:resource=&quot;@xml/snatch_red_envelope_service_config&quot;/&gt;\n&lt;/service&gt;\n</code></pre><h5 id=\"4-0之后配置服务参数-meta-data\"><a href=\"#4-0之后配置服务参数-meta-data\" class=\"headerlink\" title=\"4.0之后配置服务参数 meta-data\"></a>4.0之后配置服务参数 meta-data</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;accessibility-service\nxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\nandroid:description=&quot;@string/accessibility_description&quot;\nandroid:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged&quot;\nandroid:packageNames=&quot;com.tencent.mm,com.tencent.mobileqq&quot;\nandroid:accessibilityFeedbackType=&quot;feedbackGeneric&quot;\nandroid:notificationTimeout=&quot;100&quot;\nandroid:accessibilityFlags=&quot;flagDefault&quot;\nandroid:canRetrieveWindowContent=&quot;true&quot;/&gt;\n</code></pre><p>此处相当于配置一个<code>AccessibilityServiceInfo</code>,代码如下：<br></p>\n<pre><code>@Override\nprotected void onServiceConnected() {\n    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n    serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n    serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n    serviceInfo.packageNames = new String[]{&quot;com.tencent.mm&quot;,&quot;com.tencent.mobileqq&quot;}; \n    serviceInfo.notificationTimeout=100;\n    setServiceInfo(serviceInfo);\n}\n</code></pre><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><a href=\"https://github.com/xusx1024/SnatchRedEnvelope\" target=\"_blank\" rel=\"external\">Github:SnatchRedEnvelope</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"能做什么\"><a href=\"#能做什么\" class=\"headerlink\" title=\"能做什么\"></a>能做什么</h4><ul>\n<li>抢红包</li>\n<li>自动安装apk(偷装流氓软件)</li>\n<li>UI自动化测试</li>\n<li>监听短信内容</li>\n<li>帮助有障碍人士(…)</li>\n</ul>\n<h4 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h4><p><code>android.accessibilityservice.AccessibilityService</code></p>\n<h5 id=\"重要的方法\"><a href=\"#重要的方法\" class=\"headerlink\" title=\"重要的方法\"></a>重要的方法</h5><p><code>onAccessibilityEvent</code><br><br><code>onInterrupt</code></p>\n<h4 id=\"清单文件固定配置\"><a href=\"#清单文件固定配置\" class=\"headerlink\" title=\"清单文件固定配置\"></a>清单文件固定配置</h4><pre><code>&lt;service\n    android:name=&quot;.SnatchRedEnvelopeService&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;\n    android:label=&quot;@string/service_name&quot;\n    android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;\n    &lt;/intent-filter&gt;\n\n    &lt;meta-data\n        android:name=&quot;android.accessibilityservice&quot;\n        android:resource=&quot;@xml/snatch_red_envelope_service_config&quot;/&gt;\n&lt;/service&gt;\n</code></pre><h5 id=\"4-0之后配置服务参数-meta-data\"><a href=\"#4-0之后配置服务参数-meta-data\" class=\"headerlink\" title=\"4.0之后配置服务参数 meta-data\"></a>4.0之后配置服务参数 meta-data</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;accessibility-service\nxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\nandroid:description=&quot;@string/accessibility_description&quot;\nandroid:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged&quot;\nandroid:packageNames=&quot;com.tencent.mm,com.tencent.mobileqq&quot;\nandroid:accessibilityFeedbackType=&quot;feedbackGeneric&quot;\nandroid:notificationTimeout=&quot;100&quot;\nandroid:accessibilityFlags=&quot;flagDefault&quot;\nandroid:canRetrieveWindowContent=&quot;true&quot;/&gt;\n</code></pre><p>此处相当于配置一个<code>AccessibilityServiceInfo</code>,代码如下：<br></p>\n<pre><code>@Override\nprotected void onServiceConnected() {\n    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n    serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n    serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n    serviceInfo.packageNames = new String[]{&quot;com.tencent.mm&quot;,&quot;com.tencent.mobileqq&quot;}; \n    serviceInfo.notificationTimeout=100;\n    setServiceInfo(serviceInfo);\n}\n</code></pre><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><a href=\"https://github.com/xusx1024/SnatchRedEnvelope\" target=\"_blank\" rel=\"external\">Github:SnatchRedEnvelope</a></p>\n"},{"layout":"post","title":"简单工厂模式","date":"2017-05-23T00:00:00.000Z","_content":" \n\n#### what ####\n\n 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。\n\n\n#### 模式结构 ####\n\n- **Factory：工厂角色**<br>\n\t工厂角色负责实现创建所有实例\n\n- **Product:抽象产品角色**<br>\n\t抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n\n- **ConcreteProduct:具体的产品角色**<br>\n\t具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\t\n \n![类图](/images/simple_factory_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/simple_factory_sequence_diagram.png)\n \n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory)\n<br>\n抽象产品角色：\n\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n\n具体的产品角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductA implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product A!\");\n\t\t}\n\t}\n\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductB implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product B!\");\n\t\t}\n\t}\n\n工厂角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n测试：\n\t\n\tpackage SimpleFactory;\n\t\n\timport static org.junit.Assert.*;\n\t\n\tpublic class Test {\n\t\t@org.junit.Test\n\t\tpublic void test() throws Exception {\n\t\t\ttesting(Product.TYPEA);\n\t\t\ttesting(Product.TYPEB);\n\t\t\t// testing(3);\n\t\t}\n\t\n\t\tpublic static void testing(int type) {\n\t\t\tProduct p = ProductFactory.getTypeAConcreteProduct(type);\n\t\t\tassertNotEquals(p, null);\n\t\t\tp.use();\n\t\t}\n\t}\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 简单工厂为静态方法，调用起来方便\n- 工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护\n\n#### 使用场景 #### \n\n- 工厂类负责创建的对象比较少\n","source":"_posts/2017-05-23-design-patterns-simple-factory.md","raw":"---\nlayout: post\ntitle:  简单工厂模式\ndate:   2017-05-23\ncategories: work\ntags: 设计模式\n---\n \n\n#### what ####\n\n 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。\n\n\n#### 模式结构 ####\n\n- **Factory：工厂角色**<br>\n\t工厂角色负责实现创建所有实例\n\n- **Product:抽象产品角色**<br>\n\t抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n\n- **ConcreteProduct:具体的产品角色**<br>\n\t具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\t\n \n![类图](/images/simple_factory_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/simple_factory_sequence_diagram.png)\n \n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory)\n<br>\n抽象产品角色：\n\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n\n具体的产品角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductA implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product A!\");\n\t\t}\n\t}\n\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductB implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product B!\");\n\t\t}\n\t}\n\n工厂角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n测试：\n\t\n\tpackage SimpleFactory;\n\t\n\timport static org.junit.Assert.*;\n\t\n\tpublic class Test {\n\t\t@org.junit.Test\n\t\tpublic void test() throws Exception {\n\t\t\ttesting(Product.TYPEA);\n\t\t\ttesting(Product.TYPEB);\n\t\t\t// testing(3);\n\t\t}\n\t\n\t\tpublic static void testing(int type) {\n\t\t\tProduct p = ProductFactory.getTypeAConcreteProduct(type);\n\t\t\tassertNotEquals(p, null);\n\t\t\tp.use();\n\t\t}\n\t}\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 简单工厂为静态方法，调用起来方便\n- 工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护\n\n#### 使用场景 #### \n\n- 工厂类负责创建的对象比较少\n","slug":"design-patterns-simple-factory","published":1,"updated":"2017-06-01T06:52:44.960Z","comments":1,"photos":[],"link":"","_id":"cj3tijdl1003ph8ivrz0utr7n","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li><p><strong>Factory：工厂角色</strong><br><br>  工厂角色负责实现创建所有实例</p>\n</li>\n<li><p><strong>Product:抽象产品角色</strong><br><br>  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>\n</li>\n<li><p><strong>ConcreteProduct:具体的产品角色</strong><br><br>  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>\n</li>\n</ul>\n<p><img src=\"/images/simple_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/simple_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory\" target=\"_blank\" rel=\"external\">GitHub</a><br><br><br>抽象产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>具体的产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic class ConcreteProductA implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product A!&quot;);\n    }\n}\n\npackage SimpleFactory;\n\npublic class ConcreteProductB implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product B!&quot;);\n    }\n}\n</code></pre><p>工厂角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>测试：</p>\n<pre><code>package SimpleFactory;\n\nimport static org.junit.Assert.*;\n\npublic class Test {\n    @org.junit.Test\n    public void test() throws Exception {\n        testing(Product.TYPEA);\n        testing(Product.TYPEB);\n        // testing(3);\n    }\n\n    public static void testing(int type) {\n        Product p = ProductFactory.getTypeAConcreteProduct(type);\n        assertNotEquals(p, null);\n        p.use();\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>简单工厂为静态方法，调用起来方便</li>\n<li>工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>工厂类负责创建的对象比较少</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li><p><strong>Factory：工厂角色</strong><br><br>  工厂角色负责实现创建所有实例</p>\n</li>\n<li><p><strong>Product:抽象产品角色</strong><br><br>  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>\n</li>\n<li><p><strong>ConcreteProduct:具体的产品角色</strong><br><br>  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>\n</li>\n</ul>\n<p><img src=\"/images/simple_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/simple_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory\" target=\"_blank\" rel=\"external\">GitHub</a><br><br><br>抽象产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>具体的产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic class ConcreteProductA implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product A!&quot;);\n    }\n}\n\npackage SimpleFactory;\n\npublic class ConcreteProductB implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product B!&quot;);\n    }\n}\n</code></pre><p>工厂角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>测试：</p>\n<pre><code>package SimpleFactory;\n\nimport static org.junit.Assert.*;\n\npublic class Test {\n    @org.junit.Test\n    public void test() throws Exception {\n        testing(Product.TYPEA);\n        testing(Product.TYPEB);\n        // testing(3);\n    }\n\n    public static void testing(int type) {\n        Product p = ProductFactory.getTypeAConcreteProduct(type);\n        assertNotEquals(p, null);\n        p.use();\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>简单工厂为静态方法，调用起来方便</li>\n<li>工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>工厂类负责创建的对象比较少</li>\n</ul>\n"},{"layout":"post","title":"抽象工厂模式","date":"2017-05-25T00:00:00.000Z","_content":"\n#### 引入概念 ####\n\n- **产品等级结构：**产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n- **产品族：** 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。\n\n \n![示例图](/images/abstract_factory_product_level.png)\n\n#### what ####\n\n 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t\n![类图](/images/abstract_factory_class_diagram.png)\n\n\n#### 时序图 ####\n\n![时序图](/images/abstract_factory_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory)\n\n#### 分析 ####\n\n- 抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)\n- 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式\n- \n\n#### 使用场景 #### \n\n- 适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定\n- 比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。\n\n#### 扩展 ####\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n","source":"_posts/2017-05-25-design-patterns-abstract-factory.md","raw":"---\nlayout: post\ntitle:  抽象工厂模式\ndate:   2017-05-25\ncategories: work\ntags: 设计模式\n---\n\n#### 引入概念 ####\n\n- **产品等级结构：**产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n- **产品族：** 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。\n\n \n![示例图](/images/abstract_factory_product_level.png)\n\n#### what ####\n\n 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t\n![类图](/images/abstract_factory_class_diagram.png)\n\n\n#### 时序图 ####\n\n![时序图](/images/abstract_factory_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory)\n\n#### 分析 ####\n\n- 抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)\n- 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式\n- \n\n#### 使用场景 #### \n\n- 适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定\n- 比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。\n\n#### 扩展 ####\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n","slug":"design-patterns-abstract-factory","published":1,"updated":"2017-06-01T06:50:04.091Z","comments":1,"photos":[],"link":"","_id":"cj3tijdl4003sh8ivynmeiqh9","content":"<h4 id=\"引入概念\"><a href=\"#引入概念\" class=\"headerlink\" title=\"引入概念\"></a>引入概念</h4><ul>\n<li><strong>产品等级结构：</strong>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>\n<li><strong>产品族：</strong> 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。</li>\n</ul>\n<p><img src=\"/images/abstract_factory_product_level.png\" alt=\"示例图\"></p>\n<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/abstract_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/abstract_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)</li>\n<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式</li>\n<li></li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定</li>\n<li>比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引入概念\"><a href=\"#引入概念\" class=\"headerlink\" title=\"引入概念\"></a>引入概念</h4><ul>\n<li><strong>产品等级结构：</strong>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>\n<li><strong>产品族：</strong> 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。</li>\n</ul>\n<p><img src=\"/images/abstract_factory_product_level.png\" alt=\"示例图\"></p>\n<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/abstract_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/abstract_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)</li>\n<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式</li>\n<li></li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定</li>\n<li>比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>\n"},{"layout":"post","title":"策略模式","date":"2017-05-25T00:00:00.000Z","_content":" \n\n#### what ####\n \n策略模式是对象行为型模式<br>\n\n策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  Strategy：抽象策略类\n-  ConcreteStrategy：具体策略类\n\t\n \n![类图](/images/strategy_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/strategy_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern)\n\n#### 分析 ####\n\n- 在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if...else...等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难\n- 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。\n\n\n#### 优劣 ####\n\n- 对开闭原则完美支持，用户自由切换算法，易于扩展\n- 可以避免使用多重条件转移语句\n\n- 必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则\n- 需要维护许多策略类","source":"_posts/2017-05-25-design-patterns-strategy-pattern.md","raw":"---\nlayout: post\ntitle:  策略模式\ndate:   2017-05-25\ncategories: work\ntags: 设计模式\n---\n \n\n#### what ####\n \n策略模式是对象行为型模式<br>\n\n策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  Strategy：抽象策略类\n-  ConcreteStrategy：具体策略类\n\t\n \n![类图](/images/strategy_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/strategy_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern)\n\n#### 分析 ####\n\n- 在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if...else...等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难\n- 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。\n\n\n#### 优劣 ####\n\n- 对开闭原则完美支持，用户自由切换算法，易于扩展\n- 可以避免使用多重条件转移语句\n\n- 必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则\n- 需要维护许多策略类","slug":"design-patterns-strategy-pattern","published":1,"updated":"2017-06-01T06:46:35.826Z","comments":1,"photos":[],"link":"","_id":"cj3tijdl6003vh8ivmvua0pqc","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>策略模式是对象行为型模式<br></p>\n<p>策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>Strategy：抽象策略类</li>\n<li>ConcreteStrategy：具体策略类</li>\n</ul>\n<p><img src=\"/images/strategy_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/strategy_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难</li>\n<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。</li>\n</ul>\n<h4 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h4><ul>\n<li>对开闭原则完美支持，用户自由切换算法，易于扩展</li>\n<li><p>可以避免使用多重条件转移语句</p>\n</li>\n<li><p>必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则</p>\n</li>\n<li>需要维护许多策略类</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>策略模式是对象行为型模式<br></p>\n<p>策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>Strategy：抽象策略类</li>\n<li>ConcreteStrategy：具体策略类</li>\n</ul>\n<p><img src=\"/images/strategy_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/strategy_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难</li>\n<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。</li>\n</ul>\n<h4 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h4><ul>\n<li>对开闭原则完美支持，用户自由切换算法，易于扩展</li>\n<li><p>可以避免使用多重条件转移语句</p>\n</li>\n<li><p>必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则</p>\n</li>\n<li>需要维护许多策略类</li>\n</ul>\n"},{"layout":"post","title":"接口常量反模式","date":"2017-05-31T00:00:00.000Z","_content":" \n#### what ####\n\n在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br>\n\n下面是两个例子：\n\n\tpublic interface IConstant {\n\tString NAME = \"\";\n\tint VALUE = 2;\n\tboolean IS_TEACHER = false;\n\t}\t\n\n<br>\n\t\n\tpublic class CConstant {\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t}\n\n#### 接口的优点 ####\n\n- 接口会自动将成员变量设置为static、final的\n- 使得代码更加简单清晰\n- 字节码文件相对于类来说更少，jvm加载和维护的成本变低\n- jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快\n\n#### 反模式之处 ####\n\n由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。\n\n#### 反反模式的做法 ####\n\nfinal类 + 私有构造，如下：<br>\n\t\n\tpublic final class Constants {\n\t\tprivate Constants() {\n\t\t}\n\t\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t\n\t}\n","source":"_posts/2017-05-31-anti-patterns-constant-interface.md","raw":"---\nlayout: post\ntitle:  接口常量反模式\ndate:   2017-05-31\ncategories: work\ntags: 设计模式\n---\n \n#### what ####\n\n在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br>\n\n下面是两个例子：\n\n\tpublic interface IConstant {\n\tString NAME = \"\";\n\tint VALUE = 2;\n\tboolean IS_TEACHER = false;\n\t}\t\n\n<br>\n\t\n\tpublic class CConstant {\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t}\n\n#### 接口的优点 ####\n\n- 接口会自动将成员变量设置为static、final的\n- 使得代码更加简单清晰\n- 字节码文件相对于类来说更少，jvm加载和维护的成本变低\n- jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快\n\n#### 反模式之处 ####\n\n由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。\n\n#### 反反模式的做法 ####\n\nfinal类 + 私有构造，如下：<br>\n\t\n\tpublic final class Constants {\n\t\tprivate Constants() {\n\t\t}\n\t\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t\n\t}\n","slug":"anti-patterns-constant-interface","published":1,"updated":"2017-06-01T06:38:15.750Z","comments":1,"photos":[],"link":"","_id":"cj3tijdl8003yh8ivva4hy9a8","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br></p>\n<p>下面是两个例子：</p>\n<pre><code>public interface IConstant {\nString NAME = &quot;&quot;;\nint VALUE = 2;\nboolean IS_TEACHER = false;\n}    \n</code></pre><p><br></p>\n<pre><code>public class CConstant {\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n}\n</code></pre><h4 id=\"接口的优点\"><a href=\"#接口的优点\" class=\"headerlink\" title=\"接口的优点\"></a>接口的优点</h4><ul>\n<li>接口会自动将成员变量设置为static、final的</li>\n<li>使得代码更加简单清晰</li>\n<li>字节码文件相对于类来说更少，jvm加载和维护的成本变低</li>\n<li>jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快</li>\n</ul>\n<h4 id=\"反模式之处\"><a href=\"#反模式之处\" class=\"headerlink\" title=\"反模式之处\"></a>反模式之处</h4><p>由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。</p>\n<h4 id=\"反反模式的做法\"><a href=\"#反反模式的做法\" class=\"headerlink\" title=\"反反模式的做法\"></a>反反模式的做法</h4><p>final类 + 私有构造，如下：<br></p>\n<pre><code>public final class Constants {\n    private Constants() {\n    }\n\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br></p>\n<p>下面是两个例子：</p>\n<pre><code>public interface IConstant {\nString NAME = &quot;&quot;;\nint VALUE = 2;\nboolean IS_TEACHER = false;\n}    \n</code></pre><p><br></p>\n<pre><code>public class CConstant {\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n}\n</code></pre><h4 id=\"接口的优点\"><a href=\"#接口的优点\" class=\"headerlink\" title=\"接口的优点\"></a>接口的优点</h4><ul>\n<li>接口会自动将成员变量设置为static、final的</li>\n<li>使得代码更加简单清晰</li>\n<li>字节码文件相对于类来说更少，jvm加载和维护的成本变低</li>\n<li>jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快</li>\n</ul>\n<h4 id=\"反模式之处\"><a href=\"#反模式之处\" class=\"headerlink\" title=\"反模式之处\"></a>反模式之处</h4><p>由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。</p>\n<h4 id=\"反反模式的做法\"><a href=\"#反反模式的做法\" class=\"headerlink\" title=\"反反模式的做法\"></a>反反模式的做法</h4><p>final类 + 私有构造，如下：<br></p>\n<pre><code>public final class Constants {\n    private Constants() {\n    }\n\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n\n}\n</code></pre>"},{"layout":"post","title":"工厂方法模式","date":"2017-05-24T00:00:00.000Z","_content":" \n#### what ####\n\n 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t \n![类图](/images/factory_method_class_diagram.png)\n#### 时序图 ####\n \n![时序图](/images/factory_method_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod)\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式\n- 增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”\n- 增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销\n- 考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。\n\n#### 使用场景 #### \n\n- 调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类\n- 一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展\n\n#### 扩展 ####\n\n- 使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求\n- 产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的\n- 多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。\n","source":"_posts/2017-05-24-design-patterns-factory-method.md","raw":"---\nlayout: post\ntitle:  工厂方法模式\ndate:   2017-05-24\ncategories: work\ntags: 设计模式\n---\n \n#### what ####\n\n 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t \n![类图](/images/factory_method_class_diagram.png)\n#### 时序图 ####\n \n![时序图](/images/factory_method_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod)\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式\n- 增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”\n- 增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销\n- 考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。\n\n#### 使用场景 #### \n\n- 调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类\n- 一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展\n\n#### 扩展 ####\n\n- 使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求\n- 产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的\n- 多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。\n","slug":"design-patterns-factory-method","published":1,"updated":"2017-06-01T06:51:04.134Z","comments":1,"photos":[],"link":"","_id":"cj3tijdla0041h8ivfo8dmzvy","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/factory_method_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/factory_method_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式</li>\n<li>增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”</li>\n<li>增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销</li>\n<li>考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类</li>\n<li>一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求</li>\n<li>产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的</li>\n<li>多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/factory_method_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/factory_method_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式</li>\n<li>增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”</li>\n<li>增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销</li>\n<li>考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类</li>\n<li>一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求</li>\n<li>产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的</li>\n<li>多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。</li>\n</ul>\n"},{"title":"解释器模式","date":"2017-06-02T09:39:35.000Z","_content":"\n#### 定义 ####\n\n解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。\n解释器模式是一种行为型模式。\n#### 类图 ####\n- Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。\n- AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。\n- TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。\n- NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。\n\n![类图](/images/interpreter_class_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern)\n\n#### 分析 ####\n\n- 为自定义语言的设计和实现提供了一种解决方案\n- 使用频率不高，在正则表达式、xml文档解析等领域广泛应用\n- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护\n- 使用了大量的循环和递归，导致执行效率很低\n- 尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足\n- 一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具\n- 如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现","source":"_posts/2017-06-02-design-patterns-interpreter.md","raw":"---\ntitle: 解释器模式\ndate: 2017-06-02 09:39:35\ntags: 设计模式\ncategories: work\n---\n\n#### 定义 ####\n\n解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。\n解释器模式是一种行为型模式。\n#### 类图 ####\n- Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。\n- AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。\n- TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。\n- NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。\n\n![类图](/images/interpreter_class_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern)\n\n#### 分析 ####\n\n- 为自定义语言的设计和实现提供了一种解决方案\n- 使用频率不高，在正则表达式、xml文档解析等领域广泛应用\n- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护\n- 使用了大量的循环和递归，导致执行效率很低\n- 尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足\n- 一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具\n- 如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现","slug":"design-patterns-interpreter","published":1,"updated":"2017-06-02T07:01:45.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tijdlc0044h8iva1o9wfqk","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。<br>解释器模式是一种行为型模式。</p>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><ul>\n<li>Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li>\n<li>AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li>\n<li>TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li>\n<li>NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li>\n</ul>\n<p><img src=\"/images/interpreter_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>为自定义语言的设计和实现提供了一种解决方案</li>\n<li>使用频率不高，在正则表达式、xml文档解析等领域广泛应用</li>\n<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护</li>\n<li>使用了大量的循环和递归，导致执行效率很低</li>\n<li>尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足</li>\n<li>一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具</li>\n<li>如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。<br>解释器模式是一种行为型模式。</p>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><ul>\n<li>Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li>\n<li>AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li>\n<li>TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li>\n<li>NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li>\n</ul>\n<p><img src=\"/images/interpreter_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>为自定义语言的设计和实现提供了一种解决方案</li>\n<li>使用频率不高，在正则表达式、xml文档解析等领域广泛应用</li>\n<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护</li>\n<li>使用了大量的循环和递归，导致执行效率很低</li>\n<li>尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足</li>\n<li>一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具</li>\n<li>如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现</li>\n</ul>\n"},{"layout":"post","title":"状态模式","date":"2017-05-26T00:00:00.000Z","_content":" \n\n#### what ####\n \n状态模式是对象行为型模式<br>\n\n看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br>\n\n状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  State：抽象状态类\n-  ConcreteState：具体状态类\n \n![类图](/images/state_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/state_pattern_sequence_diagram.png)\n \n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern)\n\n#### 适用场景 ####\n\n- 对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为\n- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。\n\n\n#### 分析 ####\n\n- 在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象\n- 简单状态模式和可切换状态的状态模式\n","source":"_posts/2017-05-26-design-patterns-state-pattern.md","raw":"---\nlayout: post\ntitle:  状态模式\ndate:   2017-05-26\ncategories: work\ntags: 设计模式\n---\n \n\n#### what ####\n \n状态模式是对象行为型模式<br>\n\n看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br>\n\n状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  State：抽象状态类\n-  ConcreteState：具体状态类\n \n![类图](/images/state_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/state_pattern_sequence_diagram.png)\n \n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern)\n\n#### 适用场景 ####\n\n- 对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为\n- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。\n\n\n#### 分析 ####\n\n- 在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象\n- 简单状态模式和可切换状态的状态模式\n","slug":"design-patterns-state-pattern","published":1,"updated":"2017-06-01T06:44:53.387Z","comments":1,"photos":[],"link":"","_id":"cj3tijdle0047h8iv1qkwn53z","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>状态模式是对象行为型模式<br></p>\n<p>看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br></p>\n<p>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>State：抽象状态类</li>\n<li>ConcreteState：具体状态类</li>\n</ul>\n<p><img src=\"/images/state_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/state_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为</li>\n<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</li>\n<li>简单状态模式和可切换状态的状态模式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>状态模式是对象行为型模式<br></p>\n<p>看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br></p>\n<p>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>State：抽象状态类</li>\n<li>ConcreteState：具体状态类</li>\n</ul>\n<p><img src=\"/images/state_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/state_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为</li>\n<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</li>\n<li>简单状态模式和可切换状态的状态模式</li>\n</ul>\n"},{"title":"观察者设计模式","date":"2017-06-09T15:10:47.000Z","_content":"\n#### 定义 ####\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。\n\n观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。\n\n#### 模式结构 ####\n- Subject：目标\n- ConcreteSubject：具体目标\n- Observer：观察者\n- ConcreteObserver：具体观察者\n\n![类图](/images/observer_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/observer_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n#### 分析 ####","source":"_posts/2017-06-09-design-patterns-observer.md","raw":"---\ntitle: 观察者设计模式\ndate: 2017-6-9 15:10:47\ntags: 设计模式\ncategories: work\n---\n\n#### 定义 ####\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。\n\n观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。\n\n#### 模式结构 ####\n- Subject：目标\n- ConcreteSubject：具体目标\n- Observer：观察者\n- ConcreteObserver：具体观察者\n\n![类图](/images/observer_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/observer_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n#### 分析 ####","slug":"design-patterns-observer","published":1,"updated":"2017-06-12T08:22:02.824Z","_id":"cj3tijdlr004ah8ivu9fonfdr","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>\n<p>观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Subject：目标</li>\n<li>ConcreteSubject：具体目标</li>\n<li>Observer：观察者</li>\n<li>ConcreteObserver：具体观察者</li>\n</ul>\n<p><img src=\"/images/observer_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/observer_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>\n<p>观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Subject：目标</li>\n<li>ConcreteSubject：具体目标</li>\n<li>Observer：观察者</li>\n<li>ConcreteObserver：具体观察者</li>\n</ul>\n<p><img src=\"/images/observer_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/observer_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4>"},{"layout":"post","title":"软件开发反模式","date":"2017-05-31T00:00:00.000Z","_content":" \n\n#### **过早优化** ####\n\n##### what #####\n\t在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n\n##### why #####\n\t想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \n\tDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n\n##### how #####\n\t把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n\t当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\t\n\t不假思索就动手，还不如不做。——Tim Peter\n\n##### 总结 ##### \n\n\t优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n\n\n\n#### 单车车库 ####\n\n##### what #####\n\t花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n\n##### why #####\n\t浪费时间。\n\n##### how #####\n\t如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n\t当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n\n##### 总结 #####\n\t单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n\t避免花费太多时间在琐碎的事情上。\n\n#### 分析瘫痪 ####\n \n##### what #####\n\t对问题的过度分析，阻碍了行动和进展。\n\n##### why #####\n\t过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n\t或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。\t\n\n##### how #####\n\t意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n\t每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n\n##### 总结 #####\n\t宁愿迭代，也不用过度分析和猜测。\n\n#### 上帝类 ####\n\t\n##### what #####\n\t上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n\n##### why #####\n\t违反了单一责任原则，难以单元测试、调试和记录文档。\n\n##### how #####\n\t通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n\n##### 总结 #####\n\t避免有着太多责任和依赖的庞大的类。\n\n#### 新增类恐惧症 ####\n##### what #####\n\t认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n\n##### why #####\n\t新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n##### how #####\n\t简化设计新增类，解耦代码中不必要的耦合部分。\n\n##### 总结 #####\n\t类的数量多，并不能说明设计很糟糕。\n\n#### 内部平台效应 ####\n\n##### what #####\n\t复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n\n##### why #####\n\t重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n\n##### how #####\n\t学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n\n##### 总结 #####\n\t避免重新发明你的操作系统或开发平台已经做得很多的功能。\t\n\n#### 魔法数和字符串 ####\n\n##### what #####\n\t使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n\n##### why #####\n\t增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n\n##### how #####\n\t使用命名的常量、资源检索方法或者注释。\n\n##### 总结 #####\n\t避免在代码中出现未注释、未命名的数字和字符串字面量。\n\n#### 数字管理 ####\n>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates\n\n\n##### what #####\n\t严格地依靠数字来做决定。\n\n##### why #####\n\t在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n\t例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n\n##### how #####\n\t理智地使用测量和数字，而非盲目。\n\n##### 总结 #####\n\t用数字来得出你的决策，但不是用数字来做决定。\n\n#### 幽灵类 ####\n>要想达到完美，不是没有东西可加，而是没有东西可减。\n\n\n##### what #####\n\t无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n\n##### why #####\n\t增加了测试和维护的复杂度，降低了代码的可读性。\n\n##### how #####\n\t不要写无用的类，或者通过重构来消除。\n\n##### 总结 #####\n\t避免没有真正责任的类。","source":"_posts/2017-05-31-anti-patterns.md","raw":"---\nlayout:  \ntitle:  软件开发反模式\ndate:   2017-05-31\ncategories: work\ntags: 设计模式\n---\n \n\n#### **过早优化** ####\n\n##### what #####\n\t在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n\n##### why #####\n\t想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \n\tDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n\n##### how #####\n\t把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n\t当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\t\n\t不假思索就动手，还不如不做。——Tim Peter\n\n##### 总结 ##### \n\n\t优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n\n\n\n#### 单车车库 ####\n\n##### what #####\n\t花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n\n##### why #####\n\t浪费时间。\n\n##### how #####\n\t如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n\t当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n\n##### 总结 #####\n\t单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n\t避免花费太多时间在琐碎的事情上。\n\n#### 分析瘫痪 ####\n \n##### what #####\n\t对问题的过度分析，阻碍了行动和进展。\n\n##### why #####\n\t过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n\t或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。\t\n\n##### how #####\n\t意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n\t每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n\n##### 总结 #####\n\t宁愿迭代，也不用过度分析和猜测。\n\n#### 上帝类 ####\n\t\n##### what #####\n\t上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n\n##### why #####\n\t违反了单一责任原则，难以单元测试、调试和记录文档。\n\n##### how #####\n\t通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n\n##### 总结 #####\n\t避免有着太多责任和依赖的庞大的类。\n\n#### 新增类恐惧症 ####\n##### what #####\n\t认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n\n##### why #####\n\t新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n##### how #####\n\t简化设计新增类，解耦代码中不必要的耦合部分。\n\n##### 总结 #####\n\t类的数量多，并不能说明设计很糟糕。\n\n#### 内部平台效应 ####\n\n##### what #####\n\t复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n\n##### why #####\n\t重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n\n##### how #####\n\t学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n\n##### 总结 #####\n\t避免重新发明你的操作系统或开发平台已经做得很多的功能。\t\n\n#### 魔法数和字符串 ####\n\n##### what #####\n\t使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n\n##### why #####\n\t增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n\n##### how #####\n\t使用命名的常量、资源检索方法或者注释。\n\n##### 总结 #####\n\t避免在代码中出现未注释、未命名的数字和字符串字面量。\n\n#### 数字管理 ####\n>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates\n\n\n##### what #####\n\t严格地依靠数字来做决定。\n\n##### why #####\n\t在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n\t例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n\n##### how #####\n\t理智地使用测量和数字，而非盲目。\n\n##### 总结 #####\n\t用数字来得出你的决策，但不是用数字来做决定。\n\n#### 幽灵类 ####\n>要想达到完美，不是没有东西可加，而是没有东西可减。\n\n\n##### what #####\n\t无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n\n##### why #####\n\t增加了测试和维护的复杂度，降低了代码的可读性。\n\n##### how #####\n\t不要写无用的类，或者通过重构来消除。\n\n##### 总结 #####\n\t避免没有真正责任的类。","slug":"anti-patterns","published":1,"updated":"2017-06-01T06:43:18.436Z","comments":1,"photos":[],"link":"","_id":"cj3tijdlt004dh8ivbv1763nq","content":"<h4 id=\"过早优化\"><a href=\"#过早优化\" class=\"headerlink\" title=\"过早优化\"></a><strong>过早优化</strong></h4><h5 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n</code></pre><h5 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \nDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n</code></pre><h5 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\n不假思索就动手，还不如不做。——Tim Peter\n</code></pre><h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n</code></pre><h4 id=\"单车车库\"><a href=\"#单车车库\" class=\"headerlink\" title=\"单车车库\"></a>单车车库</h4><h5 id=\"what-1\"><a href=\"#what-1\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n</code></pre><h5 id=\"why-1\"><a href=\"#why-1\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>浪费时间。\n</code></pre><h5 id=\"how-1\"><a href=\"#how-1\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n</code></pre><h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n避免花费太多时间在琐碎的事情上。\n</code></pre><h4 id=\"分析瘫痪\"><a href=\"#分析瘫痪\" class=\"headerlink\" title=\"分析瘫痪\"></a>分析瘫痪</h4><h5 id=\"what-2\"><a href=\"#what-2\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>对问题的过度分析，阻碍了行动和进展。\n</code></pre><h5 id=\"why-2\"><a href=\"#why-2\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。    \n</code></pre><h5 id=\"how-2\"><a href=\"#how-2\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n</code></pre><h5 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>宁愿迭代，也不用过度分析和猜测。\n</code></pre><h4 id=\"上帝类\"><a href=\"#上帝类\" class=\"headerlink\" title=\"上帝类\"></a>上帝类</h4><h5 id=\"what-3\"><a href=\"#what-3\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n</code></pre><h5 id=\"why-3\"><a href=\"#why-3\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>违反了单一责任原则，难以单元测试、调试和记录文档。\n</code></pre><h5 id=\"how-3\"><a href=\"#how-3\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n</code></pre><h5 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免有着太多责任和依赖的庞大的类。\n</code></pre><h4 id=\"新增类恐惧症\"><a href=\"#新增类恐惧症\" class=\"headerlink\" title=\"新增类恐惧症\"></a>新增类恐惧症</h4><h5 id=\"what-4\"><a href=\"#what-4\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n</code></pre><h5 id=\"why-4\"><a href=\"#why-4\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n</code></pre><h5 id=\"how-4\"><a href=\"#how-4\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>简化设计新增类，解耦代码中不必要的耦合部分。\n</code></pre><h5 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>类的数量多，并不能说明设计很糟糕。\n</code></pre><h4 id=\"内部平台效应\"><a href=\"#内部平台效应\" class=\"headerlink\" title=\"内部平台效应\"></a>内部平台效应</h4><h5 id=\"what-5\"><a href=\"#what-5\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n</code></pre><h5 id=\"why-5\"><a href=\"#why-5\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n</code></pre><h5 id=\"how-5\"><a href=\"#how-5\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n</code></pre><h5 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免重新发明你的操作系统或开发平台已经做得很多的功能。    \n</code></pre><h4 id=\"魔法数和字符串\"><a href=\"#魔法数和字符串\" class=\"headerlink\" title=\"魔法数和字符串\"></a>魔法数和字符串</h4><h5 id=\"what-6\"><a href=\"#what-6\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n</code></pre><h5 id=\"why-6\"><a href=\"#why-6\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n</code></pre><h5 id=\"how-6\"><a href=\"#how-6\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>使用命名的常量、资源检索方法或者注释。\n</code></pre><h5 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免在代码中出现未注释、未命名的数字和字符串字面量。\n</code></pre><h4 id=\"数字管理\"><a href=\"#数字管理\" class=\"headerlink\" title=\"数字管理\"></a>数字管理</h4><blockquote>\n<p>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates</p>\n</blockquote>\n<h5 id=\"what-7\"><a href=\"#what-7\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>严格地依靠数字来做决定。\n</code></pre><h5 id=\"why-7\"><a href=\"#why-7\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n</code></pre><h5 id=\"how-7\"><a href=\"#how-7\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>理智地使用测量和数字，而非盲目。\n</code></pre><h5 id=\"总结-7\"><a href=\"#总结-7\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>用数字来得出你的决策，但不是用数字来做决定。\n</code></pre><h4 id=\"幽灵类\"><a href=\"#幽灵类\" class=\"headerlink\" title=\"幽灵类\"></a>幽灵类</h4><blockquote>\n<p>要想达到完美，不是没有东西可加，而是没有东西可减。</p>\n</blockquote>\n<h5 id=\"what-8\"><a href=\"#what-8\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n</code></pre><h5 id=\"why-8\"><a href=\"#why-8\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了测试和维护的复杂度，降低了代码的可读性。\n</code></pre><h5 id=\"how-8\"><a href=\"#how-8\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>不要写无用的类，或者通过重构来消除。\n</code></pre><h5 id=\"总结-8\"><a href=\"#总结-8\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免没有真正责任的类。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"过早优化\"><a href=\"#过早优化\" class=\"headerlink\" title=\"过早优化\"></a><strong>过早优化</strong></h4><h5 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n</code></pre><h5 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \nDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n</code></pre><h5 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\n不假思索就动手，还不如不做。——Tim Peter\n</code></pre><h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n</code></pre><h4 id=\"单车车库\"><a href=\"#单车车库\" class=\"headerlink\" title=\"单车车库\"></a>单车车库</h4><h5 id=\"what-1\"><a href=\"#what-1\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n</code></pre><h5 id=\"why-1\"><a href=\"#why-1\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>浪费时间。\n</code></pre><h5 id=\"how-1\"><a href=\"#how-1\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n</code></pre><h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n避免花费太多时间在琐碎的事情上。\n</code></pre><h4 id=\"分析瘫痪\"><a href=\"#分析瘫痪\" class=\"headerlink\" title=\"分析瘫痪\"></a>分析瘫痪</h4><h5 id=\"what-2\"><a href=\"#what-2\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>对问题的过度分析，阻碍了行动和进展。\n</code></pre><h5 id=\"why-2\"><a href=\"#why-2\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。    \n</code></pre><h5 id=\"how-2\"><a href=\"#how-2\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n</code></pre><h5 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>宁愿迭代，也不用过度分析和猜测。\n</code></pre><h4 id=\"上帝类\"><a href=\"#上帝类\" class=\"headerlink\" title=\"上帝类\"></a>上帝类</h4><h5 id=\"what-3\"><a href=\"#what-3\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n</code></pre><h5 id=\"why-3\"><a href=\"#why-3\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>违反了单一责任原则，难以单元测试、调试和记录文档。\n</code></pre><h5 id=\"how-3\"><a href=\"#how-3\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n</code></pre><h5 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免有着太多责任和依赖的庞大的类。\n</code></pre><h4 id=\"新增类恐惧症\"><a href=\"#新增类恐惧症\" class=\"headerlink\" title=\"新增类恐惧症\"></a>新增类恐惧症</h4><h5 id=\"what-4\"><a href=\"#what-4\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n</code></pre><h5 id=\"why-4\"><a href=\"#why-4\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n</code></pre><h5 id=\"how-4\"><a href=\"#how-4\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>简化设计新增类，解耦代码中不必要的耦合部分。\n</code></pre><h5 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>类的数量多，并不能说明设计很糟糕。\n</code></pre><h4 id=\"内部平台效应\"><a href=\"#内部平台效应\" class=\"headerlink\" title=\"内部平台效应\"></a>内部平台效应</h4><h5 id=\"what-5\"><a href=\"#what-5\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n</code></pre><h5 id=\"why-5\"><a href=\"#why-5\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n</code></pre><h5 id=\"how-5\"><a href=\"#how-5\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n</code></pre><h5 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免重新发明你的操作系统或开发平台已经做得很多的功能。    \n</code></pre><h4 id=\"魔法数和字符串\"><a href=\"#魔法数和字符串\" class=\"headerlink\" title=\"魔法数和字符串\"></a>魔法数和字符串</h4><h5 id=\"what-6\"><a href=\"#what-6\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n</code></pre><h5 id=\"why-6\"><a href=\"#why-6\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n</code></pre><h5 id=\"how-6\"><a href=\"#how-6\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>使用命名的常量、资源检索方法或者注释。\n</code></pre><h5 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免在代码中出现未注释、未命名的数字和字符串字面量。\n</code></pre><h4 id=\"数字管理\"><a href=\"#数字管理\" class=\"headerlink\" title=\"数字管理\"></a>数字管理</h4><blockquote>\n<p>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates</p>\n</blockquote>\n<h5 id=\"what-7\"><a href=\"#what-7\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>严格地依靠数字来做决定。\n</code></pre><h5 id=\"why-7\"><a href=\"#why-7\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n</code></pre><h5 id=\"how-7\"><a href=\"#how-7\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>理智地使用测量和数字，而非盲目。\n</code></pre><h5 id=\"总结-7\"><a href=\"#总结-7\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>用数字来得出你的决策，但不是用数字来做决定。\n</code></pre><h4 id=\"幽灵类\"><a href=\"#幽灵类\" class=\"headerlink\" title=\"幽灵类\"></a>幽灵类</h4><blockquote>\n<p>要想达到完美，不是没有东西可加，而是没有东西可减。</p>\n</blockquote>\n<h5 id=\"what-8\"><a href=\"#what-8\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n</code></pre><h5 id=\"why-8\"><a href=\"#why-8\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了测试和维护的复杂度，降低了代码的可读性。\n</code></pre><h5 id=\"how-8\"><a href=\"#how-8\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>不要写无用的类，或者通过重构来消除。\n</code></pre><h5 id=\"总结-8\"><a href=\"#总结-8\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免没有真正责任的类。\n</code></pre>"},{"layout":"post","title":"责任链模式","date":"2017-05-31T00:00:00.000Z","_content":"\n#### what ####\n \n责任链模式是对象行为型模式<br>\n\n责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>\n\n客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。\n\n \n#### 模式结构 ####\n\n- Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链\n- ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。\n\n![类图](/images/chain_of_responsibility_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/chain_of_responsibility_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility)\n\n#### 适用场景 ####\n\n - 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的\n - 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n - 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 \n\n\n#### 分析 ####\n\n- 责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型\n- 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。\n- 责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。\n- 纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况\n- 不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。\n","source":"_posts/2017-05-31-design-patterns-chain-of-responsibility.md","raw":"---\nlayout: post\ntitle:  责任链模式\ndate:   2017-05-31\ncategories: work\ntag: 设计模式\n---\n\n#### what ####\n \n责任链模式是对象行为型模式<br>\n\n责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>\n\n客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。\n\n \n#### 模式结构 ####\n\n- Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链\n- ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。\n\n![类图](/images/chain_of_responsibility_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/chain_of_responsibility_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility)\n\n#### 适用场景 ####\n\n - 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的\n - 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n - 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 \n\n\n#### 分析 ####\n\n- 责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型\n- 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。\n- 责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。\n- 纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况\n- 不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。\n","slug":"design-patterns-chain-of-responsibility","published":1,"updated":"2017-06-01T09:01:21.372Z","comments":1,"photos":[],"link":"","_id":"cj3tijdlw004gh8iv2hgw7p36","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>责任链模式是对象行为型模式<br></p>\n<p>责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br></p>\n<p>客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链</li>\n<li>ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。</li>\n</ul>\n<p><img src=\"/images/chain_of_responsibility_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/chain_of_responsibility_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>\n<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>\n<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型</li>\n<li>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li>\n<li>责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。</li>\n<li>纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况</li>\n<li>不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>责任链模式是对象行为型模式<br></p>\n<p>责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br></p>\n<p>客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链</li>\n<li>ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。</li>\n</ul>\n<p><img src=\"/images/chain_of_responsibility_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/chain_of_responsibility_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>\n<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>\n<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型</li>\n<li>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li>\n<li>责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。</li>\n<li>纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况</li>\n<li>不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。</li>\n</ul>\n"},{"layout":"post","title":"Git使用笔记","date":"2017-04-07T00:00:00.000Z","_content":" \n\n#### git管理github ####\n\n1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：`git@github.com:xusx1024/codewars.git`\n\n2，pc端安装git工具，`git --info-path`打印git所在路径；创建本地仓库；\n\n3，在本地文件中，右键点击 Git Bash Here，进入git命令行\n\n4，全局配置 <br>\n\t`git config --global username \"此处定义你的名字\" `<br>\n\t`git config --global useremail xxxxxxx@gmail.com`\n\n5，初始化本地仓库：\n\t`git init `\n\n6，创建readme，并上传：<br>\n\t`git add readme.txt`<br>\n\t`git commint -m \"upload readme\"`<br>\n\n7，生成SSH key，用来和Github连接：\n\t`ssh-keygen -C '这里填你刚才配置的email地址' -t rsa`然后一路点击enter，最后，得到usr/.ssh中的SSH key\n\n8，把SSH key配置到 GitHub中\n\t在用户名上，`setting -  SSH and GPG keys`\n\n9，用到 第一步的那个串了<br>\n\t`git remote add origin git@github.com:xusx1024/codewars.git`<br>\n\t`git push origin master`<br>\n \n\t\n10，以后如果添加的话：<br>\n\t`git add sth`<br>\n\t`git commint -m \"文件说明\"`<br>\n\t`git push origin master`<br>\n\n11.`git add -A .`\n添加所有文件，注意后面有个点。\n\n12.\n`git pull`  抓取远程仓库所有分支更新并合并到本地\n\n13.`git config -l` 查看git的配置信息\n\n\n\n#### git 提交空目录 ####\n\ngit与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。\n\n ","source":"_posts/2017-04-07-git-command.md","raw":"---\nlayout: post\ntitle:  Git使用笔记\ndate:   2017-04-07\ncategories: work\ntag: 杂项\n---\n \n\n#### git管理github ####\n\n1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：`git@github.com:xusx1024/codewars.git`\n\n2，pc端安装git工具，`git --info-path`打印git所在路径；创建本地仓库；\n\n3，在本地文件中，右键点击 Git Bash Here，进入git命令行\n\n4，全局配置 <br>\n\t`git config --global username \"此处定义你的名字\" `<br>\n\t`git config --global useremail xxxxxxx@gmail.com`\n\n5，初始化本地仓库：\n\t`git init `\n\n6，创建readme，并上传：<br>\n\t`git add readme.txt`<br>\n\t`git commint -m \"upload readme\"`<br>\n\n7，生成SSH key，用来和Github连接：\n\t`ssh-keygen -C '这里填你刚才配置的email地址' -t rsa`然后一路点击enter，最后，得到usr/.ssh中的SSH key\n\n8，把SSH key配置到 GitHub中\n\t在用户名上，`setting -  SSH and GPG keys`\n\n9，用到 第一步的那个串了<br>\n\t`git remote add origin git@github.com:xusx1024/codewars.git`<br>\n\t`git push origin master`<br>\n \n\t\n10，以后如果添加的话：<br>\n\t`git add sth`<br>\n\t`git commint -m \"文件说明\"`<br>\n\t`git push origin master`<br>\n\n11.`git add -A .`\n添加所有文件，注意后面有个点。\n\n12.\n`git pull`  抓取远程仓库所有分支更新并合并到本地\n\n13.`git config -l` 查看git的配置信息\n\n\n\n#### git 提交空目录 ####\n\ngit与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。\n\n ","slug":"git-command","published":1,"updated":"2017-06-01T07:20:33.325Z","comments":1,"photos":[],"link":"","_id":"cj3tijdlz004jh8ivh9r2xhip","content":"<h4 id=\"git管理github\"><a href=\"#git管理github\" class=\"headerlink\" title=\"git管理github\"></a>git管理github</h4><p>1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：<code>git@github.com:xusx1024/codewars.git</code></p>\n<p>2，pc端安装git工具，<code>git --info-path</code>打印git所在路径；创建本地仓库；</p>\n<p>3，在本地文件中，右键点击 Git Bash Here，进入git命令行</p>\n<p>4，全局配置 <br><br>    <code>git config --global username &quot;此处定义你的名字&quot;</code><br><br>    <code>git config --global useremail xxxxxxx@gmail.com</code></p>\n<p>5，初始化本地仓库：<br>    <code>git init</code></p>\n<p>6，创建readme，并上传：<br><br>    <code>git add readme.txt</code><br><br>    <code>git commint -m &quot;upload readme&quot;</code><br></p>\n<p>7，生成SSH key，用来和Github连接：<br>    <code>ssh-keygen -C &#39;这里填你刚才配置的email地址&#39; -t rsa</code>然后一路点击enter，最后，得到usr/.ssh中的SSH key</p>\n<p>8，把SSH key配置到 GitHub中<br>    在用户名上，<code>setting -  SSH and GPG keys</code></p>\n<p>9，用到 第一步的那个串了<br><br>    <code>git remote add origin git@github.com:xusx1024/codewars.git</code><br><br>    <code>git push origin master</code><br></p>\n<p>10，以后如果添加的话：<br><br>    <code>git add sth</code><br><br>    <code>git commint -m &quot;文件说明&quot;</code><br><br>    <code>git push origin master</code><br></p>\n<p>11.<code>git add -A .</code><br>添加所有文件，注意后面有个点。</p>\n<p>12.<br><code>git pull</code>  抓取远程仓库所有分支更新并合并到本地</p>\n<p>13.<code>git config -l</code> 查看git的配置信息</p>\n<h4 id=\"git-提交空目录\"><a href=\"#git-提交空目录\" class=\"headerlink\" title=\"git 提交空目录\"></a>git 提交空目录</h4><p>git与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"git管理github\"><a href=\"#git管理github\" class=\"headerlink\" title=\"git管理github\"></a>git管理github</h4><p>1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：<code>git@github.com:xusx1024/codewars.git</code></p>\n<p>2，pc端安装git工具，<code>git --info-path</code>打印git所在路径；创建本地仓库；</p>\n<p>3，在本地文件中，右键点击 Git Bash Here，进入git命令行</p>\n<p>4，全局配置 <br><br>    <code>git config --global username &quot;此处定义你的名字&quot;</code><br><br>    <code>git config --global useremail xxxxxxx@gmail.com</code></p>\n<p>5，初始化本地仓库：<br>    <code>git init</code></p>\n<p>6，创建readme，并上传：<br><br>    <code>git add readme.txt</code><br><br>    <code>git commint -m &quot;upload readme&quot;</code><br></p>\n<p>7，生成SSH key，用来和Github连接：<br>    <code>ssh-keygen -C &#39;这里填你刚才配置的email地址&#39; -t rsa</code>然后一路点击enter，最后，得到usr/.ssh中的SSH key</p>\n<p>8，把SSH key配置到 GitHub中<br>    在用户名上，<code>setting -  SSH and GPG keys</code></p>\n<p>9，用到 第一步的那个串了<br><br>    <code>git remote add origin git@github.com:xusx1024/codewars.git</code><br><br>    <code>git push origin master</code><br></p>\n<p>10，以后如果添加的话：<br><br>    <code>git add sth</code><br><br>    <code>git commint -m &quot;文件说明&quot;</code><br><br>    <code>git push origin master</code><br></p>\n<p>11.<code>git add -A .</code><br>添加所有文件，注意后面有个点。</p>\n<p>12.<br><code>git pull</code>  抓取远程仓库所有分支更新并合并到本地</p>\n<p>13.<code>git config -l</code> 查看git的配置信息</p>\n<h4 id=\"git-提交空目录\"><a href=\"#git-提交空目录\" class=\"headerlink\" title=\"git 提交空目录\"></a>git 提交空目录</h4><p>git与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。</p>\n"},{"layout":"post","title":"Android学习路线图","date":"2017-04-01T00:00:00.000Z","_content":" \n \n\n#### 程序设计 ####\n \n\n|  知识点  ||链接或书籍|进阶| \n| :------ | :------ | :------ | :------ |\n|__java__|基本语法(如继承、异常、引用、泛型等)|[Java核心技术 卷I](https://book.douban.com/subject/25762168/)（适合入门）|[Effective Java中文版](https://book.douban.com/subject/3360807/)（如何写好的Java代码）<br>[Java解惑](https://book.douban.com/subject/5362860/)（介绍烂Java代码是什么样的）\n|  | 多线程、并发 |[Java并发编程实战](https://book.douban.com/subject/10484692/)<br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）|  |\n||Java 7|[Java程序员修炼之道](https://book.douban.com/subject/24841235/) （详细的介绍Java 7 的新特性）||\n||Java 8|[写给大忙人看的Java SE 8](https://book.douban.com/subject/26274206/)<br>[函数式编程思维](https://book.douban.com/subject/26587213/)||\n||Java虚拟机|[深入理解Java虚拟机](https://book.douban.com/subject/24722612/) （并不是那么难，Java程序员都该看看）||\n||性能优化|[Java性能优化权威指南](https://book.douban.com/subject/25828043/) （后面的章节好像用处不大，前面有些部分还是值得看）||\n|__算法与数据结构__|算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br>|[数据结构与算法分析](https://book.douban.com/subject/1139426/) （涵盖面比较全、示例是Java语言）<br>[算法设计与分析基础](https://book.douban.com/subject/26337727/)（实用主义的典型、偏算法设计<br>[编程珠玑](https://book.douban.com/subject/3227098/)（实践型算法数据||\n|__操作系统__|对Linux/OS的基本认知<br>Linux的常用命令|[鸟哥的Linux私房菜](https://book.douban.com/subject/4889838/)<br>[Linux内核设计与实现(原书第3版)](https://book.douban.com/subject/6097773/)（很精炼的语言描述清楚了内核算法）||\n|__网络__|Http/Https<br>TCP/IP|[图解HTTP](https://book.douban.com/subject/25863515/)<br>[图解TCP/IP](https://book.douban.com/subject/24737674/)|[TCP/IP详解](https://book.douban.com/subject/1088054/)|\n|__Android__|四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）|[UniversalMusicePlayer](https://github.com/googlesamples/android-UniversalMusicPlayer)(通过学习一个音乐播放器的代码能很快了解四大组件)<br>[Android Training官方课程](http://hukai.me/android-training-course-in-chinese/index.html)<br>[Android一些重要知识点解析整理](https://github.com/FX-Max/Point-of-Android)<br>[Android UI/UX库](https://github.com/wasabeef/awesome-android-ui)<br>（各类常用组件及扩展组件的集合）[Picasso](http://square.github.io/picasso/)、[Glide](https://github.com/bumptech/glide)（两个图片加载库）<br>[The Google I/O 2016 Android App](https://github.com/google/iosched)(Google大会官方的App，适合学习各类实现)<br>[Android开发技术前线](http://www.devtf.cn/)（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）|[第三方库集合](https://github.com/wasabeef/awesome-android-libraries)|\n \n#### 软件工程 ####\n \n\n|  知识点  ||链接或书籍|进阶| \n| :------ | :------ | :------ | :------ |\n|__基础工具__|IDE、Git、Maven|[AndroidStudio](https://developer.android.com/studio/index.html)<br>[Git权威指南中文手册](http://iissnan.com/progit/html/zh/ch1_0.html)||\n|__软件质量__|代码整洁<br>代码质量<br>代码重构|[编写可读代码的艺术](https://book.douban.com/subject/10797189/)（来自Google工程师，专注于代码可读性）<br>[代码整洁之道](https://book.douban.com/subject/4199741/)（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br>[重构-改善既有代码的设计](https://book.douban.com/subject/4262627/)（学习改善已有代码）<br>[重构手册](https://book.douban.com/subject/1173730/)（改善代码的实际操作）||\n|__设计模式__|23种常见设计模式|[大话设计模式](https://book.douban.com/subject/2334288/)<br>[Head First设计模式](https://book.douban.com/subject/2243615/)(两本入门级的设计模式书籍)|[设计模式-可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)（设计模式在实际中的应用）|\n|__敏捷开发__||[解析极限编程](https://book.douban.com/subject/1790225/)<br>[敏捷开发的艺术](https://book.douban.com/subject/4037534/)|[敏捷软件开发-原则、模式与实践](https://book.douban.com/subject/5348122/)|\n|__专业开发__|序员职业素养<br>更高效、更实效|[程序员的是职业素养](https://book.douban.com/subject/11614538/)<br>[程序员修炼之道-从小工到专家](https://book.douban.com/subject/5387402/)||\n|__思考人生__||[黑客与画家](https://book.douban.com/subject/6021440/)(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)||\n\n\n#### 鸣谢 ####\n\n[一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本](https://www.diycode.cc/topics/122)\n <br>\n[另一份 Android 开发学习路线图](https://www.diycode.cc/topics/117)","source":"_posts/2017-04-01-android-study-path.md","raw":"---\nlayout: post\ntitle:  Android学习路线图\ndate:   2017-04-01\ncategories: work\ntag: 杂项\n---\n \n \n\n#### 程序设计 ####\n \n\n|  知识点  ||链接或书籍|进阶| \n| :------ | :------ | :------ | :------ |\n|__java__|基本语法(如继承、异常、引用、泛型等)|[Java核心技术 卷I](https://book.douban.com/subject/25762168/)（适合入门）|[Effective Java中文版](https://book.douban.com/subject/3360807/)（如何写好的Java代码）<br>[Java解惑](https://book.douban.com/subject/5362860/)（介绍烂Java代码是什么样的）\n|  | 多线程、并发 |[Java并发编程实战](https://book.douban.com/subject/10484692/)<br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）|  |\n||Java 7|[Java程序员修炼之道](https://book.douban.com/subject/24841235/) （详细的介绍Java 7 的新特性）||\n||Java 8|[写给大忙人看的Java SE 8](https://book.douban.com/subject/26274206/)<br>[函数式编程思维](https://book.douban.com/subject/26587213/)||\n||Java虚拟机|[深入理解Java虚拟机](https://book.douban.com/subject/24722612/) （并不是那么难，Java程序员都该看看）||\n||性能优化|[Java性能优化权威指南](https://book.douban.com/subject/25828043/) （后面的章节好像用处不大，前面有些部分还是值得看）||\n|__算法与数据结构__|算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br>|[数据结构与算法分析](https://book.douban.com/subject/1139426/) （涵盖面比较全、示例是Java语言）<br>[算法设计与分析基础](https://book.douban.com/subject/26337727/)（实用主义的典型、偏算法设计<br>[编程珠玑](https://book.douban.com/subject/3227098/)（实践型算法数据||\n|__操作系统__|对Linux/OS的基本认知<br>Linux的常用命令|[鸟哥的Linux私房菜](https://book.douban.com/subject/4889838/)<br>[Linux内核设计与实现(原书第3版)](https://book.douban.com/subject/6097773/)（很精炼的语言描述清楚了内核算法）||\n|__网络__|Http/Https<br>TCP/IP|[图解HTTP](https://book.douban.com/subject/25863515/)<br>[图解TCP/IP](https://book.douban.com/subject/24737674/)|[TCP/IP详解](https://book.douban.com/subject/1088054/)|\n|__Android__|四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）|[UniversalMusicePlayer](https://github.com/googlesamples/android-UniversalMusicPlayer)(通过学习一个音乐播放器的代码能很快了解四大组件)<br>[Android Training官方课程](http://hukai.me/android-training-course-in-chinese/index.html)<br>[Android一些重要知识点解析整理](https://github.com/FX-Max/Point-of-Android)<br>[Android UI/UX库](https://github.com/wasabeef/awesome-android-ui)<br>（各类常用组件及扩展组件的集合）[Picasso](http://square.github.io/picasso/)、[Glide](https://github.com/bumptech/glide)（两个图片加载库）<br>[The Google I/O 2016 Android App](https://github.com/google/iosched)(Google大会官方的App，适合学习各类实现)<br>[Android开发技术前线](http://www.devtf.cn/)（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）|[第三方库集合](https://github.com/wasabeef/awesome-android-libraries)|\n \n#### 软件工程 ####\n \n\n|  知识点  ||链接或书籍|进阶| \n| :------ | :------ | :------ | :------ |\n|__基础工具__|IDE、Git、Maven|[AndroidStudio](https://developer.android.com/studio/index.html)<br>[Git权威指南中文手册](http://iissnan.com/progit/html/zh/ch1_0.html)||\n|__软件质量__|代码整洁<br>代码质量<br>代码重构|[编写可读代码的艺术](https://book.douban.com/subject/10797189/)（来自Google工程师，专注于代码可读性）<br>[代码整洁之道](https://book.douban.com/subject/4199741/)（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br>[重构-改善既有代码的设计](https://book.douban.com/subject/4262627/)（学习改善已有代码）<br>[重构手册](https://book.douban.com/subject/1173730/)（改善代码的实际操作）||\n|__设计模式__|23种常见设计模式|[大话设计模式](https://book.douban.com/subject/2334288/)<br>[Head First设计模式](https://book.douban.com/subject/2243615/)(两本入门级的设计模式书籍)|[设计模式-可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)（设计模式在实际中的应用）|\n|__敏捷开发__||[解析极限编程](https://book.douban.com/subject/1790225/)<br>[敏捷开发的艺术](https://book.douban.com/subject/4037534/)|[敏捷软件开发-原则、模式与实践](https://book.douban.com/subject/5348122/)|\n|__专业开发__|序员职业素养<br>更高效、更实效|[程序员的是职业素养](https://book.douban.com/subject/11614538/)<br>[程序员修炼之道-从小工到专家](https://book.douban.com/subject/5387402/)||\n|__思考人生__||[黑客与画家](https://book.douban.com/subject/6021440/)(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)||\n\n\n#### 鸣谢 ####\n\n[一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本](https://www.diycode.cc/topics/122)\n <br>\n[另一份 Android 开发学习路线图](https://www.diycode.cc/topics/117)","slug":"android-study-path","published":1,"updated":"2017-06-01T07:21:18.848Z","comments":1,"photos":[],"link":"","_id":"cj3tijdm1004mh8ivjgurjwqq","content":"<h4 id=\"程序设计\"><a href=\"#程序设计\" class=\"headerlink\" title=\"程序设计\"></a>程序设计</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>java</strong></td>\n<td style=\"text-align:left\">基本语法(如继承、异常、引用、泛型等)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25762168/\" target=\"_blank\" rel=\"external\">Java核心技术 卷I</a>（适合入门）</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/3360807/\" target=\"_blank\" rel=\"external\">Effective Java中文版</a>（如何写好的Java代码）<br><a href=\"https://book.douban.com/subject/5362860/\" target=\"_blank\" rel=\"external\">Java解惑</a>（介绍烂Java代码是什么样的）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">多线程、并发</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"external\">Java并发编程实战</a><br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 7</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24841235/\" target=\"_blank\" rel=\"external\">Java程序员修炼之道</a> （详细的介绍Java 7 的新特性）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 8</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/26274206/\" target=\"_blank\" rel=\"external\">写给大忙人看的Java SE 8</a><br><a href=\"https://book.douban.com/subject/26587213/\" target=\"_blank\" rel=\"external\">函数式编程思维</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java虚拟机</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24722612/\" target=\"_blank\" rel=\"external\">深入理解Java虚拟机</a> （并不是那么难，Java程序员都该看看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">性能优化</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25828043/\" target=\"_blank\" rel=\"external\">Java性能优化权威指南</a> （后面的章节好像用处不大，前面有些部分还是值得看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>算法与数据结构</strong></td>\n<td style=\"text-align:left\">算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"external\">数据结构与算法分析</a> （涵盖面比较全、示例是Java语言）<br><a href=\"https://book.douban.com/subject/26337727/\" target=\"_blank\" rel=\"external\">算法设计与分析基础</a>（实用主义的典型、偏算法设计<br><a href=\"https://book.douban.com/subject/3227098/\" target=\"_blank\" rel=\"external\">编程珠玑</a>（实践型算法数据</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>操作系统</strong></td>\n<td style=\"text-align:left\">对Linux/OS的基本认知<br>Linux的常用命令</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/4889838/\" target=\"_blank\" rel=\"external\">鸟哥的Linux私房菜</a><br><a href=\"https://book.douban.com/subject/6097773/\" target=\"_blank\" rel=\"external\">Linux内核设计与实现(原书第3版)</a>（很精炼的语言描述清楚了内核算法）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>网络</strong></td>\n<td style=\"text-align:left\">Http/Https<br>TCP/IP</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25863515/\" target=\"_blank\" rel=\"external\">图解HTTP</a><br><a href=\"https://book.douban.com/subject/24737674/\" target=\"_blank\" rel=\"external\">图解TCP/IP</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"external\">TCP/IP详解</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Android</strong></td>\n<td style=\"text-align:left\">四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/googlesamples/android-UniversalMusicPlayer\" target=\"_blank\" rel=\"external\">UniversalMusicePlayer</a>(通过学习一个音乐播放器的代码能很快了解四大组件)<br><a href=\"http://hukai.me/android-training-course-in-chinese/index.html\" target=\"_blank\" rel=\"external\">Android Training官方课程</a><br><a href=\"https://github.com/FX-Max/Point-of-Android\" target=\"_blank\" rel=\"external\">Android一些重要知识点解析整理</a><br><a href=\"https://github.com/wasabeef/awesome-android-ui\" target=\"_blank\" rel=\"external\">Android UI/UX库</a><br>（各类常用组件及扩展组件的集合）<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"external\">Picasso</a>、<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">Glide</a>（两个图片加载库）<br><a href=\"https://github.com/google/iosched\" target=\"_blank\" rel=\"external\">The Google I/O 2016 Android App</a>(Google大会官方的App，适合学习各类实现)<br><a href=\"http://www.devtf.cn/\" target=\"_blank\" rel=\"external\">Android开发技术前线</a>（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/wasabeef/awesome-android-libraries\" target=\"_blank\" rel=\"external\">第三方库集合</a></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"软件工程\"><a href=\"#软件工程\" class=\"headerlink\" title=\"软件工程\"></a>软件工程</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础工具</strong></td>\n<td style=\"text-align:left\">IDE、Git、Maven</td>\n<td style=\"text-align:left\"><a href=\"https://developer.android.com/studio/index.html\" target=\"_blank\" rel=\"external\">AndroidStudio</a><br><a href=\"http://iissnan.com/progit/html/zh/ch1_0.html\" target=\"_blank\" rel=\"external\">Git权威指南中文手册</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>软件质量</strong></td>\n<td style=\"text-align:left\">代码整洁<br>代码质量<br>代码重构</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10797189/\" target=\"_blank\" rel=\"external\">编写可读代码的艺术</a>（来自Google工程师，专注于代码可读性）<br><a href=\"https://book.douban.com/subject/4199741/\" target=\"_blank\" rel=\"external\">代码整洁之道</a>（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br><a href=\"https://book.douban.com/subject/4262627/\" target=\"_blank\" rel=\"external\">重构-改善既有代码的设计</a>（学习改善已有代码）<br><a href=\"https://book.douban.com/subject/1173730/\" target=\"_blank\" rel=\"external\">重构手册</a>（改善代码的实际操作）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>设计模式</strong></td>\n<td style=\"text-align:left\">23种常见设计模式</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/2334288/\" target=\"_blank\" rel=\"external\">大话设计模式</a><br><a href=\"https://book.douban.com/subject/2243615/\" target=\"_blank\" rel=\"external\">Head First设计模式</a>(两本入门级的设计模式书籍)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1052241/\" target=\"_blank\" rel=\"external\">设计模式-可复用面向对象软件的基础</a>（设计模式在实际中的应用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>敏捷开发</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1790225/\" target=\"_blank\" rel=\"external\">解析极限编程</a><br><a href=\"https://book.douban.com/subject/4037534/\" target=\"_blank\" rel=\"external\">敏捷开发的艺术</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/5348122/\" target=\"_blank\" rel=\"external\">敏捷软件开发-原则、模式与实践</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>专业开发</strong></td>\n<td style=\"text-align:left\">序员职业素养<br>更高效、更实效</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/11614538/\" target=\"_blank\" rel=\"external\">程序员的是职业素养</a><br><a href=\"https://book.douban.com/subject/5387402/\" target=\"_blank\" rel=\"external\">程序员修炼之道-从小工到专家</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>思考人生</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/6021440/\" target=\"_blank\" rel=\"external\">黑客与画家</a>(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://www.diycode.cc/topics/122\" target=\"_blank\" rel=\"external\">一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本</a><br> <br><br><a href=\"https://www.diycode.cc/topics/117\" target=\"_blank\" rel=\"external\">另一份 Android 开发学习路线图</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"程序设计\"><a href=\"#程序设计\" class=\"headerlink\" title=\"程序设计\"></a>程序设计</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>java</strong></td>\n<td style=\"text-align:left\">基本语法(如继承、异常、引用、泛型等)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25762168/\" target=\"_blank\" rel=\"external\">Java核心技术 卷I</a>（适合入门）</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/3360807/\" target=\"_blank\" rel=\"external\">Effective Java中文版</a>（如何写好的Java代码）<br><a href=\"https://book.douban.com/subject/5362860/\" target=\"_blank\" rel=\"external\">Java解惑</a>（介绍烂Java代码是什么样的）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">多线程、并发</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"external\">Java并发编程实战</a><br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 7</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24841235/\" target=\"_blank\" rel=\"external\">Java程序员修炼之道</a> （详细的介绍Java 7 的新特性）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 8</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/26274206/\" target=\"_blank\" rel=\"external\">写给大忙人看的Java SE 8</a><br><a href=\"https://book.douban.com/subject/26587213/\" target=\"_blank\" rel=\"external\">函数式编程思维</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java虚拟机</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24722612/\" target=\"_blank\" rel=\"external\">深入理解Java虚拟机</a> （并不是那么难，Java程序员都该看看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">性能优化</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25828043/\" target=\"_blank\" rel=\"external\">Java性能优化权威指南</a> （后面的章节好像用处不大，前面有些部分还是值得看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>算法与数据结构</strong></td>\n<td style=\"text-align:left\">算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"external\">数据结构与算法分析</a> （涵盖面比较全、示例是Java语言）<br><a href=\"https://book.douban.com/subject/26337727/\" target=\"_blank\" rel=\"external\">算法设计与分析基础</a>（实用主义的典型、偏算法设计<br><a href=\"https://book.douban.com/subject/3227098/\" target=\"_blank\" rel=\"external\">编程珠玑</a>（实践型算法数据</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>操作系统</strong></td>\n<td style=\"text-align:left\">对Linux/OS的基本认知<br>Linux的常用命令</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/4889838/\" target=\"_blank\" rel=\"external\">鸟哥的Linux私房菜</a><br><a href=\"https://book.douban.com/subject/6097773/\" target=\"_blank\" rel=\"external\">Linux内核设计与实现(原书第3版)</a>（很精炼的语言描述清楚了内核算法）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>网络</strong></td>\n<td style=\"text-align:left\">Http/Https<br>TCP/IP</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25863515/\" target=\"_blank\" rel=\"external\">图解HTTP</a><br><a href=\"https://book.douban.com/subject/24737674/\" target=\"_blank\" rel=\"external\">图解TCP/IP</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"external\">TCP/IP详解</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Android</strong></td>\n<td style=\"text-align:left\">四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/googlesamples/android-UniversalMusicPlayer\" target=\"_blank\" rel=\"external\">UniversalMusicePlayer</a>(通过学习一个音乐播放器的代码能很快了解四大组件)<br><a href=\"http://hukai.me/android-training-course-in-chinese/index.html\" target=\"_blank\" rel=\"external\">Android Training官方课程</a><br><a href=\"https://github.com/FX-Max/Point-of-Android\" target=\"_blank\" rel=\"external\">Android一些重要知识点解析整理</a><br><a href=\"https://github.com/wasabeef/awesome-android-ui\" target=\"_blank\" rel=\"external\">Android UI/UX库</a><br>（各类常用组件及扩展组件的集合）<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"external\">Picasso</a>、<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">Glide</a>（两个图片加载库）<br><a href=\"https://github.com/google/iosched\" target=\"_blank\" rel=\"external\">The Google I/O 2016 Android App</a>(Google大会官方的App，适合学习各类实现)<br><a href=\"http://www.devtf.cn/\" target=\"_blank\" rel=\"external\">Android开发技术前线</a>（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/wasabeef/awesome-android-libraries\" target=\"_blank\" rel=\"external\">第三方库集合</a></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"软件工程\"><a href=\"#软件工程\" class=\"headerlink\" title=\"软件工程\"></a>软件工程</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础工具</strong></td>\n<td style=\"text-align:left\">IDE、Git、Maven</td>\n<td style=\"text-align:left\"><a href=\"https://developer.android.com/studio/index.html\" target=\"_blank\" rel=\"external\">AndroidStudio</a><br><a href=\"http://iissnan.com/progit/html/zh/ch1_0.html\" target=\"_blank\" rel=\"external\">Git权威指南中文手册</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>软件质量</strong></td>\n<td style=\"text-align:left\">代码整洁<br>代码质量<br>代码重构</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10797189/\" target=\"_blank\" rel=\"external\">编写可读代码的艺术</a>（来自Google工程师，专注于代码可读性）<br><a href=\"https://book.douban.com/subject/4199741/\" target=\"_blank\" rel=\"external\">代码整洁之道</a>（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br><a href=\"https://book.douban.com/subject/4262627/\" target=\"_blank\" rel=\"external\">重构-改善既有代码的设计</a>（学习改善已有代码）<br><a href=\"https://book.douban.com/subject/1173730/\" target=\"_blank\" rel=\"external\">重构手册</a>（改善代码的实际操作）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>设计模式</strong></td>\n<td style=\"text-align:left\">23种常见设计模式</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/2334288/\" target=\"_blank\" rel=\"external\">大话设计模式</a><br><a href=\"https://book.douban.com/subject/2243615/\" target=\"_blank\" rel=\"external\">Head First设计模式</a>(两本入门级的设计模式书籍)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1052241/\" target=\"_blank\" rel=\"external\">设计模式-可复用面向对象软件的基础</a>（设计模式在实际中的应用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>敏捷开发</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1790225/\" target=\"_blank\" rel=\"external\">解析极限编程</a><br><a href=\"https://book.douban.com/subject/4037534/\" target=\"_blank\" rel=\"external\">敏捷开发的艺术</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/5348122/\" target=\"_blank\" rel=\"external\">敏捷软件开发-原则、模式与实践</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>专业开发</strong></td>\n<td style=\"text-align:left\">序员职业素养<br>更高效、更实效</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/11614538/\" target=\"_blank\" rel=\"external\">程序员的是职业素养</a><br><a href=\"https://book.douban.com/subject/5387402/\" target=\"_blank\" rel=\"external\">程序员修炼之道-从小工到专家</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>思考人生</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/6021440/\" target=\"_blank\" rel=\"external\">黑客与画家</a>(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://www.diycode.cc/topics/122\" target=\"_blank\" rel=\"external\">一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本</a><br> <br><br><a href=\"https://www.diycode.cc/topics/117\" target=\"_blank\" rel=\"external\">另一份 Android 开发学习路线图</a></p>\n"},{"title":"使用Messenger进行进程间通信注意事项","date":"2017-06-08T15:49:35.000Z","_content":"\n#### 需求 ####\n\n![需求示意图](/images/auth_sequence_diagram.png)\n\n看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来\n本来懒得费事，一个`startActivityForResult`即可结束战斗\n后来发现，我的SDK里没有UI，也就没有处理`onActivityResult`的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。\n\n#### Messenger的使用 ####\n此处不是我想略，网上教程很多，看个比较完善简单的：[Android 基于Message的进程间通信 Messenger完全解析](http://blog.csdn.net/lmj623565791/article/details/47017485)\n代码有些地方不适合新的Android版本，但是也够用了。\n\n#### 注意事项 ####\n\n##### 需求问题解决 ####\nSDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。\n其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。\nkotlin代码如下：\n\n    var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\n    private val mMessenger = Messenger(object : Handler() {\n        override fun handleMessage(msgfromClient: Message) {\n            val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n            try {\n                when (msgfromClient.what) {\n                    REMOTE_CLIENT -> {//远程访问-SDK\n                        remoteMsg = msgfromClient.replyTo\n                        var intent: Intent = Intent()\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        val appID: String = bundle.get(\"APPID\") as String\n\n                        //开启授权页Activity\n                        intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                        intent.putExtra(\"appID\", appID)\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                        startActivity(intent)\n                    }\n                    LOCAL_CLIENT -> {//本地访问-授权页\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        msgToClient.obj = bundle//拿到授权页信使带来的code\n                        remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                    }\n                }\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            } catch (e: RemoteException) {\n                e.printStackTrace()\n            }\n\n            super.handleMessage(msgfromClient)\n        }\n    })\n\n\n根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。\n\n##### 单向双向 #####\n\tmsgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。\n\n##### 多向通信 ####\n在这个里[Remote Messenger Service Sample](https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample)可以看到多个客户端互相通信的官方示例。\n官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。\n\n##### 隐式启动service #####\n\n 5.0之后需要：\n\n\t\tIntent intent = new Intent();\n\t\tintent.setAction(action);\n\t\tintent.setPackage(pkgName);\n\t\tcontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n\n##### 魅族手机无法启动 #####\n设置app权限，允许后台运行即可。话说这手机牌子坑爹。\n\n\n##### Can't marshal non-Parcelable objects across processes #####\nmsg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。\n \n \n##### MainActivity has leaked ServiceConnection #####\n页面关闭时，记得unbind","source":"_posts/2017-06-08-android-ipc-messenger-tips - 副本.md","raw":"---\ntitle: 使用Messenger进行进程间通信注意事项\ndate: 2017-6-8 15:49:35\ntags: android\ncategories: work\n---\n\n#### 需求 ####\n\n![需求示意图](/images/auth_sequence_diagram.png)\n\n看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来\n本来懒得费事，一个`startActivityForResult`即可结束战斗\n后来发现，我的SDK里没有UI，也就没有处理`onActivityResult`的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。\n\n#### Messenger的使用 ####\n此处不是我想略，网上教程很多，看个比较完善简单的：[Android 基于Message的进程间通信 Messenger完全解析](http://blog.csdn.net/lmj623565791/article/details/47017485)\n代码有些地方不适合新的Android版本，但是也够用了。\n\n#### 注意事项 ####\n\n##### 需求问题解决 ####\nSDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。\n其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。\nkotlin代码如下：\n\n    var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\n    private val mMessenger = Messenger(object : Handler() {\n        override fun handleMessage(msgfromClient: Message) {\n            val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n            try {\n                when (msgfromClient.what) {\n                    REMOTE_CLIENT -> {//远程访问-SDK\n                        remoteMsg = msgfromClient.replyTo\n                        var intent: Intent = Intent()\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        val appID: String = bundle.get(\"APPID\") as String\n\n                        //开启授权页Activity\n                        intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                        intent.putExtra(\"appID\", appID)\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                        startActivity(intent)\n                    }\n                    LOCAL_CLIENT -> {//本地访问-授权页\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        msgToClient.obj = bundle//拿到授权页信使带来的code\n                        remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                    }\n                }\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            } catch (e: RemoteException) {\n                e.printStackTrace()\n            }\n\n            super.handleMessage(msgfromClient)\n        }\n    })\n\n\n根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。\n\n##### 单向双向 #####\n\tmsgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。\n\n##### 多向通信 ####\n在这个里[Remote Messenger Service Sample](https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample)可以看到多个客户端互相通信的官方示例。\n官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。\n\n##### 隐式启动service #####\n\n 5.0之后需要：\n\n\t\tIntent intent = new Intent();\n\t\tintent.setAction(action);\n\t\tintent.setPackage(pkgName);\n\t\tcontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n\n##### 魅族手机无法启动 #####\n设置app权限，允许后台运行即可。话说这手机牌子坑爹。\n\n\n##### Can't marshal non-Parcelable objects across processes #####\nmsg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。\n \n \n##### MainActivity has leaked ServiceConnection #####\n页面关闭时，记得unbind","slug":"android-ipc-messenger-tips - 副本","published":1,"updated":"2017-06-08T08:53:34.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3tijdmk0052h8ivduk46xlw","content":"<h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p><img src=\"/images/auth_sequence_diagram.png\" alt=\"需求示意图\"></p>\n<p>看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来<br>本来懒得费事，一个<code>startActivityForResult</code>即可结束战斗<br>后来发现，我的SDK里没有UI，也就没有处理<code>onActivityResult</code>的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。</p>\n<h4 id=\"Messenger的使用\"><a href=\"#Messenger的使用\" class=\"headerlink\" title=\"Messenger的使用\"></a>Messenger的使用</h4><p>此处不是我想略，网上教程很多，看个比较完善简单的：<a href=\"http://blog.csdn.net/lmj623565791/article/details/47017485\" target=\"_blank\" rel=\"external\">Android 基于Message的进程间通信 Messenger完全解析</a><br>代码有些地方不适合新的Android版本，但是也够用了。</p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><h5 id=\"需求问题解决\"><a href=\"#需求问题解决\" class=\"headerlink\" title=\"需求问题解决\"></a>需求问题解决</h5><p>SDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。<br>其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。<br>kotlin代码如下：</p>\n<pre><code>var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\nprivate val mMessenger = Messenger(object : Handler() {\n    override fun handleMessage(msgfromClient: Message) {\n        val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n        try {\n            when (msgfromClient.what) {\n                REMOTE_CLIENT -&gt; {//远程访问-SDK\n                    remoteMsg = msgfromClient.replyTo\n                    var intent: Intent = Intent()\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    val appID: String = bundle.get(&quot;APPID&quot;) as String\n\n                    //开启授权页Activity\n                    intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                    intent.putExtra(&quot;appID&quot;, appID)\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                    startActivity(intent)\n                }\n                LOCAL_CLIENT -&gt; {//本地访问-授权页\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    msgToClient.obj = bundle//拿到授权页信使带来的code\n                    remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                }\n            }\n        } catch (e: InterruptedException) {\n            e.printStackTrace()\n        } catch (e: RemoteException) {\n            e.printStackTrace()\n        }\n\n        super.handleMessage(msgfromClient)\n    }\n})\n</code></pre><p>根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。</p>\n<h5 id=\"单向双向\"><a href=\"#单向双向\" class=\"headerlink\" title=\"单向双向\"></a>单向双向</h5><pre><code>msgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n</code></pre><p>这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。</p>\n<h5 id=\"多向通信\"><a href=\"#多向通信\" class=\"headerlink\" title=\"多向通信\"></a>多向通信</h5><p>在这个里<a href=\"https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample\" target=\"_blank\" rel=\"external\">Remote Messenger Service Sample</a>可以看到多个客户端互相通信的官方示例。<br>官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。</p>\n<h5 id=\"隐式启动service\"><a href=\"#隐式启动service\" class=\"headerlink\" title=\"隐式启动service\"></a>隐式启动service</h5><p> 5.0之后需要：</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(action);\nintent.setPackage(pkgName);\ncontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n</code></pre><h5 id=\"魅族手机无法启动\"><a href=\"#魅族手机无法启动\" class=\"headerlink\" title=\"魅族手机无法启动\"></a>魅族手机无法启动</h5><p>设置app权限，允许后台运行即可。话说这手机牌子坑爹。</p>\n<h5 id=\"Can’t-marshal-non-Parcelable-objects-across-processes\"><a href=\"#Can’t-marshal-non-Parcelable-objects-across-processes\" class=\"headerlink\" title=\"Can’t marshal non-Parcelable objects across processes\"></a>Can’t marshal non-Parcelable objects across processes</h5><p>msg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。</p>\n<h5 id=\"MainActivity-has-leaked-ServiceConnection\"><a href=\"#MainActivity-has-leaked-ServiceConnection\" class=\"headerlink\" title=\"MainActivity has leaked ServiceConnection\"></a>MainActivity has leaked ServiceConnection</h5><p>页面关闭时，记得unbind</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p><img src=\"/images/auth_sequence_diagram.png\" alt=\"需求示意图\"></p>\n<p>看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来<br>本来懒得费事，一个<code>startActivityForResult</code>即可结束战斗<br>后来发现，我的SDK里没有UI，也就没有处理<code>onActivityResult</code>的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。</p>\n<h4 id=\"Messenger的使用\"><a href=\"#Messenger的使用\" class=\"headerlink\" title=\"Messenger的使用\"></a>Messenger的使用</h4><p>此处不是我想略，网上教程很多，看个比较完善简单的：<a href=\"http://blog.csdn.net/lmj623565791/article/details/47017485\" target=\"_blank\" rel=\"external\">Android 基于Message的进程间通信 Messenger完全解析</a><br>代码有些地方不适合新的Android版本，但是也够用了。</p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><h5 id=\"需求问题解决\"><a href=\"#需求问题解决\" class=\"headerlink\" title=\"需求问题解决\"></a>需求问题解决</h5><p>SDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。<br>其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。<br>kotlin代码如下：</p>\n<pre><code>var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\nprivate val mMessenger = Messenger(object : Handler() {\n    override fun handleMessage(msgfromClient: Message) {\n        val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n        try {\n            when (msgfromClient.what) {\n                REMOTE_CLIENT -&gt; {//远程访问-SDK\n                    remoteMsg = msgfromClient.replyTo\n                    var intent: Intent = Intent()\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    val appID: String = bundle.get(&quot;APPID&quot;) as String\n\n                    //开启授权页Activity\n                    intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                    intent.putExtra(&quot;appID&quot;, appID)\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                    startActivity(intent)\n                }\n                LOCAL_CLIENT -&gt; {//本地访问-授权页\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    msgToClient.obj = bundle//拿到授权页信使带来的code\n                    remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                }\n            }\n        } catch (e: InterruptedException) {\n            e.printStackTrace()\n        } catch (e: RemoteException) {\n            e.printStackTrace()\n        }\n\n        super.handleMessage(msgfromClient)\n    }\n})\n</code></pre><p>根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。</p>\n<h5 id=\"单向双向\"><a href=\"#单向双向\" class=\"headerlink\" title=\"单向双向\"></a>单向双向</h5><pre><code>msgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n</code></pre><p>这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。</p>\n<h5 id=\"多向通信\"><a href=\"#多向通信\" class=\"headerlink\" title=\"多向通信\"></a>多向通信</h5><p>在这个里<a href=\"https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample\" target=\"_blank\" rel=\"external\">Remote Messenger Service Sample</a>可以看到多个客户端互相通信的官方示例。<br>官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。</p>\n<h5 id=\"隐式启动service\"><a href=\"#隐式启动service\" class=\"headerlink\" title=\"隐式启动service\"></a>隐式启动service</h5><p> 5.0之后需要：</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(action);\nintent.setPackage(pkgName);\ncontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n</code></pre><h5 id=\"魅族手机无法启动\"><a href=\"#魅族手机无法启动\" class=\"headerlink\" title=\"魅族手机无法启动\"></a>魅族手机无法启动</h5><p>设置app权限，允许后台运行即可。话说这手机牌子坑爹。</p>\n<h5 id=\"Can’t-marshal-non-Parcelable-objects-across-processes\"><a href=\"#Can’t-marshal-non-Parcelable-objects-across-processes\" class=\"headerlink\" title=\"Can’t marshal non-Parcelable objects across processes\"></a>Can’t marshal non-Parcelable objects across processes</h5><p>msg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。</p>\n<h5 id=\"MainActivity-has-leaked-ServiceConnection\"><a href=\"#MainActivity-has-leaked-ServiceConnection\" class=\"headerlink\" title=\"MainActivity has leaked ServiceConnection\"></a>MainActivity has leaked ServiceConnection</h5><p>页面关闭时，记得unbind</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj3tijdhf0006h8ivsk3kt690","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdhp000ch8ivg9x8rd85"},{"post_id":"cj3tijdgv0000h8iv3oydp7o8","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdht000gh8ivr2z0clwp"},{"post_id":"cj3tijdhh0007h8ivwnlf4ji4","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdhw000jh8iv4c1e9ubt"},{"post_id":"cj3tijdhl000bh8ivud0oyezz","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdhz000mh8ive2svb4y6"},{"post_id":"cj3tijdh30002h8ivhh91f7i1","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdi2000ph8iv6ehcsiya"},{"post_id":"cj3tijdhq000dh8ivkbyt4gc6","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdi6000th8ivbx65l1zn"},{"post_id":"cj3tijdht000hh8ivl3lqyb80","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdi8000wh8ivrmm64w70"},{"post_id":"cj3tijdha0005h8ivchn6m37t","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdib0010h8ivvr82to6c"},{"post_id":"cj3tijdhx000kh8iv9ui2iale","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdih0013h8ivsaomlufd"},{"post_id":"cj3tijdi0000nh8ivmuq252cn","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdim0016h8iv5c2hy404"},{"post_id":"cj3tijdi3000qh8iv466urr2u","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdiq001ah8iv3rrbei6u"},{"post_id":"cj3tijdi7000uh8ivx58zom4k","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdit001dh8ivjo3rmc9j"},{"post_id":"cj3tijdi9000xh8ivg16dp68e","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdix001hh8iva24zf377"},{"post_id":"cj3tijdic0011h8ivwntlyjxq","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdj0001kh8ivz5ad9vl0"},{"post_id":"cj3tijdii0014h8iv36klxljb","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdj4001oh8ivmhwuup6n"},{"post_id":"cj3tijdin0018h8ivqol8eeea","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdj6001rh8iv7xm9brle"},{"post_id":"cj3tijdir001bh8ivfxczs8lj","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdj8001uh8ivfkt5olwp"},{"post_id":"cj3tijdiv001fh8ivxryotn4n","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjc001xh8ivwof5jnvn"},{"post_id":"cj3tijdix001ih8ivn4ofpl00","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjf0020h8ivmf8lgjim"},{"post_id":"cj3tijdj1001mh8ivr35ghav1","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdji0023h8iva0w09p1f"},{"post_id":"cj3tijdj4001ph8ivn67c7fp7","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjl0026h8ivk1qhgei9"},{"post_id":"cj3tijdj6001sh8ivs9g6nzbf","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjo0029h8iv0v3xhdm1"},{"post_id":"cj3tijdj9001vh8ivnw9kcn0l","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjq002ch8ivna9p4efj"},{"post_id":"cj3tijdjc001yh8ivvtdluupy","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjs002fh8ivikou6s7k"},{"post_id":"cj3tijdjg0021h8ivuxy50xng","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdjv002ih8ivbh1x19si"},{"post_id":"cj3tijdjj0024h8ivx402ma18","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdk0002lh8ivh83x1uq9"},{"post_id":"cj3tijdjl0027h8iv3jtr5lia","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdk3002oh8ivw8x3w7p9"},{"post_id":"cj3tijdjo002ah8ivlgbzgzb1","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdk5002rh8ivos62wrzd"},{"post_id":"cj3tijdjq002dh8ivusdaiwe1","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdk8002uh8ivhcf9uk7a"},{"post_id":"cj3tijdjs002gh8ivlx7pnm2d","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdka002xh8ivzvw89yoe"},{"post_id":"cj3tijdjw002jh8ivzrupo9y0","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdkb0030h8ivlayu46ok"},{"post_id":"cj3tijdk0002mh8ivxuuygcn6","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdke0033h8ivh1o5hqa4"},{"post_id":"cj3tijdk3002ph8iva6cyv54y","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdki0036h8ivub76ltzw"},{"post_id":"cj3tijdk6002sh8ivdzzosa13","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdkm0039h8ivt2mkbetq"},{"post_id":"cj3tijdk8002vh8ivwfe7kdvw","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdkq003ch8ivs54p0pqw"},{"post_id":"cj3tijdka002yh8ivokg4q7jc","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdks003fh8ivzy2ybf7t"},{"post_id":"cj3tijdkc0031h8iv7uki82ui","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdkv003ih8iv3vy7ih4p"},{"post_id":"cj3tijdkf0034h8ivl6ypfz98","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdkx003lh8ivmshyk5ud"},{"post_id":"cj3tijdki0037h8ivhegjo6ai","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdl0003oh8ivkxjh1xye"},{"post_id":"cj3tijdkn003ah8iv5g8yc5q1","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdl3003rh8ivr36e6hyg"},{"post_id":"cj3tijdkq003dh8ivte4j6mi3","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdl5003uh8ivl3udlmfj"},{"post_id":"cj3tijdkt003gh8ivl1qgak34","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdl8003xh8iv1j1eaae1"},{"post_id":"cj3tijdkv003jh8ivc48k2ptt","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdla0040h8iv6hfasr3w"},{"post_id":"cj3tijdkx003mh8ivd3sz36lc","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdlb0043h8iv0l2do5vv"},{"post_id":"cj3tijdl1003ph8ivrz0utr7n","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdle0046h8ivun114rk5"},{"post_id":"cj3tijdl4003sh8ivynmeiqh9","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdlq0049h8ive6glthgk"},{"post_id":"cj3tijdl6003vh8ivmvua0pqc","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdlt004ch8ivivpia1iv"},{"post_id":"cj3tijdl8003yh8ivva4hy9a8","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdlw004fh8ivcn3xrlx3"},{"post_id":"cj3tijdla0041h8ivfo8dmzvy","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdly004ih8ivoz5d7h1e"},{"post_id":"cj3tijdlc0044h8iva1o9wfqk","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm1004lh8ivjt614dt4"},{"post_id":"cj3tijdle0047h8iv1qkwn53z","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm3004oh8ivhd2p2lfa"},{"post_id":"cj3tijdlr004ah8ivu9fonfdr","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm4004qh8iv5ghf7eli"},{"post_id":"cj3tijdlt004dh8ivbv1763nq","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm4004sh8iv3m4pmw0z"},{"post_id":"cj3tijdlw004gh8iv2hgw7p36","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm5004uh8ivsvfjd224"},{"post_id":"cj3tijdlz004jh8ivh9r2xhip","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm5004wh8ivunzvrm2h"},{"post_id":"cj3tijdm1004mh8ivjgurjwqq","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdm5004yh8ivfgesgh5b"},{"post_id":"cj3tijdmk0052h8ivduk46xlw","category_id":"cj3tijdh60003h8iv9a4p1142","_id":"cj3tijdmp0055h8iv6s0hw7j5"}],"PostTag":[{"post_id":"cj3tijdgv0000h8iv3oydp7o8","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdhl000ah8ivozwo6gv7"},{"post_id":"cj3tijdh30002h8ivhh91f7i1","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdhv000ih8ivhqa5pthg"},{"post_id":"cj3tijdha0005h8ivchn6m37t","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdi2000oh8iv1n1bechg"},{"post_id":"cj3tijdhx000kh8iv9ui2iale","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdi4000rh8ivq4hxrau6"},{"post_id":"cj3tijdi0000nh8ivmuq252cn","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdi8000vh8iv8ctzll1n"},{"post_id":"cj3tijdhf0006h8ivsk3kt690","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdia000yh8iv85wbz5ll"},{"post_id":"cj3tijdi7000uh8ivx58zom4k","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdie0012h8ivegy8dbs8"},{"post_id":"cj3tijdhh0007h8ivwnlf4ji4","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdil0015h8iv6xj3s7md"},{"post_id":"cj3tijdi9000xh8ivg16dp68e","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdio0019h8ivnpcej5f8"},{"post_id":"cj3tijdic0011h8ivwntlyjxq","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdis001ch8ivlcxh5m2b"},{"post_id":"cj3tijdhl000bh8ivud0oyezz","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdiw001gh8ivvpp837lq"},{"post_id":"cj3tijdii0014h8iv36klxljb","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdiz001jh8iv1udvdifx"},{"post_id":"cj3tijdin0018h8ivqol8eeea","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdj3001nh8ivbgg7mgm4"},{"post_id":"cj3tijdhq000dh8ivkbyt4gc6","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdj5001qh8ivszo177d0"},{"post_id":"cj3tijdir001bh8ivfxczs8lj","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdj7001th8ivcxiitgfl"},{"post_id":"cj3tijdiv001fh8ivxryotn4n","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdjb001wh8iva6yz9sj7"},{"post_id":"cj3tijdht000hh8ivl3lqyb80","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdje001zh8iv10jif9tz"},{"post_id":"cj3tijdix001ih8ivn4ofpl00","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdjh0022h8ivafcaia56"},{"post_id":"cj3tijdj1001mh8ivr35ghav1","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdjk0025h8ivq37b0b72"},{"post_id":"cj3tijdi3000qh8iv466urr2u","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdjn0028h8ivumvnq3ct"},{"post_id":"cj3tijdj4001ph8ivn67c7fp7","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdjq002bh8iv2crqr8ra"},{"post_id":"cj3tijdj6001sh8ivs9g6nzbf","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdjr002eh8ivrfie0cyd"},{"post_id":"cj3tijdj9001vh8ivnw9kcn0l","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdju002hh8ivcq8vq9e1"},{"post_id":"cj3tijdjc001yh8ivvtdluupy","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdjz002kh8ivk5amuc14"},{"post_id":"cj3tijdjg0021h8ivuxy50xng","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdk2002nh8iv1qpcvaj8"},{"post_id":"cj3tijdjj0024h8ivx402ma18","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdk4002qh8ivhogp7fuh"},{"post_id":"cj3tijdjl0027h8iv3jtr5lia","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdk7002th8ivki195k25"},{"post_id":"cj3tijdjo002ah8ivlgbzgzb1","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdk9002wh8ivscwdcoof"},{"post_id":"cj3tijdjq002dh8ivusdaiwe1","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdkb002zh8ivngy65hbq"},{"post_id":"cj3tijdjq002dh8ivusdaiwe1","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdkd0032h8ivnugt6qyz"},{"post_id":"cj3tijdjs002gh8ivlx7pnm2d","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdkg0035h8ivcnh6nfzf"},{"post_id":"cj3tijdjw002jh8ivzrupo9y0","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdkl0038h8ivwek3xom5"},{"post_id":"cj3tijdk0002mh8ivxuuygcn6","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdko003bh8ivkof52hka"},{"post_id":"cj3tijdk3002ph8iva6cyv54y","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdkr003eh8iv2fw1r6vb"},{"post_id":"cj3tijdk6002sh8ivdzzosa13","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdku003hh8ivec76a2ae"},{"post_id":"cj3tijdk8002vh8ivwfe7kdvw","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdkw003kh8ivo2ja16gd"},{"post_id":"cj3tijdka002yh8ivokg4q7jc","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdkz003nh8iv7vixfi9z"},{"post_id":"cj3tijdkc0031h8iv7uki82ui","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdl3003qh8iv0mitncfw"},{"post_id":"cj3tijdkf0034h8ivl6ypfz98","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdl5003th8iv8xmettjt"},{"post_id":"cj3tijdki0037h8ivhegjo6ai","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdl7003wh8ivkmh9yyfv"},{"post_id":"cj3tijdkn003ah8iv5g8yc5q1","tag_id":"cj3tijdh90004h8ivtfaud753","_id":"cj3tijdl9003zh8ivvmj95i5a"},{"post_id":"cj3tijdkq003dh8ivte4j6mi3","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdlb0042h8ivwo2c8xh5"},{"post_id":"cj3tijdkt003gh8ivl1qgak34","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdld0045h8ivdkgbutd7"},{"post_id":"cj3tijdkv003jh8ivc48k2ptt","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdlf0048h8iv8icxye0y"},{"post_id":"cj3tijdkx003mh8ivd3sz36lc","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdls004bh8iv4bl4svxp"},{"post_id":"cj3tijdl1003ph8ivrz0utr7n","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdlv004eh8iva9kkkvv9"},{"post_id":"cj3tijdl4003sh8ivynmeiqh9","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdly004hh8ivj5e9f9ef"},{"post_id":"cj3tijdl6003vh8ivmvua0pqc","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm0004kh8ivz0db7obo"},{"post_id":"cj3tijdl8003yh8ivva4hy9a8","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm2004nh8ivtx7bx077"},{"post_id":"cj3tijdla0041h8ivfo8dmzvy","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm3004ph8iv70qs6tvy"},{"post_id":"cj3tijdlc0044h8iva1o9wfqk","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm4004rh8ivlmaagvm3"},{"post_id":"cj3tijdle0047h8iv1qkwn53z","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm4004th8iv60cec0og"},{"post_id":"cj3tijdlr004ah8ivu9fonfdr","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm5004vh8ivi4k1uqti"},{"post_id":"cj3tijdlt004dh8ivbv1763nq","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm5004xh8ivhbsrk5r3"},{"post_id":"cj3tijdlw004gh8iv2hgw7p36","tag_id":"cj3tijdia000zh8ivqqx98vdg","_id":"cj3tijdm6004zh8ivrz8mqsv8"},{"post_id":"cj3tijdlz004jh8ivh9r2xhip","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdm60050h8ivuhbhkjgw"},{"post_id":"cj3tijdm1004mh8ivjgurjwqq","tag_id":"cj3tijdi5000sh8iv2g8x8935","_id":"cj3tijdm60051h8ivqy7rn0ug"},{"post_id":"cj3tijdmk0052h8ivduk46xlw","tag_id":"cj3tijdhj0009h8ivksux3ej6","_id":"cj3tijdmo0054h8ivjkow7pg2"}],"Tag":[{"name":"算法","_id":"cj3tijdh90004h8ivtfaud753"},{"name":"android","_id":"cj3tijdhj0009h8ivksux3ej6"},{"name":"杂项","_id":"cj3tijdi5000sh8iv2g8x8935"},{"name":"设计模式","_id":"cj3tijdia000zh8ivqqx98vdg"}]}}