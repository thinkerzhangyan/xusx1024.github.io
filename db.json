{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.MDOWN","path":"README.MDOWN","modified":1,"renderable":0},{"_id":"source/images/7r_muvaqb4myb9.jpg","path":"images/7r_muvaqb4myb9.jpg","modified":1,"renderable":0},{"_id":"source/images/Application_launch.jpg","path":"images/Application_launch.jpg","modified":1,"renderable":0},{"_id":"source/images/SA&rank.png","path":"images/SA&rank.png","modified":1,"renderable":0},{"_id":"source/images/abstract_factory_class_diagram.png","path":"images/abstract_factory_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/abstract_factory_product_level.png","path":"images/abstract_factory_product_level.png","modified":1,"renderable":0},{"_id":"source/images/abstract_factory_sequence_diagram.png","path":"images/abstract_factory_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/adapter_pattern_class_diagram_1.png","path":"images/adapter_pattern_class_diagram_1.png","modified":1,"renderable":0},{"_id":"source/images/adapter_pattern_class_diagram_2.png","path":"images/adapter_pattern_class_diagram_2.png","modified":1,"renderable":0},{"_id":"source/images/adapter_pattern_sequence_diagram.png","path":"images/adapter_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/adm_question.png","path":"images/adm_question.png","modified":1,"renderable":0},{"_id":"source/images/adb_launch_time.png","path":"images/adb_launch_time.png","modified":1,"renderable":0},{"_id":"source/images/alertDialog.png","path":"images/alertDialog.png","modified":1,"renderable":0},{"_id":"source/images/andfix-yuanli.png","path":"images/andfix-yuanli.png","modified":1,"renderable":0},{"_id":"source/images/app_main.png","path":"images/app_main.png","modified":1,"renderable":0},{"_id":"source/images/auth_sequence_diagram.png","path":"images/auth_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/battery-historian-upload.png","path":"images/battery-historian-upload.png","modified":1,"renderable":0},{"_id":"source/images/battery_historian_file_info.png","path":"images/battery_historian_file_info.png","modified":1,"renderable":0},{"_id":"source/images/battery_historian_historian.png","path":"images/battery_historian_historian.png","modified":1,"renderable":0},{"_id":"source/images/bridge_pattern_class_diagram.png","path":"images/bridge_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/bridge_pattern_sequence_diagram.png","path":"images/bridge_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/bucket-sort-1.png","path":"images/bucket-sort-1.png","modified":1,"renderable":0},{"_id":"source/images/battery_temperature.png","path":"images/battery_temperature.png","modified":1,"renderable":0},{"_id":"source/images/bucket-sort-2.png","path":"images/bucket-sort-2.png","modified":1,"renderable":0},{"_id":"source/images/cas.png","path":"images/cas.png","modified":1,"renderable":0},{"_id":"source/images/chain_of_responsibility_class_diagram.png","path":"images/chain_of_responsibility_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/chain_of_responsibility_sequence_diagram.png","path":"images/chain_of_responsibility_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/color-key-for-debug-GPU-overdraw-output.png","path":"images/color-key-for-debug-GPU-overdraw-output.png","modified":1,"renderable":0},{"_id":"source/images/command_pattern_sequence_diagram.png","path":"images/command_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/command_pattern_class_diagram.png","path":"images/command_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/composite_pattern_class_diagram_1.png","path":"images/composite_pattern_class_diagram_1.png","modified":1,"renderable":0},{"_id":"source/images/composite_pattern_class_diagram_2.png","path":"images/composite_pattern_class_diagram_2.png","modified":1,"renderable":0},{"_id":"source/images/counting_sort_1.png","path":"images/counting_sort_1.png","modified":1,"renderable":0},{"_id":"source/images/decorator_pattern_class_diagram_1.png","path":"images/decorator_pattern_class_diagram_1.png","modified":1,"renderable":0},{"_id":"source/images/dalvik&art.png","path":"images/dalvik&art.png","modified":1,"renderable":0},{"_id":"source/images/decorator_pattern_class_diagram_2.png","path":"images/decorator_pattern_class_diagram_2.png","modified":1,"renderable":0},{"_id":"source/images/decorator_pattern_class_diagram_3.png","path":"images/decorator_pattern_class_diagram_3.png","modified":1,"renderable":0},{"_id":"source/images/decorator_pattern_sequence_diagram.png","path":"images/decorator_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/display_activity.png","path":"images/display_activity.png","modified":1,"renderable":0},{"_id":"source/images/display_time.png","path":"images/display_time.png","modified":1,"renderable":0},{"_id":"source/images/facade_pattern_class_diagram.png","path":"images/facade_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/facade_pattern_sequence_diagram.png","path":"images/facade_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/factory_method_class_diagram.png","path":"images/factory_method_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/factory_method_sequence_diagram.png","path":"images/factory_method_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/favicon.jpg","path":"images/favicon.jpg","modified":1,"renderable":0},{"_id":"source/images/flyweight_pattern_class_diagram_1.png","path":"images/flyweight_pattern_class_diagram_1.png","modified":1,"renderable":0},{"_id":"source/images/flyweight_pattern_class_diagram_2.png","path":"images/flyweight_pattern_class_diagram_2.png","modified":1,"renderable":0},{"_id":"source/images/flyweight_pattern_sequence_diagram.png","path":"images/flyweight_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/freud.jpg","path":"images/freud.jpg","modified":1,"renderable":0},{"_id":"source/images/interpreter_class_diagram.png","path":"images/interpreter_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/iterator_pattern_class_diagram.png","path":"images/iterator_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/kotlin_extension_fun.png","path":"images/kotlin_extension_fun.png","modified":1,"renderable":0},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":0},{"_id":"source/images/mediator_pattern_class_diagram.png","path":"images/mediator_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/mediator_pattern_sequence_diagram.png","path":"images/mediator_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/memento_pattern_class_diagram.png","path":"images/memento_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/memento_pattern_sequence_diagram.png","path":"images/memento_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-1.png","path":"images/nimabledroid-1.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-2.png","path":"images/nimabledroid-2.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-3.png","path":"images/nimabledroid-3.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-4.png","path":"images/nimabledroid-4.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-5.png","path":"images/nimabledroid-5.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-6.png","path":"images/nimabledroid-6.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-8.png","path":"images/nimabledroid-8.png","modified":1,"renderable":0},{"_id":"source/images/observer_pattern_class_diagram.png","path":"images/observer_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/observer_pattern_sequence_diagram.png","path":"images/observer_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/prefix_doubleing_demo_1.png","path":"images/prefix_doubleing_demo_1.png","modified":1,"renderable":0},{"_id":"source/images/profileGPURendering.png","path":"images/profileGPURendering.png","modified":1,"renderable":0},{"_id":"source/images/prototype_class_uml.png","path":"images/prototype_class_uml.png","modified":1,"renderable":0},{"_id":"source/images/prototype_sequence_uml.png","path":"images/prototype_sequence_uml.png","modified":1,"renderable":0},{"_id":"source/images/proxy_pattern_class_diagram.png","path":"images/proxy_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/proxy_pattern_sequence_diagram.png","path":"images/proxy_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/report_full_drawn.png","path":"images/report_full_drawn.png","modified":1,"renderable":0},{"_id":"source/images/setup-docker-toolbox.png","path":"images/setup-docker-toolbox.png","modified":1,"renderable":0},{"_id":"source/images/simple_factory_class_diagram.png","path":"images/simple_factory_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/simple_factory_sequence_diagram.png","path":"images/simple_factory_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/state_pattern_class_diagram.png","path":"images/state_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/state_pattern_sequence_diagram.png","path":"images/state_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/strategy_pattern_class_diagram.png","path":"images/strategy_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/system_server.png","path":"images/system_server.png","modified":1,"renderable":0},{"_id":"source/images/strategy_pattern_sequence_diagram.png","path":"images/strategy_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/template_method_pattern_class_diagram.png","path":"images/template_method_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/thread-read-write.jpg","path":"images/thread-read-write.jpg","modified":1,"renderable":0},{"_id":"source/images/visitor_pattern_sequence_diagram.png","path":"images/visitor_pattern_sequence_diagram.png","modified":1,"renderable":0},{"_id":"source/images/visitor_pattern_class_diagram.png","path":"images/visitor_pattern_class_diagram.png","modified":1,"renderable":0},{"_id":"source/images/weixin.png","path":"images/weixin.png","modified":1,"renderable":0},{"_id":"source/images/why_need_lock.jpg","path":"images/why_need_lock.jpg","modified":1,"renderable":0},{"_id":"source/images/wifi-supplicant.png","path":"images/wifi-supplicant.png","modified":1,"renderable":0},{"_id":"source/images/window_uml.jpg","path":"images/window_uml.jpg","modified":1,"renderable":0},{"_id":"source/images/zhifubao.PNG","path":"images/zhifubao.PNG","modified":1,"renderable":0},{"_id":"source/images/HTTP持久连接.png","path":"images/HTTP持久连接.png","modified":1,"renderable":0},{"_id":"source/images/ZygoteInit.png","path":"images/ZygoteInit.png","modified":1,"renderable":0},{"_id":"source/images/andfix-guocheng.png","path":"images/andfix-guocheng.png","modified":1,"renderable":0},{"_id":"source/images/android-framework.png","path":"images/android-framework.png","modified":1,"renderable":0},{"_id":"source/images/android-singleton-1.png","path":"images/android-singleton-1.png","modified":1,"renderable":0},{"_id":"source/images/android-start-1.png","path":"images/android-start-1.png","modified":1,"renderable":0},{"_id":"source/images/android-singleton-2.png","path":"images/android-singleton-2.png","modified":1,"renderable":0},{"_id":"source/images/android-start-2.png","path":"images/android-start-2.png","modified":1,"renderable":0},{"_id":"source/images/apk-build.jpg","path":"images/apk-build.jpg","modified":1,"renderable":0},{"_id":"source/images/bind_application.jpg","path":"images/bind_application.jpg","modified":1,"renderable":0},{"_id":"source/images/buckets_sort.png","path":"images/buckets_sort.png","modified":1,"renderable":0},{"_id":"source/images/jiezishu.jpg","path":"images/jiezishu.jpg","modified":1,"renderable":0},{"_id":"source/images/launch_android.png","path":"images/launch_android.png","modified":1,"renderable":0},{"_id":"source/images/nimabledroid-7.png","path":"images/nimabledroid-7.png","modified":1,"renderable":0},{"_id":"source/images/process_creation.jpg","path":"images/process_creation.jpg","modified":1,"renderable":0},{"_id":"source/images/radix_sort.png","path":"images/radix_sort.png","modified":1,"renderable":0},{"_id":"source/images/start_activity.jpg","path":"images/start_activity.jpg","modified":1,"renderable":0},{"_id":"source/images/tcp-ip通信传输流.png","path":"images/tcp-ip通信传输流.png","modified":1,"renderable":0},{"_id":"source/images/window_layer.jpg","path":"images/window_layer.jpg","modified":1,"renderable":0},{"_id":"source/images/counting_sort_2.png","path":"images/counting_sort_2.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/images/banner.jpg","path":"images/banner.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/particle.js","path":"js/src/particle.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/images/activity-window-layer.jpg","path":"images/activity-window-layer.jpg","modified":1,"renderable":0},{"_id":"source/images/java_web_study_path.png","path":"images/java_web_study_path.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"source/images/executePhase.png","path":"images/executePhase.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"ade5084bc2268cad70fa91a177ff21e537983169","modified":1487228298683},{"_id":"source/README.MDOWN","hash":"333070538f45d2ca6a79d385c52c5c2dc62de6c2","modified":1496310320063},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1496297484613},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1496297484613},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1496297484615},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1496297484617},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1496297484617},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1496297484617},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1496297484618},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1496297484619},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1496297484619},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1496297484618},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1496297484619},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1496297484620},{"_id":"themes/next/bower.json","hash":"936b9aed1934471bb74cdaacc3fb8031eb01fe23","modified":1496297484621},{"_id":"themes/next/_config.yml","hash":"f503fd9c3f96a9cd93b25cf3078a8a45de92c329","modified":1498440591175},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1496297484621},{"_id":"themes/next/package.json","hash":"a5c189d4c4e946e936d3b5e29e2d81ddaf03ff96","modified":1496297484668},{"_id":"source/_posts/2017-02-07-stack-with-getmin-fun.md","hash":"d51018f59602d6ab9e705dc320e683b818ca1110","modified":1502937416177},{"_id":"source/_posts/2017-02-06-first-post.md","hash":"f5eb7b86f99b2eb472c916ae5f6a38908803d8f1","modified":1502937378523},{"_id":"source/_posts/2017-02-09-Debug-GPU-Overdraw-Walkthrough.md","hash":"e2c7004f1ec7f7db8619ac5929b39b0ad608b8ad","modified":1510820835765},{"_id":"source/_posts/2017-02-09-Profile-Gpu-rendering.md","hash":"8e3fb9a725143be49d7a4cf535d83114dde197f6","modified":1510821013765},{"_id":"source/_posts/2017-02-11-design-patterns-singleton-1.md","hash":"807c6a2e2a7c6c60d7b9fa5172a41b7e9f0a2794","modified":1502937554300},{"_id":"source/_posts/2017-02-10-how-use-android-device-monitor.md","hash":"1e16e3b318f5c9b39185902c12fdbb9b97f8beeb","modified":1510821000046},{"_id":"source/_posts/2017-02-11-design-patterns-singleton-2.md","hash":"4fe6834c0989338743ad6751b527c5f99c142f24","modified":1502937560998},{"_id":"source/_posts/2017-02-11-different-between-ADT.md","hash":"5c9aea1fe25388e5ce1678c4ff95c1270d773449","modified":1502937579666},{"_id":"source/_posts/2017-02-11-two-stacks-makeup-queue.md","hash":"78e0181a549f24831e936cf0226ff9ed50d742df","modified":1502937602139},{"_id":"source/_posts/2017-02-11-reverse-stack.md","hash":"59982a487b85b39e6b6878b3a512885e6f6608df","modified":1502937587395},{"_id":"source/_posts/2017-02-12-design-patterns-singleton-4.md","hash":"0f8351696994a3b1a16bcc4149edfb2cc491f28e","modified":1502937612795},{"_id":"source/_posts/2017-02-13-optimization-app-launch.md","hash":"b889c0f810758b01299dbcc060f0f0b54cccb960","modified":1510820979342},{"_id":"source/_posts/2017-02-16-get-max-window.md","hash":"49f16c1d80de3b57d67cb7588743f77bf4a40583","modified":1502937642550},{"_id":"source/_posts/2017-02-16-hanoi-problom.md","hash":"64317e0ae1c545c8962039e18a84337949d718ed","modified":1502937667537},{"_id":"source/_posts/2017-02-17-get-max-tree.md","hash":"59a4ff889a95e5e324dc32d65e405788ca888d6d","modified":1502937671473},{"_id":"source/_posts/2017-02-20-decrease-apk-size.md","hash":"5a551a2b147fcdc15b306f28a3a8947b0fab2808","modified":1510820967184},{"_id":"source/_posts/2017-02-21-design-patterns-singleton-5.md","hash":"b8b832c2ffc2853e85a14330b4c2aeb594bdb337","modified":1502937689170},{"_id":"source/_posts/2017-02-14-sort-stack-by-stack.md","hash":"f79d633585eb9a6439c03e7a7435774551fccf32","modified":1502937633218},{"_id":"source/_posts/2017-02-22-android-system-service-all.md","hash":"d0862a6b004e2e7e62c936a20b80c72ce1c9c72f","modified":1513663827237},{"_id":"source/_posts/2017-02-23-android-system-service-LayoutInflater.md","hash":"cdbda9f3c76cffacb98edcdba482c8d16bbe4537","modified":1502937773095},{"_id":"source/_posts/2017-02-23-java-volatile.md","hash":"e1988d2864155b66fb84da1b6917daa87e19c151","modified":1502937717444},{"_id":"source/_posts/2017-03-01-kotlin-in-project.md","hash":"ac9ea46239d87bbc182f89de3338f942e2ce902f","modified":1502937724458},{"_id":"source/_posts/2017-03-02-android-system-service-window-manager.md","hash":"fc99a3803884427bbd465b815d3a04df29290ca7","modified":1502937761252},{"_id":"source/_posts/2017-03-03-design-patterns-builder-1.md","hash":"0d80ee3fcd5e35aae63cf63b25d5bdf376ac9ad9","modified":1502937784747},{"_id":"source/_posts/2017-03-03-design-patterns-builder-2.md","hash":"3e97fd9490cbc87cf1f4278a658a647ef7d5c2af","modified":1502937788987},{"_id":"source/_posts/2017-03-15-tinker-source-code-1.md","hash":"8f0ee6abc67caf4aa694a324aeb00799a7e7c65d","modified":1510821141053},{"_id":"source/_posts/2017-03-18-design-patterns-prototype-1.md","hash":"79340a7de0c7091cd1f47b5ec2d29a2742144bb3","modified":1502937817365},{"_id":"source/_posts/2017-02-11-design-patterns-singleton-3.md","hash":"b8841672f5a9cf78786d8c6c84c6bfcd22510a60","modified":1502937568616},{"_id":"source/_posts/2017-03-19-design-patterns-prototype-2.md","hash":"429831e8d382d6a2e080d93dc69d499a65165d9e","modified":1502937838317},{"_id":"source/_posts/2017-03-18-design-patterns-start.md","hash":"f8d746bcb46ac48d813d84dfda923b1bb5dc735a","modified":1502937834364},{"_id":"source/_posts/2017-03-27-kernel-user-space.md","hash":"472bcd407b268e495a6bae582ed39cbd16536d4e","modified":1502937852328},{"_id":"source/_posts/2017-03-30-tinker-source-code-3.md","hash":"87da6b99b70ae0fc5cc0624b661df175e67cae5b","modified":1517392464753},{"_id":"source/_posts/2017-03-30-tinker-source-code-2.md","hash":"0690ccfc40be2946d2ab6f40d5bde736468d668b","modified":1510821148463},{"_id":"source/_posts/2017-04-01-findbug-notes.md","hash":"31497ad12fcc9128cb0c27632764114c8a7a65a7","modified":1502937932031},{"_id":"source/_posts/2017-04-07-git-command.md","hash":"4f2ef2cdba34791b103a682de7e3d582c6b31096","modified":1503293876478},{"_id":"source/_posts/2017-04-10-bucket-sort.md","hash":"c23af2e16b604dbb2b1e5a621646394f0c195b7d","modified":1517392489366},{"_id":"source/_posts/2017-04-10-radix-sort.md","hash":"f90f6a909563453d77077e02a727af2ba5220d9f","modified":1517392496181},{"_id":"source/_posts/2017-04-11-counting-sort.md","hash":"5b91f07afc68a82279578c8c07c2853e0ac6da73","modified":1517392509436},{"_id":"source/_posts/2017-04-11-suffix-sort-baseon-prefix-doubleing.md","hash":"029a15e8d1eab09970214b273d86736fd8ae675b","modified":1517392528538},{"_id":"source/_posts/2017-04-20-android-system-service-AccessibilityManager.md","hash":"b71638d809e22c096e32bd85614f4248c3edf1ba","modified":1502937995806},{"_id":"source/_posts/2017-04-13-suffix-sort-baseon-dc3.md","hash":"3eeb89dfac310adcf4ee5fe2ef165f224455555f","modified":1517392627181},{"_id":"source/_posts/2017-04-21-android-special-api.md","hash":"59fa2568cfabf2f425c40a17c8c24fd392af70a3","modified":1510820955604},{"_id":"source/_posts/2017-05-15-javaee-tips.md","hash":"5df1f60ab8ab1eec871fcf329579e36a5f878064","modified":1502938055552},{"_id":"source/_posts/2017-04-01-android-study-path.md","hash":"7905262d910bd67ecbbd27a81fdbb41cacafe46b","modified":1517797828607},{"_id":"source/_posts/2017-05-09-android-develop-sdk-tips.md","hash":"15a7de5aa9865490279cab258e0f3fadcac1e3c1","modified":1510821266322},{"_id":"source/_posts/2017-05-18-android-system-service-CaptioningManager.md","hash":"2669ac589a096a26df84872e315e163e01192cce","modified":1502938065951},{"_id":"source/_posts/2017-05-23-design-patterns-simple-factory.md","hash":"fa3e0237a725737cd8584ceaf72b8b6e9f09dc9a","modified":1502938074700},{"_id":"source/_posts/2017-05-24-design-patterns-factory-method.md","hash":"b9c773a5a7c5c0a39ce0e7e1d9b641d2a785e105","modified":1502938085477},{"_id":"source/_posts/2017-05-25-design-patterns-strategy-pattern.md","hash":"63216566986c27c51d004321b9925f8c2d7b0a1f","modified":1502938095664},{"_id":"source/_posts/2017-05-25-design-patterns-abstract-factory.md","hash":"a55ec26c6279b910d7edc15258e76f56cad7fca3","modified":1502938091066},{"_id":"source/_posts/2017-05-26-design-patterns-state-pattern.md","hash":"48cd0c0b503ad82af2e1f4d8c13564ee1af1489e","modified":1502938100082},{"_id":"source/_posts/2017-05-31-anti-patterns-constant-interface.md","hash":"259d07e3aa47b020d6c9d19d710e7cf5b41296cd","modified":1502938108898},{"_id":"source/_posts/2017-05-31-anti-patterns.md","hash":"9bad63fdc378ffe9ac17bd872ca825e39bce9e72","modified":1502938105503},{"_id":"source/_posts/2017-06-02-design-patterns-interpreter.md","hash":"1285890570ca6eb2e9e085cffd87b3ead864927e","modified":1502938119695},{"_id":"source/_posts/2017-05-31-design-patterns-chain-of-responsibility.md","hash":"60e044b36885f08444125351cf9137f6f287f3ba","modified":1502938113599},{"_id":"source/_posts/2017-06-08-android-ipc-messenger-tips.md","hash":"6183c0bfdbf60f950c6407a7da0808fcbe38b15c","modified":1510820943290},{"_id":"source/_posts/2017-06-12-httprequest-study-tips.md","hash":"adee9793a045a4b8f01ce276f2319e554f1f5721","modified":1502938163931},{"_id":"source/_posts/2017-06-09-design-patterns-observer.md","hash":"fa26de19268b5e847755b07ebaea047c22094ecd","modified":1502938143305},{"_id":"source/_posts/2017-06-13-ambiguity-effect.md","hash":"210b8beeaf03cb32f0113e363f9e7484fcfba07a","modified":1510821231272},{"_id":"source/_posts/2017-06-13-coding-study-tips.md","hash":"e864e29f1c55eecfd495f791f344f26c01c6aa66","modified":1502938193649},{"_id":"source/_posts/2017-06-13-design-patterns-mediator.md","hash":"7505c8b3c94359122e5e2d834f7a095d29e965c9","modified":1502938204209},{"_id":"source/_posts/2017-06-14-jsp-study-tips.md","hash":"aafa377001b06682736ef30c194388c63b06106a","modified":1505302882984},{"_id":"source/_posts/2017-06-14-design-patterns-command.md","hash":"f3e09027c2511562cfb541b3979d1a1589df64d5","modified":1502938210038},{"_id":"source/_posts/2017-06-15-design-patterns-iterator.md","hash":"d4e804baf7c9966513e71dc72b3354ae8fa4660b","modified":1502938233983},{"_id":"source/_posts/2017-06-16-design-patterns-memento.md","hash":"f186460df1442f67ae420088ac7a96dbe4a1aaba","modified":1502938237468},{"_id":"source/_posts/2017-06-19-design-patterns-template-method.md","hash":"c8c4fc55bea3fbdf8f6715ed7902a7ed35785e4f","modified":1502938241488},{"_id":"source/_posts/2017-06-20-design-patterns-visitor.md","hash":"b33a14f0eed9b84260df96b8628833717e7e88cb","modified":1502938246440},{"_id":"source/_posts/2017-06-21-design-patterns-adapter.md","hash":"30e3f34df18194c38c031cd87b6c1b24d2a8b4d7","modified":1502938255399},{"_id":"source/_posts/2017-06-22-design-patterns-bridge.md","hash":"338f9218dd212cfc67aee2e3fa6a1ae8de6dfd6d","modified":1502938258696},{"_id":"source/_posts/2017-06-26-design-patterns-composite.md","hash":"777df9f40eb5686e0e3af11cfc9de1bfc2abcb1c","modified":1502938269996},{"_id":"source/_posts/2017-06-23-design-patterns-decorator.md","hash":"903354ba9400f7e63ba50224057d75b107a494d3","modified":1502938262738},{"_id":"source/_posts/2017-06-26-design-patterns-facade.md","hash":"43a1d2b0a4ca9284cc4c5a377b3bfb0c358dd093","modified":1502938275152},{"_id":"source/_posts/2017-06-27-design-patterns-flyweight.md","hash":"494646955c71d8267a4f92d73721d1c1c9518a5f","modified":1502938280710},{"_id":"source/_posts/2017-07-03-net-work-day02.md","hash":"60b7fca947202bf8d75e18e26d2bfe8c9d0e4e90","modified":1502938302703},{"_id":"source/_posts/2017-06-29-net-work-day01.md","hash":"129d10000ca6632cf1862ce5fcb6776fd4ce6565","modified":1502938297967},{"_id":"source/_posts/2017-06-28-design-patterns-proxy.md","hash":"19bfb38ec261085a69a06bbeb7a1866382d69cdb","modified":1502938286695},{"_id":"source/_posts/2017-07-03-uses-feature.md","hash":"fdec94c07506718b86f42b4f156f317a0cb7ac9e","modified":1510820926627},{"_id":"source/_posts/2017-07-05-net-work-day03.md","hash":"a960a5ab3f8510f887f2984ed948b5ee1f1b4ce4","modified":1502938320254},{"_id":"source/_posts/2017-07-14-android-notes.md","hash":"a9bfbfef53d9f8d73b8dd67b24255633971c2123","modified":1510820892451},{"_id":"source/_posts/2017-08-17-raspbarry-first.md","hash":"f06467b791bf64960452b2eab025145dcb3958a9","modified":1510821296317},{"_id":"source/_posts/2017-08-17-android-system-service-Account-Manager.md","hash":"4bd34f9dc27930473bd4c4e867c8f4e7d541dfbd","modified":1506677024538},{"_id":"source/_posts/2017-09-19-be-better.md","hash":"6898a63da0a37a465f9301686267b833dc5e71d9","modified":1510821214336},{"_id":"source/_posts/2017-09-29-android-system-service-Activity-Manager.md","hash":"ebcdf52e69281bd49fc334964389b1897e6c35a9","modified":1513650348166},{"_id":"source/_posts/2017-11-17-android-zygote.md","hash":"886d105be03f6e72505573cf0776d68c420ce87d","modified":1510883673028},{"_id":"source/_posts/2017-11-09-android-memory-leak.md","hash":"b0c73aa8d06a626ff9e99af9b21ff6ba8828f77d","modified":1510824461994},{"_id":"source/_posts/2017-11-21-baseball-game.md","hash":"28ee8ea13eec9bc05468b1bbdf9cb5a32a64913d","modified":1517212215608},{"_id":"source/_posts/2017-12-21-pat-yi-1001.md","hash":"5f1d3873e03901043b19a09702853abac1a06d90","modified":1517211907933},{"_id":"source/_posts/2017-12-21-pat-yi-1002.md","hash":"784e5ddd70e441297bc42260d57e57e1a8f9e35a","modified":1517211903707},{"_id":"source/_posts/2017-12-21-pat-yi-1004.md","hash":"f171c5ecfd527665e17fd2d4c751242d60e62c5d","modified":1517211893540},{"_id":"source/_posts/2017-12-21-pat-yi-1003.md","hash":"210bf4f971df512dcf2c7c4cc02c85359f8758a5","modified":1517211899492},{"_id":"source/_posts/2017-12-22-pat-yi-1005.md","hash":"00bda39b28bb618f07ca94852da59e0672b9b854","modified":1517211888154},{"_id":"source/_posts/2017-12-22-pat-yi-1006.md","hash":"357d8ceaae309e0d8232c26d0e0360e01dd9c858","modified":1517211882333},{"_id":"source/_posts/2017-08-22-license-introduce.md","hash":"15a3cb2a8d1905d133a5a7ba11aaece42e129fa9","modified":1503474929572},{"_id":"source/_posts/2017-12-25-pat-yi-1007.md","hash":"cea48bc4522ed4598c8c7a92d270d686c89af99d","modified":1517211878021},{"_id":"source/_posts/2017-12-25-pat-yi-1009.md","hash":"cfec9610485b9c7ed9401596f7a4414b7b4b0082","modified":1517211866923},{"_id":"source/_posts/2017-12-25-pat-yi-1008.md","hash":"91ac257a90790fb724a8cacabb078f4077423c7c","modified":1517211871320},{"_id":"source/_posts/2017-12-25-pat-yi-1010.md","hash":"2989b032834a187e811db756c99d424f309efa23","modified":1517211861398},{"_id":"source/_posts/2017-12-26-kotlin-extension-function.md","hash":"f4056b969122ff64eacacd5aeeaa1ba895579729","modified":1514367289850},{"_id":"source/_posts/2017-12-26-new-year-about-android.md","hash":"bf1952f460e54f60d85b1829d5a3227c7efb8ede","modified":1514270503178},{"_id":"source/_posts/2018-01-08-battery-historian-2.md","hash":"a348a7892f3ad4e83514580972c9744193deff3d","modified":1516150766312},{"_id":"source/_posts/2018-01-04-battery-historian.md","hash":"8de16aee4a03dde07b182116f276596bbd39e54f","modified":1516150771254},{"_id":"source/_posts/2018-01-10-android-system-service-prework.md","hash":"abc1a057b4ef881413a972395e771c93ab788a10","modified":1515553455661},{"_id":"source/_posts/2018-01-11-android-system-service-AudioManager.md","hash":"c189677e1552a6fd824bdc2fc77084ef70fc85fa","modified":1515561857329},{"_id":"source/_posts/2018-01-15-android-samples-index.md","hash":"daf70e9c2e8a200107b7047950799f1ff6ad2f68","modified":1516261142085},{"_id":"source/_posts/2018-01-22-pat-yi-1011.md","hash":"7da024295280b9e9eeea6d5b9145ed8d2f3febed","modified":1517211832709},{"_id":"source/_posts/2018-01-22-pat-yi-1012.md","hash":"3b9a8e32cbaeba47db7f47957a92e37867e6e981","modified":1517211836902},{"_id":"source/_posts/2018-01-22-pat-yi-1013.md","hash":"d1a818c42849469ed92f635bd2ad74461e449b12","modified":1517211841606},{"_id":"source/_posts/2018-01-29-pat-yi-1015.md","hash":"4190f494d2c7d968dc4cabec048d96bc1b69b079","modified":1517211825184},{"_id":"source/_posts/2018-01-22-pat-yi-1014.md","hash":"b48eb67f7fe80eccf1abf10daee7cbc78d1cd2e1","modified":1517211820142},{"_id":"source/_posts/2018-01-29-pat-yi-1016.md","hash":"2939b9871b7f75965b3a91e611cd8f51a5d98333","modified":1517211814990},{"_id":"source/_posts/2018-01-30-pat-yi-1018.md","hash":"8e2379dbb06d617e767ee6a0a483f4f19d954bab","modified":1517391980872},{"_id":"source/_posts/2018-01-29-pat-yi-1017.md","hash":"5d24911b1b63f8e96e57f6e71ff5460459dfe0e6","modified":1517211792137},{"_id":"source/_posts/2018-01-31-final_in_JVM.md","hash":"0a92e28dd0fbcf26b729fbd71f14e18baee200dc","modified":1517387449864},{"_id":"source/_posts/2018-01-31-pat-yi-1019.md","hash":"1f8e4a3af7a12dae27ac2016d4dbbe06ea6d190a","modified":1517797291802},{"_id":"source/_posts/2018-02-05-reactive-native-pre.md","hash":"6dea9feb66128060f16cf5c1375995516cc01425","modified":1517902090179},{"_id":"source/tags/index.md","hash":"91194adb308c25130702a2d8d0f772a3801a8992","modified":1496300609182},{"_id":"source/categories/index.md","hash":"90b0dd05e7d51a9877e0e134900d2ca8da4b5bdb","modified":1496300382475},{"_id":"source/images/7r_muvaqb4myb9.jpg","hash":"af46b3c2a10b4cb54e8018f399c63111f7a06670","modified":1490862241000},{"_id":"source/images/Application_launch.jpg","hash":"d6683ac86c393d27adccc2c5c9a2b91797f8db5e","modified":1486970914262},{"_id":"source/images/SA&rank.png","hash":"cba2f733f3df9592b626f087d03b14747dbcc363","modified":1491967520879},{"_id":"source/images/abstract_factory_class_diagram.png","hash":"c0e466213adbf9931c6616057b7617372cd5a8be","modified":1495677427686},{"_id":"source/images/abstract_factory_product_level.png","hash":"bcbe45cdd1b1f733f697cc1dbdbf6ad53f09ed26","modified":1495679636006},{"_id":"source/images/abstract_factory_sequence_diagram.png","hash":"e04578d76c60f9bd05a6e9c9e4f077f1127c69e5","modified":1495678670690},{"_id":"source/images/adapter_pattern_class_diagram_1.png","hash":"34c1c832d151014970e806501ccc4eab7c992a92","modified":1498031704039},{"_id":"source/images/adapter_pattern_class_diagram_2.png","hash":"7436ed2ae2bfefd12c9f6de491a3ce38150bc36b","modified":1498032438190},{"_id":"source/images/adapter_pattern_sequence_diagram.png","hash":"dbc21f85ab87391a6f0eaa80fd983e195312b44f","modified":1498033250160},{"_id":"source/images/adm_question.png","hash":"16e6f5732a97f4f6befad08cea95e2becabe707e","modified":1486636592674},{"_id":"source/images/adb_launch_time.png","hash":"b6880efe89603403fa3c8ea114c41cd4476480cc","modified":1487052269659},{"_id":"source/images/alertDialog.png","hash":"b1a4a11ae6842152215a369a3ba0ac63b6e0467b","modified":1489579827478},{"_id":"source/images/andfix-yuanli.png","hash":"9a6606d861e34760311ab0802898a8da64cc3837","modified":1490853022941},{"_id":"source/images/app_main.png","hash":"9271e25ac79802b9f95d048622c5ee0dfdf83da7","modified":1507785918406},{"_id":"source/images/auth_sequence_diagram.png","hash":"9c7a7d8e7448dd8fffd466e12985e2a1df804d01","modified":1496909629143},{"_id":"source/images/battery-historian-upload.png","hash":"008b759b478e117aaa742e2eef0c42ed05d7d837","modified":1515035661021},{"_id":"source/images/battery_historian_file_info.png","hash":"41434ff4c3f703e7b8638a8f071b3fb793a75fb2","modified":1515377519433},{"_id":"source/images/battery_historian_historian.png","hash":"aab15db7d11cd2c7359a3245d0d5b8de44e0b893","modified":1515380087934},{"_id":"source/images/bridge_pattern_class_diagram.png","hash":"157f80a225b4570d355d6df47780266065e953b4","modified":1498100466125},{"_id":"source/images/bridge_pattern_sequence_diagram.png","hash":"5b3d9632efd6752670f79ba6c1dd4afb8c962fe0","modified":1498110246265},{"_id":"source/images/bucket-sort-1.png","hash":"d2940855ea9a6787ebb32a3f934e08dc778f3c77","modified":1491817600790},{"_id":"source/images/battery_temperature.png","hash":"116903236f46104118447d08a47291d4466b877c","modified":1515396209222},{"_id":"source/images/bucket-sort-2.png","hash":"accd3506e9d5601e300163825057b89daabd7d18","modified":1491817608442},{"_id":"source/images/cas.png","hash":"7242110c25aeb18b24d04f0f43c40e0f91c17236","modified":1487829400646},{"_id":"source/images/chain_of_responsibility_class_diagram.png","hash":"0abcf5464f6e932116cf458b9086f67c09d6aab1","modified":1496199741997},{"_id":"source/images/chain_of_responsibility_sequence_diagram.png","hash":"c8cd464b1f95cec18f88f58a74e2f63f20c6df99","modified":1496200207473},{"_id":"source/images/color-key-for-debug-GPU-overdraw-output.png","hash":"4d59e7f47921bbf3e92d5427bc15cfede1488fb7","modified":1486623494826},{"_id":"source/images/command_pattern_sequence_diagram.png","hash":"6cca5b814179f33a472c06a3372b3c781fdf61c8","modified":1497429193863},{"_id":"source/images/command_pattern_class_diagram.png","hash":"152286aa1de53dcade3462c37f8364815f056c73","modified":1497426783115},{"_id":"source/images/composite_pattern_class_diagram_1.png","hash":"aad2dcc5de56b5fdbb14731e232c18ac9b189d96","modified":1498468211633},{"_id":"source/images/composite_pattern_class_diagram_2.png","hash":"9f78ca18e3f07f7129e29ca8d49246f0efa2ff1a","modified":1498468618342},{"_id":"source/images/counting_sort_1.png","hash":"d8103872bcdfaa6d5a3929f6b66a6a2662bbfa7b","modified":1491891306062},{"_id":"source/images/decorator_pattern_class_diagram_1.png","hash":"1c6396a345997c97f969d9b268c0ba307c07416a","modified":1498190102636},{"_id":"source/images/dalvik&art.png","hash":"d5863fd26b9cf58eda0f1f94f4628378e4c9a360","modified":1490844718748},{"_id":"source/images/decorator_pattern_class_diagram_2.png","hash":"fb87be2939067438e606212daba6077c209df311","modified":1498199514017},{"_id":"source/images/decorator_pattern_class_diagram_3.png","hash":"6391767cf152cfe9e0ba58df9c117b7f9840d4be","modified":1498199835467},{"_id":"source/images/decorator_pattern_sequence_diagram.png","hash":"efc8e842f603d845e5bff2df1e245df32715108b","modified":1498200125758},{"_id":"source/images/display_activity.png","hash":"b610bec11cb27ae9c4f4d6ac23ee2ba8f8eeea2f","modified":1487043483456},{"_id":"source/images/display_time.png","hash":"6f501173846bfb463090ebb95b8d14a615e5674d","modified":1487044421629},{"_id":"source/images/facade_pattern_class_diagram.png","hash":"57b500d617eef0e1eb90aa356d7034f107964d5c","modified":1498441949713},{"_id":"source/images/facade_pattern_sequence_diagram.png","hash":"d67010cb6548ef0fb9ec2306197beadd67d69da8","modified":1498442243017},{"_id":"source/images/factory_method_class_diagram.png","hash":"bab58386656070f96e1e90fbc0fdf054a49e9421","modified":1495606530857},{"_id":"source/images/factory_method_sequence_diagram.png","hash":"4835d6de18f5f4321a9de33df2f2dd037c77ba5e","modified":1495607020115},{"_id":"source/images/favicon.jpg","hash":"7a9e1116cce436bc3f573f37f1a8e0009da12b71","modified":1497947774549},{"_id":"source/images/flyweight_pattern_class_diagram_1.png","hash":"fee242901dcf351835417a3e02179f01489519eb","modified":1498534630009},{"_id":"source/images/flyweight_pattern_class_diagram_2.png","hash":"568c1ee25ddade001b58b3958315ab0bd672dae9","modified":1498534950676},{"_id":"source/images/flyweight_pattern_sequence_diagram.png","hash":"08885c69bf2e2fb9b5250401c6e93a3f75a44542","modified":1498535945927},{"_id":"source/images/freud.jpg","hash":"9357a1a99b199e45887664c60f0f0f11f24041ec","modified":1486363512704},{"_id":"source/images/interpreter_class_diagram.png","hash":"6f7e54dd97607bc6d93ebcbe1784d4dd9e257cca","modified":1496385969235},{"_id":"source/images/iterator_pattern_class_diagram.png","hash":"62cca67905184bc116d75ae8c520dc65c4a1f1ed","modified":1497497711363},{"_id":"source/images/kotlin_extension_fun.png","hash":"e857a984c055fc17fb644abcc4911b52c01084d0","modified":1514255694841},{"_id":"source/images/logo.jpg","hash":"3eb36e46abf8a787451602b2ddffcf6bb09a6399","modified":1486450208784},{"_id":"source/images/mediator_pattern_class_diagram.png","hash":"a957854316c2603ca0ea1d992ccac5d5f8270782","modified":1497332411113},{"_id":"source/images/mediator_pattern_sequence_diagram.png","hash":"898b5a5bd5fb93431547a7f8f4d5cc3320a9b7d9","modified":1497341035529},{"_id":"source/images/memento_pattern_class_diagram.png","hash":"13406401ecfe6d357dec5c598c256cd3a42eb8df","modified":1497837300478},{"_id":"source/images/memento_pattern_sequence_diagram.png","hash":"f9c06bec9a8a1e5ebebfc1d1192c623c2b21d184","modified":1497842216704},{"_id":"source/images/nimabledroid-1.png","hash":"6586e412624c993930f805c86e41d0c0b2654f94","modified":1487571934483},{"_id":"source/images/nimabledroid-2.png","hash":"65bf7c4291610546e76f44d569f1be171fe57f0f","modified":1487572357630},{"_id":"source/images/nimabledroid-3.png","hash":"e796783e61b8fe32567653d078d13404a0af1ba1","modified":1487572981474},{"_id":"source/images/nimabledroid-4.png","hash":"847fc2be037605236a1f2b63ce00a003f51a8ac0","modified":1487573340332},{"_id":"source/images/nimabledroid-5.png","hash":"b23531d50109d46e72638565e91894f3f95f0097","modified":1487573490523},{"_id":"source/images/nimabledroid-6.png","hash":"464ab8612bdd72ea1a4b8fe36bb12a2fc39d6d1a","modified":1487575007185},{"_id":"source/images/nimabledroid-8.png","hash":"f5a6abb86c236c06aeb499a365e837e88fb33e79","modified":1487577966839},{"_id":"source/images/observer_pattern_class_diagram.png","hash":"4a1ac8301f3bfd6f7449d63d1d82d410dbe54076","modified":1497248504012},{"_id":"source/images/observer_pattern_sequence_diagram.png","hash":"2f178bb114c24c65c75a90d1ec9b39428a34f5b3","modified":1497249548256},{"_id":"source/images/prefix_doubleing_demo_1.png","hash":"9c567fbb4d66317428cf0e1600e21fe0b6c3de1f","modified":1492051945807},{"_id":"source/images/profileGPURendering.png","hash":"e708185ee02ef267aaae5a556b2f6192ed0c37db","modified":1486610828032},{"_id":"source/images/prototype_class_uml.png","hash":"59db65d97c32c411d02c0260bf7f6b9ababc5574","modified":1489988778878},{"_id":"source/images/prototype_sequence_uml.png","hash":"6bb2bfc16855bd8f1520922854269ca69ec4de92","modified":1489988778880},{"_id":"source/images/proxy_pattern_class_diagram.png","hash":"9647e8930a348ceee7df08391de67e6a96483e33","modified":1498619871795},{"_id":"source/images/proxy_pattern_sequence_diagram.png","hash":"17f1f4abbdb7d683004824affa9ed310350e9eb5","modified":1498620139653},{"_id":"source/images/report_full_drawn.png","hash":"b741e0e7e917080d77c0b67de552d5bf586c258d","modified":1487054066113},{"_id":"source/images/setup-docker-toolbox.png","hash":"94cad78aa22bd869941043ca63a5f1398fc77a0f","modified":1515034546301},{"_id":"source/images/simple_factory_class_diagram.png","hash":"c9a60d7d16a5100c862351012c4fa95ff9937a62","modified":1495530790779},{"_id":"source/images/simple_factory_sequence_diagram.png","hash":"83a65c92511df27418d6ad52128c16ccd0178a70","modified":1495607141686},{"_id":"source/images/state_pattern_class_diagram.png","hash":"8ccc786c93967c02ea18c33c641c1df90a0421a0","modified":1495857456210},{"_id":"source/images/state_pattern_sequence_diagram.png","hash":"ff39a9772c06b964949d6ec02475972f4dfeccae","modified":1496195062893},{"_id":"source/images/strategy_pattern_class_diagram.png","hash":"fae1e60d37de870a9af4801c9b208f3988404a88","modified":1495696109940},{"_id":"source/images/system_server.png","hash":"f173fa7b4fa5ae8c9ecab9fcbfcf956e3090469e","modified":1507799548263},{"_id":"source/images/strategy_pattern_sequence_diagram.png","hash":"a7b78bd51a57cf1cb9f03e40c55efdb2a5b7c2fb","modified":1495696701537},{"_id":"source/images/template_method_pattern_class_diagram.png","hash":"0fbecec1b63d712f0e8811931828fb00a2079045","modified":1497859668980},{"_id":"source/images/thread-read-write.jpg","hash":"7580f93e70460f1b1505ede59c4275347ced7115","modified":1487815329892},{"_id":"source/images/visitor_pattern_sequence_diagram.png","hash":"bbb5f405f44ca8d5e30445dcae90c94dffc7bfc8","modified":1497946113950},{"_id":"source/images/visitor_pattern_class_diagram.png","hash":"e1731b0d088da0b0cfc46cb0e2c68ae1af05bd09","modified":1497925849794},{"_id":"source/images/weixin.png","hash":"8440a3c8373959f478b3157ccab4757177e1a26a","modified":1486367323710},{"_id":"source/images/why_need_lock.jpg","hash":"0af05020d7e3eb07f9ac89546700f572ad330a05","modified":1487832203771},{"_id":"source/images/wifi-supplicant.png","hash":"957c0f35e969606b1b4f6b122cb17fdc3c5a6f80","modified":1515394917166},{"_id":"source/images/window_uml.jpg","hash":"765d329cd78215084c4948c3d1b7e16a31b0e47f","modified":1488445004924},{"_id":"source/images/zhifubao.PNG","hash":"c63413255fb1ce7fc4fbcfc111d778eb15d7a311","modified":1486365955635},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1496297484596},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"6070278c2e3b31bc1e40c485f66da5336bd2cbb0","modified":1496306036064},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1496297484603},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1496297034938},{"_id":"themes/next/.git/index","hash":"2b60791a9cc48df2ae92c25901a95b455898d284","modified":1497267250561},{"_id":"themes/next/.git/packed-refs","hash":"563200918c3db98fcd347e91e8e9a5c1d211b309","modified":1496297484590},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"4de856de657a27f340f245eb491a1f52ceba1735","modified":1496297484616},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1496297484616},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1496297484622},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1496297484623},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1496297484623},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1496297484624},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1496297484624},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1496297484625},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1496297484625},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1496297484626},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1496297484626},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1496297484627},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3111ce4cc5f30868b3628f9f805d2aef3b75d1c1","modified":1496297484627},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1496297484627},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1496297484628},{"_id":"themes/next/layout/_layout.swig","hash":"7dcdf10b62918f1a37ee7220d6dcd9269604581b","modified":1496307274591},{"_id":"themes/next/layout/archive.swig","hash":"a1d1e91013baaaeb7deaf35c6d3975971ce38e02","modified":1496297484665},{"_id":"themes/next/layout/category.swig","hash":"f315f12651de8065fdad73b003da4335ef177173","modified":1496297484665},{"_id":"themes/next/layout/page.swig","hash":"22ba721a9688d490fc66f360e5a319288b63b05a","modified":1496297484666},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1496297484667},{"_id":"themes/next/layout/schedule.swig","hash":"8086f1163b10460258ecbbbe48b057b22bb2f02e","modified":1496297484667},{"_id":"themes/next/layout/tag.swig","hash":"cc9878932580c890f8f3e569225e29bb37e25b49","modified":1496297484668},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1496297484669},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1496297484670},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1496297484666},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1496297484814},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1496297484813},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1496297484814},{"_id":"source/images/HTTP持久连接.png","hash":"270950e03ab5d949160707672a5367abb6541171","modified":1499053808249},{"_id":"source/images/ZygoteInit.png","hash":"1418e5b380faf421a3c1f01d96d59c1a62dd394d","modified":1507789923286},{"_id":"source/images/andfix-guocheng.png","hash":"7c93e893cd6c6671329a11f1bf8decc42c6f86ef","modified":1490853038512},{"_id":"source/images/android-framework.png","hash":"230c46a62b62d7ef52794f90a9edb1d6bf98103c","modified":1466994725423},{"_id":"source/images/android-singleton-1.png","hash":"fd6ab0facbbab4aad00bb97a14e6fde34c652dce","modified":1487644625164},{"_id":"source/images/android-start-1.png","hash":"e4d5954607ba63ec61e3453782ca07c698ef1981","modified":1488425852425},{"_id":"source/images/android-singleton-2.png","hash":"18d9b78197c5c7d212cce529c19991b80a860eb9","modified":1487654246983},{"_id":"source/images/android-start-2.png","hash":"ded4bfb0aede0b4014560e617dced60d0a89daa6","modified":1488425752626},{"_id":"source/images/apk-build.jpg","hash":"5644bbecb5a042ba8f98fbe531f8d13fb7c31180","modified":1487812074207},{"_id":"source/images/bind_application.jpg","hash":"77f938f4d138a8cbd2700ff1234f5a8690d6dc6c","modified":1487041684318},{"_id":"source/images/buckets_sort.png","hash":"6fa55aa83587eb6715d7452ebf2eb1249845a6bf","modified":1491815003024},{"_id":"source/images/jiezishu.jpg","hash":"93fd6ae5c99759843193e372dad75d7361505418","modified":1486363512706},{"_id":"source/images/launch_android.png","hash":"ded4bfb0aede0b4014560e617dced60d0a89daa6","modified":1488421669608},{"_id":"source/images/nimabledroid-7.png","hash":"1b49612acbfff4dbf21943a71d0a1df01a53aa21","modified":1487576625904},{"_id":"source/images/process_creation.jpg","hash":"bf904f21499ae9777995e9294df6970601711236","modified":1487041453091},{"_id":"source/images/radix_sort.png","hash":"3a7613976d28adcb24a2e8b807baa7838193f36f","modified":1491812052327},{"_id":"source/images/start_activity.jpg","hash":"f9ff94c1e1643f253544813cf414cd8a44a90a99","modified":1487042238975},{"_id":"source/images/tcp-ip通信传输流.png","hash":"b9f79869b23f5c023be89012a7c2b957c8df6fa6","modified":1499051543403},{"_id":"source/images/window_layer.jpg","hash":"fc810796fc8470dbcf319d3b38eb548d16bb2409","modified":1488441257895},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484726},{"_id":"source/images/counting_sort_2.png","hash":"0723b9f177fc026062d9d7d42ad074874b216744","modified":1491891439935},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1496297034939},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1496297034940},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1496297034941},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1496297034942},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1496297034943},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1496297034943},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1496297034944},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1496297034945},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1496297034945},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1496297034946},{"_id":"themes/next/.git/logs/HEAD","hash":"72708db86b454856abfb7c1b50eb704f5d315603","modified":1496306036069},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1496297034940},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1496297484629},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1496297484629},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1496297484630},{"_id":"themes/next/layout/_macro/post.swig","hash":"6f3c6078b9dbc238ccf86fb228c24c0b94f67d47","modified":1496297484631},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1496297484631},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1496297484632},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"4b029551ddb44c53f895e96cf8ff5ffbe02322fb","modified":1496297484633},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1496297484633},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5258c03149aa18e9abfeb8de10e435a406d9c924","modified":1496297484634},{"_id":"themes/next/layout/_partials/footer.swig","hash":"23b943851f0073795f8589a635c944bc09a6e2cc","modified":1498209625966},{"_id":"themes/next/layout/_partials/head.swig","hash":"09b110f77c415c5b71ebd886771a10bc84b95633","modified":1496297484635},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1496297484637},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1496297484637},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1496297484637},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1496297484638},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1496297484642},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1496297484643},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1496297484645},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1496297484658},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1496297484659},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1496297484659},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1496297484660},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1496297484660},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1496297484661},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1496297484670},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1496297484671},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1496297484671},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1496297484672},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1496297484672},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1496297484673},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1496297484673},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1496297484726},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1496297484727},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1496297484728},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1496297484728},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1496297484729},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1496297484729},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1496297484731},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1496297484730},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1496297484731},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1496297484732},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1496297484732},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1496297484732},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1496297484733},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1496297484733},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1496297484734},{"_id":"source/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1496286231020},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484644},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484644},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484710},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484711},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484724},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484725},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1496297484709},{"_id":"themes/next/.git/objects/50/50716176f1fb5c6ac661d827006e260ca25328","hash":"3b0b9213cec7c64997dea871fc0f921a293cdb61","modified":1496306027406},{"_id":"themes/next/.git/objects/50/7a32b3adba9938ecf9eef90a55a395758eb4da","hash":"788128321c30ad07f19729747d394f26e3ea116e","modified":1496306021850},{"_id":"themes/next/.git/refs/heads/master","hash":"ddccc60ee50c8fca1811f756ccaa3bcdbe2b6cfb","modified":1496306036068},{"_id":"themes/next/.git/objects/f6/2b02317374740a2b286814eb8008e12341431c","hash":"f8dd696af6b5a7f92fda1e4ad3a2056fb600218a","modified":1496306036065},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1496297484636},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1496297484636},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1496297484638},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1496297484639},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1496297484639},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1496297484640},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1496297484640},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1496297484641},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1496297484641},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1496297484645},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1496297484643},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1496297484646},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1496297484647},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1496297484647},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1496297484647},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1496297484648},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1496297484648},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1496297484649},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1496297484649},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1496297484650},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1496297484650},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1496297484651},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1496297484651},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1496297484652},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1496297484652},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"0f38f053841ef77cdce56a84cfbb4dd4c3329486","modified":1496297484653},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"0399bbdc524ba50930cb6f8e2d5628ff682fc612","modified":1496297484654},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"c75024151fc63220e7d01035d8a1aff9affdecc7","modified":1496297484654},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"de95ec8920d1660680078451008f8bd69f14d082","modified":1496297484655},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1496297484653},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"a0c042a74ea1afcb19daac7e2604a2bc5495037b","modified":1496297484663},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1496297484664},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1496297484662},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1496297484665},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1496297484709},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1496297484710},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1496297484711},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1496297484723},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1496297484724},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dacede1cc110c762e7a5468dc0e34ae1a962d5aa","modified":1496297484725},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1496297484735},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1496297484735},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ec035e20d1f26bf553a79877180ba312bea885c","modified":1496297484736},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1496297484736},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1496297484737},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1496297484737},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1496297484738},{"_id":"themes/next/source/js/src/particle.js","hash":"914c8e99af756e7004359aaa71fee4e59f214649","modified":1496307229919},{"_id":"themes/next/source/js/src/post-details.js","hash":"bfaf52b69aad96566aa21b785973441a2555b4ba","modified":1496297484738},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1496297484740},{"_id":"themes/next/source/js/src/utils.js","hash":"c976214b8bbaa9512b886bf3687e94696f705e33","modified":1496297484740},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1496297484739},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1496297484749},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1496297484753},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1496297484754},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1496297484755},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1496297484764},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1496297484765},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1496297484765},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1496297484766},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"68db2c0bf1064176627199394f25f6dc37ea23ad","modified":1496297484754},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1496297484787},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1496297484768},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1496297484769},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1496297484769},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1496297484770},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1496297484770},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1496297484789},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1496297484789},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1496297484790},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1496297484791},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1496297484791},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1496297484792},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1496297484793},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1496297484792},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1496297484793},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1496297484794},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1496297484794},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1496297484795},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1496297484796},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1496297484795},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1496297484796},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1496297484797},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1496297484797},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1496297484798},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1496297484798},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1496297484799},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1496297484800},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1496297484800},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1496297484801},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1496297484808},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1496297484808},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1496297484812},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1496297484811},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1496297484813},{"_id":"source/images/activity-window-layer.jpg","hash":"652713e1e4c2feefd06cefa58fb09e0710b67eae","modified":1487918148014},{"_id":"source/images/java_web_study_path.png","hash":"3842d0a0718999b0dd3b9b52e37e896a922888ae","modified":1495021333231},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1496297484788},{"_id":"source/images/executePhase.png","hash":"db3135e42a00e47cad7b3a3be301438f82969b20","modified":1486621071269},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"72708db86b454856abfb7c1b50eb704f5d315603","modified":1496306036070},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1496297484594},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1496297484662},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1496297484662},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1496297484712},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1496297484713},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1496297484713},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1496297484714},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1496297484712},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1496297484714},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1496297484715},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1496297484717},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1496297484717},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1496297484718},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1496297484718},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1496297484719},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1496297484721},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1496297484720},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1496297484721},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1496297484722},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1496297484722},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1496297484722},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1496297484748},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"95518d298d3c5c271faec2e4977df9e5dedd5d84","modified":1496297484747},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1496297484755},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1496297484756},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1496297484756},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1496297484757},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1496297484758},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1496297484758},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1496297484762},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1496297484763},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1496297484764},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1496297484767},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1496297484768},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1496297484771},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1496297484772},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1496297484773},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1496297484806},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1496297484807},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4ba6f2a615693b9b5afc266d9c833697016085fd","modified":1496297484675},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"1dc2ed435e41ca041f43bd9633d5d95139afbb42","modified":1496297484675},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1496297484676},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1496297484676},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1496297484677},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1496297484685},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1496297484697},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1496297484739},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4998bedff9c84a09a294b8ef36ede2e3644d3528","modified":1496297484706},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1496297484707},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1496297484707},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1496297484708},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1496297484708},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1496297484706},{"_id":"themes/next/.git/objects/pack/pack-3595cf5ed2e58730f18acba487797f4280a52c6f.idx","hash":"b3e79ce106d78a3125b9530d58dc6cbafeafd73d","modified":1496297484505},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"524cfca7b6ab135d81ea723d8de06fdf0dbe7e56","modified":1496297484745},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1496297484746},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1496297484785},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1496297484786},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1496297484810},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"e926e30eca94fc2adcd9132d9e5d6f88b114b05f","modified":1496297484594},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1496297484715},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1496297484716},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1496297484719},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1496297484742},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1496297484742},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1496297484743},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1496297484744},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1496297484759},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1496297484760},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1496297484759},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1496297484761},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1496297484761},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1496297484761},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1496297484775},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1496297484778},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1496297484784},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1496297484677},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1496297484678},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1496297484678},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1496297484679},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1496297484679},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1496297484680},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1496297484680},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1496297484682},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1496297484681},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1496297484682},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1496297484683},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1496297484683},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1496297484684},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1496297484684},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1496297484685},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1496297484686},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1496297484686},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1496297484687},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1496297484688},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"658accf8e196721f295003da66941e6d1f7b81b0","modified":1496297484688},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1496297484689},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1496297484689},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1496297484690},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1496297484690},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1496297484690},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2cb09973d29a8e34e2a3425ac6e0938296970d8e","modified":1496297484691},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1496297484687},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"268c9704481fdb0b4d1e646196386143990fe235","modified":1496297484691},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bc08cfb2ef2ff44ba3fc7dffdb2deb01a9d17d15","modified":1496297484692},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1496297484693},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1496297484694},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1496297484694},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1496297484695},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c9f76d4f6806ef70fa2160c97afa0a0e0ae5373e","modified":1496297484696},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1496297484695},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1496297484696},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1496297484697},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1496297484692},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1496297484698},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1496297484698},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1496297484699},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1496297484699},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"8420b4be386469337243336aee694297875bd439","modified":1496297484700},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1496297484701},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1496297484700},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1496297484702},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1496297484703},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1496297484704},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1496297484704},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"cd526e814f9323a79fe835085d64867d34b3715d","modified":1496297484703},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1496297484701},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1496297484704},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"eb45ee16051624c6e36a274c0a9538e961f10c4d","modified":1496297484705},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1496297484752},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1496297484805},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1496297484782},{"_id":"themes/next/.git/objects/pack/pack-3595cf5ed2e58730f18acba487797f4280a52c6f.pack","hash":"304720442ad2c867514e7afe59c469bf14d7c347","modified":1496297484513}],"Category":[{"name":"Algorithm","_id":"cjdcfv1a800042sivspy8bn7s"},{"name":"Others","_id":"cjdcfv1as00092sivf2o7a82d"},{"name":"Android","_id":"cjdcfv1az000f2siv2zdl0jaw"},{"name":"Design Pattern","_id":"cjdcfv1be000s2sive6u5alhs"},{"name":"Android System Framework","_id":"cjdcfv1cr001r2sivyw2pq0qj"},{"name":"JAVA & kotlin","_id":"cjdcfv1d300212siv7p59a53r"},{"name":"Operation System","_id":"cjdcfv1dy002t2sivgntf5za9"},{"name":"NetWork","_id":"cjdcfv1g300502sivz64cy0vy"}],"Data":[],"Page":[{"title":"tags","date":"2017-06-01T15:02:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-06-01 15:02:25\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-06-01T07:03:29.182Z","path":"tags/index.html","layout":"page","_id":"cjdcfv19z00012sivqdg328k0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-06-01T14:58:36.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-06-01 14:58:36\ntype: \"categories\"\ncomments: false\t\t\n---\n","updated":"2017-06-01T06:59:42.475Z","path":"categories/index.html","layout":"page","_id":"cjdcfv1a500032siv34hzx4mt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"设计一个有getMin功能的栈","date":"2017-02-07T00:00:00.000Z","_content":" \n\n#### **题目** ####\n\n\n##### 设计一个有getMin功能的栈 #####\n>\n实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。\n\n#### **要求** ####\n>\n1. pop,push,getMin操作的时间复杂度都是O(1)-【注】：*pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM *\n2. 设计的栈类型可以使用现成的栈结构-【注】：*使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM * \n\n\n#### **难度** ####\n>\n士 ★☆☆☆\n\n\n#### **解答** ####\n>\n在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。\n\n##### **第一种设计方案** #####\n\n\t\n 压入数据规则\n \n\n假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；\n\t\n- 如果为空，则newNum也压入stackMin\n- 如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小\n- 如果newNum更小或两者相等，则newNum也压入stackMin\n- 如果stackMin中栈顶元素小，则stackMin不压入任何内容\n\n\n\n 弹出数据规则\n\n先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。\n\n通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。\n\n当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。\n\n\n\n**查询当前栈中最小值的操作**\n\t\n即stackMin的栈顶元素\n\n\n\t\tpublic class MyStack1 {\n\t\tprivate Stack<Integer> stackData;\n\t\tprivate Stack<Integer> stackMin;\n\t\n\t\tpublic MyStack1() {\n\t\t\tthis.stackData = new Stack<>();\n\t\t\tthis.stackMin = new Stack<>();\n\t\t}\n\t\n\t\tpublic void push(int newNum) {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t} else if (newNum <= this.getmin()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t}\n\t\n\t\t\tthis.stackData.push(newNum);\n\t\t}\n\t\n\t\tpublic int pop() {\n\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t}\n\t\t\tint value = stackData.peek();\n\t\t\tif (value == this.getmin()) {\n\t\t\t\tstackMin.pop();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\n\t\tpublic int getmin() {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t}\n\t\t\treturn stackMin.peek();\n\t\t}\n\t\n\t    }\n\n \n\n\n##### **第二种设计方案** #####\n\n - 压入数据规则\n\n>\n假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。\n如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：\n如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。\n\n\n- 弹出数据规则\n\n\n>\n在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value\n\n- 查询当前栈中最小值的操作\n\n\n>\n即stackMin的栈顶元素\n\n\n\t\t\n\t\tpublic class MyStack2 {\n\t\t\n\t\t\tprivate Stack<Integer> stackData;\n\t\t\tprivate Stack<Integer> stackMin;\n\t\t\n\t\t\tpublic MyStack2() {\n\t\t\t\tthis.stackData = new Stack<>();\n\t\t\t\tthis.stackMin = new Stack<>();\n\t\t\t}\n\t\t\n\t\t\tpublic void push(int newNum) {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else if (newNum < this.getmin()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else {\n\t\t\t\t\tint newMin = stackMin.peek();\n\t\t\t\t\tstackMin.push(newMin);\n\t\t\t\t}\n\t\t\n\t\t\t\tthis.stackData.push(newNum);\n\t\t\t}\n\t\t\n\t\t\tpublic int pop() {\n\t\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t\t}\n\t\t\n\t\t\t\tint value = stackData.peek();\n\t\t\t\tstackMin.pop();\n\t\t\t\tstackData.pop();\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\n\t\t\tpublic int getmin() {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t\t}\n\t\t\t\treturn stackMin.peek();\n\t\t\t}\n\t\t}\n\n\n\n#### **点评** ####\n\n\t方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n\t区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n\n\n#### **java.util.stack** ####\n\n \n\n\tpackage java.util;\n\t \n\tpublic class Stack<E> extends Vector<E> {\n\t    /**\n\t     * Creates an empty Stack.\n\t     */\n\t    public Stack() {\n\t    }\n\t\n\t    /**\n\t     * Pushes an item onto the top of this stack. This has exactly\n\t     * the same effect as:\n\t     * <blockquote><pre>\n\t     * addElement(item)</pre></blockquote>\n\t     *\n\t     * @param   item   the item to be pushed onto this stack.\n\t     * @return  the <code>item</code> argument.\n\t     * @see     java.util.Vector#addElement\n\t     */\n\t    public E push(E item) {\n\t        addElement(item);\n\t\n\t        return item;\n\t    }\n\t\n\t    /**\n\t     * Removes the object at the top of this stack and returns that\n\t     * object as the value of this function.\n\t     *\n\t     * @return  The object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E pop() {\n\t        E       obj;\n\t        int     len = size();\n\t\n\t        obj = peek();\n\t        removeElementAt(len - 1);\n\t\n\t        return obj;\n\t    }\n\t\n\t    /**\n\t     * Looks at the object at the top of this stack without removing it\n\t     * from the stack.\n\t     *\n\t     * @return  the object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E peek() {\n\t        int     len = size();\n\t\n\t        if (len == 0)\n\t            throw new EmptyStackException();\n\t        return elementAt(len - 1);\n\t    }\n\t\n\t    /**\n\t     * Tests if this stack is empty.\n\t     *\n\t     * @return  <code>true</code> if and only if this stack contains\n\t     *          no items; <code>false</code> otherwise.\n\t     */\n\t    public boolean empty() {\n\t        return size() == 0;\n\t    }\n\t\n\t    /**\n\t     * Returns the 1-based position where an object is on this stack.\n\t     * If the object <tt>o</tt> occurs as an item in this stack, this\n\t     * method returns the distance from the top of the stack of the\n\t     * occurrence nearest the top of the stack; the topmost item on the\n\t     * stack is considered to be at distance <tt>1</tt>. The <tt>equals</tt>\n\t     * method is used to compare <tt>o</tt> to the\n\t     * items in this stack.\n\t     *\n\t     * @param   o   the desired object.\n\t     * @return  the 1-based position from the top of the stack where\n\t     *          the object is located; the return value <code>-1</code>\n\t     *          indicates that the object is not on the stack.\n\t     */\n\t    public synchronized int search(Object o) {\n\t        int i = lastIndexOf(o);\n\t\n\t        if (i >= 0) {\n\t            return size() - i;\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n\t    private static final long serialVersionUID = 1224463164541339165L;\n\t}\n\n#### **栈的简单概念** ####\n\n>\n栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。\n \n\n【注】*栈在java中有[数据结构和数据存储结构](http://xusx1024.com/2017/02/11/different-between-ADT/)两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。*3/3/2017 11:13:33 AM \n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-07-stack-with-getmin-fun.md","raw":"---\nlayout: post\ntitle:  设计一个有getMin功能的栈\ndate:   2017-02-07\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### **题目** ####\n\n\n##### 设计一个有getMin功能的栈 #####\n>\n实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。\n\n#### **要求** ####\n>\n1. pop,push,getMin操作的时间复杂度都是O(1)-【注】：*pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM *\n2. 设计的栈类型可以使用现成的栈结构-【注】：*使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM * \n\n\n#### **难度** ####\n>\n士 ★☆☆☆\n\n\n#### **解答** ####\n>\n在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。\n\n##### **第一种设计方案** #####\n\n\t\n 压入数据规则\n \n\n假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；\n\t\n- 如果为空，则newNum也压入stackMin\n- 如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小\n- 如果newNum更小或两者相等，则newNum也压入stackMin\n- 如果stackMin中栈顶元素小，则stackMin不压入任何内容\n\n\n\n 弹出数据规则\n\n先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。\n\n通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。\n\n当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。\n\n\n\n**查询当前栈中最小值的操作**\n\t\n即stackMin的栈顶元素\n\n\n\t\tpublic class MyStack1 {\n\t\tprivate Stack<Integer> stackData;\n\t\tprivate Stack<Integer> stackMin;\n\t\n\t\tpublic MyStack1() {\n\t\t\tthis.stackData = new Stack<>();\n\t\t\tthis.stackMin = new Stack<>();\n\t\t}\n\t\n\t\tpublic void push(int newNum) {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t} else if (newNum <= this.getmin()) {\n\t\t\t\tstackMin.push(newNum);\n\t\t\t}\n\t\n\t\t\tthis.stackData.push(newNum);\n\t\t}\n\t\n\t\tpublic int pop() {\n\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t}\n\t\t\tint value = stackData.peek();\n\t\t\tif (value == this.getmin()) {\n\t\t\t\tstackMin.pop();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t\n\t\tpublic int getmin() {\n\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t}\n\t\t\treturn stackMin.peek();\n\t\t}\n\t\n\t    }\n\n \n\n\n##### **第二种设计方案** #####\n\n - 压入数据规则\n\n>\n假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。\n如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：\n如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。\n\n\n- 弹出数据规则\n\n\n>\n在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value\n\n- 查询当前栈中最小值的操作\n\n\n>\n即stackMin的栈顶元素\n\n\n\t\t\n\t\tpublic class MyStack2 {\n\t\t\n\t\t\tprivate Stack<Integer> stackData;\n\t\t\tprivate Stack<Integer> stackMin;\n\t\t\n\t\t\tpublic MyStack2() {\n\t\t\t\tthis.stackData = new Stack<>();\n\t\t\t\tthis.stackMin = new Stack<>();\n\t\t\t}\n\t\t\n\t\t\tpublic void push(int newNum) {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else if (newNum < this.getmin()) {\n\t\t\t\t\tstackMin.push(newNum);\n\t\t\t\t} else {\n\t\t\t\t\tint newMin = stackMin.peek();\n\t\t\t\t\tstackMin.push(newMin);\n\t\t\t\t}\n\t\t\n\t\t\t\tthis.stackData.push(newNum);\n\t\t\t}\n\t\t\n\t\t\tpublic int pop() {\n\t\t\t\tif (this.stackData.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is Empty.\");\n\t\t\t\t}\n\t\t\n\t\t\t\tint value = stackData.peek();\n\t\t\t\tstackMin.pop();\n\t\t\t\tstackData.pop();\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\n\t\t\tpublic int getmin() {\n\t\t\t\tif (this.stackMin.isEmpty()) {\n\t\t\t\t\tthrow new RuntimeException(\"Your stack is empty.\");\n\t\t\t\t}\n\t\t\t\treturn stackMin.peek();\n\t\t\t}\n\t\t}\n\n\n\n#### **点评** ####\n\n\t方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n\t区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n\n\n#### **java.util.stack** ####\n\n \n\n\tpackage java.util;\n\t \n\tpublic class Stack<E> extends Vector<E> {\n\t    /**\n\t     * Creates an empty Stack.\n\t     */\n\t    public Stack() {\n\t    }\n\t\n\t    /**\n\t     * Pushes an item onto the top of this stack. This has exactly\n\t     * the same effect as:\n\t     * <blockquote><pre>\n\t     * addElement(item)</pre></blockquote>\n\t     *\n\t     * @param   item   the item to be pushed onto this stack.\n\t     * @return  the <code>item</code> argument.\n\t     * @see     java.util.Vector#addElement\n\t     */\n\t    public E push(E item) {\n\t        addElement(item);\n\t\n\t        return item;\n\t    }\n\t\n\t    /**\n\t     * Removes the object at the top of this stack and returns that\n\t     * object as the value of this function.\n\t     *\n\t     * @return  The object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E pop() {\n\t        E       obj;\n\t        int     len = size();\n\t\n\t        obj = peek();\n\t        removeElementAt(len - 1);\n\t\n\t        return obj;\n\t    }\n\t\n\t    /**\n\t     * Looks at the object at the top of this stack without removing it\n\t     * from the stack.\n\t     *\n\t     * @return  the object at the top of this stack (the last item\n\t     *          of the <tt>Vector</tt> object).\n\t     * @throws  EmptyStackException  if this stack is empty.\n\t     */\n\t    public synchronized E peek() {\n\t        int     len = size();\n\t\n\t        if (len == 0)\n\t            throw new EmptyStackException();\n\t        return elementAt(len - 1);\n\t    }\n\t\n\t    /**\n\t     * Tests if this stack is empty.\n\t     *\n\t     * @return  <code>true</code> if and only if this stack contains\n\t     *          no items; <code>false</code> otherwise.\n\t     */\n\t    public boolean empty() {\n\t        return size() == 0;\n\t    }\n\t\n\t    /**\n\t     * Returns the 1-based position where an object is on this stack.\n\t     * If the object <tt>o</tt> occurs as an item in this stack, this\n\t     * method returns the distance from the top of the stack of the\n\t     * occurrence nearest the top of the stack; the topmost item on the\n\t     * stack is considered to be at distance <tt>1</tt>. The <tt>equals</tt>\n\t     * method is used to compare <tt>o</tt> to the\n\t     * items in this stack.\n\t     *\n\t     * @param   o   the desired object.\n\t     * @return  the 1-based position from the top of the stack where\n\t     *          the object is located; the return value <code>-1</code>\n\t     *          indicates that the object is not on the stack.\n\t     */\n\t    public synchronized int search(Object o) {\n\t        int i = lastIndexOf(o);\n\t\n\t        if (i >= 0) {\n\t            return size() - i;\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n\t    private static final long serialVersionUID = 1224463164541339165L;\n\t}\n\n#### **栈的简单概念** ####\n\n>\n栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。\n \n\n【注】*栈在java中有[数据结构和数据存储结构](http://xusx1024.com/2017/02/11/different-between-ADT/)两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。*3/3/2017 11:13:33 AM \n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"stack-with-getmin-fun","published":1,"updated":"2017-08-17T02:36:56.177Z","comments":1,"photos":[],"link":"","_id":"cjdcfv19s00002sivso9kjmuu","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a><strong>题目</strong></h4><h5 id=\"设计一个有getMin功能的栈\"><a href=\"#设计一个有getMin功能的栈\" class=\"headerlink\" title=\"设计一个有getMin功能的栈\"></a>设计一个有getMin功能的栈</h5><p>&gt;<br>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>\n<h4 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a><strong>要求</strong></h4><p>&gt;</p>\n<ol>\n<li>pop,push,getMin操作的时间复杂度都是O(1)-【注】：<em>pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM </em></li>\n<li>设计的栈类型可以使用现成的栈结构-【注】：<em>使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM </em> </li>\n</ol>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a><strong>难度</strong></h4><p>&gt;<br>士 ★☆☆☆</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a><strong>解答</strong></h4><p>&gt;<br>在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。</p>\n<h5 id=\"第一种设计方案\"><a href=\"#第一种设计方案\" class=\"headerlink\" title=\"第一种设计方案\"></a><strong>第一种设计方案</strong></h5><p> 压入数据规则</p>\n<p>假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；</p>\n<ul>\n<li>如果为空，则newNum也压入stackMin</li>\n<li>如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小</li>\n<li>如果newNum更小或两者相等，则newNum也压入stackMin</li>\n<li>如果stackMin中栈顶元素小，则stackMin不压入任何内容</li>\n</ul>\n<p> 弹出数据规则</p>\n<p>先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。</p>\n<p>通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。</p>\n<p>当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。</p>\n<p><strong>查询当前栈中最小值的操作</strong></p>\n<p>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack1 {\nprivate Stack&lt;Integer&gt; stackData;\nprivate Stack&lt;Integer&gt; stackMin;\n\npublic MyStack1() {\n    this.stackData = new Stack&lt;&gt;();\n    this.stackMin = new Stack&lt;&gt;();\n}\n\npublic void push(int newNum) {\n    if (this.stackMin.isEmpty()) {\n        stackMin.push(newNum);\n    } else if (newNum &lt;= this.getmin()) {\n        stackMin.push(newNum);\n    }\n\n    this.stackData.push(newNum);\n}\n\npublic int pop() {\n    if (this.stackData.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n    }\n    int value = stackData.peek();\n    if (value == this.getmin()) {\n        stackMin.pop();\n    }\n    return value;\n}\n\npublic int getmin() {\n    if (this.stackMin.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is empty.&quot;);\n    }\n    return stackMin.peek();\n}\n\n}\n</code></pre><h5 id=\"第二种设计方案\"><a href=\"#第二种设计方案\" class=\"headerlink\" title=\"第二种设计方案\"></a><strong>第二种设计方案</strong></h5><ul>\n<li>压入数据规则</li>\n</ul>\n<p>&gt;<br>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。<br>如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：<br>如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。</p>\n<ul>\n<li>弹出数据规则</li>\n</ul>\n<p>&gt;<br>在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value</p>\n<ul>\n<li>查询当前栈中最小值的操作</li>\n</ul>\n<p>&gt;<br>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack2 {\n\n    private Stack&lt;Integer&gt; stackData;\n    private Stack&lt;Integer&gt; stackMin;\n\n    public MyStack2() {\n        this.stackData = new Stack&lt;&gt;();\n        this.stackMin = new Stack&lt;&gt;();\n    }\n\n    public void push(int newNum) {\n        if (this.stackMin.isEmpty()) {\n            stackMin.push(newNum);\n        } else if (newNum &lt; this.getmin()) {\n            stackMin.push(newNum);\n        } else {\n            int newMin = stackMin.peek();\n            stackMin.push(newMin);\n        }\n\n        this.stackData.push(newNum);\n    }\n\n    public int pop() {\n        if (this.stackData.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n        }\n\n        int value = stackData.peek();\n        stackMin.pop();\n        stackData.pop();\n        return value;\n    }\n\n    public int getmin() {\n        if (this.stackMin.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is empty.&quot;);\n        }\n        return stackMin.peek();\n    }\n}\n</code></pre><h4 id=\"点评\"><a href=\"#点评\" class=\"headerlink\" title=\"点评\"></a><strong>点评</strong></h4><pre><code>方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n</code></pre><h4 id=\"java-util-stack\"><a href=\"#java-util-stack\" class=\"headerlink\" title=\"java.util.stack\"></a><strong>java.util.stack</strong></h4><pre><code>package java.util;\n\npublic class Stack&lt;E&gt; extends Vector&lt;E&gt; {\n    /**\n     * Creates an empty Stack.\n     */\n    public Stack() {\n    }\n\n    /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * &lt;blockquote&gt;&lt;pre&gt;\n     * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt;\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the &lt;code&gt;item&lt;/code&gt; argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n\n    /**\n     * Removes the object at the top of this stack and returns that\n     * object as the value of this function.\n     *\n     * @return  The object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E pop() {\n        E       obj;\n        int     len = size();\n\n        obj = peek();\n        removeElementAt(len - 1);\n\n        return obj;\n    }\n\n    /**\n     * Looks at the object at the top of this stack without removing it\n     * from the stack.\n     *\n     * @return  the object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E peek() {\n        int     len = size();\n\n        if (len == 0)\n            throw new EmptyStackException();\n        return elementAt(len - 1);\n    }\n\n    /**\n     * Tests if this stack is empty.\n     *\n     * @return  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains\n     *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.\n     */\n    public boolean empty() {\n        return size() == 0;\n    }\n\n    /**\n     * Returns the 1-based position where an object is on this stack.\n     * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this\n     * method returns the distance from the top of the stack of the\n     * occurrence nearest the top of the stack; the topmost item on the\n     * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt;\n     * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the\n     * items in this stack.\n     *\n     * @param   o   the desired object.\n     * @return  the 1-based position from the top of the stack where\n     *          the object is located; the return value &lt;code&gt;-1&lt;/code&gt;\n     *          indicates that the object is not on the stack.\n     */\n    public synchronized int search(Object o) {\n        int i = lastIndexOf(o);\n\n        if (i &gt;= 0) {\n            return size() - i;\n        }\n        return -1;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = 1224463164541339165L;\n}\n</code></pre><h4 id=\"栈的简单概念\"><a href=\"#栈的简单概念\" class=\"headerlink\" title=\"栈的简单概念\"></a><strong>栈的简单概念</strong></h4><p>&gt;<br>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。</p>\n<p>【注】<em>栈在java中有<a href=\"http://xusx1024.com/2017/02/11/different-between-ADT/\" target=\"_blank\" rel=\"external\">数据结构和数据存储结构</a>两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。</em>3/3/2017 11:13:33 AM </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a><strong>题目</strong></h4><h5 id=\"设计一个有getMin功能的栈\"><a href=\"#设计一个有getMin功能的栈\" class=\"headerlink\" title=\"设计一个有getMin功能的栈\"></a>设计一个有getMin功能的栈</h5><p>&gt;<br>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>\n<h4 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a><strong>要求</strong></h4><p>&gt;</p>\n<ol>\n<li>pop,push,getMin操作的时间复杂度都是O(1)-【注】：<em>pop，push的时间复杂度本来就是O(1)，所以关注点在getMin的时间复杂度上。3/3/2017 11:16:04 AM </em></li>\n<li>设计的栈类型可以使用现成的栈结构-【注】：<em>使用变量是无法达到getMin的O(1)的，eg：2，3，4，1。3/3/2017 11:16:21 AM </em> </li>\n</ol>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a><strong>难度</strong></h4><p>&gt;<br>士 ★☆☆☆</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a><strong>解答</strong></h4><p>&gt;<br>在设计上我们使用两个栈，一个栈用来保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData;另一个栈用于保存每一步的最小值，这个栈记为stackMin。具体的实现方式有两种。</p>\n<h5 id=\"第一种设计方案\"><a href=\"#第一种设计方案\" class=\"headerlink\" title=\"第一种设计方案\"></a><strong>第一种设计方案</strong></h5><p> 压入数据规则</p>\n<p>假如当前数据为newNum,先将其压入stackData。然后判断stackMin是否为空；</p>\n<ul>\n<li>如果为空，则newNum也压入stackMin</li>\n<li>如果不为空，则比较nuwNum和stackMin的栈顶元素哪一个更小</li>\n<li>如果newNum更小或两者相等，则newNum也压入stackMin</li>\n<li>如果stackMin中栈顶元素小，则stackMin不压入任何内容</li>\n</ul>\n<p> 弹出数据规则</p>\n<p>先在stackData中弹出栈顶元素，记为value。然后比较当前stackMin的栈顶元素和value哪一个更小。</p>\n<p>通过上文的压入规则可知，stackMin中存在的元素是从栈底到栈顶逐渐变小的，stackMin栈顶的元素及时stackMin栈的最小值，也是stackData栈的最小值。所以不会出现value小于stackMin栈顶元素的情况，value只可能大于或等于stackMin的栈顶元素。</p>\n<p>当value等于stackMin的栈顶元素时，stackMin弹出栈顶元素【保证stackMin的栈顶始终为最小元素的值 3/3/2017 11:51:24 AM 】；当value大于stackMin的栈顶元素时，stackMin不弹出栈顶元素；返回value。</p>\n<p><strong>查询当前栈中最小值的操作</strong></p>\n<p>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack1 {\nprivate Stack&lt;Integer&gt; stackData;\nprivate Stack&lt;Integer&gt; stackMin;\n\npublic MyStack1() {\n    this.stackData = new Stack&lt;&gt;();\n    this.stackMin = new Stack&lt;&gt;();\n}\n\npublic void push(int newNum) {\n    if (this.stackMin.isEmpty()) {\n        stackMin.push(newNum);\n    } else if (newNum &lt;= this.getmin()) {\n        stackMin.push(newNum);\n    }\n\n    this.stackData.push(newNum);\n}\n\npublic int pop() {\n    if (this.stackData.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n    }\n    int value = stackData.peek();\n    if (value == this.getmin()) {\n        stackMin.pop();\n    }\n    return value;\n}\n\npublic int getmin() {\n    if (this.stackMin.isEmpty()) {\n        throw new RuntimeException(&quot;Your stack is empty.&quot;);\n    }\n    return stackMin.peek();\n}\n\n}\n</code></pre><h5 id=\"第二种设计方案\"><a href=\"#第二种设计方案\" class=\"headerlink\" title=\"第二种设计方案\"></a><strong>第二种设计方案</strong></h5><ul>\n<li>压入数据规则</li>\n</ul>\n<p>&gt;<br>假设当前数据为newNum，先将其压入stackData。然后判断stackMin是否为空。<br>如果为空，则newNum也压入stackMin；如果不为空，则判断newNum和stackMin的栈顶元素大小：<br>如果newNum比较小，则压入stackMin；否则再次将stackMin栈顶元素压入stackMin。</p>\n<ul>\n<li>弹出数据规则</li>\n</ul>\n<p>&gt;<br>在stackData中弹出数据记为value；弹出stackMin的栈顶；返回value</p>\n<ul>\n<li>查询当前栈中最小值的操作</li>\n</ul>\n<p>&gt;<br>即stackMin的栈顶元素</p>\n<pre><code>public class MyStack2 {\n\n    private Stack&lt;Integer&gt; stackData;\n    private Stack&lt;Integer&gt; stackMin;\n\n    public MyStack2() {\n        this.stackData = new Stack&lt;&gt;();\n        this.stackMin = new Stack&lt;&gt;();\n    }\n\n    public void push(int newNum) {\n        if (this.stackMin.isEmpty()) {\n            stackMin.push(newNum);\n        } else if (newNum &lt; this.getmin()) {\n            stackMin.push(newNum);\n        } else {\n            int newMin = stackMin.peek();\n            stackMin.push(newMin);\n        }\n\n        this.stackData.push(newNum);\n    }\n\n    public int pop() {\n        if (this.stackData.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is Empty.&quot;);\n        }\n\n        int value = stackData.peek();\n        stackMin.pop();\n        stackData.pop();\n        return value;\n    }\n\n    public int getmin() {\n        if (this.stackMin.isEmpty()) {\n            throw new RuntimeException(&quot;Your stack is empty.&quot;);\n        }\n        return stackMin.peek();\n    }\n}\n</code></pre><h4 id=\"点评\"><a href=\"#点评\" class=\"headerlink\" title=\"点评\"></a><strong>点评</strong></h4><pre><code>方案一和方案二其实都是用stackMin栈保存着stackData每一步的最小值。共同点是所有操作的时间复杂度都为O(1)、空间复杂度都为O(n).\n区别是：方案一中stackMin压入时稍省空间，但是弹出操作稍费时间；方案二中stackMin压入时稍费时间，但是弹出操作稍省时间。\n</code></pre><h4 id=\"java-util-stack\"><a href=\"#java-util-stack\" class=\"headerlink\" title=\"java.util.stack\"></a><strong>java.util.stack</strong></h4><pre><code>package java.util;\n\npublic class Stack&lt;E&gt; extends Vector&lt;E&gt; {\n    /**\n     * Creates an empty Stack.\n     */\n    public Stack() {\n    }\n\n    /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * &lt;blockquote&gt;&lt;pre&gt;\n     * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt;\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the &lt;code&gt;item&lt;/code&gt; argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n\n    /**\n     * Removes the object at the top of this stack and returns that\n     * object as the value of this function.\n     *\n     * @return  The object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E pop() {\n        E       obj;\n        int     len = size();\n\n        obj = peek();\n        removeElementAt(len - 1);\n\n        return obj;\n    }\n\n    /**\n     * Looks at the object at the top of this stack without removing it\n     * from the stack.\n     *\n     * @return  the object at the top of this stack (the last item\n     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).\n     * @throws  EmptyStackException  if this stack is empty.\n     */\n    public synchronized E peek() {\n        int     len = size();\n\n        if (len == 0)\n            throw new EmptyStackException();\n        return elementAt(len - 1);\n    }\n\n    /**\n     * Tests if this stack is empty.\n     *\n     * @return  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains\n     *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.\n     */\n    public boolean empty() {\n        return size() == 0;\n    }\n\n    /**\n     * Returns the 1-based position where an object is on this stack.\n     * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this\n     * method returns the distance from the top of the stack of the\n     * occurrence nearest the top of the stack; the topmost item on the\n     * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt;\n     * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the\n     * items in this stack.\n     *\n     * @param   o   the desired object.\n     * @return  the 1-based position from the top of the stack where\n     *          the object is located; the return value &lt;code&gt;-1&lt;/code&gt;\n     *          indicates that the object is not on the stack.\n     */\n    public synchronized int search(Object o) {\n        int i = lastIndexOf(o);\n\n        if (i &gt;= 0) {\n            return size() - i;\n        }\n        return -1;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = 1224463164541339165L;\n}\n</code></pre><h4 id=\"栈的简单概念\"><a href=\"#栈的简单概念\" class=\"headerlink\" title=\"栈的简单概念\"></a><strong>栈的简单概念</strong></h4><p>&gt;<br>栈是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶。对栈的基本操作有push(进栈)和pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。栈又叫做后进先出表。</p>\n<p>【注】<em>栈在java中有<a href=\"http://xusx1024.com/2017/02/11/different-between-ADT/\" target=\"_blank\" rel=\"external\">数据结构和数据存储结构</a>两种功能。即stack是数据结构概念，但是java语言中实现了stack功能的容器，也命名为stack。比较特殊和容易让人迷惑。</em>3/3/2017 11:13:33 AM </p>\n"},{"layout":"post","title":"first test post","date":"2017-02-06T00:00:00.000Z","_content":" \n\n#### 目录1 ####\n\n\n##### 正文标题 #####\n\n表格：\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 |\n\n图片：\n![test](/images/SA&rank.png)\n","source":"_posts/2017-02-06-first-post.md","raw":"---\nlayout: post\ntitle:  first test post\ndate:   2017-02-06\ncategories: Others\ntag: 杂项\n---\n \n\n#### 目录1 ####\n\n\n##### 正文标题 #####\n\n表格：\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 |\n\n图片：\n![test](/images/SA&rank.png)\n","slug":"first-post","published":1,"updated":"2017-08-17T02:36:18.523Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1a200022sivljv15xo4","content":"<h4 id=\"目录1\"><a href=\"#目录1\" class=\"headerlink\" title=\"目录1\"></a>目录1</h4><h5 id=\"正文标题\"><a href=\"#正文标题\" class=\"headerlink\" title=\"正文标题\"></a>正文标题</h5><p>表格：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务</td>\n</tr>\n</tbody>\n</table>\n<p>图片：<br><img src=\"/images/SA&amp;rank.png\" alt=\"test\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"目录1\"><a href=\"#目录1\" class=\"headerlink\" title=\"目录1\"></a>目录1</h4><h5 id=\"正文标题\"><a href=\"#正文标题\" class=\"headerlink\" title=\"正文标题\"></a>正文标题</h5><p>表格：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务</td>\n</tr>\n</tbody>\n</table>\n<p>图片：<br><img src=\"/images/SA&amp;rank.png\" alt=\"test\"></p>\n"},{"layout":"post","title":"Android过度绘制优化","date":"2017-02-09T00:00:00.000Z","_content":"\n \n\n#### what ####\n \n\n##### 过渡绘制 #####\n \n\n\t过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n\n##### 开启 #####\n\n\t\n\t开发者选项 - 调试GPU过渡绘制\n\n##### 解释 #####\n\n\n![示例图](/images/color-key-for-debug-GPU-overdraw-output.png)\n\n- True color: No overdraw\n- Blue: Overdrawn once\n- Green: Overdrawn twice\n- Pink: Overdrawn three times\n- Red: Overdrawn four or more times\n\n#### how ####\n\n\t\n\n1.  >去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。\n\t>\n    \t修改页面的主题：\n\t\t<item name=\"android:windowBackground\">@android:color/transparent</item>\n    \t<item name=\"android:windowBackground\">@null</item>\n\t>\t\t\n\t\t代码中修改：\n\t\tgetWindow().setBackgroundDrawable(null)\n\t\tgetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\n\t>\t null和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n\n2. >移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。\n\n3. >选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。\n\n4. >对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过[canvas.clipRect()](https://developer.android.com/reference/android/graphics/Canvas.html)来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用[canvas.quickreject()](https://developer.android.com/reference/android/graphics/Canvas.html)来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。\n\n5. >使用merge标签，减少布局嵌套层次。\n\n6. >使用动态inflate或者ViewStub替代setVisibility。\n\n7. >对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。\n\n8. >使用.9图，透明区域会被android的2D渲染器优化。\n\n9. >好的展示设计和交互。使UI宽而浅而不是浅而深。\n\n\n#### 标准 ####\n\n\t\t\n\t  过度绘制不可避免\n\t\n\t  尽量控制在绿色及其以下\n\t\n\t  尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n\t  不允许出现超过屏幕1/4的红色区域\n   ","source":"_posts/2017-02-09-Debug-GPU-Overdraw-Walkthrough.md","raw":"---\nlayout: post\ntitle:  Android过度绘制优化\ndate:   2017-02-09\ncategories: Android\ntag: android\n---\n\n \n\n#### what ####\n \n\n##### 过渡绘制 #####\n \n\n\t过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n\n##### 开启 #####\n\n\t\n\t开发者选项 - 调试GPU过渡绘制\n\n##### 解释 #####\n\n\n![示例图](/images/color-key-for-debug-GPU-overdraw-output.png)\n\n- True color: No overdraw\n- Blue: Overdrawn once\n- Green: Overdrawn twice\n- Pink: Overdrawn three times\n- Red: Overdrawn four or more times\n\n#### how ####\n\n\t\n\n1.  >去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。\n\t>\n    \t修改页面的主题：\n\t\t<item name=\"android:windowBackground\">@android:color/transparent</item>\n    \t<item name=\"android:windowBackground\">@null</item>\n\t>\t\t\n\t\t代码中修改：\n\t\tgetWindow().setBackgroundDrawable(null)\n\t\tgetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\n\t>\t null和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n\n2. >移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。\n\n3. >选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。\n\n4. >对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过[canvas.clipRect()](https://developer.android.com/reference/android/graphics/Canvas.html)来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用[canvas.quickreject()](https://developer.android.com/reference/android/graphics/Canvas.html)来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。\n\n5. >使用merge标签，减少布局嵌套层次。\n\n6. >使用动态inflate或者ViewStub替代setVisibility。\n\n7. >对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。\n\n8. >使用.9图，透明区域会被android的2D渲染器优化。\n\n9. >好的展示设计和交互。使UI宽而浅而不是浅而深。\n\n\n#### 标准 ####\n\n\t\t\n\t  过度绘制不可避免\n\t\n\t  尽量控制在绿色及其以下\n\t\n\t  尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n\t  不允许出现超过屏幕1/4的红色区域\n   ","slug":"Debug-GPU-Overdraw-Walkthrough","published":1,"updated":"2017-11-16T08:27:15.765Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ae00062siv7rpyiz4y","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"过渡绘制\"><a href=\"#过渡绘制\" class=\"headerlink\" title=\"过渡绘制\"></a>过渡绘制</h5><pre><code>过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n</code></pre><h5 id=\"开启\"><a href=\"#开启\" class=\"headerlink\" title=\"开启\"></a>开启</h5><pre><code>开发者选项 - 调试GPU过渡绘制\n</code></pre><h5 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h5><p><img src=\"/images/color-key-for-debug-GPU-overdraw-output.png\" alt=\"示例图\"></p>\n<ul>\n<li>True color: No overdraw</li>\n<li>Blue: Overdrawn once</li>\n<li>Green: Overdrawn twice</li>\n<li>Pink: Overdrawn three times</li>\n<li>Red: Overdrawn four or more times</li>\n</ul>\n<h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><ol>\n<li><blockquote>\n<p>去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。</p>\n<pre><code>修改页面的主题：\n&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;\n&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;\n\n代码中修改：\ngetWindow().setBackgroundDrawable(null)\ngetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\nnull和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n</code></pre></blockquote>\n</li>\n<li><blockquote>\n<p>移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用merge标签，减少布局嵌套层次。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用动态inflate或者ViewStub替代setVisibility。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用.9图，透明区域会被android的2D渲染器优化。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>好的展示设计和交互。使UI宽而浅而不是浅而深。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"标准\"><a href=\"#标准\" class=\"headerlink\" title=\"标准\"></a>标准</h4><pre><code>过度绘制不可避免\n\n尽量控制在绿色及其以下\n\n尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n不允许出现超过屏幕1/4的红色区域\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"过渡绘制\"><a href=\"#过渡绘制\" class=\"headerlink\" title=\"过渡绘制\"></a>过渡绘制</h5><pre><code>过渡绘制(OverDraw)，屏幕上的某个像素，在同一帧内被重绘多次。如果App中过渡绘制问题严重，会浪费大量CPU、GPU资源，直接表现为App卡顿。\n</code></pre><h5 id=\"开启\"><a href=\"#开启\" class=\"headerlink\" title=\"开启\"></a>开启</h5><pre><code>开发者选项 - 调试GPU过渡绘制\n</code></pre><h5 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h5><p><img src=\"/images/color-key-for-debug-GPU-overdraw-output.png\" alt=\"示例图\"></p>\n<ul>\n<li>True color: No overdraw</li>\n<li>Blue: Overdrawn once</li>\n<li>Green: Overdrawn twice</li>\n<li>Pink: Overdrawn three times</li>\n<li>Red: Overdrawn four or more times</li>\n</ul>\n<h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><ol>\n<li><blockquote>\n<p>去掉window默认背景。在Activity中，使用setContentView绑定布局时，android会自动填充一个背景，如果我们App有自己的页面底色，因此不需要默认分配的背景。</p>\n<pre><code>修改页面的主题：\n&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;\n&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;\n\n代码中修改：\ngetWindow().setBackgroundDrawable(null)\ngetWindow().setBackgroundDrawableResource(android.R.color.transparent);\n\nnull和transparent差别不大，如果有activity右滑返回功能，null,在某些机型(Nexus6p)上，会出现错乱, 建议使用transparent。 \n</code></pre></blockquote>\n</li>\n<li><blockquote>\n<p>移除不必要的背景，xml布局编码时，防止背景重复，比如ListView的背景和item的背景都是白色，那么可以选择去掉其中一个。一般情况下，背景重复会引起大部分重绘问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>选择适当父布局。LinearLayout、ReleativeLayout，最常用的两种布局。RL表达能力强，LL易用，层级多，所以在层级相同的情况下，使用LL，尽量不要使用AbsoluteLayout。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于那些过于复杂的自定义的View(通常重写了onDraw方法)，我们可以通过<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.clipRect()</a>来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。我们还可以使用<a href=\"https://developer.android.com/reference/android/graphics/Canvas.html\" target=\"_blank\" rel=\"external\">canvas.quickreject()</a>来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用merge标签，减少布局嵌套层次。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用动态inflate或者ViewStub替代setVisibility。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为”@android:color/transparent”,来解决对应的问题。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>使用.9图，透明区域会被android的2D渲染器优化。</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p>好的展示设计和交互。使UI宽而浅而不是浅而深。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"标准\"><a href=\"#标准\" class=\"headerlink\" title=\"标准\"></a>标准</h4><pre><code>过度绘制不可避免\n\n尽量控制在绿色及其以下\n\n尽可能避免出现粉红及以上，如果不可避免，尽可能减少\n\n不允许出现超过屏幕1/4的红色区域\n</code></pre>"},{"layout":"post","title":"Gpu呈现模式分析","date":"2017-02-09T00:00:00.000Z","_content":" \n\n#### 引言 ####\n\n \t在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n\n![玄学曲线](/images/profileGPURendering.png)\n\n\n#### 说说这张图片 ####\n\n##### 绿横线 #####\n\n\t在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n\n##### 红柱 #####\n\n\t红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n\n![绘图执行图](/images/executePhase.png)\n\n##### 黄柱 #####\n\n\t黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n\n##### 蓝柱 #####\n\n\t假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n\t在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n\t所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n\n\n","source":"_posts/2017-02-09-Profile-Gpu-rendering.md","raw":"---\nlayout: post\ntitle:  Gpu呈现模式分析\ndate:   2017-02-09\ncategories: Android \ntag: android\n---\n \n\n#### 引言 ####\n\n \t在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n\n![玄学曲线](/images/profileGPURendering.png)\n\n\n#### 说说这张图片 ####\n\n##### 绿横线 #####\n\n\t在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n\n##### 红柱 #####\n\n\t红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n\n![绘图执行图](/images/executePhase.png)\n\n##### 黄柱 #####\n\n\t黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n\n##### 蓝柱 #####\n\n\t假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n\t在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n\t所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n\n\n","slug":"Profile-Gpu-rendering","published":1,"updated":"2017-11-16T08:30:13.765Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ak00072sivszas54jj","content":"<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><pre><code>在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n</code></pre><p><img src=\"/images/profileGPURendering.png\" alt=\"玄学曲线\"></p>\n<h4 id=\"说说这张图片\"><a href=\"#说说这张图片\" class=\"headerlink\" title=\"说说这张图片\"></a>说说这张图片</h4><h5 id=\"绿横线\"><a href=\"#绿横线\" class=\"headerlink\" title=\"绿横线\"></a>绿横线</h5><pre><code>在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n</code></pre><h5 id=\"红柱\"><a href=\"#红柱\" class=\"headerlink\" title=\"红柱\"></a>红柱</h5><pre><code>红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n</code></pre><p><img src=\"/images/executePhase.png\" alt=\"绘图执行图\"></p>\n<h5 id=\"黄柱\"><a href=\"#黄柱\" class=\"headerlink\" title=\"黄柱\"></a>黄柱</h5><pre><code>黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n</code></pre><h5 id=\"蓝柱\"><a href=\"#蓝柱\" class=\"headerlink\" title=\"蓝柱\"></a>蓝柱</h5><pre><code>假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><pre><code>在android手机中，会发现开发者选项 - GPU呈现模式分析的选项。很多道友用之来测试其手机的流畅度。开启之后大概就是这样子了：\n</code></pre><p><img src=\"/images/profileGPURendering.png\" alt=\"玄学曲线\"></p>\n<h4 id=\"说说这张图片\"><a href=\"#说说这张图片\" class=\"headerlink\" title=\"说说这张图片\"></a>说说这张图片</h4><h5 id=\"绿横线\"><a href=\"#绿横线\" class=\"headerlink\" title=\"绿横线\"></a>绿横线</h5><pre><code>在android系统中是以每秒60帧为满帧的，所以1000ms / 60 = 16ms/帧。即每帧快于16ms为流畅，这根绿线即16ms线，低于该绿线为流畅。\n</code></pre><h5 id=\"红柱\"><a href=\"#红柱\" class=\"headerlink\" title=\"红柱\"></a>红柱</h5><pre><code>红色代表了“执行时间”，它指的是Android渲染引擎执行绘制命令的时间，为了绘制到屏幕上，Android需要使用OpenGL ES的API接口来绘制Display List。这些API有效地将数据发送到GPU，最后在屏幕上显示出来。假如当前界面的视图越多，那么红色便会“跳”得越高。实际使用中，比如平时刷App遇到许多缩略图需要加载，那么红色会突然跳很高，但是此时你的页面滑动其实是流畅的，虽然等了零点几秒图片才加载出来，但并不意味着你卡住了。\n</code></pre><p><img src=\"/images/executePhase.png\" alt=\"绘图执行图\"></p>\n<h5 id=\"黄柱\"><a href=\"#黄柱\" class=\"headerlink\" title=\"黄柱\"></a>黄柱</h5><pre><code>黄色通常较短，它代表CPU通知GPU“你已经完成一帧视图的渲染了”，不过这是一个阻塞调用，CPU会等待GPU的回话，当GPU说“好了，知道了”，才算完事儿。假如黄色很高，说明当前GPU过于忙碌，有很多命令需要去处理。\n</code></pre><h5 id=\"蓝柱\"><a href=\"#蓝柱\" class=\"headerlink\" title=\"蓝柱\"></a>蓝柱</h5><pre><code>假如通过蓝色来判断流畅度，参考意义比较大。蓝色代表了视图测量绘制所花费的时间，或者说它代表需要多长时间去创建和更新你的DisplayList。\n在Android中，一个视图在可以实际的进行渲染之前，它必须被转换成GPU所熟悉的格式，简单来说就是几条绘图命令，即执行每一个View的onDraw方法，创建或者更新每一个View的DisplayList对象。\n所以蓝色越短，体验越流畅，当你看到蓝色很高，可能是因为你的一堆视图突然变得无效了，需要重新绘制，或者你的几个自定义视图的onDraw方法过于复杂。\n</code></pre>"},{"layout":"post","title":"单例设计模式(一)基础知识","date":"2017-02-11T00:00:00.000Z","_content":"\n#### what ####\n\n##### 来自wiki #####\n\n>[单例模式](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。\n比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\n\n##### 来自IBM #####\n\n>与wiki相重复的内容，不再摘录。\n[单例模式](http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：\n1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 \n\n#### how ####\n\n##### 饿汉单例 #####\n\tpublic class Singleton {\n\t private Singleton(){}\n\t private static Singleton instance = new Singleton();\n\t public static Singleton getInsatnce(){\n\t return instance;\n\t }\n\t}\n\n> 上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。\n\n##### 懒汉单例 #####\n\n\tpublic class LazySingleton {\n\t\n\t\tprivate LazySingleton() {\n\t\t}\n\t\n\t\tpublic static LazySingleton instance = null;\n\t\n\t\tpublic static synchronized LazySingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tinstance = new LazySingleton();\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br/>\n\n> 在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。\n\n##### 懒汉单例的改进：静态内部类单例 #####\n\n\tpublic class StaticInnerClassSingleton {\n\t\n\t\tprivate StaticInnerClassSingleton() {\n\t\t}\n\t\n\t\tpublic StaticInnerClassSingleton getInstance() {\n\t\t\treturn SingletonHolder.instance;\n\t\t}\n\t\n\t\tprivate static class SingletonHolder {\n\t\t\tprivate static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n\t\t}\n\t}\n\n> 使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。\n\n##### DoubleCheckLock 实现单例 #####\n\t\n\tpublic class DCLSingleton {\n\t\n\t\tprivate static DCLSingleton instance = null;\n\t\n\t\tprivate DCLSingleton() {\n\t\t}\n\t\n\t\tpublic DCLSingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tsynchronized (DCLSingleton.class) {\n\t\t\t\t\tif (instance == null) {\n\t\t\t\t\t\tinstance = new DCLSingleton();\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br/>因为\n> ```instance = new DCLSingleton();```\n>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br/>\n>1.给DCLSingleton的实例分配内存<br/>\n>2.调用DCLSingleton的构造，初始化成员字段<br/>\n>3.将instance对象指向分配的内存空间<br/>\n\n\n>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中*Cache、寄存器到主内存回写顺序*的规定，上面2、3的顺序无法保证先后执行的。<br/>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br/>\n>解决：JDK1.5之后，```private static volatile DCLSingleton instance = null;``` \n>使用volatile关键字，可以保证instance对象*每次都是从主内存中读取*。\n\n##### 容器维护多个单例 #####\n\n\n\timport java.util.HashMap;\n\timport java.util.Map;\n\t\n\tpublic class SingletonManager {\n\t\tprivate static Map<String,Object> objMap = new HashMap<>();\n\t\t\n\t\tprivate SingletonManager(){}\n\t\t\n\t\tpublic static void registerService(String key,Object instance){\n\t\t\tif(!objMap.containsKey(key)){\n\t\t\t\tobjMap.put(key, instance);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Object getService(String key){\n\t\t\treturn objMap.get(key);\n\t\t}\n\t\n\t}\n\n> 根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)\n \n##### 枚举单例 #####\n\n\tpublic enum EnumSingleton {\n\t\n\t\tINSTANCE;\n\t\n\t\tpublic void doSomething() {\n\t\t}\n\t}\n\n> 写法简单，线程安全，在任何情况下都是单例！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-11-design-patterns-singleton-1.md","raw":"---\nlayout: post\ntitle:  单例设计模式(一)基础知识\ndate:   2017-02-11\ncategories: Design Pattern\ntag: 设计模式\n---\n\n#### what ####\n\n##### 来自wiki #####\n\n>[单例模式](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。\n比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。\n\n##### 来自IBM #####\n\n>与wiki相重复的内容，不再摘录。\n[单例模式](http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：\n1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 \n\n#### how ####\n\n##### 饿汉单例 #####\n\tpublic class Singleton {\n\t private Singleton(){}\n\t private static Singleton instance = new Singleton();\n\t public static Singleton getInsatnce(){\n\t return instance;\n\t }\n\t}\n\n> 上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。\n\n##### 懒汉单例 #####\n\n\tpublic class LazySingleton {\n\t\n\t\tprivate LazySingleton() {\n\t\t}\n\t\n\t\tpublic static LazySingleton instance = null;\n\t\n\t\tpublic static synchronized LazySingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tinstance = new LazySingleton();\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br/>\n\n> 在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。\n\n##### 懒汉单例的改进：静态内部类单例 #####\n\n\tpublic class StaticInnerClassSingleton {\n\t\n\t\tprivate StaticInnerClassSingleton() {\n\t\t}\n\t\n\t\tpublic StaticInnerClassSingleton getInstance() {\n\t\t\treturn SingletonHolder.instance;\n\t\t}\n\t\n\t\tprivate static class SingletonHolder {\n\t\t\tprivate static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n\t\t}\n\t}\n\n> 使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。\n\n##### DoubleCheckLock 实现单例 #####\n\t\n\tpublic class DCLSingleton {\n\t\n\t\tprivate static DCLSingleton instance = null;\n\t\n\t\tprivate DCLSingleton() {\n\t\t}\n\t\n\t\tpublic DCLSingleton getInstance() {\n\t\t\tif (instance == null) {\n\t\t\t\tsynchronized (DCLSingleton.class) {\n\t\t\t\t\tif (instance == null) {\n\t\t\t\t\t\tinstance = new DCLSingleton();\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t}\n\n> 同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br/>因为\n> ```instance = new DCLSingleton();```\n>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br/>\n>1.给DCLSingleton的实例分配内存<br/>\n>2.调用DCLSingleton的构造，初始化成员字段<br/>\n>3.将instance对象指向分配的内存空间<br/>\n\n\n>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中*Cache、寄存器到主内存回写顺序*的规定，上面2、3的顺序无法保证先后执行的。<br/>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br/>\n>解决：JDK1.5之后，```private static volatile DCLSingleton instance = null;``` \n>使用volatile关键字，可以保证instance对象*每次都是从主内存中读取*。\n\n##### 容器维护多个单例 #####\n\n\n\timport java.util.HashMap;\n\timport java.util.Map;\n\t\n\tpublic class SingletonManager {\n\t\tprivate static Map<String,Object> objMap = new HashMap<>();\n\t\t\n\t\tprivate SingletonManager(){}\n\t\t\n\t\tpublic static void registerService(String key,Object instance){\n\t\t\tif(!objMap.containsKey(key)){\n\t\t\t\tobjMap.put(key, instance);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Object getService(String key){\n\t\t\treturn objMap.get(key);\n\t\t}\n\t\n\t}\n\n> 根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)\n \n##### 枚举单例 #####\n\n\tpublic enum EnumSingleton {\n\t\n\t\tINSTANCE;\n\t\n\t\tpublic void doSomething() {\n\t\t}\n\t}\n\n> 写法简单，线程安全，在任何情况下都是单例！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"design-patterns-singleton-1","published":1,"updated":"2017-08-17T02:39:14.300Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1an00082siv89xt78uk","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"来自wiki\"><a href=\"#来自wiki\" class=\"headerlink\" title=\"来自wiki\"></a>来自wiki</h5><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"external\">单例模式</a>又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。<br>比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>\n</blockquote>\n<h5 id=\"来自IBM\"><a href=\"#来自IBM\" class=\"headerlink\" title=\"来自IBM\"></a>来自IBM</h5><blockquote>\n<p>与wiki相重复的内容，不再摘录。<br><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/\" target=\"_blank\" rel=\"external\">单例模式</a>是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：<br>1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；<br>2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 </p>\n</blockquote>\n<h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><h5 id=\"饿汉单例\"><a href=\"#饿汉单例\" class=\"headerlink\" title=\"饿汉单例\"></a>饿汉单例</h5><pre><code>public class Singleton {\n private Singleton(){}\n private static Singleton instance = new Singleton();\n public static Singleton getInsatnce(){\n return instance;\n }\n}\n</code></pre><blockquote>\n<p>上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。</p>\n</blockquote>\n<h5 id=\"懒汉单例\"><a href=\"#懒汉单例\" class=\"headerlink\" title=\"懒汉单例\"></a>懒汉单例</h5><pre><code>public class LazySingleton {\n\n    private LazySingleton() {\n    }\n\n    public static LazySingleton instance = null;\n\n    public static synchronized LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br></p>\n<p>在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。</p>\n</blockquote>\n<h5 id=\"懒汉单例的改进：静态内部类单例\"><a href=\"#懒汉单例的改进：静态内部类单例\" class=\"headerlink\" title=\"懒汉单例的改进：静态内部类单例\"></a>懒汉单例的改进：静态内部类单例</h5><pre><code>public class StaticInnerClassSingleton {\n\n    private StaticInnerClassSingleton() {\n    }\n\n    public StaticInnerClassSingleton getInstance() {\n        return SingletonHolder.instance;\n    }\n\n    private static class SingletonHolder {\n        private static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n    }\n}\n</code></pre><blockquote>\n<p>使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。</p>\n</blockquote>\n<h5 id=\"DoubleCheckLock-实现单例\"><a href=\"#DoubleCheckLock-实现单例\" class=\"headerlink\" title=\"DoubleCheckLock 实现单例\"></a>DoubleCheckLock 实现单例</h5><pre><code>public class DCLSingleton {\n\n    private static DCLSingleton instance = null;\n\n    private DCLSingleton() {\n    }\n\n    public DCLSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DCLSingleton.class) {\n                if (instance == null) {\n                    instance = new DCLSingleton();\n                }\n\n            }\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br>因为<br><code>instance = new DCLSingleton();</code><br>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br><br>1.给DCLSingleton的实例分配内存<br><br>2.调用DCLSingleton的构造，初始化成员字段<br><br>3.将instance对象指向分配的内存空间<br></p>\n<p>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中<em>Cache、寄存器到主内存回写顺序</em>的规定，上面2、3的顺序无法保证先后执行的。<br>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br><br>解决：JDK1.5之后，<code>private static volatile DCLSingleton instance = null;</code><br>使用volatile关键字，可以保证instance对象<em>每次都是从主内存中读取</em>。</p>\n</blockquote>\n<h5 id=\"容器维护多个单例\"><a href=\"#容器维护多个单例\" class=\"headerlink\" title=\"容器维护多个单例\"></a>容器维护多个单例</h5><pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class SingletonManager {\n    private static Map&lt;String,Object&gt; objMap = new HashMap&lt;&gt;();\n\n    private SingletonManager(){}\n\n    public static void registerService(String key,Object instance){\n        if(!objMap.containsKey(key)){\n            objMap.put(key, instance);\n        }\n    }\n\n    public static Object getService(String key){\n        return objMap.get(key);\n    }\n\n}\n</code></pre><blockquote>\n<p>根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)</p>\n</blockquote>\n<h5 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h5><pre><code>public enum EnumSingleton {\n\n    INSTANCE;\n\n    public void doSomething() {\n    }\n}\n</code></pre><blockquote>\n<p>写法简单，线程安全，在任何情况下都是单例！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><h5 id=\"来自wiki\"><a href=\"#来自wiki\" class=\"headerlink\" title=\"来自wiki\"></a>来自wiki</h5><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"external\">单例模式</a>又叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。<br>比如：在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>\n</blockquote>\n<h5 id=\"来自IBM\"><a href=\"#来自IBM\" class=\"headerlink\" title=\"来自IBM\"></a>来自IBM</h5><blockquote>\n<p>与wiki相重复的内容，不再摘录。<br><a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-Singleton/\" target=\"_blank\" rel=\"external\">单例模式</a>是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。Java里面实现单例是一个虚拟机的范围，因为装载类的功能是由虚拟机做的，所以一个虚拟机在通过自己的ClassLoader装载实现单例类的时候就会创建一个类实例。在Java语言中，这样的行为有两大好处：<br>1.对于频繁使用的对象，可以省略创建对象所话费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；<br>2.由于new操作的次数减少，因而对系统内存的使用频率降低，这将减轻GC压力，缩短GC停顿时间。 </p>\n</blockquote>\n<h4 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h4><h5 id=\"饿汉单例\"><a href=\"#饿汉单例\" class=\"headerlink\" title=\"饿汉单例\"></a>饿汉单例</h5><pre><code>public class Singleton {\n private Singleton(){}\n private static Singleton instance = new Singleton();\n public static Singleton getInsatnce(){\n return instance;\n }\n}\n</code></pre><blockquote>\n<p>上述代码不足之处是无法对instance实例做延时加载，假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类时，单例对象就会被建立，如果此时这个单例类在系统中还扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否会用到。</p>\n</blockquote>\n<h5 id=\"懒汉单例\"><a href=\"#懒汉单例\" class=\"headerlink\" title=\"懒汉单例\"></a>懒汉单例</h5><pre><code>public class LazySingleton {\n\n    private LazySingleton() {\n    }\n\n    public static LazySingleton instance = null;\n\n    public static synchronized LazySingleton getInstance() {\n        if (instance == null) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>上述代码首先对于静态成员变量instance初始化复赋值为null，确保系统启动时没有额外的负载；其次在getInstance()工厂方法中判断单例是否已经存在；注意，我们的getInstance()方法中添加了synchronized关键字，这就是注意事项中，在多线程情况下保证单例对象唯一性的手段。因此每次调用都要进行同步，造成不必要的开销，明显增加多线程环境下耗时。<br></p>\n<p>在多线程的应用场合下。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，解决该问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(会降低效率)。</p>\n</blockquote>\n<h5 id=\"懒汉单例的改进：静态内部类单例\"><a href=\"#懒汉单例的改进：静态内部类单例\" class=\"headerlink\" title=\"懒汉单例的改进：静态内部类单例\"></a>懒汉单例的改进：静态内部类单例</h5><pre><code>public class StaticInnerClassSingleton {\n\n    private StaticInnerClassSingleton() {\n    }\n\n    public StaticInnerClassSingleton getInstance() {\n        return SingletonHolder.instance;\n    }\n\n    private static class SingletonHolder {\n        private static final StaticInnerClassSingleton instance = new StaticInnerClassSingleton();\n    }\n}\n</code></pre><blockquote>\n<p>使用内部类来维护单例的实例，第一次加载StaticInnerClassSingleton类时，不会初始化instance，只有在第一次调用getInstance()时，才会加载SingletonHolder，初始化instance。由于实例的建立是在类加载时完成，不仅可以确保线程安全，也无需使用synchronized关键字，因此推荐使用。</p>\n</blockquote>\n<h5 id=\"DoubleCheckLock-实现单例\"><a href=\"#DoubleCheckLock-实现单例\" class=\"headerlink\" title=\"DoubleCheckLock 实现单例\"></a>DoubleCheckLock 实现单例</h5><pre><code>public class DCLSingleton {\n\n    private static DCLSingleton instance = null;\n\n    private DCLSingleton() {\n    }\n\n    public DCLSingleton getInstance() {\n        if (instance == null) {\n            synchronized (DCLSingleton.class) {\n                if (instance == null) {\n                    instance = new DCLSingleton();\n                }\n\n            }\n        }\n        return instance;\n    }\n}\n</code></pre><blockquote>\n<p>同步关键字加载方法上，如懒汉式单例，增加系统开销，影响效率。上述代码，第一次判空，可以避免不必要的同步，第二次判空是避免多线程情况下，instance实例为空，DCL失效。<br>因为<br><code>instance = new DCLSingleton();</code><br>并非原子操作，这句代码最终会被编译成多条汇编命令，大致做了三件事：<br><br>1.给DCLSingleton的实例分配内存<br><br>2.调用DCLSingleton的构造，初始化成员字段<br><br>3.将instance对象指向分配的内存空间<br></p>\n<p>由于Java编译器允许处理器乱序执行，以及JDK1.5之前的JMM(java memory model即Java内存模型)中<em>Cache、寄存器到主内存回写顺序</em>的规定，上面2、3的顺序无法保证先后执行的。<br>如果线程A的3执行完，此时instance不为null，2却没有执行，被切换到线程B上，B可以直接取走instance，使用就会报错，这就是DCL失效。<br><br>解决：JDK1.5之后，<code>private static volatile DCLSingleton instance = null;</code><br>使用volatile关键字，可以保证instance对象<em>每次都是从主内存中读取</em>。</p>\n</blockquote>\n<h5 id=\"容器维护多个单例\"><a href=\"#容器维护多个单例\" class=\"headerlink\" title=\"容器维护多个单例\"></a>容器维护多个单例</h5><pre><code>import java.util.HashMap;\nimport java.util.Map;\n\npublic class SingletonManager {\n    private static Map&lt;String,Object&gt; objMap = new HashMap&lt;&gt;();\n\n    private SingletonManager(){}\n\n    public static void registerService(String key,Object instance){\n        if(!objMap.containsKey(key)){\n            objMap.put(key, instance);\n        }\n    }\n\n    public static Object getService(String key){\n        return objMap.get(key);\n    }\n\n}\n</code></pre><blockquote>\n<p>根据key,使用map管理多种类型的单例，在使用时可以统一进行获取操作，可降低用户的使用成本。(个人感觉没啥用)</p>\n</blockquote>\n<h5 id=\"枚举单例\"><a href=\"#枚举单例\" class=\"headerlink\" title=\"枚举单例\"></a>枚举单例</h5><pre><code>public enum EnumSingleton {\n\n    INSTANCE;\n\n    public void doSomething() {\n    }\n}\n</code></pre><blockquote>\n<p>写法简单，线程安全，在任何情况下都是单例！</p>\n</blockquote>\n"},{"layout":"post","title":"Android Device Monitor不显示App进程信息问题","date":"2017-02-10T00:00:00.000Z","_content":"\n \n#### 问题现象 ####\n\n\t\n![ADM现象截图](/images/adm_question.png)\n\n\t如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n\n> 去查看Hierarchy View，提示如下：\t\t\n> \n-  Unable to get view server version from device;\n-  Unable to get view server protocol version from device\n-  Unable to get the focused window from device\n-  Unable to debug device\n \t \n\n#### 原因 ####\n\n\tFor security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n \n\n#### 解决方法 ####\n\n##### 方法一 #####\n\n\t使用模拟器，推荐\n\n##### 方法二 #####\n\n\tapp不签名，也可以查看到\n\n##### 方法三 #####\n\n\t经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n\t[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n\n\n\n#### 名词解释 ####\n\n\tDDMS：Dalvik Debug Monitor Server","source":"_posts/2017-02-10-how-use-android-device-monitor.md","raw":"---\nlayout: post\ntitle:  Android Device Monitor不显示App进程信息问题\ndate:   2017-02-10\ncategories: Android \ntag: android\n---\n\n \n#### 问题现象 ####\n\n\t\n![ADM现象截图](/images/adm_question.png)\n\n\t如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n\n> 去查看Hierarchy View，提示如下：\t\t\n> \n-  Unable to get view server version from device;\n-  Unable to get view server protocol version from device\n-  Unable to get the focused window from device\n-  Unable to debug device\n \t \n\n#### 原因 ####\n\n\tFor security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n \n\n#### 解决方法 ####\n\n##### 方法一 #####\n\n\t使用模拟器，推荐\n\n##### 方法二 #####\n\n\tapp不签名，也可以查看到\n\n##### 方法三 #####\n\n\t经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n\t[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n\n\n\n#### 名词解释 ####\n\n\tDDMS：Dalvik Debug Monitor Server","slug":"how-use-android-device-monitor","published":1,"updated":"2017-11-16T08:30:00.046Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1av000c2sivdsnw79wl","content":"<h4 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h4><p><img src=\"/images/adm_question.png\" alt=\"ADM现象截图\"></p>\n<pre><code>如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n</code></pre><blockquote>\n<p>去查看Hierarchy View，提示如下：        </p>\n<ul>\n<li>Unable to get view server version from device;</li>\n<li>Unable to get view server protocol version from device</li>\n<li>Unable to get the focused window from device</li>\n<li>Unable to debug device</li>\n</ul>\n</blockquote>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><pre><code>For security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n</code></pre><h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>使用模拟器，推荐\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>app不签名，也可以查看到\n</code></pre><h5 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h5><pre><code>经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n</code></pre><h4 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h4><pre><code>DDMS：Dalvik Debug Monitor Server\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h4><p><img src=\"/images/adm_question.png\" alt=\"ADM现象截图\"></p>\n<pre><code>如图所示，CTRL + SHIFT + A 输入Android Device Monitor并打开，可以看到连接了两部手机，但都没有显示我想要调试的进程信息。\n</code></pre><blockquote>\n<p>去查看Hierarchy View，提示如下：        </p>\n<ul>\n<li>Unable to get view server version from device;</li>\n<li>Unable to get view server protocol version from device</li>\n<li>Unable to get the focused window from device</li>\n<li>Unable to debug device</li>\n</ul>\n</blockquote>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><pre><code>For security reasons HierarchyViewer does NOT work on production builds. It works only with userdebug and engineering builds (this includes the emulator.)\n</code></pre><h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>使用模拟器，推荐\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>app不签名，也可以查看到\n</code></pre><h5 id=\"方法三\"><a href=\"#方法三\" class=\"headerlink\" title=\"方法三\"></a>方法三</h5><pre><code>经常会引起OOM等问题，但是还是贴出来，不推荐使用：\n\n[ViewServer](https://github.com/romainguy/ViewServer/blob/master/viewserver/src/main/java/com/android/debug/hv/ViewServer.java)\n</code></pre><h4 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h4><pre><code>DDMS：Dalvik Debug Monitor Server\n</code></pre>"},{"layout":"post","title":"单例设计模式(二)真●单例唯一$序列化","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 序列化对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n\n然后看我们的测试代码：\n\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.io.FileOutputStream;\n\timport java.io.ObjectInputStream;\n\timport java.io.ObjectOutputStream;\n\n\tpublic class SerializableDemo1 {\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\"tempFile\"));\n\t\t\t\toos.writeObject(Singleton.getInstance());\n\t\t\t\tFile file = new File(\"tempFile\");\n\t\t\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n\t\t\t\t\t\tfile));\n\t\t\t\tSingleton instance = (Singleton) ois.readObject();\n\t\t\t\tSystem.out.println(\"反序列化后的对象和原来的是否相等？\"\n\t\t\t\t\t\t+ (Singleton.getInstance() == instance));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n> 运行后： ``` 反序列化后的对象和原来的是否相等？false ```\n\n> 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。\n\n\n#### 序列化破坏单例の原因 ####\n\n反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,<br/>\n发现：``` Object obj = readObject0(false);```<br/>\n继续：\n\n\t case TC_OBJECT:\n\t                    return checkResolve(readOrdinaryObject(unshared));\n\n探究： ```ObjectInputStream$readOrdinaryObject```\n\n该方法关键代码片段一：\n\n\t Object obj;\n\t        try {\n\t            obj = desc.isInstantiable() ? desc.newInstance() : null;\n\t        } catch (Exception ex) {\n\t            throw (IOException) new InvalidClassException(\n\t                desc.forClass().getName(),\n\t                \"unable to create instance\").initCause(ex);\n\t        }\n\n> 该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br/>\n> ```isInstantiable```：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。\n> ```desc.newInstance()```：该方法通过反射的方式调用无参构造方法新建一个对象\n\n所以：\n\n> 反序列化会通过反射调用无参的构造创建一个新的对象\n\n该方法关键代码片段二：\n\n\t if (obj != null &&\n\t            handles.lookupException(passHandle) == null &&\n\t            desc.hasReadResolveMethod())\n\t        {\n\t            Object rep = desc.invokeReadResolve(obj);\n\t            if (unshared && rep.getClass().isArray()) {\n\t                rep = cloneArray(rep);\n\t            }\n\t            if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }\n\t        }\n\n> ```hasReadResolveMethod```： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br/>\n> ```invokeReadResolve```： 通过反射的方式调用要被反序列化的类的readResolve方法<br/>\n> ```if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }```：\n>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。\n\n#### 结论一 ####\n\n\t由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n","source":"_posts/2017-02-11-design-patterns-singleton-2.md","raw":"---\nlayout: post\ntitle:  单例设计模式(二)真●单例唯一$序列化\ndate:   2017-02-11\ncategories: Design Pattern\ntag: 设计模式\n---\n \n\n#### 序列化对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n\n然后看我们的测试代码：\n\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.io.FileOutputStream;\n\timport java.io.ObjectInputStream;\n\timport java.io.ObjectOutputStream;\n\n\tpublic class SerializableDemo1 {\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tObjectOutputStream oos = new ObjectOutputStream(\n\t\t\t\t\t\tnew FileOutputStream(\"tempFile\"));\n\t\t\t\toos.writeObject(Singleton.getInstance());\n\t\t\t\tFile file = new File(\"tempFile\");\n\t\t\t\tObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n\t\t\t\t\t\tfile));\n\t\t\t\tSingleton instance = (Singleton) ois.readObject();\n\t\t\t\tSystem.out.println(\"反序列化后的对象和原来的是否相等？\"\n\t\t\t\t\t\t+ (Singleton.getInstance() == instance));\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n> 运行后： ``` 反序列化后的对象和原来的是否相等？false ```\n\n> 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。\n\n\n#### 序列化破坏单例の原因 ####\n\n反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,<br/>\n发现：``` Object obj = readObject0(false);```<br/>\n继续：\n\n\t case TC_OBJECT:\n\t                    return checkResolve(readOrdinaryObject(unshared));\n\n探究： ```ObjectInputStream$readOrdinaryObject```\n\n该方法关键代码片段一：\n\n\t Object obj;\n\t        try {\n\t            obj = desc.isInstantiable() ? desc.newInstance() : null;\n\t        } catch (Exception ex) {\n\t            throw (IOException) new InvalidClassException(\n\t                desc.forClass().getName(),\n\t                \"unable to create instance\").initCause(ex);\n\t        }\n\n> 该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br/>\n> ```isInstantiable```：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。\n> ```desc.newInstance()```：该方法通过反射的方式调用无参构造方法新建一个对象\n\n所以：\n\n> 反序列化会通过反射调用无参的构造创建一个新的对象\n\n该方法关键代码片段二：\n\n\t if (obj != null &&\n\t            handles.lookupException(passHandle) == null &&\n\t            desc.hasReadResolveMethod())\n\t        {\n\t            Object rep = desc.invokeReadResolve(obj);\n\t            if (unshared && rep.getClass().isArray()) {\n\t                rep = cloneArray(rep);\n\t            }\n\t            if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }\n\t        }\n\n> ```hasReadResolveMethod```： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br/>\n> ```invokeReadResolve```： 通过反射的方式调用要被反序列化的类的readResolve方法<br/>\n> ```if (rep != obj) {\n\t                handles.setObject(passHandle, obj = rep);\n\t            }```：\n>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。\n\n#### 结论一 ####\n\n\t由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\n\timport java.io.Serializable;\n\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\n\t\tpublic static volatile Singleton singleton;\n\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\n\t\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n\t}\n","slug":"design-patterns-singleton-2","published":1,"updated":"2017-08-17T02:39:20.998Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ay000e2siv0gpa0z9n","content":"<h4 id=\"序列化对单例的破坏\"><a href=\"#序列化对单例的破坏\" class=\"headerlink\" title=\"序列化对单例的破坏\"></a>序列化对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class SerializableDemo1 {\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(\n                    new FileOutputStream(&quot;tempFile&quot;));\n            oos.writeObject(Singleton.getInstance());\n            File file = new File(&quot;tempFile&quot;);\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n                    file));\n            Singleton instance = (Singleton) ois.readObject();\n            System.out.println(&quot;反序列化后的对象和原来的是否相等？&quot;\n                    + (Singleton.getInstance() == instance));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt; 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 序列化破坏单例の原因 ####</div><div class=\"line\"></div><div class=\"line\">反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,&lt;br/&gt;</div><div class=\"line\">发现：``` Object obj = readObject0(false);```&lt;br/&gt;</div><div class=\"line\">继续：</div><div class=\"line\"></div><div class=\"line\">\t case TC_OBJECT:</div><div class=\"line\">\t                    return checkResolve(readOrdinaryObject(unshared));</div><div class=\"line\"></div><div class=\"line\">探究： ```ObjectInputStream$readOrdinaryObject</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>该方法关键代码片段一：</p>\n<pre><code>Object obj;\n       try {\n           obj = desc.isInstantiable() ? desc.newInstance() : null;\n       } catch (Exception ex) {\n           throw (IOException) new InvalidClassException(\n               desc.forClass().getName(),\n               &quot;unable to create instance&quot;).initCause(ex);\n       }\n</code></pre><blockquote>\n<p>该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br><br><code>isInstantiable</code>：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。<br><code>desc.newInstance()</code>：该方法通过反射的方式调用无参构造方法新建一个对象</p>\n</blockquote>\n<p>所以：</p>\n<blockquote>\n<p>反序列化会通过反射调用无参的构造创建一个新的对象</p>\n</blockquote>\n<p>该方法关键代码片段二：</p>\n<pre><code>if (obj != null &amp;&amp;\n           handles.lookupException(passHandle) == null &amp;&amp;\n           desc.hasReadResolveMethod())\n       {\n           Object rep = desc.invokeReadResolve(obj);\n           if (unshared &amp;&amp; rep.getClass().isArray()) {\n               rep = cloneArray(rep);\n           }\n           if (rep != obj) {\n               handles.setObject(passHandle, obj = rep);\n           }\n       }\n</code></pre><blockquote>\n<p><code>hasReadResolveMethod</code>： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br><br><code>invokeReadResolve</code>： 通过反射的方式调用要被反序列化的类的readResolve方法<br><br><code>if (rep != obj) {\n                    handles.setObject(passHandle, obj = rep);\n                }</code>：<br>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。</p>\n</blockquote>\n<h4 id=\"结论一\"><a href=\"#结论一\" class=\"headerlink\" title=\"结论一\"></a>结论一</h4><pre><code>由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\nimport java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    private Object readResolve() {\n        return singleton;\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"序列化对单例的破坏\"><a href=\"#序列化对单例的破坏\" class=\"headerlink\" title=\"序列化对单例的破坏\"></a>序列化对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class SerializableDemo1 {\n    public static void main(String[] args) {\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(\n                    new FileOutputStream(&quot;tempFile&quot;));\n            oos.writeObject(Singleton.getInstance());\n            File file = new File(&quot;tempFile&quot;);\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\n                    file));\n            Singleton instance = (Singleton) ois.readObject();\n            System.out.println(&quot;反序列化后的对象和原来的是否相等？&quot;\n                    + (Singleton.getInstance() == instance));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <figure class=\"highlight plain\"><figcaption><span>```</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt; 通过对Singleton的序列化与反序列化得到的对象是```一个新的对象```，这就破坏了Singleton的单例性。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 序列化破坏单例の原因 ####</div><div class=\"line\"></div><div class=\"line\">反序列化后，为什么是一个新的对象？我们从```ObjectInputStream$readObject()```方法追踪,&lt;br/&gt;</div><div class=\"line\">发现：``` Object obj = readObject0(false);```&lt;br/&gt;</div><div class=\"line\">继续：</div><div class=\"line\"></div><div class=\"line\">\t case TC_OBJECT:</div><div class=\"line\">\t                    return checkResolve(readOrdinaryObject(unshared));</div><div class=\"line\"></div><div class=\"line\">探究： ```ObjectInputStream$readOrdinaryObject</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>该方法关键代码片段一：</p>\n<pre><code>Object obj;\n       try {\n           obj = desc.isInstantiable() ? desc.newInstance() : null;\n       } catch (Exception ex) {\n           throw (IOException) new InvalidClassException(\n               desc.forClass().getName(),\n               &quot;unable to create instance&quot;).initCause(ex);\n       }\n</code></pre><blockquote>\n<p>该obj,就是我们反序列化要得到的对象，即readObject()返回的对象。<br><br><code>isInstantiable</code>：如果一个Serializable/externalizable的类可以在运行时被实例化，那么该方法就返回true。<br><code>desc.newInstance()</code>：该方法通过反射的方式调用无参构造方法新建一个对象</p>\n</blockquote>\n<p>所以：</p>\n<blockquote>\n<p>反序列化会通过反射调用无参的构造创建一个新的对象</p>\n</blockquote>\n<p>该方法关键代码片段二：</p>\n<pre><code>if (obj != null &amp;&amp;\n           handles.lookupException(passHandle) == null &amp;&amp;\n           desc.hasReadResolveMethod())\n       {\n           Object rep = desc.invokeReadResolve(obj);\n           if (unshared &amp;&amp; rep.getClass().isArray()) {\n               rep = cloneArray(rep);\n           }\n           if (rep != obj) {\n               handles.setObject(passHandle, obj = rep);\n           }\n       }\n</code></pre><blockquote>\n<p><code>hasReadResolveMethod</code>： 如果实现了Serializable或者externalizable接口的类中包含readResolve,则返回true<br><br><code>invokeReadResolve</code>： 通过反射的方式调用要被反序列化的类的readResolve方法<br><br><code>if (rep != obj) {\n                    handles.setObject(passHandle, obj = rep);\n                }</code>：<br>如果readResolve得到的对象和desc.newInstance()调用无参构造得到的对象不同，那么使用readResolve方法中返回的Object。</p>\n</blockquote>\n<h4 id=\"结论一\"><a href=\"#结论一\" class=\"headerlink\" title=\"结论一\"></a>结论一</h4><pre><code>由上可得，我们在自己的单例中增加readResolve方法，返回当前单例的实例，即可防止反序列化得到对象不一致问题。如下：\n\nimport java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n    private Object readResolve() {\n        return singleton;\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"队列、堆栈与数组链表的关系","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 数据结构的概念 ####\n\n\t指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n\n\n#### 数据存储结构的概念 ####\n\t\n\t这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n\t非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n\n##### 数组和链表 #####\n\t\n\t数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n\t链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n\t\n\n|类型 |内存空间 |长度的可变性 |对数据的访问\n|-----|:-------:|:----------:|:----------:|\n|数组|连续的内存空间，相同多数据下占用较小内存|需要提前给定|移动数据麻烦，访问数据方便|\n|链表|可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间|可以伸缩|移动数据方便，访问数据麻烦|\n\n##### 堆栈和栈 #####\n\t[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n\n##### Java中的堆和栈#####\n\t\t\n\t1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n\t2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。","source":"_posts/2017-02-11-different-between-ADT.md","raw":"---\nlayout: post\ntitle:  队列、堆栈与数组链表的关系\ndate:   2017-02-11\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### 数据结构的概念 ####\n\n\t指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n\n\n#### 数据存储结构的概念 ####\n\t\n\t这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n\t非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n\n##### 数组和链表 #####\n\t\n\t数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n\t链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n\t\n\n|类型 |内存空间 |长度的可变性 |对数据的访问\n|-----|:-------:|:----------:|:----------:|\n|数组|连续的内存空间，相同多数据下占用较小内存|需要提前给定|移动数据麻烦，访问数据方便|\n|链表|可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间|可以伸缩|移动数据方便，访问数据麻烦|\n\n##### 堆栈和栈 #####\n\t[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n\n##### Java中的堆和栈#####\n\t\t\n\t1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n\t2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。","slug":"different-between-ADT","published":1,"updated":"2017-08-17T02:39:39.666Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1b0000h2sivrrgv0z3h","content":"<h4 id=\"数据结构的概念\"><a href=\"#数据结构的概念\" class=\"headerlink\" title=\"数据结构的概念\"></a>数据结构的概念</h4><pre><code>指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n</code></pre><h4 id=\"数据存储结构的概念\"><a href=\"#数据存储结构的概念\" class=\"headerlink\" title=\"数据存储结构的概念\"></a>数据存储结构的概念</h4><pre><code>这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n</code></pre><h5 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h5><pre><code>数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n</code></pre><table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:center\">内存空间</th>\n<th style=\"text-align:center\">长度的可变性</th>\n<th style=\"text-align:center\">对数据的访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数组</td>\n<td style=\"text-align:center\">连续的内存空间，相同多数据下占用较小内存</td>\n<td style=\"text-align:center\">需要提前给定</td>\n<td style=\"text-align:center\">移动数据麻烦，访问数据方便</td>\n</tr>\n<tr>\n<td>链表</td>\n<td style=\"text-align:center\">可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间</td>\n<td style=\"text-align:center\">可以伸缩</td>\n<td style=\"text-align:center\">移动数据方便，访问数据麻烦</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"堆栈和栈\"><a href=\"#堆栈和栈\" class=\"headerlink\" title=\"堆栈和栈\"></a>堆栈和栈</h5><pre><code>[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n</code></pre><h5 id=\"Java中的堆和栈\"><a href=\"#Java中的堆和栈\" class=\"headerlink\" title=\"Java中的堆和栈\"></a>Java中的堆和栈</h5><pre><code>1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"数据结构的概念\"><a href=\"#数据结构的概念\" class=\"headerlink\" title=\"数据结构的概念\"></a>数据结构的概念</h4><pre><code>指相互之间存在一种或多种特定关系的数据元素的集合。简单的理解就是：数据结构就是描述对象逻辑关系的学科。比如：队列就是一种先进先出的逻辑结构，栈是一种先进后出的逻辑结构，家谱是一种树形的逻辑结构。\n</code></pre><h4 id=\"数据存储结构的概念\"><a href=\"#数据存储结构的概念\" class=\"headerlink\" title=\"数据存储结构的概念\"></a>数据存储结构的概念</h4><pre><code>这是计算机的一个概念，即描述数据在计算机中存储方式的学科；常用的存储方式就两种：顺序存储、非顺序存储。顺序存储就是把数据存储在一块连续的存储介质(硬盘)上，数组就是典型的连续存储。\n非顺序存储就是各个数据不一定存在一个连续的位置上，只要每个数据知道它前面的数据和后面的数据，就能把所有的数据连续起来，链表就是典型的非顺序存储。\n</code></pre><h5 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h5><pre><code>数组属于顺序存储，通过直接访问数组下标即可得到元素的存储位置，所以访问时间都是相同。\n链表属于数据的链接存储，由于每个元素的位置保存在它的前驱或者后继中，所以只有访问到其前驱结点或后继结点后才能够按指针访问到自己，访问元素的时间与该元素结点在链接存储中的位置有关。\n</code></pre><table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:center\">内存空间</th>\n<th style=\"text-align:center\">长度的可变性</th>\n<th style=\"text-align:center\">对数据的访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数组</td>\n<td style=\"text-align:center\">连续的内存空间，相同多数据下占用较小内存</td>\n<td style=\"text-align:center\">需要提前给定</td>\n<td style=\"text-align:center\">移动数据麻烦，访问数据方便</td>\n</tr>\n<tr>\n<td>链表</td>\n<td style=\"text-align:center\">可以连续，也可以不连续，占用较大内存，需要存放前驱和后继的空间</td>\n<td style=\"text-align:center\">可以伸缩</td>\n<td style=\"text-align:center\">移动数据方便，访问数据麻烦</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"堆栈和栈\"><a href=\"#堆栈和栈\" class=\"headerlink\" title=\"堆栈和栈\"></a>堆栈和栈</h5><pre><code>[堆栈](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88)（英语：stack），也可直接称栈（港澳台作堆叠）\n</code></pre><h5 id=\"Java中的堆和栈\"><a href=\"#Java中的堆和栈\" class=\"headerlink\" title=\"Java中的堆和栈\"></a>Java中的堆和栈</h5><pre><code>1. 栈具有数据结构中栈的特点，所有存放在它里面的数据都是生命周期很明确，能够快速反应的，所以在Java中使用栈来存放8个基本数据类型和引用变量，用完就马上销毁。\n2. 堆可以理解它就是一个可大可小，任人分配的内存操作单元，因此它的特点就是动态分配内存，适合存放大的数据量，比如一个对象的所有信息，虽然它的引用指向栈中的某个引用变量；所以Java中堆是存放new出来的对象的。\n</code></pre>"},{"layout":"post","title":"由两个栈组成的队列","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 由两个栈组成的队列 #####\n\n\n\t编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n\t具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n\t根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n\n##### 注意事项 #####\n\t\t\n\t1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n\t2. 如果stackPop要接收数据，必须保证stackPop为空。\n\n##### stackPush压入stackPop的操作时机 #####\n\t\n\t调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\t\n\tpublic class TwoStackQueue {\n\n\t\tpublic Stack<Integer> stackPush;\n\t\tpublic Stack<Integer> stackPop;\n\t\n\t\tpublic TwoStackQueue() {\n\t\t\tstackPop = new Stack<>();\n\t\t\tstackPush = new Stack<>();\n\t\t}\n\t\n\t\tpublic void add(int pushInt) {\n\t\t\tstackPush.push(pushInt);\n\t\t}\n\t\n\t\tpublic int poll() {\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.pop();\n\t\t}\n\t\t\n\t\tpublic int peek(){\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.peek();\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-11-two-stacks-makeup-queue.md","raw":"---\nlayout: post\ntitle:  由两个栈组成的队列\ndate:   2017-02-11\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 由两个栈组成的队列 #####\n\n\n\t编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n\t具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n\t根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n\n##### 注意事项 #####\n\t\t\n\t1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n\t2. 如果stackPop要接收数据，必须保证stackPop为空。\n\n##### stackPush压入stackPop的操作时机 #####\n\t\n\t调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\t\n\tpublic class TwoStackQueue {\n\n\t\tpublic Stack<Integer> stackPush;\n\t\tpublic Stack<Integer> stackPop;\n\t\n\t\tpublic TwoStackQueue() {\n\t\t\tstackPop = new Stack<>();\n\t\t\tstackPush = new Stack<>();\n\t\t}\n\t\n\t\tpublic void add(int pushInt) {\n\t\t\tstackPush.push(pushInt);\n\t\t}\n\t\n\t\tpublic int poll() {\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.pop();\n\t\t}\n\t\t\n\t\tpublic int peek(){\n\t\t\tif (stackPop.empty() && stackPush.empty()) {\n\t\t\t\tthrow new RuntimeException(\"Queue is empty!\");\n\t\t\t} else if (stackPop.empty()) {\n\t\t\t\twhile (!stackPush.empty()) {\n\t\t\t\t\tstackPop.push(stackPush.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackPop.peek();\n\t\t}\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"two-stacks-makeup-queue","published":1,"updated":"2017-08-17T02:40:02.139Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1b3000j2sivp0or7opb","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"由两个栈组成的队列\"><a href=\"#由两个栈组成的队列\" class=\"headerlink\" title=\"由两个栈组成的队列\"></a>由两个栈组成的队列</h5><pre><code>编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n</code></pre><h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><pre><code>1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n2. 如果stackPop要接收数据，必须保证stackPop为空。\n</code></pre><h5 id=\"stackPush压入stackPop的操作时机\"><a href=\"#stackPush压入stackPop的操作时机\" class=\"headerlink\" title=\"stackPush压入stackPop的操作时机\"></a>stackPush压入stackPop的操作时机</h5><pre><code>调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class TwoStackQueue {\n\n    public Stack&lt;Integer&gt; stackPush;\n    public Stack&lt;Integer&gt; stackPop;\n\n    public TwoStackQueue() {\n        stackPop = new Stack&lt;&gt;();\n        stackPush = new Stack&lt;&gt;();\n    }\n\n    public void add(int pushInt) {\n        stackPush.push(pushInt);\n    }\n\n    public int poll() {\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n\n    public int peek(){\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"由两个栈组成的队列\"><a href=\"#由两个栈组成的队列\" class=\"headerlink\" title=\"由两个栈组成的队列\"></a>由两个栈组成的队列</h5><pre><code>编写一个类，使用两个栈实现队列，支持队列的基本操作(add,poll,peek)\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>栈的特点是先进后出，而队列的特点是先进先出。我们用两个栈，互相反序，实现类似队列的操作。\n具体实现上是一个栈作为压入栈，在压入数据时只往这个栈中压入，记为stackPush，另一个栈只作为弹出栈，记为stackPop。\n根据栈的特点，循环把stackPush中的数据压入stackPop中，stackPop的栈顶元素即为队列的dequeue元素。\n</code></pre><h5 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><pre><code>1. 如果stackPush要往stackPop中压入数据，必须一次性压入完毕；\n2. 如果stackPop要接收数据，必须保证stackPop为空。\n</code></pre><h5 id=\"stackPush压入stackPop的操作时机\"><a href=\"#stackPush压入stackPop的操作时机\" class=\"headerlink\" title=\"stackPush压入stackPop的操作时机\"></a>stackPush压入stackPop的操作时机</h5><pre><code>调用add、poll、peek三种方法中任何一种时发生都是可以，只要满足注意事项提到的两点，就不会出错。下面的例子是在调用poll和peek方法时进行压入数据的。\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class TwoStackQueue {\n\n    public Stack&lt;Integer&gt; stackPush;\n    public Stack&lt;Integer&gt; stackPop;\n\n    public TwoStackQueue() {\n        stackPop = new Stack&lt;&gt;();\n        stackPush = new Stack&lt;&gt;();\n    }\n\n    public void add(int pushInt) {\n        stackPush.push(pushInt);\n    }\n\n    public int poll() {\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n\n    public int peek(){\n        if (stackPop.empty() &amp;&amp; stackPush.empty()) {\n            throw new RuntimeException(&quot;Queue is empty!&quot;);\n        } else if (stackPop.empty()) {\n            while (!stackPush.empty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n}\n</code></pre>"},{"layout":"post","title":"如何仅用递归函数和栈操作逆序一个栈","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n\t一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t需要设计两个递归函数。\n\t1，将stack的栈底元素返回并移除；\n\t2，将stack逆序；\n\n \n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\n\tpublic class ReverseStack {\n\n\tprivate static int getAndRemoveLastElement(Stack<Integer> stack) {\n\t\tint result = stack.pop();\n\t\tif (stack.empty()) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\tint last = getAndRemoveLastElement(stack);\n\t\t\tstack.push(result);//此处将除栈底外的元素重新压入\n\t\t\treturn last;\n\t\t}\n\t}\n\n\tpublic static void reverse(Stack<Integer> stack) {\n\t\tif (stack.empty()) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tint i = getAndRemoveLastElement(stack);\n\t\t\treverse(stack);\n\t\t\tstack.push(i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-02-11-reverse-stack.md","raw":"---\nlayout: post\ntitle:  如何仅用递归函数和栈操作逆序一个栈\ndate:   2017-02-11\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### 题目 ####\n\n\t一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t需要设计两个递归函数。\n\t1，将stack的栈底元素返回并移除；\n\t2，将stack逆序；\n\n \n\n#### 代码 ####\n\t\t\n\timport java.util.Stack;\n\n\tpublic class ReverseStack {\n\n\tprivate static int getAndRemoveLastElement(Stack<Integer> stack) {\n\t\tint result = stack.pop();\n\t\tif (stack.empty()) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\tint last = getAndRemoveLastElement(stack);\n\t\t\tstack.push(result);//此处将除栈底外的元素重新压入\n\t\t\treturn last;\n\t\t}\n\t}\n\n\tpublic static void reverse(Stack<Integer> stack) {\n\t\tif (stack.empty()) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tint i = getAndRemoveLastElement(stack);\n\t\t\treverse(stack);\n\t\t\tstack.push(i);\n\t\t}\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"reverse-stack","published":1,"updated":"2017-08-17T02:39:47.395Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1b8000o2sivbx6r0fo4","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>需要设计两个递归函数。\n1，将stack的栈底元素返回并移除；\n2，将stack逆序；\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class ReverseStack {\n\nprivate static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) {\n    int result = stack.pop();\n    if (stack.empty()) {\n        return result;\n    } else {\n        int last = getAndRemoveLastElement(stack);\n        stack.push(result);//此处将除栈底外的元素重新压入\n        return last;\n    }\n}\n\npublic static void reverse(Stack&lt;Integer&gt; stack) {\n    if (stack.empty()) {\n        return;\n    } else {\n        int i = getAndRemoveLastElement(stack);\n        reverse(stack);\n        stack.push(i);\n    }\n}\n</code></pre><p>}</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中一次压入1，2，3，那么从栈顶到栈底依次为3，2，1.将这个栈逆序，从栈顶到栈底依次为1，2，3.但是只能用递归函数来实现，不能用其他数据结构。\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>需要设计两个递归函数。\n1，将stack的栈底元素返回并移除；\n2，将stack逆序；\n</code></pre><h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>import java.util.Stack;\n\npublic class ReverseStack {\n\nprivate static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) {\n    int result = stack.pop();\n    if (stack.empty()) {\n        return result;\n    } else {\n        int last = getAndRemoveLastElement(stack);\n        stack.push(result);//此处将除栈底外的元素重新压入\n        return last;\n    }\n}\n\npublic static void reverse(Stack&lt;Integer&gt; stack) {\n    if (stack.empty()) {\n        return;\n    } else {\n        int i = getAndRemoveLastElement(stack);\n        reverse(stack);\n        stack.push(i);\n    }\n}\n</code></pre><p>}</p>\n"},{"layout":"post","title":"单例设计模式(四)并不总是有效的readResolve","date":"2017-02-12T00:00:00.000Z","_content":" \n#### what ####\n\n在[《单例设计模式(二)真●单例唯一$序列化》](http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2)中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。\n\n1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。\n\n2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：\n\t\n\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。\n事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。\n\n\n4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。\n\n\n#### 题外话-readObject ####\n\n是的，关于反序列时的攻击。\n\n伪字节流的攻击法：对应的策略是提供一个readObject方法。\n但是并没有完成足够的保护性拷贝。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t    // 再进行状态参数的有效性验证\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n内部私有域盗用攻击法：对应的处理代码如下。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t \n\t    // 对可变组件进行保护性拷贝\n\t    start = new Date(start.getTime());\n\t    end = new Date(end.getTime());\n\t \n\t    // 进一步检测内部状态参数是否有效\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n#### 鸣谢 ####\n\n[代码迷](http://www.daimami.com/java-other/356857.htm)\n\n\n","source":"_posts/2017-02-12-design-patterns-singleton-4.md","raw":"---\nlayout: post\ntitle:  单例设计模式(四)并不总是有效的readResolve\ndate:   2017-02-12\ncategories: Design Pattern\ntag: 设计模式\n---\n \n#### what ####\n\n在[《单例设计模式(二)真●单例唯一$序列化》](http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2)中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。\n\n1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。\n\n2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：\n\t\n\tprivate Object readResolve() {\n\t\t\treturn singleton;\n\t\t}\n\n3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。\n事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。\n\n\n4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。\n\n\n#### 题外话-readObject ####\n\n是的，关于反序列时的攻击。\n\n伪字节流的攻击法：对应的策略是提供一个readObject方法。\n但是并没有完成足够的保护性拷贝。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t    // 再进行状态参数的有效性验证\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n内部私有域盗用攻击法：对应的处理代码如下。\n\n\tprivate void readObject(ObjectInputStream s) throws IOException,\n\t       ClassNotFoundException {\n\t    s.defaultReadObject();//先调用默认恢复\n\t \n\t    // 对可变组件进行保护性拷贝\n\t    start = new Date(start.getTime());\n\t    end = new Date(end.getTime());\n\t \n\t    // 进一步检测内部状态参数是否有效\n\t    if (start.compareTo(end) > 0)\n\t       throw new InvalidObjectException(start + \" after \" + end);\n\t}\n\n#### 鸣谢 ####\n\n[代码迷](http://www.daimami.com/java-other/356857.htm)\n\n\n","slug":"design-patterns-singleton-4","published":1,"updated":"2017-08-17T02:40:12.795Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1bc000r2sivb6d2af7c","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在<a href=\"http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2\" target=\"_blank\" rel=\"external\">《单例设计模式(二)真●单例唯一$序列化》</a>中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。</p>\n<p>1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。</p>\n<p>2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：</p>\n<pre><code>private Object readResolve() {\n        return singleton;\n    }\n</code></pre><p>3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。<br>事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。</p>\n<p>4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。</p>\n<h4 id=\"题外话-readObject\"><a href=\"#题外话-readObject\" class=\"headerlink\" title=\"题外话-readObject\"></a>题外话-readObject</h4><p>是的，关于反序列时的攻击。</p>\n<p>伪字节流的攻击法：对应的策略是提供一个readObject方法。<br>但是并没有完成足够的保护性拷贝。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n    // 再进行状态参数的有效性验证\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><p>内部私有域盗用攻击法：对应的处理代码如下。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n\n    // 对可变组件进行保护性拷贝\n    start = new Date(start.getTime());\n    end = new Date(end.getTime());\n\n    // 进一步检测内部状态参数是否有效\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"http://www.daimami.com/java-other/356857.htm\" target=\"_blank\" rel=\"external\">代码迷</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在<a href=\"http://xusx1024.github.io/2017/02/11/design-patterns-singleton-2\" target=\"_blank\" rel=\"external\">《单例设计模式(二)真●单例唯一$序列化》</a>中，我们已经分析了序列化和反序列化对单例类的实例唯一性的影响，原因以及解决方法。当我读《effective java》第十一章：序列化，发现readResolve的解决办法，也会有一些问题。</p>\n<p>1.对于实现了Serializable接口的单实例类，只要反序列化就一定会调用readObject方法，产生一个不同于现VM中实例的新对象。</p>\n<p>2.readResolve方法允许你用另一个实例去替代readObject方法创建的实例，如下：</p>\n<pre><code>private Object readResolve() {\n        return singleton;\n    }\n</code></pre><p>3.所以说，单例模式在序列化成字节码流后对反序列化根本没有用(被readResolve替换掉了)，所以，不需要将任何域序列化，所以单例中的所有实例域都应该被声明为transient。<br>事实上，如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域都必须声明为transient。</p>\n<p>4.因此我们的结论是ENUM最佳。但是如果必须编写可序列化的实例受控的类，它的实例在编译时还不知道，那就无法将类表示成一个枚举类型，因此readResolve进行实例控制也并不过时。</p>\n<h4 id=\"题外话-readObject\"><a href=\"#题外话-readObject\" class=\"headerlink\" title=\"题外话-readObject\"></a>题外话-readObject</h4><p>是的，关于反序列时的攻击。</p>\n<p>伪字节流的攻击法：对应的策略是提供一个readObject方法。<br>但是并没有完成足够的保护性拷贝。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n    // 再进行状态参数的有效性验证\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><p>内部私有域盗用攻击法：对应的处理代码如下。</p>\n<pre><code>private void readObject(ObjectInputStream s) throws IOException,\n       ClassNotFoundException {\n    s.defaultReadObject();//先调用默认恢复\n\n    // 对可变组件进行保护性拷贝\n    start = new Date(start.getTime());\n    end = new Date(end.getTime());\n\n    // 进一步检测内部状态参数是否有效\n    if (start.compareTo(end) &gt; 0)\n       throw new InvalidObjectException(start + &quot; after &quot; + end);\n}\n</code></pre><h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"http://www.daimami.com/java-other/356857.htm\" target=\"_blank\" rel=\"external\">代码迷</a></p>\n"},{"layout":"post","title":"Android app 启动优化","date":"2017-02-13T00:00:00.000Z","_content":" \n\n\n#### 基本概念 ####\n    Android Application与其他移动平台有两个重大不同点：\n\n    1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n    2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\n    Android进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n\n#### 进程启动策略 ####\n\n    简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n\n#### Android系统的启动 ####\n\n    与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为\"daemons\"的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n    随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n    启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n\n\n#### App的启动 ####\n\n![app launch](/images/Application_launch.jpg)\n\n>\nclick事件会调用```startActivity(Intent)```，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：\n>\n- 第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息\n- 指向信息被存储在一个intent对象中\n- 下面重要的一步是通过```grantUriPermissionLocked()```方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity\n- 如果有权限，ActivityManagerService会检查并在新的task中启动目标activity\n- 现在，是时候检查这个进程的ProcessRecord是否存在了\n- 如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。\n\n##### 创建进程 #####\n\n> ActivityManagerService调用```startProcessLocked()```方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用```ZygoteInit.main()```方法来实例化ActivityThread对象并最终返回新进程的pid.\n> ActivityThread随后依次调用```Looper.prepareLoop()```和```Looper.loop()```来开启消息循环。\n\n流程图如下：\n![process creation](/images/process_creation.jpg)\n\n##### 绑定Application #####\n\n> 接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用```bindApplication()```方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过```handleBindApplication()```处理该消息。然后调用```makeApplication()```方法来加载App的classes到内存中。\n 流程如下：\n\n![bind application](/images/bind_application.jpg)\n\t\n##### 启动Activity #####\n\n> 经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。\n> 实际调用方法是```realStartActivity()```，它会调用application线程对象中的```sheduleLaunchActivity()```发送一个LAUNCH_ACTIVITY消息到消息队列中，通过```handleLaunchActivity()```来处理该消息。\n\n 假设点击的是一个视频浏览的App，其流程如下：\n\n![start activity](/images/start_activity.jpg)\n##### Activity显示 #####\n\n> Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。\n\n如图：\n![display activity](/images/display_activity.png)\n\n#### 测量App的启动时间 ####\n\n\tactivity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n\n##### Display Time #####\n\n\tapi19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n\n图为抓取微信开启时间：\n![wechat display time](/images/display_time.png)\n\n##### ADB命令查看启动时间 #####\n\n`adb shell am start -W [packageName]/[packageName.MainActivity]`\n\n![adb see launch time](/images/adb_launch_time.png)\n>\n- ThisTime：最后一个启动的Activity的启动耗时；\n- TotalTime:到达当前页面的所有Activity的启动耗时；\n- WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。\n\n`adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4`\n\n>\n这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，`bugreport`参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。\n\n\n##### 代码中自定义上报启动时间 #####\n\n由于我们在一个App启动的开始，会做一些预操作，比如：\n- 加载第三方黑盒SDK\n- 网络、图片等框架的构造\n- 业务数据预请求\n\n所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API>=19的版本，在这些预操作做完之后手动调用`reportFullyDrawn`。这样Log中会增加一条日志：\n\n![reportFullyDrawn time](/images/report_full_drawn.png)\n\n#### 优化点 ####\n\n##### 背景Theme #####\n\t\n\t当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n\n>\t\n\t<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t            android:opacity=\"opaque\">\n\t<!-- android:opacity=\"opaque\"防止在启动的时候出现背景的闪烁 -->\n\t    <item android:drawable=\"@android:color/darker_gray\"/>\n\t    <item>\n\t        <bitmap\n\t            android:gravity=\"center\"\n\t            android:src=\"@mipmap/ic_launcher\"/>\n\t    </item>\n\t</layer-list>\n\n>\n\t<style name=\"StartStyle\" parent=\"AppTheme\">\n        <item name=\"android:windowBackground\">@drawable/start_window</item>\n    </style>\n\n\n##### 异步初始化 #####\n\t\n\t根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n\n##### 资源优化 #####\n\n>\t\n- 布局宽而浅，不要窄而深\n- \t使用.9\n- \ttinyPNG\n- \t混淆\n\n\n\n\n\n#### 鸣谢 ####\n\n[Launch-Time Performance ](https://developer.android.com/topic/performance/launch-time.html)\n\n[Android Application启动流程分析](http://www.jianshu.com/p/a5532ecc8377)\n\n[一触即发 App启动优化最佳实践](https://segmentfault.com/a/1190000007406875#articleHeader9)\n\n在线检测App：[nimbledroid](https://nimbledroid.com/) \n\t","source":"_posts/2017-02-13-optimization-app-launch.md","raw":"---\nlayout: post\ntitle:  Android app 启动优化\ndate:   2017-02-13\ncategories: Android \ntag: android\n---\n \n\n\n#### 基本概念 ####\n    Android Application与其他移动平台有两个重大不同点：\n\n    1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n    2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\n    Android进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n\n#### 进程启动策略 ####\n\n    简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n\n#### Android系统的启动 ####\n\n    与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为\"daemons\"的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n    随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n    启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n\n\n#### App的启动 ####\n\n![app launch](/images/Application_launch.jpg)\n\n>\nclick事件会调用```startActivity(Intent)```，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：\n>\n- 第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息\n- 指向信息被存储在一个intent对象中\n- 下面重要的一步是通过```grantUriPermissionLocked()```方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity\n- 如果有权限，ActivityManagerService会检查并在新的task中启动目标activity\n- 现在，是时候检查这个进程的ProcessRecord是否存在了\n- 如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。\n\n##### 创建进程 #####\n\n> ActivityManagerService调用```startProcessLocked()```方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用```ZygoteInit.main()```方法来实例化ActivityThread对象并最终返回新进程的pid.\n> ActivityThread随后依次调用```Looper.prepareLoop()```和```Looper.loop()```来开启消息循环。\n\n流程图如下：\n![process creation](/images/process_creation.jpg)\n\n##### 绑定Application #####\n\n> 接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用```bindApplication()```方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过```handleBindApplication()```处理该消息。然后调用```makeApplication()```方法来加载App的classes到内存中。\n 流程如下：\n\n![bind application](/images/bind_application.jpg)\n\t\n##### 启动Activity #####\n\n> 经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。\n> 实际调用方法是```realStartActivity()```，它会调用application线程对象中的```sheduleLaunchActivity()```发送一个LAUNCH_ACTIVITY消息到消息队列中，通过```handleLaunchActivity()```来处理该消息。\n\n 假设点击的是一个视频浏览的App，其流程如下：\n\n![start activity](/images/start_activity.jpg)\n##### Activity显示 #####\n\n> Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。\n\n如图：\n![display activity](/images/display_activity.png)\n\n#### 测量App的启动时间 ####\n\n\tactivity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n\n##### Display Time #####\n\n\tapi19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n\n图为抓取微信开启时间：\n![wechat display time](/images/display_time.png)\n\n##### ADB命令查看启动时间 #####\n\n`adb shell am start -W [packageName]/[packageName.MainActivity]`\n\n![adb see launch time](/images/adb_launch_time.png)\n>\n- ThisTime：最后一个启动的Activity的启动耗时；\n- TotalTime:到达当前页面的所有Activity的启动耗时；\n- WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。\n\n`adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4`\n\n>\n这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，`bugreport`参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。\n\n\n##### 代码中自定义上报启动时间 #####\n\n由于我们在一个App启动的开始，会做一些预操作，比如：\n- 加载第三方黑盒SDK\n- 网络、图片等框架的构造\n- 业务数据预请求\n\n所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API>=19的版本，在这些预操作做完之后手动调用`reportFullyDrawn`。这样Log中会增加一条日志：\n\n![reportFullyDrawn time](/images/report_full_drawn.png)\n\n#### 优化点 ####\n\n##### 背景Theme #####\n\t\n\t当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n\n>\t\n\t<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\t            android:opacity=\"opaque\">\n\t<!-- android:opacity=\"opaque\"防止在启动的时候出现背景的闪烁 -->\n\t    <item android:drawable=\"@android:color/darker_gray\"/>\n\t    <item>\n\t        <bitmap\n\t            android:gravity=\"center\"\n\t            android:src=\"@mipmap/ic_launcher\"/>\n\t    </item>\n\t</layer-list>\n\n>\n\t<style name=\"StartStyle\" parent=\"AppTheme\">\n        <item name=\"android:windowBackground\">@drawable/start_window</item>\n    </style>\n\n\n##### 异步初始化 #####\n\t\n\t根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n\n##### 资源优化 #####\n\n>\t\n- 布局宽而浅，不要窄而深\n- \t使用.9\n- \ttinyPNG\n- \t混淆\n\n\n\n\n\n#### 鸣谢 ####\n\n[Launch-Time Performance ](https://developer.android.com/topic/performance/launch-time.html)\n\n[Android Application启动流程分析](http://www.jianshu.com/p/a5532ecc8377)\n\n[一触即发 App启动优化最佳实践](https://segmentfault.com/a/1190000007406875#articleHeader9)\n\n在线检测App：[nimbledroid](https://nimbledroid.com/) \n\t","slug":"optimization-app-launch","published":1,"updated":"2017-11-16T08:29:39.342Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1bg000w2sivst6jqaes","content":"<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><pre><code>Android Application与其他移动平台有两个重大不同点：\n\n1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\nAndroid进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n</code></pre><h4 id=\"进程启动策略\"><a href=\"#进程启动策略\" class=\"headerlink\" title=\"进程启动策略\"></a>进程启动策略</h4><pre><code>简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n</code></pre><h4 id=\"Android系统的启动\"><a href=\"#Android系统的启动\" class=\"headerlink\" title=\"Android系统的启动\"></a>Android系统的启动</h4><pre><code>与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为&quot;daemons&quot;的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n</code></pre><h4 id=\"App的启动\"><a href=\"#App的启动\" class=\"headerlink\" title=\"App的启动\"></a>App的启动</h4><p><img src=\"/images/Application_launch.jpg\" alt=\"app launch\"></p>\n<p>&gt;<br>click事件会调用<code>startActivity(Intent)</code>，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：<br>&gt;</p>\n<ul>\n<li>第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息</li>\n<li>指向信息被存储在一个intent对象中</li>\n<li>下面重要的一步是通过<code>grantUriPermissionLocked()</code>方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity</li>\n<li>如果有权限，ActivityManagerService会检查并在新的task中启动目标activity</li>\n<li>现在，是时候检查这个进程的ProcessRecord是否存在了</li>\n<li>如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。</li>\n</ul>\n<h5 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h5><blockquote>\n<p>ActivityManagerService调用<code>startProcessLocked()</code>方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用<code>ZygoteInit.main()</code>方法来实例化ActivityThread对象并最终返回新进程的pid.<br>ActivityThread随后依次调用<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>来开启消息循环。</p>\n</blockquote>\n<p>流程图如下：<br><img src=\"/images/process_creation.jpg\" alt=\"process creation\"></p>\n<h5 id=\"绑定Application\"><a href=\"#绑定Application\" class=\"headerlink\" title=\"绑定Application\"></a>绑定Application</h5><blockquote>\n<p>接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用<code>bindApplication()</code>方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过<code>handleBindApplication()</code>处理该消息。然后调用<code>makeApplication()</code>方法来加载App的classes到内存中。<br> 流程如下：</p>\n</blockquote>\n<p><img src=\"/images/bind_application.jpg\" alt=\"bind application\"></p>\n<h5 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h5><blockquote>\n<p>经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。<br>实际调用方法是<code>realStartActivity()</code>，它会调用application线程对象中的<code>sheduleLaunchActivity()</code>发送一个LAUNCH_ACTIVITY消息到消息队列中，通过<code>handleLaunchActivity()</code>来处理该消息。</p>\n</blockquote>\n<p> 假设点击的是一个视频浏览的App，其流程如下：</p>\n<p><img src=\"/images/start_activity.jpg\" alt=\"start activity\"></p>\n<h5 id=\"Activity显示\"><a href=\"#Activity显示\" class=\"headerlink\" title=\"Activity显示\"></a>Activity显示</h5><blockquote>\n<p>Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。</p>\n</blockquote>\n<p>如图：<br><img src=\"/images/display_activity.png\" alt=\"display activity\"></p>\n<h4 id=\"测量App的启动时间\"><a href=\"#测量App的启动时间\" class=\"headerlink\" title=\"测量App的启动时间\"></a>测量App的启动时间</h4><pre><code>activity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n</code></pre><h5 id=\"Display-Time\"><a href=\"#Display-Time\" class=\"headerlink\" title=\"Display Time\"></a>Display Time</h5><pre><code>api19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n</code></pre><p>图为抓取微信开启时间：<br><img src=\"/images/display_time.png\" alt=\"wechat display time\"></p>\n<h5 id=\"ADB命令查看启动时间\"><a href=\"#ADB命令查看启动时间\" class=\"headerlink\" title=\"ADB命令查看启动时间\"></a>ADB命令查看启动时间</h5><p><code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></p>\n<p><img src=\"/images/adb_launch_time.png\" alt=\"adb see launch time\"><br>&gt;</p>\n<ul>\n<li>ThisTime：最后一个启动的Activity的启动耗时；</li>\n<li>TotalTime:到达当前页面的所有Activity的启动耗时；</li>\n<li>WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。</li>\n</ul>\n<p><code>adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4</code></p>\n<p>&gt;<br>这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，<code>bugreport</code>参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。</p>\n<h5 id=\"代码中自定义上报启动时间\"><a href=\"#代码中自定义上报启动时间\" class=\"headerlink\" title=\"代码中自定义上报启动时间\"></a>代码中自定义上报启动时间</h5><p>由于我们在一个App启动的开始，会做一些预操作，比如：</p>\n<ul>\n<li>加载第三方黑盒SDK</li>\n<li>网络、图片等框架的构造</li>\n<li>业务数据预请求</li>\n</ul>\n<p>所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API&gt;=19的版本，在这些预操作做完之后手动调用<code>reportFullyDrawn</code>。这样Log中会增加一条日志：</p>\n<p><img src=\"/images/report_full_drawn.png\" alt=\"reportFullyDrawn time\"></p>\n<h4 id=\"优化点\"><a href=\"#优化点\" class=\"headerlink\" title=\"优化点\"></a>优化点</h4><h5 id=\"背景Theme\"><a href=\"#背景Theme\" class=\"headerlink\" title=\"背景Theme\"></a>背景Theme</h5><pre><code>当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n</code></pre><blockquote>\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            android:opacity=&quot;opaque&quot;&gt;\n&lt;!-- android:opacity=&quot;opaque&quot;防止在启动的时候出现背景的闪烁 --&gt;\n    &lt;item android:drawable=&quot;@android:color/darker_gray&quot;/&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:gravity=&quot;center&quot;\n            android:src=&quot;@mipmap/ic_launcher&quot;/&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre></blockquote>\n<p>&gt;<br>    <style name=\"StartStyle\" parent=\"AppTheme\"><br>        <item name=\"android:windowBackground\">@drawable/start_window</item><br>    </style></p>\n<h5 id=\"异步初始化\"><a href=\"#异步初始化\" class=\"headerlink\" title=\"异步初始化\"></a>异步初始化</h5><pre><code>根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n</code></pre><h5 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h5><blockquote>\n<ul>\n<li>布局宽而浅，不要窄而深</li>\n<li>使用.9</li>\n<li>tinyPNG</li>\n<li>混淆</li>\n</ul>\n</blockquote>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://developer.android.com/topic/performance/launch-time.html\" target=\"_blank\" rel=\"external\">Launch-Time Performance </a></p>\n<p><a href=\"http://www.jianshu.com/p/a5532ecc8377\" target=\"_blank\" rel=\"external\">Android Application启动流程分析</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007406875#articleHeader9\" target=\"_blank\" rel=\"external\">一触即发 App启动优化最佳实践</a></p>\n<p>在线检测App：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">nimbledroid</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><pre><code>Android Application与其他移动平台有两个重大不同点：\n\n1.每个Android App都在一个独立空间里，意味着其运行在一个单独的进程中，拥有自己的VM，被系统分配一个唯一的user ID.\n\n2.Android App由很多不同组件(四大组件)组成，这些组件还可以启动其他App的组件，因此，Android App并没有一个类似程序入口的main()方法。\n\n\n\nAndroid进程与Linux进程一样。默认情况下，每个apk运行在自己的Linux进程中。另外，默认一个进程里面只有一个线程-主线程。这个主线程中有一个Looper实例，通过调用Looper.loop()从Message队列里面取出Message来做相应的处理。\n</code></pre><h4 id=\"进程启动策略\"><a href=\"#进程启动策略\" class=\"headerlink\" title=\"进程启动策略\"></a>进程启动策略</h4><pre><code>简单的说，进程在其需要时被启动。任意时候，当用户或其他组件调取你apk中的任意组件时，如果你的apk没有运行，系统会为其创建一个新的进程并启动。通常，这个进程会持续运行直到被系统杀死。关键是：进程是在被需要的时候才创建。\n</code></pre><h4 id=\"Android系统的启动\"><a href=\"#Android系统的启动\" class=\"headerlink\" title=\"Android系统的启动\"></a>Android系统的启动</h4><pre><code>与众多基于Linux内核的系统类似，Android系统启动时，bootloader启动内核和init进程，init进程分裂出更多名为&quot;daemons&quot;的底层的Linux进程(守护进程)。诸如android debug daemon,USB daemon等。这些守护进程处理底层硬件相关的接口。\n\n随后，init进程会启动一个非常有意思的进程：“Zygote”。这是一个Android平台的非常基础的进程。这个进程初始化了第一个VM，并且预加载了framework和众多App所需要的通用资源。然后它开启一个Socket接口来监听请求，一旦收到新的请求，Zygote会根据请求，基于自身预加载的VM来孵化出一个新的VM创建一个新的进程。\n\n启动Zygote之后，init进程会启动runtime进程。Zygote会孵化出一个超级管理进程：System Server。 SystemServer会启动所有系统核心服务，例如Activity Manger Service,硬件相关的Service等。到此，系统准备好启动它的第一个App进程：Home进程了。\n</code></pre><h4 id=\"App的启动\"><a href=\"#App的启动\" class=\"headerlink\" title=\"App的启动\"></a>App的启动</h4><p><img src=\"/images/Application_launch.jpg\" alt=\"app launch\"></p>\n<p>&gt;<br>click事件会调用<code>startActivity(Intent)</code>，会通过Binder IPC机制，最终调用到ActivityManagerService.该Service会执行如下操作：<br>&gt;</p>\n<ul>\n<li>第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息</li>\n<li>指向信息被存储在一个intent对象中</li>\n<li>下面重要的一步是通过<code>grantUriPermissionLocked()</code>方法来验证用户是否有足够的权限去调用该Intent对象指向的Activity</li>\n<li>如果有权限，ActivityManagerService会检查并在新的task中启动目标activity</li>\n<li>现在，是时候检查这个进程的ProcessRecord是否存在了</li>\n<li>如果PrecessRecord为null，ActivityManagerService会创建新的进程来实例化目标activity。</li>\n</ul>\n<h5 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h5><blockquote>\n<p>ActivityManagerService调用<code>startProcessLocked()</code>方法来创建新的进程，该方法通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身，并调用<code>ZygoteInit.main()</code>方法来实例化ActivityThread对象并最终返回新进程的pid.<br>ActivityThread随后依次调用<code>Looper.prepareLoop()</code>和<code>Looper.loop()</code>来开启消息循环。</p>\n</blockquote>\n<p>流程图如下：<br><img src=\"/images/process_creation.jpg\" alt=\"process creation\"></p>\n<h5 id=\"绑定Application\"><a href=\"#绑定Application\" class=\"headerlink\" title=\"绑定Application\"></a>绑定Application</h5><blockquote>\n<p>接下来要做的就是将进程和指定的Application绑定起来。这个是通过上一节的ActivityThread对象中调用<code>bindApplication()</code>方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中，最终通过<code>handleBindApplication()</code>处理该消息。然后调用<code>makeApplication()</code>方法来加载App的classes到内存中。<br> 流程如下：</p>\n</blockquote>\n<p><img src=\"/images/bind_application.jpg\" alt=\"bind application\"></p>\n<h5 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity\"></a>启动Activity</h5><blockquote>\n<p>经过前两个步骤之后，系统已经拥有了该application的进程。后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。<br>实际调用方法是<code>realStartActivity()</code>，它会调用application线程对象中的<code>sheduleLaunchActivity()</code>发送一个LAUNCH_ACTIVITY消息到消息队列中，通过<code>handleLaunchActivity()</code>来处理该消息。</p>\n</blockquote>\n<p> 假设点击的是一个视频浏览的App，其流程如下：</p>\n<p><img src=\"/images/start_activity.jpg\" alt=\"start activity\"></p>\n<h5 id=\"Activity显示\"><a href=\"#Activity显示\" class=\"headerlink\" title=\"Activity显示\"></a>Activity显示</h5><blockquote>\n<p>Activity被创建出来后，会依次加载主题样式Theme中的windowBackground等属性，以及配置Activity层级上的一些属性，再inflate布局，当onCreate、onStart、onResume方法都走完，最后才进行setContentView的measure、layout、draw显示在界面上，此时可以看到App的第一帧画面了。</p>\n</blockquote>\n<p>如图：<br><img src=\"/images/display_activity.png\" alt=\"display activity\"></p>\n<h4 id=\"测量App的启动时间\"><a href=\"#测量App的启动时间\" class=\"headerlink\" title=\"测量App的启动时间\"></a>测量App的启动时间</h4><pre><code>activity的启动时执行的方法：onCreat()、onStart()、onResume()的生命周期结束了，应用也不算是完全启动，还需要等View树全部构建完毕，一般认为，setContentView中的View全部显示结束了，算作是应用完全启动了。\n</code></pre><h5 id=\"Display-Time\"><a href=\"#Display-Time\" class=\"headerlink\" title=\"Display Time\"></a>Display Time</h5><pre><code>api19之后，Android系统Log中增加了ActivityManager:Displayed [packageName/activityName]: time。所以，在Android Monitor中使用 ActivityManager:Displayed filter，查看启动首页的时间，这个时间是Activity启动到Layout全部显示的时间。\n</code></pre><p>图为抓取微信开启时间：<br><img src=\"/images/display_time.png\" alt=\"wechat display time\"></p>\n<h5 id=\"ADB命令查看启动时间\"><a href=\"#ADB命令查看启动时间\" class=\"headerlink\" title=\"ADB命令查看启动时间\"></a>ADB命令查看启动时间</h5><p><code>adb shell am start -W [packageName]/[packageName.MainActivity]</code></p>\n<p><img src=\"/images/adb_launch_time.png\" alt=\"adb see launch time\"><br>&gt;</p>\n<ul>\n<li>ThisTime：最后一个启动的Activity的启动耗时；</li>\n<li>TotalTime:到达当前页面的所有Activity的启动耗时；</li>\n<li>WaitTime：ActivityManagerService启动App的Activity时的总时间，包括当前Activity的onPause()和目的Activity的启动。</li>\n</ul>\n<p><code>adb shell screenrecord --bugreport /sdcard/ScreenRecord.mp4</code></p>\n<p>&gt;<br>这是一个录屏命令，和Android Monitor的Screen Recorder Options的功能一样，<code>bugreport</code>参数决定了视屏左上角会增加录制视频的时间和当前画面所在的帧数。个人感觉这玩意儿比较鸡肋。</p>\n<h5 id=\"代码中自定义上报启动时间\"><a href=\"#代码中自定义上报启动时间\" class=\"headerlink\" title=\"代码中自定义上报启动时间\"></a>代码中自定义上报启动时间</h5><p>由于我们在一个App启动的开始，会做一些预操作，比如：</p>\n<ul>\n<li>加载第三方黑盒SDK</li>\n<li>网络、图片等框架的构造</li>\n<li>业务数据预请求</li>\n</ul>\n<p>所以ActivityManager:Displayed并不能精确我们App完全的启动时间。我们可以在API&gt;=19的版本，在这些预操作做完之后手动调用<code>reportFullyDrawn</code>。这样Log中会增加一条日志：</p>\n<p><img src=\"/images/report_full_drawn.png\" alt=\"reportFullyDrawn time\"></p>\n<h4 id=\"优化点\"><a href=\"#优化点\" class=\"headerlink\" title=\"优化点\"></a>优化点</h4><h5 id=\"背景Theme\"><a href=\"#背景Theme\" class=\"headerlink\" title=\"背景Theme\"></a>背景Theme</h5><pre><code>当系统加载一个Activity的时候，onCreate()是一个耗时过程，为增加用户体验，系统会优先绘制一些初始界面：根据当前Activity的Theme来绘制，当Activity加载完毕后，才会替换为真正的界面。代码如下：\n</code></pre><blockquote>\n<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            android:opacity=&quot;opaque&quot;&gt;\n&lt;!-- android:opacity=&quot;opaque&quot;防止在启动的时候出现背景的闪烁 --&gt;\n    &lt;item android:drawable=&quot;@android:color/darker_gray&quot;/&gt;\n    &lt;item&gt;\n        &lt;bitmap\n            android:gravity=&quot;center&quot;\n            android:src=&quot;@mipmap/ic_launcher&quot;/&gt;\n    &lt;/item&gt;\n&lt;/layer-list&gt;\n</code></pre></blockquote>\n<p>&gt;<br>    <style name=\"StartStyle\" parent=\"AppTheme\"><br>        <item name=\"android:windowBackground\">@drawable/start_window</item><br>    </style></p>\n<h5 id=\"异步初始化\"><a href=\"#异步初始化\" class=\"headerlink\" title=\"异步初始化\"></a>异步初始化</h5><pre><code>根据业务，利用多线程，IntentService等来异步和延迟初始化的操作 \n</code></pre><h5 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h5><blockquote>\n<ul>\n<li>布局宽而浅，不要窄而深</li>\n<li>使用.9</li>\n<li>tinyPNG</li>\n<li>混淆</li>\n</ul>\n</blockquote>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://developer.android.com/topic/performance/launch-time.html\" target=\"_blank\" rel=\"external\">Launch-Time Performance </a></p>\n<p><a href=\"http://www.jianshu.com/p/a5532ecc8377\" target=\"_blank\" rel=\"external\">Android Application启动流程分析</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007406875#articleHeader9\" target=\"_blank\" rel=\"external\">一触即发 App启动优化最佳实践</a></p>\n<p>在线检测App：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">nimbledroid</a> </p>\n"},{"layout":"post","title":"生成窗口最大值数组","date":"2017-02-16T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 生成窗口最大值数组 #####\n\n有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。\n例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：\n\n>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br/>\n>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br/>\n>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br/>\n>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br/>\n>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br/>\n>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br/>\n \n\n>请实现一个函数：\n>\n- 输入：整型数组arr，窗口大小为w\n- 输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。\n\n以上例，结果应为：{5,5,5,4,6,7}.\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一:O(N * w)#####\n\n\t public class Demo {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static int[] getMaxWindow(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tfor (int i = 0; i < arr.length - w + 1; i++) {\n\t\t\t\tint x = arr[i];\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (arr[i + j] >= x)\n\t\t\t\t\t\tx = arr[i + j];\n\t\t\t\t}\n\t\t\t\tresult[i] = x;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n##### 方法二:O(N)#####\n\n>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。\n>放入规则：\n1. 如果qmax为空，直接把下标i放入；\n2. 如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；\n\n>弹出规则：\n如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。\n\n>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).\n\n>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则`java.lang.ArrayIndexOutOfBoundsException`.\n\n\tpublic static int[] getMaxWindow2(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tLinkedList<Integer> qmax = new LinkedList<>();\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\n\t\t\t\twhile (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {\n\t\t\t\t\tqmax.pollLast();\n\t\t\t\t}\n\t\t\t\tqmax.addLast(i);\n\t\t\t\tif (qmax.peekFirst() == i - w) {\n\t\t\t\t\tqmax.pollFirst();\n\t\t\t\t}\n\t\t\t\tif (i >= w - 1)\n\t\t\t\t\tresult[index++] = arr[qmax.peekFirst()];\n\t\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n###### 双端队列的实现类 ######\n\n\n\tpublic class LinkedList<E> extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n\n \n\n\tpublic class ArrayDeque<E> extends AbstractCollection<E>\n\t                           implements Deque<E>, Cloneable, Serializable\n\n  \n\n\n[java集合类深入分析之Queue篇](http://shmilyaw-hotmail-com.iteye.com/blog/1700599)\n\n\n","source":"_posts/2017-02-16-get-max-window.md","raw":"---\nlayout: post\ntitle:  生成窗口最大值数组\ndate:   2017-02-16\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 生成窗口最大值数组 #####\n\n有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。\n例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：\n\n>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br/>\n>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br/>\n>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br/>\n>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br/>\n>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br/>\n>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br/>\n \n\n>请实现一个函数：\n>\n- 输入：整型数组arr，窗口大小为w\n- 输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。\n\n以上例，结果应为：{5,5,5,4,6,7}.\n\n#### 难度 ####\n\n\t尉 ★★☆☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一:O(N * w)#####\n\n\t public class Demo {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tSystem.out.println(arr[i]);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static int[] getMaxWindow(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tfor (int i = 0; i < arr.length - w + 1; i++) {\n\t\t\t\tint x = arr[i];\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (arr[i + j] >= x)\n\t\t\t\t\t\tx = arr[i + j];\n\t\t\t\t}\n\t\t\t\tresult[i] = x;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\n##### 方法二:O(N)#####\n\n>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。\n>放入规则：\n1. 如果qmax为空，直接把下标i放入；\n2. 如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；\n\n>弹出规则：\n如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。\n\n>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).\n\n>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则`java.lang.ArrayIndexOutOfBoundsException`.\n\n\tpublic static int[] getMaxWindow2(int[] arr, int w) {\n\t\t\tint[] result = new int[arr.length - w + 1];\n\t\t\tLinkedList<Integer> qmax = new LinkedList<>();\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\n\t\t\t\twhile (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[i]) {\n\t\t\t\t\tqmax.pollLast();\n\t\t\t\t}\n\t\t\t\tqmax.addLast(i);\n\t\t\t\tif (qmax.peekFirst() == i - w) {\n\t\t\t\t\tqmax.pollFirst();\n\t\t\t\t}\n\t\t\t\tif (i >= w - 1)\n\t\t\t\t\tresult[index++] = arr[qmax.peekFirst()];\n\t\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n###### 双端队列的实现类 ######\n\n\n\tpublic class LinkedList<E> extends AbstractSequentialList<E>\n\t    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n\n \n\n\tpublic class ArrayDeque<E> extends AbstractCollection<E>\n\t                           implements Deque<E>, Cloneable, Serializable\n\n  \n\n\n[java集合类深入分析之Queue篇](http://shmilyaw-hotmail-com.iteye.com/blog/1700599)\n\n\n","slug":"get-max-window","published":1,"updated":"2017-08-17T02:40:42.550Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1bk000z2siv0y2vtc9f","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"生成窗口最大值数组\"><a href=\"#生成窗口最大值数组\" class=\"headerlink\" title=\"生成窗口最大值数组\"></a>生成窗口最大值数组</h5><p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。<br>例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：</p>\n<blockquote>\n<p>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br><br>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br><br>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br><br>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br><br>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br><br>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br></p>\n<p>请实现一个函数：</p>\n<ul>\n<li>输入：整型数组arr，窗口大小为w</li>\n<li>输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。</li>\n</ul>\n</blockquote>\n<p>以上例，结果应为：{5,5,5,4,6,7}.</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一-O-N-w\"><a href=\"#方法一-O-N-w\" class=\"headerlink\" title=\"方法一:O(N * w)\"></a>方法一:O(N * w)</h5><pre><code> public class Demo {\n\n    public static void main(String[] args) {\n        int[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n\n    public static int[] getMaxWindow(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        for (int i = 0; i &lt; arr.length - w + 1; i++) {\n            int x = arr[i];\n            for (int j = 0; j &lt; w; j++) {\n                if (arr[i + j] &gt;= x)\n                    x = arr[i + j];\n            }\n            result[i] = x;\n        }\n        return result;\n    }\n}\n</code></pre><h5 id=\"方法二-O-N\"><a href=\"#方法二-O-N\" class=\"headerlink\" title=\"方法二:O(N)\"></a>方法二:O(N)</h5><blockquote>\n<p>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。<br>放入规则：</p>\n<ol>\n<li>如果qmax为空，直接把下标i放入；</li>\n<li>如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；</li>\n</ol>\n<p>弹出规则：<br>如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。</p>\n<p>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).</p>\n<p>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则<code>java.lang.ArrayIndexOutOfBoundsException</code>.</p>\n</blockquote>\n<pre><code>public static int[] getMaxWindow2(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();\n        int index = 0;\n        for (int i = 0; i &lt; arr.length; i++) {\n\n            while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) {\n                qmax.pollLast();\n            }\n            qmax.addLast(i);\n            if (qmax.peekFirst() == i - w) {\n                qmax.pollFirst();\n            }\n            if (i &gt;= w - 1)\n                result[index++] = arr[qmax.peekFirst()];\n\n        }\n        return result;\n    }\n</code></pre><h6 id=\"双端队列的实现类\"><a href=\"#双端队列的实现类\" class=\"headerlink\" title=\"双端队列的实现类\"></a>双端队列的实现类</h6><pre><code>public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable\n\n\n\npublic class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;\n                           implements Deque&lt;E&gt;, Cloneable, Serializable\n</code></pre><p><a href=\"http://shmilyaw-hotmail-com.iteye.com/blog/1700599\" target=\"_blank\" rel=\"external\">java集合类深入分析之Queue篇</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"生成窗口最大值数组\"><a href=\"#生成窗口最大值数组\" class=\"headerlink\" title=\"生成窗口最大值数组\"></a>生成窗口最大值数组</h5><p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑倒最右边，窗口每次向右边滑一个位置。<br>例如，数组[4,3,5,4,3,3,6,7]，窗口大小为3时：</p>\n<blockquote>\n<p>[4 3 5] 4 3 3 6 7 窗口中最大值为5 <br><br>4 [3 5 4] 3 3 6 7 窗口中最大值为5 <br><br>4 3 [5 4 3] 3 6 7 窗口中最大值为5 <br><br>4 3 5 [4 3 3] 6 7 窗口中最大值为4 <br><br>4 3 5 4 [3 3 6] 7 窗口中最大值为6 <br><br>4 3 5 4 3 [3 6 7] 窗口中最大值为7 <br></p>\n<p>请实现一个函数：</p>\n<ul>\n<li>输入：整型数组arr，窗口大小为w</li>\n<li>输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。</li>\n</ul>\n</blockquote>\n<p>以上例，结果应为：{5,5,5,4,6,7}.</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>尉 ★★☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一-O-N-w\"><a href=\"#方法一-O-N-w\" class=\"headerlink\" title=\"方法一:O(N * w)\"></a>方法一:O(N * w)</h5><pre><code> public class Demo {\n\n    public static void main(String[] args) {\n        int[] arr = getMaxWindow(new int[] { 4, 3, 5, 4, 3, 3, 6, 7 }, 3);\n        for (int i = 0; i &lt; arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n\n    public static int[] getMaxWindow(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        for (int i = 0; i &lt; arr.length - w + 1; i++) {\n            int x = arr[i];\n            for (int j = 0; j &lt; w; j++) {\n                if (arr[i + j] &gt;= x)\n                    x = arr[i + j];\n            }\n            result[i] = x;\n        }\n        return result;\n    }\n}\n</code></pre><h5 id=\"方法二-O-N\"><a href=\"#方法二-O-N\" class=\"headerlink\" title=\"方法二:O(N)\"></a>方法二:O(N)</h5><blockquote>\n<p>本题的关键在于利用双端队列来实现窗口最大值的更新。生成双端队列qmax存放数组arr中的下标。<br>放入规则：</p>\n<ol>\n<li>如果qmax为空，直接把下标i放入；</li>\n<li>如果qmax不为空，比较arr[i]和qmax队尾下标对应的数组元素，如果arr[i]比较大，则持续弹出qmax中的元素，直至arr[i]小于qmax下标对应的元素或者qmax符合第一条；</li>\n</ol>\n<p>弹出规则：<br>如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出队头。</p>\n<p>上述过程，每个下标最多进入qmax一次，出qmax一次，所以遍历的过程中进出双端队列的操作时间复杂度是O(n).</p>\n<p>注意，我们的目的数组的大小为：n-w+1，在arr的循环过程中，录入数据进入目的数组时，注意过滤其边界，否则<code>java.lang.ArrayIndexOutOfBoundsException</code>.</p>\n</blockquote>\n<pre><code>public static int[] getMaxWindow2(int[] arr, int w) {\n        int[] result = new int[arr.length - w + 1];\n        LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();\n        int index = 0;\n        for (int i = 0; i &lt; arr.length; i++) {\n\n            while (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i]) {\n                qmax.pollLast();\n            }\n            qmax.addLast(i);\n            if (qmax.peekFirst() == i - w) {\n                qmax.pollFirst();\n            }\n            if (i &gt;= w - 1)\n                result[index++] = arr[qmax.peekFirst()];\n\n        }\n        return result;\n    }\n</code></pre><h6 id=\"双端队列的实现类\"><a href=\"#双端队列的实现类\" class=\"headerlink\" title=\"双端队列的实现类\"></a>双端队列的实现类</h6><pre><code>public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable\n\n\n\npublic class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;\n                           implements Deque&lt;E&gt;, Cloneable, Serializable\n</code></pre><p><a href=\"http://shmilyaw-hotmail-com.iteye.com/blog/1700599\" target=\"_blank\" rel=\"external\">java集合类深入分析之Queue篇</a></p>\n"},{"layout":"post","title":"用栈来求解汉诺塔的问题","date":"2017-02-16T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 用栈来求解汉诺塔问题 #####\n\n\n\t汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n\t例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n\tMove 2 from left to mid\n\tMove 1 from right to mid\n\tMove 1 from mid to left\n\tMove 2 from mid to right\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n \n\n用以下两种方法解决\n\n- 方法一：递归的方法\n- 方法二：非递归的方法，用栈来模拟汉诺塔的三个塔\n\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一 #####\n\n\t/**\n\t * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n\t * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n\t * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n\t * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n\t * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n\t * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n\t * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n\t * \n\t */\n\tpublic class HanoiProblem {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(process(7, \"left\", \"mid\", \"right\", \"left\", \"right\"));\n\t\t}\n\t\n\t\tpublic static int hanoiProblem1(int num, String left, String mid, String right) {\n\t\t\tif (num < 1)\n\t\t\t\treturn 0;\n\t\n\t\t\treturn process(num, left, mid, right, left, right);\n\t\n\t\t}\n\t\n\t\tpublic static int process(int num, String left, String mid, String right, String from, String to) {\n\t\t\tif (num == 1) {\n\t\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + mid);\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + mid + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\tString another = (from.equals(left) || to.equals(left)) ? right : left;\n\t\t\t\tint part1 = process(num, left, mid, right, from, another);\n\t\t\t\tint part2 = 1;// what's this?\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + to);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, another, to);\n\t\t\t\treturn part1 + part2 + part3;\n\t\t\t} else {\n\t\t\t\tint part1 = process(num - 1, left, mid, right, from, to);\n\t\t\t\tint part2 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + mid);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, to, from);\n\t\t\t\tint part4 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + mid + \" to \" + to);\n\t\t\t\tint part5 = process(num - 1, left, mid, right, from, to);\n\t\t\t\treturn part1 + part2 + part3 + part4 + part5;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n##### 方法二 #####\n\t\n\timport java.util.Stack;\n\t\n\t/**\n\t * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n\t * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n\t * \n\t * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n\t * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n\t * \n\t * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n\t * 第二原则：相邻不可逆原则；比如L->M发生了，那么下一步一定不可为：M->L这样的操作，没意义。\n\t * \n\t * 非递归方法结论： <br/>\n\t * 1.第一个动作一定是L->M；<br/>\n\t * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class HanoiProblem2 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(hanoi(4, \"L\", \"M\", \"R\"));\n\t\t}\n\t\tpublic static int hanoi(int num, String left, String mid, String right) {\n\t\t\tStack<Integer> lS = new Stack<>();\n\t\t\tStack<Integer> mS = new Stack<>();\n\t\t\tStack<Integer> rS = new Stack<>();\n\t\t\tlS.push(Integer.MAX_VALUE);\n\t\t\tmS.push(Integer.MAX_VALUE);\n\t\t\trS.push(Integer.MAX_VALUE);\n\t\t\tfor (int i = num; i > 0; i--) {\n\t\t\t\tlS.push(i);\n\t\t\t}\n\t\n\t\t\tAction[] record = { Action.No };\n\t\t\tint step = 0;\n\t\t\twhile (rS.size() != num + 1) {\n\t\t\t\tstep += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n\t\t\t\tstep += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n\t\t\t\tstep += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n\t\t\t\tstep += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n\t\t\t}\n\t\t\treturn step;\n\t\t}\n\t\n\t\tpublic static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack<Integer> fStack,\n\t\t\t\tStack<Integer> tStack, String from, String to) {\n\t\t\tif (record[0] != preNoAct && fStack.peek() < tStack.peek()) {\n\t\t\t\ttStack.push(fStack.pop());\n\t\t\t\tSystem.out.println(\"Move \" + tStack.peek() + \" from \" + from + \" to \" + to);\n\t\t\t\trecord[0] = nowAct;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\t\n\tenum Action {\n\t\tNo, LToM, MToL, MToR, RToM\n\t\n\t} \n\n\n\n\n\n\n\n","source":"_posts/2017-02-16-hanoi-problom.md","raw":"---\nlayout: post\ntitle:  用栈来求解汉诺塔的问题\ndate:   2017-02-16\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 用栈来求解汉诺塔问题 #####\n\n\n\t汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n\t例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n\tMove 2 from left to mid\n\tMove 1 from right to mid\n\tMove 1 from mid to left\n\tMove 2 from mid to right\n\tMove 1 from left to mid\n\tMove 1 from mid to right\n \n\n用以下两种方法解决\n\n- 方法一：递归的方法\n- 方法二：非递归的方法，用栈来模拟汉诺塔的三个塔\n\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n\n#### 解答 ####\n \n\t \n\n\n##### 方法一 #####\n\n\t/**\n\t * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n\t * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n\t * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n\t * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n\t * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n\t * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n\t * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n\t * \n\t */\n\tpublic class HanoiProblem {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(process(7, \"left\", \"mid\", \"right\", \"left\", \"right\"));\n\t\t}\n\t\n\t\tpublic static int hanoiProblem1(int num, String left, String mid, String right) {\n\t\t\tif (num < 1)\n\t\t\t\treturn 0;\n\t\n\t\t\treturn process(num, left, mid, right, left, right);\n\t\n\t\t}\n\t\n\t\tpublic static int process(int num, String left, String mid, String right, String from, String to) {\n\t\t\tif (num == 1) {\n\t\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + from + \" to \" + mid);\n\t\t\t\t\tSystem.out.println(\"Move 1 from \" + mid + \" to \" + to);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (from.equals(mid) || to.equals(mid)) {\n\t\t\t\tString another = (from.equals(left) || to.equals(left)) ? right : left;\n\t\t\t\tint part1 = process(num, left, mid, right, from, another);\n\t\t\t\tint part2 = 1;// what's this?\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + to);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, another, to);\n\t\t\t\treturn part1 + part2 + part3;\n\t\t\t} else {\n\t\t\t\tint part1 = process(num - 1, left, mid, right, from, to);\n\t\t\t\tint part2 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + from + \" to \" + mid);\n\t\t\t\tint part3 = process(num - 1, left, mid, right, to, from);\n\t\t\t\tint part4 = 1;\n\t\t\t\tSystem.out.println(\"Move \" + num + \" from \" + mid + \" to \" + to);\n\t\t\t\tint part5 = process(num - 1, left, mid, right, from, to);\n\t\t\t\treturn part1 + part2 + part3 + part4 + part5;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n##### 方法二 #####\n\t\n\timport java.util.Stack;\n\t\n\t/**\n\t * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n\t * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n\t * \n\t * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n\t * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n\t * \n\t * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n\t * 第二原则：相邻不可逆原则；比如L->M发生了，那么下一步一定不可为：M->L这样的操作，没意义。\n\t * \n\t * 非递归方法结论： <br/>\n\t * 1.第一个动作一定是L->M；<br/>\n\t * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class HanoiProblem2 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tSystem.out.println(hanoi(4, \"L\", \"M\", \"R\"));\n\t\t}\n\t\tpublic static int hanoi(int num, String left, String mid, String right) {\n\t\t\tStack<Integer> lS = new Stack<>();\n\t\t\tStack<Integer> mS = new Stack<>();\n\t\t\tStack<Integer> rS = new Stack<>();\n\t\t\tlS.push(Integer.MAX_VALUE);\n\t\t\tmS.push(Integer.MAX_VALUE);\n\t\t\trS.push(Integer.MAX_VALUE);\n\t\t\tfor (int i = num; i > 0; i--) {\n\t\t\t\tlS.push(i);\n\t\t\t}\n\t\n\t\t\tAction[] record = { Action.No };\n\t\t\tint step = 0;\n\t\t\twhile (rS.size() != num + 1) {\n\t\t\t\tstep += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n\t\t\t\tstep += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n\t\t\t\tstep += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n\t\t\t\tstep += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n\t\t\t}\n\t\t\treturn step;\n\t\t}\n\t\n\t\tpublic static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack<Integer> fStack,\n\t\t\t\tStack<Integer> tStack, String from, String to) {\n\t\t\tif (record[0] != preNoAct && fStack.peek() < tStack.peek()) {\n\t\t\t\ttStack.push(fStack.pop());\n\t\t\t\tSystem.out.println(\"Move \" + tStack.peek() + \" from \" + from + \" to \" + to);\n\t\t\t\trecord[0] = nowAct;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\t\n\tenum Action {\n\t\tNo, LToM, MToL, MToR, RToM\n\t\n\t} \n\n\n\n\n\n\n\n","slug":"hanoi-problom","published":1,"updated":"2017-08-17T02:41:07.537Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1bp00142sivp1gayl7y","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"用栈来求解汉诺塔问题\"><a href=\"#用栈来求解汉诺塔问题\" class=\"headerlink\" title=\"用栈来求解汉诺塔问题\"></a>用栈来求解汉诺塔问题</h5><pre><code>汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\nMove 1 from left to mid\nMove 1 from mid to right\nMove 2 from left to mid\nMove 1 from right to mid\nMove 1 from mid to left\nMove 2 from mid to right\nMove 1 from left to mid\nMove 1 from mid to right\n</code></pre><p>用以下两种方法解决</p>\n<ul>\n<li>方法一：递归的方法</li>\n<li>方法二：非递归的方法，用栈来模拟汉诺塔的三个塔</li>\n</ul>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>/**\n * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n * \n */\npublic class HanoiProblem {\n\n    public static void main(String[] args) {\n        System.out.println(process(7, &quot;left&quot;, &quot;mid&quot;, &quot;right&quot;, &quot;left&quot;, &quot;right&quot;));\n    }\n\n    public static int hanoiProblem1(int num, String left, String mid, String right) {\n        if (num &lt; 1)\n            return 0;\n\n        return process(num, left, mid, right, left, right);\n\n    }\n\n    public static int process(int num, String left, String mid, String right, String from, String to) {\n        if (num == 1) {\n            if (from.equals(mid) || to.equals(mid)) {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to);\n                return 1;\n            } else {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + mid);\n                System.out.println(&quot;Move 1 from &quot; + mid + &quot; to &quot; + to);\n                return 1;\n            }\n        }\n        if (from.equals(mid) || to.equals(mid)) {\n            String another = (from.equals(left) || to.equals(left)) ? right : left;\n            int part1 = process(num, left, mid, right, from, another);\n            int part2 = 1;// what&apos;s this?\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to);\n            int part3 = process(num - 1, left, mid, right, another, to);\n            return part1 + part2 + part3;\n        } else {\n            int part1 = process(num - 1, left, mid, right, from, to);\n            int part2 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + mid);\n            int part3 = process(num - 1, left, mid, right, to, from);\n            int part4 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + mid + &quot; to &quot; + to);\n            int part5 = process(num - 1, left, mid, right, from, to);\n            return part1 + part2 + part3 + part4 + part5;\n        }\n    }\n}\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>import java.util.Stack;\n\n/**\n * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n * \n * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n * \n * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n * 第二原则：相邻不可逆原则；比如L-&gt;M发生了，那么下一步一定不可为：M-&gt;L这样的操作，没意义。\n * \n * 非递归方法结论： &lt;br/&gt;\n * 1.第一个动作一定是L-&gt;M；&lt;br/&gt;\n * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n * \n * @author sxx.xu\n *\n */\npublic class HanoiProblem2 {\n\n    public static void main(String[] args) {\n        System.out.println(hanoi(4, &quot;L&quot;, &quot;M&quot;, &quot;R&quot;));\n    }\n    public static int hanoi(int num, String left, String mid, String right) {\n        Stack&lt;Integer&gt; lS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; mS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; rS = new Stack&lt;&gt;();\n        lS.push(Integer.MAX_VALUE);\n        mS.push(Integer.MAX_VALUE);\n        rS.push(Integer.MAX_VALUE);\n        for (int i = num; i &gt; 0; i--) {\n            lS.push(i);\n        }\n\n        Action[] record = { Action.No };\n        int step = 0;\n        while (rS.size() != num + 1) {\n            step += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n            step += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n            step += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n            step += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n        }\n        return step;\n    }\n\n    public static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack&lt;Integer&gt; fStack,\n            Stack&lt;Integer&gt; tStack, String from, String to) {\n        if (record[0] != preNoAct &amp;&amp; fStack.peek() &lt; tStack.peek()) {\n            tStack.push(fStack.pop());\n            System.out.println(&quot;Move &quot; + tStack.peek() + &quot; from &quot; + from + &quot; to &quot; + to);\n            record[0] = nowAct;\n            return 1;\n        }\n        return 0;\n    }\n\n}\n\nenum Action {\n    No, LToM, MToL, MToR, RToM\n\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"用栈来求解汉诺塔问题\"><a href=\"#用栈来求解汉诺塔问题\" class=\"headerlink\" title=\"用栈来求解汉诺塔问题\"></a>用栈来求解汉诺塔问题</h5><pre><code>汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，而是必须经过中间。求当塔有N层的时候，打印最优移动过程和最优移动总步数。\n\n例如，当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：\n\nMove 1 from left to mid\nMove 1 from mid to right\nMove 2 from left to mid\nMove 1 from right to mid\nMove 1 from mid to left\nMove 2 from mid to right\nMove 1 from left to mid\nMove 1 from mid to right\n</code></pre><p>用以下两种方法解决</p>\n<ul>\n<li>方法一：递归的方法</li>\n<li>方法二：非递归的方法，用栈来模拟汉诺塔的三个塔</li>\n</ul>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><h5 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h5><pre><code>/**\n * 递归的方法： 首先，如果只剩最上层(递归的终止条件)的塔需要移动，则有如下处理： \n * 1.如果希望从“左”移到“中”，打印“Move 1 from left to mid” \n * 2.如果希望从“中”移到“右”，打印“Move 1 from mid to right” \n * 3.如果希望从“右”移到“中”，打印“Move 1 from right to mid” \n * 4.如果希望从“中”移到“左”，打印“Move 1 from mind to left”\n * 5.如果希望从“右”移到“左”，打印“Move 1 from right to mid” 和 “Move 1 from mind to left”\n * 6.如果希望从“左”移到“右”，打印“Move 1 from left to mid” 和 “Move 1 from mid to right”\n * \n */\npublic class HanoiProblem {\n\n    public static void main(String[] args) {\n        System.out.println(process(7, &quot;left&quot;, &quot;mid&quot;, &quot;right&quot;, &quot;left&quot;, &quot;right&quot;));\n    }\n\n    public static int hanoiProblem1(int num, String left, String mid, String right) {\n        if (num &lt; 1)\n            return 0;\n\n        return process(num, left, mid, right, left, right);\n\n    }\n\n    public static int process(int num, String left, String mid, String right, String from, String to) {\n        if (num == 1) {\n            if (from.equals(mid) || to.equals(mid)) {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + to);\n                return 1;\n            } else {\n                System.out.println(&quot;Move 1 from &quot; + from + &quot; to &quot; + mid);\n                System.out.println(&quot;Move 1 from &quot; + mid + &quot; to &quot; + to);\n                return 1;\n            }\n        }\n        if (from.equals(mid) || to.equals(mid)) {\n            String another = (from.equals(left) || to.equals(left)) ? right : left;\n            int part1 = process(num, left, mid, right, from, another);\n            int part2 = 1;// what&apos;s this?\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to);\n            int part3 = process(num - 1, left, mid, right, another, to);\n            return part1 + part2 + part3;\n        } else {\n            int part1 = process(num - 1, left, mid, right, from, to);\n            int part2 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + mid);\n            int part3 = process(num - 1, left, mid, right, to, from);\n            int part4 = 1;\n            System.out.println(&quot;Move &quot; + num + &quot; from &quot; + mid + &quot; to &quot; + to);\n            int part5 = process(num - 1, left, mid, right, from, to);\n            return part1 + part2 + part3 + part4 + part5;\n        }\n    }\n}\n</code></pre><h5 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h5><pre><code>import java.util.Stack;\n\n/**\n * 非递归方法 —— 用栈来模拟整个过程 修改后的汉诺塔问题不能让任何塔从“左”直接移动到“右”，也不能从“右”直接移动到“左”，而是要经过\n * 中间。也就是说，实际动作只有4个：“左”到“中”、“中”到“左”、“中”到“右”、“右”到“中”。\n * \n * 现在我们把左、中、右三个地点抽象成栈，依次记为LS,MS,RS。最初所有的塔都在LS上。\n * 那么如上4个动作就可以看作是：某一个栈(from)把栈顶元素弹出，然后压入另一个栈(to)，做为该栈的栈顶。\n * \n * 第一原则：小压大的原则；每个栈的栈顶-栈底元素，从小到大。\n * 第二原则：相邻不可逆原则；比如L-&gt;M发生了，那么下一步一定不可为：M-&gt;L这样的操作，没意义。\n * \n * 非递归方法结论： &lt;br/&gt;\n * 1.第一个动作一定是L-&gt;M；&lt;br/&gt;\n * 2.在走出最少步数过程中的任何时刻，四个动作中只有一个动作不违反小压大和相邻不可逆原则，另外三个动作一定都会违反。\n * \n * @author sxx.xu\n *\n */\npublic class HanoiProblem2 {\n\n    public static void main(String[] args) {\n        System.out.println(hanoi(4, &quot;L&quot;, &quot;M&quot;, &quot;R&quot;));\n    }\n    public static int hanoi(int num, String left, String mid, String right) {\n        Stack&lt;Integer&gt; lS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; mS = new Stack&lt;&gt;();\n        Stack&lt;Integer&gt; rS = new Stack&lt;&gt;();\n        lS.push(Integer.MAX_VALUE);\n        mS.push(Integer.MAX_VALUE);\n        rS.push(Integer.MAX_VALUE);\n        for (int i = num; i &gt; 0; i--) {\n            lS.push(i);\n        }\n\n        Action[] record = { Action.No };\n        int step = 0;\n        while (rS.size() != num + 1) {\n            step += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);\n            step += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);\n            step += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);\n            step += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);\n        }\n        return step;\n    }\n\n    public static int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack&lt;Integer&gt; fStack,\n            Stack&lt;Integer&gt; tStack, String from, String to) {\n        if (record[0] != preNoAct &amp;&amp; fStack.peek() &lt; tStack.peek()) {\n            tStack.push(fStack.pop());\n            System.out.println(&quot;Move &quot; + tStack.peek() + &quot; from &quot; + from + &quot; to &quot; + to);\n            record[0] = nowAct;\n            return 1;\n        }\n        return 0;\n    }\n\n}\n\nenum Action {\n    No, LToM, MToL, MToR, RToM\n\n} \n</code></pre>"},{"layout":"post","title":"构造数组的MaxTree","date":"2017-02-17T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n##### 构造数组的MaxTree #####\n\n定义二叉树结点如下：\n\n\tpublic class Node {\n\t\tpublic int value;\n\t\tpublic Node left;\n\t\tpublic Node right;\n\t\n\t\tpublic Node(int data) {\n\t\t\tthis.value = data;\n\t\t}\n\t}\n\n一个数组的MaxTree定义如下。\n\n- 数组必须没有重复元素。\n- MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。\n- 包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。\n\n给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n#### 解答 ####\n\n下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。\n\n> arr = {3,4,5,1,2}<br/>\n> 3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br/>\n> 4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br/>\n> 5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br/>\n> 1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br/>\n> 2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br/>\n\n以下列原则来建立这颗树：\n\n - 每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。\n - 如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。\n\n示例代码如下：\n\t\t\n\t\timport java.util.HashMap;\n\t\timport java.util.Stack;\n\t\t\n\t\tpublic class MaxTree {\n\t\t\n\t\t\tpublic Node getMaxTree(int[] arr) {\n\t\t\n\t\t\t\tNode[] nArr = new Node[arr.length];\n\t\t\t\tfor (int i = 0; i != arr.length; i++) {\n\t\t\t\t\tnArr[i] = new Node(arr[i]);\n\t\t\t\t}\n\t\t\n\t\t\t\tStack<Node> stack = new Stack<>();\n\t\t\t\tHashMap<Node, Node> lBigMap = new HashMap<>();\n\t\t\t\tHashMap<Node, Node> rBigMap = new HashMap<>();\n\t\t\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tfor (int i = nArr.length; i != -1; i--) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tNode head = null;\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\tNode left = lBigMap.get(curNode);\n\t\t\t\t\tNode right = rBigMap.get(curNode);\n\t\t\n\t\t\t\t\tif (left == null && right == null) {\n\t\t\t\t\t\thead = curNode;\n\t\t\t\t\t} else if (left == null) {\n\t\t\t\t\t\tif (right.left == null) {\n\t\t\t\t\t\t\tright.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tright.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (right == null) {\n\t\t\t\t\t\tif (left.left == null) {\n\t\t\t\t\t\t\tleft.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNode parent = left.value < right.value ? left : right;\n\t\t\t\t\t\tif (parent.left == null) {\n\t\t\t\t\t\t\tparent.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\n\t\t\t\t}\n\t\t\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\n\t\t\tprivate void popStackSetMap(Stack<Node> stack, HashMap<Node, Node> map) {\n\t\t\t\tNode popNode = stack.pop();\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tmap.put(popNode, null);\n\t\t\t\t} else {\n\t\t\t\t\tmap.put(popNode, stack.peek());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t","source":"_posts/2017-02-17-get-max-tree.md","raw":"---\nlayout: post\ntitle:  构造数组的MaxTree\ndate:   2017-02-17\ncategories: Algorithm\ntag: 算法\n---\n \n\n#### 题目 ####\n\n##### 构造数组的MaxTree #####\n\n定义二叉树结点如下：\n\n\tpublic class Node {\n\t\tpublic int value;\n\t\tpublic Node left;\n\t\tpublic Node right;\n\t\n\t\tpublic Node(int data) {\n\t\t\tthis.value = data;\n\t\t}\n\t}\n\n一个数组的MaxTree定义如下。\n\n- 数组必须没有重复元素。\n- MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。\n- 包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。\n\n给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).\n\n#### 难度 ####\n\n\t校 ★★★☆\n\n#### 解答 ####\n\n下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。\n\n> arr = {3,4,5,1,2}<br/>\n> 3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br/>\n> 4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br/>\n> 5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br/>\n> 1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br/>\n> 2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br/>\n\n以下列原则来建立这颗树：\n\n - 每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。\n - 如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。\n\n示例代码如下：\n\t\t\n\t\timport java.util.HashMap;\n\t\timport java.util.Stack;\n\t\t\n\t\tpublic class MaxTree {\n\t\t\n\t\t\tpublic Node getMaxTree(int[] arr) {\n\t\t\n\t\t\t\tNode[] nArr = new Node[arr.length];\n\t\t\t\tfor (int i = 0; i != arr.length; i++) {\n\t\t\t\t\tnArr[i] = new Node(arr[i]);\n\t\t\t\t}\n\t\t\n\t\t\t\tStack<Node> stack = new Stack<>();\n\t\t\t\tHashMap<Node, Node> lBigMap = new HashMap<>();\n\t\t\t\tHashMap<Node, Node> rBigMap = new HashMap<>();\n\t\t\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, lBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tfor (int i = nArr.length; i != -1; i--) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\twhile ((!stack.isEmpty()) && stack.peek().value < curNode.value) {\n\t\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(curNode);\n\t\t\t\t}\n\t\t\n\t\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\t\tpopStackSetMap(stack, rBigMap);\n\t\t\t\t}\n\t\t\n\t\t\t\tNode head = null;\n\t\t\t\tfor (int i = 0; i != nArr.length; i++) {\n\t\t\t\t\tNode curNode = nArr[i];\n\t\t\t\t\tNode left = lBigMap.get(curNode);\n\t\t\t\t\tNode right = rBigMap.get(curNode);\n\t\t\n\t\t\t\t\tif (left == null && right == null) {\n\t\t\t\t\t\thead = curNode;\n\t\t\t\t\t} else if (left == null) {\n\t\t\t\t\t\tif (right.left == null) {\n\t\t\t\t\t\t\tright.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tright.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (right == null) {\n\t\t\t\t\t\tif (left.left == null) {\n\t\t\t\t\t\t\tleft.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNode parent = left.value < right.value ? left : right;\n\t\t\t\t\t\tif (parent.left == null) {\n\t\t\t\t\t\t\tparent.left = curNode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent.right = curNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\n\t\t\t\t}\n\t\t\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\n\t\t\tprivate void popStackSetMap(Stack<Node> stack, HashMap<Node, Node> map) {\n\t\t\t\tNode popNode = stack.pop();\n\t\t\t\tif (stack.isEmpty()) {\n\t\t\t\t\tmap.put(popNode, null);\n\t\t\t\t} else {\n\t\t\t\t\tmap.put(popNode, stack.peek());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t","slug":"get-max-tree","published":1,"updated":"2017-08-17T02:41:11.473Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1bt00172siv8grk49m0","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"构造数组的MaxTree\"><a href=\"#构造数组的MaxTree\" class=\"headerlink\" title=\"构造数组的MaxTree\"></a>构造数组的MaxTree</h5><p>定义二叉树结点如下：</p>\n<pre><code>public class Node {\n    public int value;\n    public Node left;\n    public Node right;\n\n    public Node(int data) {\n        this.value = data;\n    }\n}\n</code></pre><p>一个数组的MaxTree定义如下。</p>\n<ul>\n<li>数组必须没有重复元素。</li>\n<li>MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。</li>\n<li>包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。</li>\n</ul>\n<p>给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><p>下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。</p>\n<blockquote>\n<p>arr = {3,4,5,1,2}<br><br>3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br><br>4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br><br>5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br><br>1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br><br>2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br></p>\n</blockquote>\n<p>以下列原则来建立这颗树：</p>\n<ul>\n<li>每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。</li>\n<li>如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.HashMap;\nimport java.util.Stack;\n\npublic class MaxTree {\n\n    public Node getMaxTree(int[] arr) {\n\n        Node[] nArr = new Node[arr.length];\n        for (int i = 0; i != arr.length; i++) {\n            nArr[i] = new Node(arr[i]);\n        }\n\n        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();\n        HashMap&lt;Node, Node&gt; lBigMap = new HashMap&lt;&gt;();\n        HashMap&lt;Node, Node&gt; rBigMap = new HashMap&lt;&gt;();\n\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, lBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, lBigMap);\n        }\n\n        for (int i = nArr.length; i != -1; i--) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, rBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, rBigMap);\n        }\n\n        Node head = null;\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            Node left = lBigMap.get(curNode);\n            Node right = rBigMap.get(curNode);\n\n            if (left == null &amp;&amp; right == null) {\n                head = curNode;\n            } else if (left == null) {\n                if (right.left == null) {\n                    right.left = curNode;\n                } else {\n                    right.right = curNode;\n                }\n            } else if (right == null) {\n                if (left.left == null) {\n                    left.left = curNode;\n                } else {\n                    left.right = curNode;\n                }\n            } else {\n                Node parent = left.value &lt; right.value ? left : right;\n                if (parent.left == null) {\n                    parent.left = curNode;\n                } else {\n                    parent.right = curNode;\n                }\n            }\n\n        }\n\n        return head;\n    }\n\n    private void popStackSetMap(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map) {\n        Node popNode = stack.pop();\n        if (stack.isEmpty()) {\n            map.put(popNode, null);\n        } else {\n            map.put(popNode, stack.peek());\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><h5 id=\"构造数组的MaxTree\"><a href=\"#构造数组的MaxTree\" class=\"headerlink\" title=\"构造数组的MaxTree\"></a>构造数组的MaxTree</h5><p>定义二叉树结点如下：</p>\n<pre><code>public class Node {\n    public int value;\n    public Node left;\n    public Node right;\n\n    public Node(int data) {\n        this.value = data;\n    }\n}\n</code></pre><p>一个数组的MaxTree定义如下。</p>\n<ul>\n<li>数组必须没有重复元素。</li>\n<li>MaxTree是一颗二叉树，数组的每一个值对应一个二叉树节点。</li>\n<li>包括MaxTree树在内且在其中的每一颗树上，值最大的节点都是树的头。</li>\n</ul>\n<p>给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，则时间复杂度为O(n)、额外空间复杂度为O(n).</p>\n<h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>校 ★★★☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><p>下面举例说明如何在满足空间和时间复杂度的要求下生成MaxTree。</p>\n<blockquote>\n<p>arr = {3,4,5,1,2}<br><br>3的左边第一个比3大的数：无  3的右边第一个比3大的数：4<br><br>4的左边第一个比4大的数：无  4的右边第一个比4大的数：5<br><br>5的左边第一个比5大的数：无  5的右边第一个比5大的数：无<br><br>1的左边第一个比1大的数：5   1的右边第一个比1大的数：2<br><br>2的左边第一个比2大的数：5   2的右边第一个比2大的数：无<br></p>\n</blockquote>\n<p>以下列原则来建立这颗树：</p>\n<ul>\n<li>每一个数的父节点是他左边第一个比他大的数和他右边第一个比他大的数中，较小的那个。</li>\n<li>如果一个数左边没有比他大的数，右边也没有。也就是说，这个数是整个数组的最大值，那么这个数是MaxTree的头节点。</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.HashMap;\nimport java.util.Stack;\n\npublic class MaxTree {\n\n    public Node getMaxTree(int[] arr) {\n\n        Node[] nArr = new Node[arr.length];\n        for (int i = 0; i != arr.length; i++) {\n            nArr[i] = new Node(arr[i]);\n        }\n\n        Stack&lt;Node&gt; stack = new Stack&lt;&gt;();\n        HashMap&lt;Node, Node&gt; lBigMap = new HashMap&lt;&gt;();\n        HashMap&lt;Node, Node&gt; rBigMap = new HashMap&lt;&gt;();\n\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, lBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, lBigMap);\n        }\n\n        for (int i = nArr.length; i != -1; i--) {\n            Node curNode = nArr[i];\n            while ((!stack.isEmpty()) &amp;&amp; stack.peek().value &lt; curNode.value) {\n                popStackSetMap(stack, rBigMap);\n            }\n            stack.push(curNode);\n        }\n\n        while (!stack.isEmpty()) {\n            popStackSetMap(stack, rBigMap);\n        }\n\n        Node head = null;\n        for (int i = 0; i != nArr.length; i++) {\n            Node curNode = nArr[i];\n            Node left = lBigMap.get(curNode);\n            Node right = rBigMap.get(curNode);\n\n            if (left == null &amp;&amp; right == null) {\n                head = curNode;\n            } else if (left == null) {\n                if (right.left == null) {\n                    right.left = curNode;\n                } else {\n                    right.right = curNode;\n                }\n            } else if (right == null) {\n                if (left.left == null) {\n                    left.left = curNode;\n                } else {\n                    left.right = curNode;\n                }\n            } else {\n                Node parent = left.value &lt; right.value ? left : right;\n                if (parent.left == null) {\n                    parent.left = curNode;\n                } else {\n                    parent.right = curNode;\n                }\n            }\n\n        }\n\n        return head;\n    }\n\n    private void popStackSetMap(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; map) {\n        Node popNode = stack.pop();\n        if (stack.isEmpty()) {\n            map.put(popNode, null);\n        } else {\n            map.put(popNode, stack.peek());\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"APK瘦身","date":"2017-02-20T00:00:00.000Z","_content":" \n#### 在线检测 ####\n\n>在线分析APK：[NimbleDroid](https://nimbledroid.com/)\n\n\n##### 实例分析-Summary #####\n\n\t我们上传一个apk，看看这款App的分析结果。\n\n![Summary](/images/nimabledroid-1.png)\n\n- File Name 我们上传的App名字\n- File Size 文件大小\n- Method Count 方法总数\n- Uploaded via Site 谁在什么时间上传 \n\n\n![Summary](/images/nimabledroid-2.png)\n\n- Scenario：Cold StartUp 冷启动场景下\n- Slowdowns 速度减缓的地方\n- Merm Leaks 内存泄漏的地方\n- Time-Real Time 时间花费\n- Memory-Max Use 内存占用\n- Network-down 下载数据量\n- Network-up 上传数据量\n- Disk I/O-Read 从磁盘读取数据量\n- Disk I/O-Write 写入磁盘的数据量\n\n\n##### 实例分析-File Sizes #####\n\n![Summary](/images/nimabledroid-3.png)\n\n> 在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。\n\n![Summary](/images/nimabledroid-4.png)\n>不同类型的文件所占体积大小。\n\n\n##### 实例分析-Method Count #####\n![Summary](/images/nimabledroid-5.png)\n\n>各SDK方法数统计。\n\n\n##### 实例分析-具体Scenario分析 #####\n\n我们考察冷启动从欢迎页启动到主页这个场景。看到时间为`4.8s`,感觉有些长了。我们使用Android Monitor的日志，过滤`ActivityManager:Displayed`，看到欢迎页是`569ms`，主页是`613ms`。\n\n![Summary](/images/nimabledroid-6.png)\n如图：\n\n- Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。\n- Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。\n- Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。\n- Speed - Dependencies 有时应用中的依赖关系会影响性能。\n\n- BaseActivity、BaseFragment的初始化操作\n- PushAgent.onAppStart 推送服务启动\n- ClassUtil.getGenericSuperclass fastjson的方法\n- ViewPager.onMeasure 欢迎页的测量\n- Jackson JSON Parser jackjson的解析\n \n我们选取一个方法点击进入详细，如图：\n\n![Summary](/images/nimabledroid-7.png)\n\n在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。\n\n\n![Summary](/images/nimabledroid-8.png)\n\n> 看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！\n\n\n\n#### 优化注意点 ####\n\n\n##### 资源 #####\n\n- 清除未使用的资源，Android lint analyze & shrinkResource\n- 大图片使用tinyPNG\n- png转webp\n- [AndResGuard](https://github.com/shwenzhang/AndResGuard)\n\n\n##### 第三方库 #####\n\t\n- 清除不必须的第三方jar，尤其是Android support \n\n##### 冗余代码 #####\n\n- inspect code","source":"_posts/2017-02-20-decrease-apk-size.md","raw":"---\nlayout: post\ntitle:  APK瘦身\ndate:   2017-02-20\ncategories: Android \ntag: android\n---\n \n#### 在线检测 ####\n\n>在线分析APK：[NimbleDroid](https://nimbledroid.com/)\n\n\n##### 实例分析-Summary #####\n\n\t我们上传一个apk，看看这款App的分析结果。\n\n![Summary](/images/nimabledroid-1.png)\n\n- File Name 我们上传的App名字\n- File Size 文件大小\n- Method Count 方法总数\n- Uploaded via Site 谁在什么时间上传 \n\n\n![Summary](/images/nimabledroid-2.png)\n\n- Scenario：Cold StartUp 冷启动场景下\n- Slowdowns 速度减缓的地方\n- Merm Leaks 内存泄漏的地方\n- Time-Real Time 时间花费\n- Memory-Max Use 内存占用\n- Network-down 下载数据量\n- Network-up 上传数据量\n- Disk I/O-Read 从磁盘读取数据量\n- Disk I/O-Write 写入磁盘的数据量\n\n\n##### 实例分析-File Sizes #####\n\n![Summary](/images/nimabledroid-3.png)\n\n> 在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。\n\n![Summary](/images/nimabledroid-4.png)\n>不同类型的文件所占体积大小。\n\n\n##### 实例分析-Method Count #####\n![Summary](/images/nimabledroid-5.png)\n\n>各SDK方法数统计。\n\n\n##### 实例分析-具体Scenario分析 #####\n\n我们考察冷启动从欢迎页启动到主页这个场景。看到时间为`4.8s`,感觉有些长了。我们使用Android Monitor的日志，过滤`ActivityManager:Displayed`，看到欢迎页是`569ms`，主页是`613ms`。\n\n![Summary](/images/nimabledroid-6.png)\n如图：\n\n- Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。\n- Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。\n- Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。\n- Speed - Dependencies 有时应用中的依赖关系会影响性能。\n\n- BaseActivity、BaseFragment的初始化操作\n- PushAgent.onAppStart 推送服务启动\n- ClassUtil.getGenericSuperclass fastjson的方法\n- ViewPager.onMeasure 欢迎页的测量\n- Jackson JSON Parser jackjson的解析\n \n我们选取一个方法点击进入详细，如图：\n\n![Summary](/images/nimabledroid-7.png)\n\n在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。\n\n\n![Summary](/images/nimabledroid-8.png)\n\n> 看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！\n\n\n\n#### 优化注意点 ####\n\n\n##### 资源 #####\n\n- 清除未使用的资源，Android lint analyze & shrinkResource\n- 大图片使用tinyPNG\n- png转webp\n- [AndResGuard](https://github.com/shwenzhang/AndResGuard)\n\n\n##### 第三方库 #####\n\t\n- 清除不必须的第三方jar，尤其是Android support \n\n##### 冗余代码 #####\n\n- inspect code","slug":"decrease-apk-size","published":1,"updated":"2017-11-16T08:29:27.184Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1by001c2sivlbmeqpeo","content":"<h4 id=\"在线检测\"><a href=\"#在线检测\" class=\"headerlink\" title=\"在线检测\"></a>在线检测</h4><blockquote>\n<p>在线分析APK：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">NimbleDroid</a></p>\n</blockquote>\n<h5 id=\"实例分析-Summary\"><a href=\"#实例分析-Summary\" class=\"headerlink\" title=\"实例分析-Summary\"></a>实例分析-Summary</h5><pre><code>我们上传一个apk，看看这款App的分析结果。\n</code></pre><p><img src=\"/images/nimabledroid-1.png\" alt=\"Summary\"></p>\n<ul>\n<li>File Name 我们上传的App名字</li>\n<li>File Size 文件大小</li>\n<li>Method Count 方法总数</li>\n<li>Uploaded via Site 谁在什么时间上传 </li>\n</ul>\n<p><img src=\"/images/nimabledroid-2.png\" alt=\"Summary\"></p>\n<ul>\n<li>Scenario：Cold StartUp 冷启动场景下</li>\n<li>Slowdowns 速度减缓的地方</li>\n<li>Merm Leaks 内存泄漏的地方</li>\n<li>Time-Real Time 时间花费</li>\n<li>Memory-Max Use 内存占用</li>\n<li>Network-down 下载数据量</li>\n<li>Network-up 上传数据量</li>\n<li>Disk I/O-Read 从磁盘读取数据量</li>\n<li>Disk I/O-Write 写入磁盘的数据量</li>\n</ul>\n<h5 id=\"实例分析-File-Sizes\"><a href=\"#实例分析-File-Sizes\" class=\"headerlink\" title=\"实例分析-File Sizes\"></a>实例分析-File Sizes</h5><p><img src=\"/images/nimabledroid-3.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。</p>\n</blockquote>\n<p><img src=\"/images/nimabledroid-4.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>不同类型的文件所占体积大小。</p>\n</blockquote>\n<h5 id=\"实例分析-Method-Count\"><a href=\"#实例分析-Method-Count\" class=\"headerlink\" title=\"实例分析-Method Count\"></a>实例分析-Method Count</h5><p><img src=\"/images/nimabledroid-5.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>各SDK方法数统计。</p>\n</blockquote>\n<h5 id=\"实例分析-具体Scenario分析\"><a href=\"#实例分析-具体Scenario分析\" class=\"headerlink\" title=\"实例分析-具体Scenario分析\"></a>实例分析-具体Scenario分析</h5><p>我们考察冷启动从欢迎页启动到主页这个场景。看到时间为<code>4.8s</code>,感觉有些长了。我们使用Android Monitor的日志，过滤<code>ActivityManager:Displayed</code>，看到欢迎页是<code>569ms</code>，主页是<code>613ms</code>。</p>\n<p><img src=\"/images/nimabledroid-6.png\" alt=\"Summary\"><br>如图：</p>\n<ul>\n<li>Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。</li>\n<li>Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。</li>\n<li>Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。</li>\n<li><p>Speed - Dependencies 有时应用中的依赖关系会影响性能。</p>\n</li>\n<li><p>BaseActivity、BaseFragment的初始化操作</p>\n</li>\n<li>PushAgent.onAppStart 推送服务启动</li>\n<li>ClassUtil.getGenericSuperclass fastjson的方法</li>\n<li>ViewPager.onMeasure 欢迎页的测量</li>\n<li>Jackson JSON Parser jackjson的解析</li>\n</ul>\n<p>我们选取一个方法点击进入详细，如图：</p>\n<p><img src=\"/images/nimabledroid-7.png\" alt=\"Summary\"></p>\n<p>在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。</p>\n<p><img src=\"/images/nimabledroid-8.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！</p>\n</blockquote>\n<h4 id=\"优化注意点\"><a href=\"#优化注意点\" class=\"headerlink\" title=\"优化注意点\"></a>优化注意点</h4><h5 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h5><ul>\n<li>清除未使用的资源，Android lint analyze &amp; shrinkResource</li>\n<li>大图片使用tinyPNG</li>\n<li>png转webp</li>\n<li><a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"external\">AndResGuard</a></li>\n</ul>\n<h5 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h5><ul>\n<li>清除不必须的第三方jar，尤其是Android support </li>\n</ul>\n<h5 id=\"冗余代码\"><a href=\"#冗余代码\" class=\"headerlink\" title=\"冗余代码\"></a>冗余代码</h5><ul>\n<li>inspect code</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"在线检测\"><a href=\"#在线检测\" class=\"headerlink\" title=\"在线检测\"></a>在线检测</h4><blockquote>\n<p>在线分析APK：<a href=\"https://nimbledroid.com/\" target=\"_blank\" rel=\"external\">NimbleDroid</a></p>\n</blockquote>\n<h5 id=\"实例分析-Summary\"><a href=\"#实例分析-Summary\" class=\"headerlink\" title=\"实例分析-Summary\"></a>实例分析-Summary</h5><pre><code>我们上传一个apk，看看这款App的分析结果。\n</code></pre><p><img src=\"/images/nimabledroid-1.png\" alt=\"Summary\"></p>\n<ul>\n<li>File Name 我们上传的App名字</li>\n<li>File Size 文件大小</li>\n<li>Method Count 方法总数</li>\n<li>Uploaded via Site 谁在什么时间上传 </li>\n</ul>\n<p><img src=\"/images/nimabledroid-2.png\" alt=\"Summary\"></p>\n<ul>\n<li>Scenario：Cold StartUp 冷启动场景下</li>\n<li>Slowdowns 速度减缓的地方</li>\n<li>Merm Leaks 内存泄漏的地方</li>\n<li>Time-Real Time 时间花费</li>\n<li>Memory-Max Use 内存占用</li>\n<li>Network-down 下载数据量</li>\n<li>Network-up 上传数据量</li>\n<li>Disk I/O-Read 从磁盘读取数据量</li>\n<li>Disk I/O-Write 写入磁盘的数据量</li>\n</ul>\n<h5 id=\"实例分析-File-Sizes\"><a href=\"#实例分析-File-Sizes\" class=\"headerlink\" title=\"实例分析-File Sizes\"></a>实例分析-File Sizes</h5><p><img src=\"/images/nimabledroid-3.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>在此，我们看到100kb以上的文件。其中某些lib下的多余库，高清大图片是我们关注的重点。</p>\n</blockquote>\n<p><img src=\"/images/nimabledroid-4.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>不同类型的文件所占体积大小。</p>\n</blockquote>\n<h5 id=\"实例分析-Method-Count\"><a href=\"#实例分析-Method-Count\" class=\"headerlink\" title=\"实例分析-Method Count\"></a>实例分析-Method Count</h5><p><img src=\"/images/nimabledroid-5.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>各SDK方法数统计。</p>\n</blockquote>\n<h5 id=\"实例分析-具体Scenario分析\"><a href=\"#实例分析-具体Scenario分析\" class=\"headerlink\" title=\"实例分析-具体Scenario分析\"></a>实例分析-具体Scenario分析</h5><p>我们考察冷启动从欢迎页启动到主页这个场景。看到时间为<code>4.8s</code>,感觉有些长了。我们使用Android Monitor的日志，过滤<code>ActivityManager:Displayed</code>，看到欢迎页是<code>569ms</code>，主页是<code>613ms</code>。</p>\n<p><img src=\"/images/nimabledroid-6.png\" alt=\"Summary\"><br>如图：</p>\n<ul>\n<li>Speed - Hung CPU Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在该条目下因为此时正在使用CPU。</li>\n<li>Speed - Hung Wait Methods 挂起CPU方法使UI落后，反应延迟。对用户来说是长于32ms。方法在此条目下因为正在等待可用的资源，尽管没有使用CPU。</li>\n<li>Speed - Hot Methods 热方法即执行其调用的CPU时间长于100ms。</li>\n<li><p>Speed - Dependencies 有时应用中的依赖关系会影响性能。</p>\n</li>\n<li><p>BaseActivity、BaseFragment的初始化操作</p>\n</li>\n<li>PushAgent.onAppStart 推送服务启动</li>\n<li>ClassUtil.getGenericSuperclass fastjson的方法</li>\n<li>ViewPager.onMeasure 欢迎页的测量</li>\n<li>Jackson JSON Parser jackjson的解析</li>\n</ul>\n<p>我们选取一个方法点击进入详细，如图：</p>\n<p><img src=\"/images/nimabledroid-7.png\" alt=\"Summary\"></p>\n<p>在此我们可以看到，Umeng推送，百度定位，检查版本更新，检查热修复包版本，retrofitmanager初始化。</p>\n<p><img src=\"/images/nimabledroid-8.png\" alt=\"Summary\"></p>\n<blockquote>\n<p>看到这个对比图，还是老脸微红的。现在的SDK都要求在Application里初始化，搞的定位，推送，热修复，网络框架，图片框架都在这里了，皮，真的皮！</p>\n</blockquote>\n<h4 id=\"优化注意点\"><a href=\"#优化注意点\" class=\"headerlink\" title=\"优化注意点\"></a>优化注意点</h4><h5 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h5><ul>\n<li>清除未使用的资源，Android lint analyze &amp; shrinkResource</li>\n<li>大图片使用tinyPNG</li>\n<li>png转webp</li>\n<li><a href=\"https://github.com/shwenzhang/AndResGuard\" target=\"_blank\" rel=\"external\">AndResGuard</a></li>\n</ul>\n<h5 id=\"第三方库\"><a href=\"#第三方库\" class=\"headerlink\" title=\"第三方库\"></a>第三方库</h5><ul>\n<li>清除不必须的第三方jar，尤其是Android support </li>\n</ul>\n<h5 id=\"冗余代码\"><a href=\"#冗余代码\" class=\"headerlink\" title=\"冗余代码\"></a>冗余代码</h5><ul>\n<li>inspect code</li>\n</ul>\n"},{"layout":"post","title":"单例设计模式(五) Android中单例的应用","date":"2017-02-21T00:00:00.000Z","_content":"\n \n\n\n#### 写在前面的关键点 ####\n\n我们知道，单例模式的特点：\n\n- 只有一个实例\n- 占用内存及资源较少，可防止对象不停的创建和销毁\n- 全局访问\n- 扩展性差\n- 与单一职责原则有冲突\n\n根据其特点，我们去看源码或者设计应用就可以做到有据可循了。\n\n#### Android系统源码中 ####\n\n##### 示例一【饿汉单例】：android.text.Editable.Factory.java #####\n\t\n\t   /**\n\t     * Factory used by TextView to create new Editables.  You can subclass\n\t     * it to provide something other than SpannableStringBuilder.\n\t     */\n\t    public static class Factory {\n\t        private static Editable.Factory sInstance = new Editable.Factory();\n\t      \n\t        public static Editable.Factory getInstance() {\n\t            return sInstance;\n\t        }\n\n\t        public Editable newEditable(CharSequence source) {\n\t            return new SpannableStringBuilder(source);\n\t        }\n\t    }\n\n> Editable 即 `android.widget.EditText#getText()` 返回的对象。最常用的大概是`et.getText().toString()`吧。\n\n然后从EditText-> TextView可以看到：\n\n    private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\n    private Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n\n然后考察其应用：\n\n\t private InputFilter[] mFilters = NO_FILTERS;\n\t private void setText(CharSequence text, BufferType type,\n\t                         boolean notifyBefore, int oldlen) {\n\t\t.\n\t\t.\n\t\t.\n\n\t\tEditable t = mEditableFactory.newEditable(text);\n        text = t;\n        setFilters(t, mFilters);\n\n\t\t.\n\t\t.\n\t\t.\n\t}\n\n得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。\n\n\n##### 示例二【懒汉单例】：ArrowKeyMovementMethod.java #####\n\n\tprivate static ArrowKeyMovementMethod sInstance;\t\n    public static MovementMethod getInstance() {\n        if (sInstance == null) {\n            sInstance = new ArrowKeyMovementMethod();\n        }\n\n        return sInstance;\n    }\n\n>看类名好像是光标移动相关的东东，跟进去看一下好了。<br/>\n>`initialize`初始化，把光标放在末尾位置；<br/>\n>`onTouchEvent`处理触摸拖拽事件；<br/>\n>`canSelectArbitrarily` 根据名字，是否可以任意选择，固定返回true；<br/>\n>`onTakeFocus` 获取焦点后的默认操作：光标放末尾\n\n\n\n\n##### 示例三【线程同步锁单例】：LocalBroadcastManager.java #####\n\n\n\tprivate static final Object mLock = new Object();\n    private static LocalBroadcastManager mInstance;\n\n    public static LocalBroadcastManager getInstance(Context context) {\n        synchronized (mLock) {\n            if (mInstance == null) {\n                mInstance = new LocalBroadcastManager(context.getApplicationContext());\n            }\n            return mInstance;\n        }\n    }\n\n>看类名是本地广播管理类，先看其类注释：<br/>\n\n>\n Helper to register for and send broadcasts of Intents to local objects\n within your process.  This has a number of advantages over sending\n global broadcasts with {@link android.content.Context#sendBroadcast}<br/>\n进程内帮助注册和发送广播给本地对象。相比于```Context#sendBroadcast```有巨大优势！<br/>\n\n优势有三：<br/>\n1. 应用内发送，不必担心私有数据泄露；<br/>\n2. 别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br/>\n3. 比通过系统发送广播更加有效。\n\n##### 示例四【线程同步锁单例】：InputMethodManager.java #####\n\n\tstatic InputMethodManager sInstance;\n\tpublic static InputMethodManager getInstance() {\n\t        synchronized (InputMethodManager.class) {\n\t            if (sInstance == null) {\n\t                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n\t                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n\t                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n\t            }\n\t            return sInstance;\n\t        }\n\t    }\n\n>用来控制显示和隐藏输入法面板。\n>\n##### 示例五【容器单例】：FocusFinder.java #####\n    \nFocusFinder.java\n\n\t    private static final ThreadLocal<FocusFinder> tlFocusFinder =\n            new ThreadLocal<FocusFinder>() {\n                @Override\n                protected FocusFinder initialValue() {\n                    return new FocusFinder();\n                }\n            };\n\n\t\tpublic static FocusFinder getInstance() {\n\t        return tlFocusFinder.get();\n\t    }\n\nThreadLocal.java\n\t\n\t    /**\n\t     * Returns the value in the current thread's copy of this\n\t     * thread-local variable.  If the variable has no value for the\n\t     * current thread, it is first initialized to the value returned\n\t     * by an invocation of the {@link #initialValue} method.\n\t     *\n\t     * @return the current thread's value of this thread-local\n\t     */\n\t    public T get() {\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null) {\n\t            ThreadLocalMap.Entry e = map.getEntry(this);\n\t            if (e != null)\n\t                return (T)e.value;\n\t        }\n\t        return setInitialValue();\n\t    }\n\t\n-\n\t\n\t    /**\n\t     * Variant of set() to establish initialValue. Used instead\n\t     * of set() in case user has overridden the set() method.\n\t     *\n\t     * @return the initial value\n\t     */\n\t    private T setInitialValue() {\n\t        T value = initialValue();\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null)\n\t            map.set(this, value);\n\t        else\n\t            createMap(t, value);\n\t        return value;\n\t    }\n\t\n\t    protected T initialValue() {\n\t        return null;\n\t    }\n\n> 一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：\n\n\n    private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n        View next = null;\n        if (focused != null) {\n            next = findNextUserSpecifiedFocus(root, focused, direction);\n        }\n        if (next != null) {\n            return next;\n        }\n        ArrayList<View> focusables = mTempList;\n        try {\n            focusables.clear();\n            root.addFocusables(focusables, direction);\n            if (!focusables.isEmpty()) {\n                next = findNextFocus(root, focused, focusedRect, direction, focusables);\n            }\n        } finally {\n            focusables.clear();\n        }\n        return next;\n    }\n\n##### 示例六【容器单例】：android.app.SystemServiceRegistry.java #####\n\n>\n该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。\n\n[源码地址](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java)。\n\n[服务说明在此](http://xusx1024.com/2017/02/22/android-system-service/)。\n\n##### 示例七【别样的单例】：BidiFormatter.java #####\n\n实例\n\t\n\t\tprivate static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n\t            false /* LTR context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\t\n\t    private static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n\t            true /* RTL context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\n构造\n\n\t   private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n\t        mIsRtlContext = isRtlContext;\n\t        mFlags = flags;\n\t        mDefaultTextDirectionHeuristic = heuristic;\n\t    }\n\n获取实例：\n\n    public static BidiFormatter getInstance() {\n        return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n    }\n \n    public static BidiFormatter getInstance(boolean rtlContext) {\n        return getDefaultInstanceFromContext(rtlContext);\n    }\n \n    public static BidiFormatter getInstance(Locale locale) {\n        return getDefaultInstanceFromContext(isRtlLocale(locale));\n    }\n\n>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br/>\n>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br/>\n>如果要开启，在Manifest.xml中，修改Application结点的属性`android:supportsRtl`为true<br/>\n>另外，我们在xml布局时，经常看到提示：使用`android:layout_marginStart`替代`android:layout_marginLeft`这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。\n\n注1：\n> 其中volatial修饰的实例没有找到，Enum实现的单例也没找到。\n\n\n\n注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：\n\n![Android 源码中常见单例 图一](/images/android-singleton-1.png)\n\n![Android 源码中常见单例 图二](/images/android-singleton-2.png)\n\n\n#### Android App开发中 ####\n\n分析上半部可得：\n\n- 内部类单例-饿汉式\n- 简单单例-懒汉式\n- 多线程调用-带线程锁的懒汉式\n- 多种单例-容器管理单例\n\n我负责的app中，整理了一下，大概有如下会需要到单例：\n1. Application\n2. 定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类\n3. 升级管理\n\n","source":"_posts/2017-02-21-design-patterns-singleton-5.md","raw":"---\nlayout: post\ntitle:  单例设计模式(五) Android中单例的应用\ndate:   2017-02-21\ncategories: Design Pattern\ntag: 设计模式\n---\n\n \n\n\n#### 写在前面的关键点 ####\n\n我们知道，单例模式的特点：\n\n- 只有一个实例\n- 占用内存及资源较少，可防止对象不停的创建和销毁\n- 全局访问\n- 扩展性差\n- 与单一职责原则有冲突\n\n根据其特点，我们去看源码或者设计应用就可以做到有据可循了。\n\n#### Android系统源码中 ####\n\n##### 示例一【饿汉单例】：android.text.Editable.Factory.java #####\n\t\n\t   /**\n\t     * Factory used by TextView to create new Editables.  You can subclass\n\t     * it to provide something other than SpannableStringBuilder.\n\t     */\n\t    public static class Factory {\n\t        private static Editable.Factory sInstance = new Editable.Factory();\n\t      \n\t        public static Editable.Factory getInstance() {\n\t            return sInstance;\n\t        }\n\n\t        public Editable newEditable(CharSequence source) {\n\t            return new SpannableStringBuilder(source);\n\t        }\n\t    }\n\n> Editable 即 `android.widget.EditText#getText()` 返回的对象。最常用的大概是`et.getText().toString()`吧。\n\n然后从EditText-> TextView可以看到：\n\n    private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\n    private Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n\n然后考察其应用：\n\n\t private InputFilter[] mFilters = NO_FILTERS;\n\t private void setText(CharSequence text, BufferType type,\n\t                         boolean notifyBefore, int oldlen) {\n\t\t.\n\t\t.\n\t\t.\n\n\t\tEditable t = mEditableFactory.newEditable(text);\n        text = t;\n        setFilters(t, mFilters);\n\n\t\t.\n\t\t.\n\t\t.\n\t}\n\n得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。\n\n\n##### 示例二【懒汉单例】：ArrowKeyMovementMethod.java #####\n\n\tprivate static ArrowKeyMovementMethod sInstance;\t\n    public static MovementMethod getInstance() {\n        if (sInstance == null) {\n            sInstance = new ArrowKeyMovementMethod();\n        }\n\n        return sInstance;\n    }\n\n>看类名好像是光标移动相关的东东，跟进去看一下好了。<br/>\n>`initialize`初始化，把光标放在末尾位置；<br/>\n>`onTouchEvent`处理触摸拖拽事件；<br/>\n>`canSelectArbitrarily` 根据名字，是否可以任意选择，固定返回true；<br/>\n>`onTakeFocus` 获取焦点后的默认操作：光标放末尾\n\n\n\n\n##### 示例三【线程同步锁单例】：LocalBroadcastManager.java #####\n\n\n\tprivate static final Object mLock = new Object();\n    private static LocalBroadcastManager mInstance;\n\n    public static LocalBroadcastManager getInstance(Context context) {\n        synchronized (mLock) {\n            if (mInstance == null) {\n                mInstance = new LocalBroadcastManager(context.getApplicationContext());\n            }\n            return mInstance;\n        }\n    }\n\n>看类名是本地广播管理类，先看其类注释：<br/>\n\n>\n Helper to register for and send broadcasts of Intents to local objects\n within your process.  This has a number of advantages over sending\n global broadcasts with {@link android.content.Context#sendBroadcast}<br/>\n进程内帮助注册和发送广播给本地对象。相比于```Context#sendBroadcast```有巨大优势！<br/>\n\n优势有三：<br/>\n1. 应用内发送，不必担心私有数据泄露；<br/>\n2. 别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br/>\n3. 比通过系统发送广播更加有效。\n\n##### 示例四【线程同步锁单例】：InputMethodManager.java #####\n\n\tstatic InputMethodManager sInstance;\n\tpublic static InputMethodManager getInstance() {\n\t        synchronized (InputMethodManager.class) {\n\t            if (sInstance == null) {\n\t                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n\t                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n\t                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n\t            }\n\t            return sInstance;\n\t        }\n\t    }\n\n>用来控制显示和隐藏输入法面板。\n>\n##### 示例五【容器单例】：FocusFinder.java #####\n    \nFocusFinder.java\n\n\t    private static final ThreadLocal<FocusFinder> tlFocusFinder =\n            new ThreadLocal<FocusFinder>() {\n                @Override\n                protected FocusFinder initialValue() {\n                    return new FocusFinder();\n                }\n            };\n\n\t\tpublic static FocusFinder getInstance() {\n\t        return tlFocusFinder.get();\n\t    }\n\nThreadLocal.java\n\t\n\t    /**\n\t     * Returns the value in the current thread's copy of this\n\t     * thread-local variable.  If the variable has no value for the\n\t     * current thread, it is first initialized to the value returned\n\t     * by an invocation of the {@link #initialValue} method.\n\t     *\n\t     * @return the current thread's value of this thread-local\n\t     */\n\t    public T get() {\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null) {\n\t            ThreadLocalMap.Entry e = map.getEntry(this);\n\t            if (e != null)\n\t                return (T)e.value;\n\t        }\n\t        return setInitialValue();\n\t    }\n\t\n-\n\t\n\t    /**\n\t     * Variant of set() to establish initialValue. Used instead\n\t     * of set() in case user has overridden the set() method.\n\t     *\n\t     * @return the initial value\n\t     */\n\t    private T setInitialValue() {\n\t        T value = initialValue();\n\t        Thread t = Thread.currentThread();\n\t        ThreadLocalMap map = getMap(t);\n\t        if (map != null)\n\t            map.set(this, value);\n\t        else\n\t            createMap(t, value);\n\t        return value;\n\t    }\n\t\n\t    protected T initialValue() {\n\t        return null;\n\t    }\n\n> 一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：\n\n\n    private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n        View next = null;\n        if (focused != null) {\n            next = findNextUserSpecifiedFocus(root, focused, direction);\n        }\n        if (next != null) {\n            return next;\n        }\n        ArrayList<View> focusables = mTempList;\n        try {\n            focusables.clear();\n            root.addFocusables(focusables, direction);\n            if (!focusables.isEmpty()) {\n                next = findNextFocus(root, focused, focusedRect, direction, focusables);\n            }\n        } finally {\n            focusables.clear();\n        }\n        return next;\n    }\n\n##### 示例六【容器单例】：android.app.SystemServiceRegistry.java #####\n\n>\n该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。\n\n[源码地址](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java)。\n\n[服务说明在此](http://xusx1024.com/2017/02/22/android-system-service/)。\n\n##### 示例七【别样的单例】：BidiFormatter.java #####\n\n实例\n\t\n\t\tprivate static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n\t            false /* LTR context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\t\n\t    private static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n\t            true /* RTL context */,\n\t            DEFAULT_FLAGS,\n\t            DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\n构造\n\n\t   private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n\t        mIsRtlContext = isRtlContext;\n\t        mFlags = flags;\n\t        mDefaultTextDirectionHeuristic = heuristic;\n\t    }\n\n获取实例：\n\n    public static BidiFormatter getInstance() {\n        return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n    }\n \n    public static BidiFormatter getInstance(boolean rtlContext) {\n        return getDefaultInstanceFromContext(rtlContext);\n    }\n \n    public static BidiFormatter getInstance(Locale locale) {\n        return getDefaultInstanceFromContext(isRtlLocale(locale));\n    }\n\n>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br/>\n>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br/>\n>如果要开启，在Manifest.xml中，修改Application结点的属性`android:supportsRtl`为true<br/>\n>另外，我们在xml布局时，经常看到提示：使用`android:layout_marginStart`替代`android:layout_marginLeft`这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。\n\n注1：\n> 其中volatial修饰的实例没有找到，Enum实现的单例也没找到。\n\n\n\n注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：\n\n![Android 源码中常见单例 图一](/images/android-singleton-1.png)\n\n![Android 源码中常见单例 图二](/images/android-singleton-2.png)\n\n\n#### Android App开发中 ####\n\n分析上半部可得：\n\n- 内部类单例-饿汉式\n- 简单单例-懒汉式\n- 多线程调用-带线程锁的懒汉式\n- 多种单例-容器管理单例\n\n我负责的app中，整理了一下，大概有如下会需要到单例：\n1. Application\n2. 定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类\n3. 升级管理\n\n","slug":"design-patterns-singleton-5","published":1,"updated":"2017-08-17T02:41:29.170Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1c2001f2sivu5305bs6","content":"<h4 id=\"写在前面的关键点\"><a href=\"#写在前面的关键点\" class=\"headerlink\" title=\"写在前面的关键点\"></a>写在前面的关键点</h4><p>我们知道，单例模式的特点：</p>\n<ul>\n<li>只有一个实例</li>\n<li>占用内存及资源较少，可防止对象不停的创建和销毁</li>\n<li>全局访问</li>\n<li>扩展性差</li>\n<li>与单一职责原则有冲突</li>\n</ul>\n<p>根据其特点，我们去看源码或者设计应用就可以做到有据可循了。</p>\n<h4 id=\"Android系统源码中\"><a href=\"#Android系统源码中\" class=\"headerlink\" title=\"Android系统源码中\"></a>Android系统源码中</h4><h5 id=\"示例一【饿汉单例】：android-text-Editable-Factory-java\"><a href=\"#示例一【饿汉单例】：android-text-Editable-Factory-java\" class=\"headerlink\" title=\"示例一【饿汉单例】：android.text.Editable.Factory.java\"></a>示例一【饿汉单例】：android.text.Editable.Factory.java</h5><pre><code>/**\n  * Factory used by TextView to create new Editables.  You can subclass\n  * it to provide something other than SpannableStringBuilder.\n  */\n public static class Factory {\n     private static Editable.Factory sInstance = new Editable.Factory();\n\n     public static Editable.Factory getInstance() {\n         return sInstance;\n     }\n\n     public Editable newEditable(CharSequence source) {\n         return new SpannableStringBuilder(source);\n     }\n }\n</code></pre><blockquote>\n<p>Editable 即 <code>android.widget.EditText#getText()</code> 返回的对象。最常用的大概是<code>et.getText().toString()</code>吧。</p>\n</blockquote>\n<p>然后从EditText-&gt; TextView可以看到：</p>\n<pre><code>private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\nprivate Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n</code></pre><p>然后考察其应用：</p>\n<pre><code> private InputFilter[] mFilters = NO_FILTERS;\n private void setText(CharSequence text, BufferType type,\n                         boolean notifyBefore, int oldlen) {\n    .\n    .\n    .\n\n    Editable t = mEditableFactory.newEditable(text);\n    text = t;\n    setFilters(t, mFilters);\n\n    .\n    .\n    .\n}\n</code></pre><p>得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。</p>\n<h5 id=\"示例二【懒汉单例】：ArrowKeyMovementMethod-java\"><a href=\"#示例二【懒汉单例】：ArrowKeyMovementMethod-java\" class=\"headerlink\" title=\"示例二【懒汉单例】：ArrowKeyMovementMethod.java\"></a>示例二【懒汉单例】：ArrowKeyMovementMethod.java</h5><pre><code>private static ArrowKeyMovementMethod sInstance;    \npublic static MovementMethod getInstance() {\n    if (sInstance == null) {\n        sInstance = new ArrowKeyMovementMethod();\n    }\n\n    return sInstance;\n}\n</code></pre><blockquote>\n<p>看类名好像是光标移动相关的东东，跟进去看一下好了。<br><br><code>initialize</code>初始化，把光标放在末尾位置；<br><br><code>onTouchEvent</code>处理触摸拖拽事件；<br><br><code>canSelectArbitrarily</code> 根据名字，是否可以任意选择，固定返回true；<br><br><code>onTakeFocus</code> 获取焦点后的默认操作：光标放末尾</p>\n</blockquote>\n<h5 id=\"示例三【线程同步锁单例】：LocalBroadcastManager-java\"><a href=\"#示例三【线程同步锁单例】：LocalBroadcastManager-java\" class=\"headerlink\" title=\"示例三【线程同步锁单例】：LocalBroadcastManager.java\"></a>示例三【线程同步锁单例】：LocalBroadcastManager.java</h5><pre><code>private static final Object mLock = new Object();\nprivate static LocalBroadcastManager mInstance;\n\npublic static LocalBroadcastManager getInstance(Context context) {\n    synchronized (mLock) {\n        if (mInstance == null) {\n            mInstance = new LocalBroadcastManager(context.getApplicationContext());\n        }\n        return mInstance;\n    }\n}\n</code></pre><blockquote>\n<p>看类名是本地广播管理类，先看其类注释：<br></p>\n</blockquote>\n<p>&gt;<br> Helper to register for and send broadcasts of Intents to local objects<br> within your process.  This has a number of advantages over sending<br> global broadcasts with {@link android.content.Context#sendBroadcast}<br><br>进程内帮助注册和发送广播给本地对象。相比于<code>Context#sendBroadcast</code>有巨大优势！<br></p>\n<p>优势有三：<br></p>\n<ol>\n<li>应用内发送，不必担心私有数据泄露；<br></li>\n<li>别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br></li>\n<li>比通过系统发送广播更加有效。</li>\n</ol>\n<h5 id=\"示例四【线程同步锁单例】：InputMethodManager-java\"><a href=\"#示例四【线程同步锁单例】：InputMethodManager-java\" class=\"headerlink\" title=\"示例四【线程同步锁单例】：InputMethodManager.java\"></a>示例四【线程同步锁单例】：InputMethodManager.java</h5><pre><code>static InputMethodManager sInstance;\npublic static InputMethodManager getInstance() {\n        synchronized (InputMethodManager.class) {\n            if (sInstance == null) {\n                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n            }\n            return sInstance;\n        }\n    }\n</code></pre><blockquote>\n<p>用来控制显示和隐藏输入法面板。</p>\n<h5 id=\"示例五【容器单例】：FocusFinder-java\"><a href=\"#示例五【容器单例】：FocusFinder-java\" class=\"headerlink\" title=\"示例五【容器单例】：FocusFinder.java\"></a>示例五【容器单例】：FocusFinder.java</h5></blockquote>\n<p>FocusFinder.java</p>\n<pre><code>private static final ThreadLocal&lt;FocusFinder&gt; tlFocusFinder =\n    new ThreadLocal&lt;FocusFinder&gt;() {\n        @Override\n        protected FocusFinder initialValue() {\n            return new FocusFinder();\n        }\n    };\n\npublic static FocusFinder getInstance() {\n    return tlFocusFinder.get();\n}\n</code></pre><p>ThreadLocal.java</p>\n<pre><code>/**\n * Returns the value in the current thread&apos;s copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread&apos;s value of this thread-local\n */\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>-</p>\n<pre><code>/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n</code></pre><blockquote>\n<p>一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：</p>\n</blockquote>\n<pre><code>private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n    View next = null;\n    if (focused != null) {\n        next = findNextUserSpecifiedFocus(root, focused, direction);\n    }\n    if (next != null) {\n        return next;\n    }\n    ArrayList&lt;View&gt; focusables = mTempList;\n    try {\n        focusables.clear();\n        root.addFocusables(focusables, direction);\n        if (!focusables.isEmpty()) {\n            next = findNextFocus(root, focused, focusedRect, direction, focusables);\n        }\n    } finally {\n        focusables.clear();\n    }\n    return next;\n}\n</code></pre><h5 id=\"示例六【容器单例】：android-app-SystemServiceRegistry-java\"><a href=\"#示例六【容器单例】：android-app-SystemServiceRegistry-java\" class=\"headerlink\" title=\"示例六【容器单例】：android.app.SystemServiceRegistry.java\"></a>示例六【容器单例】：android.app.SystemServiceRegistry.java</h5><p>&gt;<br>该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。</p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java\" target=\"_blank\" rel=\"external\">源码地址</a>。</p>\n<p><a href=\"http://xusx1024.com/2017/02/22/android-system-service/\" target=\"_blank\" rel=\"external\">服务说明在此</a>。</p>\n<h5 id=\"示例七【别样的单例】：BidiFormatter-java\"><a href=\"#示例七【别样的单例】：BidiFormatter-java\" class=\"headerlink\" title=\"示例七【别样的单例】：BidiFormatter.java\"></a>示例七【别样的单例】：BidiFormatter.java</h5><p>实例</p>\n<pre><code>private static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n        false /* LTR context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\nprivate static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n        true /* RTL context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n</code></pre><p>构造</p>\n<pre><code>private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n     mIsRtlContext = isRtlContext;\n     mFlags = flags;\n     mDefaultTextDirectionHeuristic = heuristic;\n }\n</code></pre><p>获取实例：</p>\n<pre><code>public static BidiFormatter getInstance() {\n    return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n}\n\npublic static BidiFormatter getInstance(boolean rtlContext) {\n    return getDefaultInstanceFromContext(rtlContext);\n}\n\npublic static BidiFormatter getInstance(Locale locale) {\n    return getDefaultInstanceFromContext(isRtlLocale(locale));\n}\n</code></pre><blockquote>\n<p>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br><br>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br><br>如果要开启，在Manifest.xml中，修改Application结点的属性<code>android:supportsRtl</code>为true<br><br>另外，我们在xml布局时，经常看到提示：使用<code>android:layout_marginStart</code>替代<code>android:layout_marginLeft</code>这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。</p>\n</blockquote>\n<p>注1：</p>\n<blockquote>\n<p>其中volatial修饰的实例没有找到，Enum实现的单例也没找到。</p>\n</blockquote>\n<p>注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：</p>\n<p><img src=\"/images/android-singleton-1.png\" alt=\"Android 源码中常见单例 图一\"></p>\n<p><img src=\"/images/android-singleton-2.png\" alt=\"Android 源码中常见单例 图二\"></p>\n<h4 id=\"Android-App开发中\"><a href=\"#Android-App开发中\" class=\"headerlink\" title=\"Android App开发中\"></a>Android App开发中</h4><p>分析上半部可得：</p>\n<ul>\n<li>内部类单例-饿汉式</li>\n<li>简单单例-懒汉式</li>\n<li>多线程调用-带线程锁的懒汉式</li>\n<li>多种单例-容器管理单例</li>\n</ul>\n<p>我负责的app中，整理了一下，大概有如下会需要到单例：</p>\n<ol>\n<li>Application</li>\n<li>定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类</li>\n<li>升级管理</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"写在前面的关键点\"><a href=\"#写在前面的关键点\" class=\"headerlink\" title=\"写在前面的关键点\"></a>写在前面的关键点</h4><p>我们知道，单例模式的特点：</p>\n<ul>\n<li>只有一个实例</li>\n<li>占用内存及资源较少，可防止对象不停的创建和销毁</li>\n<li>全局访问</li>\n<li>扩展性差</li>\n<li>与单一职责原则有冲突</li>\n</ul>\n<p>根据其特点，我们去看源码或者设计应用就可以做到有据可循了。</p>\n<h4 id=\"Android系统源码中\"><a href=\"#Android系统源码中\" class=\"headerlink\" title=\"Android系统源码中\"></a>Android系统源码中</h4><h5 id=\"示例一【饿汉单例】：android-text-Editable-Factory-java\"><a href=\"#示例一【饿汉单例】：android-text-Editable-Factory-java\" class=\"headerlink\" title=\"示例一【饿汉单例】：android.text.Editable.Factory.java\"></a>示例一【饿汉单例】：android.text.Editable.Factory.java</h5><pre><code>/**\n  * Factory used by TextView to create new Editables.  You can subclass\n  * it to provide something other than SpannableStringBuilder.\n  */\n public static class Factory {\n     private static Editable.Factory sInstance = new Editable.Factory();\n\n     public static Editable.Factory getInstance() {\n         return sInstance;\n     }\n\n     public Editable newEditable(CharSequence source) {\n         return new SpannableStringBuilder(source);\n     }\n }\n</code></pre><blockquote>\n<p>Editable 即 <code>android.widget.EditText#getText()</code> 返回的对象。最常用的大概是<code>et.getText().toString()</code>吧。</p>\n</blockquote>\n<p>然后从EditText-&gt; TextView可以看到：</p>\n<pre><code>private Editable.Factory mEditableFactory = Editable.Factory.getInstance();\nprivate Spannable.Factory mSpannableFactory = Spannable.Factory.getInstance();\n</code></pre><p>然后考察其应用：</p>\n<pre><code> private InputFilter[] mFilters = NO_FILTERS;\n private void setText(CharSequence text, BufferType type,\n                         boolean notifyBefore, int oldlen) {\n    .\n    .\n    .\n\n    Editable t = mEditableFactory.newEditable(text);\n    text = t;\n    setFilters(t, mFilters);\n\n    .\n    .\n    .\n}\n</code></pre><p>得到其用途：提供一个Editable的实现类【SpannableStringBuilder】的实例，然后应用filter。</p>\n<h5 id=\"示例二【懒汉单例】：ArrowKeyMovementMethod-java\"><a href=\"#示例二【懒汉单例】：ArrowKeyMovementMethod-java\" class=\"headerlink\" title=\"示例二【懒汉单例】：ArrowKeyMovementMethod.java\"></a>示例二【懒汉单例】：ArrowKeyMovementMethod.java</h5><pre><code>private static ArrowKeyMovementMethod sInstance;    \npublic static MovementMethod getInstance() {\n    if (sInstance == null) {\n        sInstance = new ArrowKeyMovementMethod();\n    }\n\n    return sInstance;\n}\n</code></pre><blockquote>\n<p>看类名好像是光标移动相关的东东，跟进去看一下好了。<br><br><code>initialize</code>初始化，把光标放在末尾位置；<br><br><code>onTouchEvent</code>处理触摸拖拽事件；<br><br><code>canSelectArbitrarily</code> 根据名字，是否可以任意选择，固定返回true；<br><br><code>onTakeFocus</code> 获取焦点后的默认操作：光标放末尾</p>\n</blockquote>\n<h5 id=\"示例三【线程同步锁单例】：LocalBroadcastManager-java\"><a href=\"#示例三【线程同步锁单例】：LocalBroadcastManager-java\" class=\"headerlink\" title=\"示例三【线程同步锁单例】：LocalBroadcastManager.java\"></a>示例三【线程同步锁单例】：LocalBroadcastManager.java</h5><pre><code>private static final Object mLock = new Object();\nprivate static LocalBroadcastManager mInstance;\n\npublic static LocalBroadcastManager getInstance(Context context) {\n    synchronized (mLock) {\n        if (mInstance == null) {\n            mInstance = new LocalBroadcastManager(context.getApplicationContext());\n        }\n        return mInstance;\n    }\n}\n</code></pre><blockquote>\n<p>看类名是本地广播管理类，先看其类注释：<br></p>\n</blockquote>\n<p>&gt;<br> Helper to register for and send broadcasts of Intents to local objects<br> within your process.  This has a number of advantages over sending<br> global broadcasts with {@link android.content.Context#sendBroadcast}<br><br>进程内帮助注册和发送广播给本地对象。相比于<code>Context#sendBroadcast</code>有巨大优势！<br></p>\n<p>优势有三：<br></p>\n<ol>\n<li>应用内发送，不必担心私有数据泄露；<br></li>\n<li>别的应用无法发送我自己的应用本地广播，不必担心安全漏洞；<br></li>\n<li>比通过系统发送广播更加有效。</li>\n</ol>\n<h5 id=\"示例四【线程同步锁单例】：InputMethodManager-java\"><a href=\"#示例四【线程同步锁单例】：InputMethodManager-java\" class=\"headerlink\" title=\"示例四【线程同步锁单例】：InputMethodManager.java\"></a>示例四【线程同步锁单例】：InputMethodManager.java</h5><pre><code>static InputMethodManager sInstance;\npublic static InputMethodManager getInstance() {\n        synchronized (InputMethodManager.class) {\n            if (sInstance == null) {\n                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);\n                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);\n                sInstance = new InputMethodManager(service, Looper.getMainLooper());\n            }\n            return sInstance;\n        }\n    }\n</code></pre><blockquote>\n<p>用来控制显示和隐藏输入法面板。</p>\n<h5 id=\"示例五【容器单例】：FocusFinder-java\"><a href=\"#示例五【容器单例】：FocusFinder-java\" class=\"headerlink\" title=\"示例五【容器单例】：FocusFinder.java\"></a>示例五【容器单例】：FocusFinder.java</h5></blockquote>\n<p>FocusFinder.java</p>\n<pre><code>private static final ThreadLocal&lt;FocusFinder&gt; tlFocusFinder =\n    new ThreadLocal&lt;FocusFinder&gt;() {\n        @Override\n        protected FocusFinder initialValue() {\n            return new FocusFinder();\n        }\n    };\n\npublic static FocusFinder getInstance() {\n    return tlFocusFinder.get();\n}\n</code></pre><p>ThreadLocal.java</p>\n<pre><code>/**\n * Returns the value in the current thread&apos;s copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread&apos;s value of this thread-local\n */\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n</code></pre><p>-</p>\n<pre><code>/**\n * Variant of set() to establish initialValue. Used instead\n * of set() in case user has overridden the set() method.\n *\n * @return the initial value\n */\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n</code></pre><blockquote>\n<p>一个用来从当前焦点视图给定的方向中找到下个焦点视图的算法。主要功能代码在此方法里：</p>\n</blockquote>\n<pre><code>private View findNextFocus(ViewGroup root, View focused, Rect focusedRect, int direction) {\n    View next = null;\n    if (focused != null) {\n        next = findNextUserSpecifiedFocus(root, focused, direction);\n    }\n    if (next != null) {\n        return next;\n    }\n    ArrayList&lt;View&gt; focusables = mTempList;\n    try {\n        focusables.clear();\n        root.addFocusables(focusables, direction);\n        if (!focusables.isEmpty()) {\n            next = findNextFocus(root, focused, focusedRect, direction, focusables);\n        }\n    } finally {\n        focusables.clear();\n    }\n    return next;\n}\n</code></pre><h5 id=\"示例六【容器单例】：android-app-SystemServiceRegistry-java\"><a href=\"#示例六【容器单例】：android-app-SystemServiceRegistry-java\" class=\"headerlink\" title=\"示例六【容器单例】：android.app.SystemServiceRegistry.java\"></a>示例六【容器单例】：android.app.SystemServiceRegistry.java</h5><p>&gt;<br>该类我们就不粘贴代码了，因为Android里所有的系统的单例都维护在这里。</p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/SystemServiceRegistry.java\" target=\"_blank\" rel=\"external\">源码地址</a>。</p>\n<p><a href=\"http://xusx1024.com/2017/02/22/android-system-service/\" target=\"_blank\" rel=\"external\">服务说明在此</a>。</p>\n<h5 id=\"示例七【别样的单例】：BidiFormatter-java\"><a href=\"#示例七【别样的单例】：BidiFormatter-java\" class=\"headerlink\" title=\"示例七【别样的单例】：BidiFormatter.java\"></a>示例七【别样的单例】：BidiFormatter.java</h5><p>实例</p>\n<pre><code>private static final BidiFormatter DEFAULT_LTR_INSTANCE = new BidiFormatter(\n        false /* LTR context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n\nprivate static final BidiFormatter DEFAULT_RTL_INSTANCE = new BidiFormatter(\n        true /* RTL context */,\n        DEFAULT_FLAGS,\n        DEFAULT_TEXT_DIRECTION_HEURISTIC);\n</code></pre><p>构造</p>\n<pre><code>private BidiFormatter(boolean isRtlContext, int flags, TextDirectionHeuristic heuristic) {\n     mIsRtlContext = isRtlContext;\n     mFlags = flags;\n     mDefaultTextDirectionHeuristic = heuristic;\n }\n</code></pre><p>获取实例：</p>\n<pre><code>public static BidiFormatter getInstance() {\n    return getDefaultInstanceFromContext(isRtlLocale(Locale.getDefault()));\n}\n\npublic static BidiFormatter getInstance(boolean rtlContext) {\n    return getDefaultInstanceFromContext(rtlContext);\n}\n\npublic static BidiFormatter getInstance(Locale locale) {\n    return getDefaultInstanceFromContext(isRtlLocale(locale));\n}\n</code></pre><blockquote>\n<p>BidiFormatter中的单例让我耳目一新。多种类型的static final 修饰的实例。<br><br>这个类是4.2之后增加的新功能，通常文本是从左到右的顺序排列和阅读的。如果你是用阿拉伯语或者希伯来语，那么文本就从右往左排序才方便了。<br><br>如果要开启，在Manifest.xml中，修改Application结点的属性<code>android:supportsRtl</code>为true<br><br>另外，我们在xml布局时，经常看到提示：使用<code>android:layout_marginStart</code>替代<code>android:layout_marginLeft</code>这样的提示，这就是因为，在LTR和RTL模式下，view的布局是相反的，其相对距离也是相反，使用建议api，可省却该麻烦，真良心。</p>\n</blockquote>\n<p>注1：</p>\n<blockquote>\n<p>其中volatial修饰的实例没有找到，Enum实现的单例也没找到。</p>\n</blockquote>\n<p>注2：Android 源码中常见单例(在AS中ctrl+alt+shift+n)：</p>\n<p><img src=\"/images/android-singleton-1.png\" alt=\"Android 源码中常见单例 图一\"></p>\n<p><img src=\"/images/android-singleton-2.png\" alt=\"Android 源码中常见单例 图二\"></p>\n<h4 id=\"Android-App开发中\"><a href=\"#Android-App开发中\" class=\"headerlink\" title=\"Android App开发中\"></a>Android App开发中</h4><p>分析上半部可得：</p>\n<ul>\n<li>内部类单例-饿汉式</li>\n<li>简单单例-懒汉式</li>\n<li>多线程调用-带线程锁的懒汉式</li>\n<li>多种单例-容器管理单例</li>\n</ul>\n<p>我负责的app中，整理了一下，大概有如下会需要到单例：</p>\n<ol>\n<li>Application</li>\n<li>定位、汉字转拼音、crash抓取、图片、网络、以及其他工具类</li>\n<li>升级管理</li>\n</ol>\n"},{"layout":"post","title":"用一个栈实现另一个栈的排序","date":"2017-02-14T00:00:00.000Z","_content":" \n\n\n#### 题目 ####\n    \n\t一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n\n#### 难度 ####\n\n\t士 ★☆☆☆\n\n\n#### 解答 ####\n \n\t将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n\n- 如果cur小于或等于help的栈顶元素，将cur压入help；\n- 如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；\n\n示例代码如下：\n\n\t\n\timport java.util.Stack;\n\t\n\tpublic class SortStackByStack {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tStack<Integer> ss = new Stack<>();\n\t\t\tss.push(7);\n\t\t\tss.push(2);\n\t\t\tss.push(8);\n\t\t\tss.push(3);\n\t\t\tss.push(9);\n\t\t\tsortStackByStack(ss);\n\t\n\t\t}\n\t\n\t\tpublic static void sortStackByStack(Stack<Integer> stack) {\n\t\t\tStack<Integer> help = new Stack<>();\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint cur = stack.pop();\n\t\t\t\twhile (!help.isEmpty() && help.peek() < cur) {\n\t\t\t\t\tstack.push(help.pop());\n\t\t\t\t}\n\t\t\t\thelp.push(cur);\n\t\t\t}\n\t\t\twhile (!help.isEmpty()) {\n\t\t\t\tstack.push(help.pop());\n\t\t\t}\n\t\t}\n\t}\n","source":"_posts/2017-02-14-sort-stack-by-stack.md","raw":"---\nlayout: post\ntitle:  用一个栈实现另一个栈的排序\ndate:   2017-02-14\ncategories: Algorithm\ntag: 算法\n---\n \n\n\n#### 题目 ####\n    \n\t一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n\n#### 难度 ####\n\n\t士 ★☆☆☆\n\n\n#### 解答 ####\n \n\t将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n\n- 如果cur小于或等于help的栈顶元素，将cur压入help；\n- 如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；\n\n示例代码如下：\n\n\t\n\timport java.util.Stack;\n\t\n\tpublic class SortStackByStack {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tStack<Integer> ss = new Stack<>();\n\t\t\tss.push(7);\n\t\t\tss.push(2);\n\t\t\tss.push(8);\n\t\t\tss.push(3);\n\t\t\tss.push(9);\n\t\t\tsortStackByStack(ss);\n\t\n\t\t}\n\t\n\t\tpublic static void sortStackByStack(Stack<Integer> stack) {\n\t\t\tStack<Integer> help = new Stack<>();\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint cur = stack.pop();\n\t\t\t\twhile (!help.isEmpty() && help.peek() < cur) {\n\t\t\t\t\tstack.push(help.pop());\n\t\t\t\t}\n\t\t\t\thelp.push(cur);\n\t\t\t}\n\t\t\twhile (!help.isEmpty()) {\n\t\t\t\tstack.push(help.pop());\n\t\t\t}\n\t\t}\n\t}\n","slug":"sort-stack-by-stack","published":1,"updated":"2017-08-17T02:40:33.218Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1c8001k2sivy1doplwb","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>士 ★☆☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n</code></pre><ul>\n<li>如果cur小于或等于help的栈顶元素，将cur压入help；</li>\n<li>如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.Stack;\n\npublic class SortStackByStack {\n\n    public static void main(String[] args) {\n        Stack&lt;Integer&gt; ss = new Stack&lt;&gt;();\n        ss.push(7);\n        ss.push(2);\n        ss.push(8);\n        ss.push(3);\n        ss.push(9);\n        sortStackByStack(ss);\n\n    }\n\n    public static void sortStackByStack(Stack&lt;Integer&gt; stack) {\n        Stack&lt;Integer&gt; help = new Stack&lt;&gt;();\n        while (!stack.isEmpty()) {\n            int cur = stack.pop();\n            while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) {\n                stack.push(help.pop());\n            }\n            help.push(cur);\n        }\n        while (!help.isEmpty()) {\n            stack.push(help.pop());\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个栈中的元素的类型为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？\n</code></pre><h4 id=\"难度\"><a href=\"#难度\" class=\"headerlink\" title=\"难度\"></a>难度</h4><pre><code>士 ★☆☆☆\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>将要排序的栈记为stack，申请的辅助栈记为help。在stack上执行pop操作，弹出的元素记为cur。\n</code></pre><ul>\n<li>如果cur小于或等于help的栈顶元素，将cur压入help；</li>\n<li>如果cur大于help的栈顶元素，则将help元素逐个弹出，并压入stack，直至cur小于或等于栈顶元素，将cur压入help；</li>\n</ul>\n<p>示例代码如下：</p>\n<pre><code>import java.util.Stack;\n\npublic class SortStackByStack {\n\n    public static void main(String[] args) {\n        Stack&lt;Integer&gt; ss = new Stack&lt;&gt;();\n        ss.push(7);\n        ss.push(2);\n        ss.push(8);\n        ss.push(3);\n        ss.push(9);\n        sortStackByStack(ss);\n\n    }\n\n    public static void sortStackByStack(Stack&lt;Integer&gt; stack) {\n        Stack&lt;Integer&gt; help = new Stack&lt;&gt;();\n        while (!stack.isEmpty()) {\n            int cur = stack.pop();\n            while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) {\n                stack.push(help.pop());\n            }\n            help.push(cur);\n        }\n        while (!help.isEmpty()) {\n            stack.push(help.pop());\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"Android系统服务:服务概览","date":"2017-02-22T00:00:00.000Z","_content":" \n\n#### 一些说明 ####\n\n这个系列学习的系统服务，绝大多数是`android.app.SystemServiceRegistry`里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层`Application framework`。\n \n![application framework](/images/android-framework.png)\n\n其中核心平台服务包括：\n\n- Context.ACTIVITY_SERVICE -> ActivityManager\n- Context.WINDOW_SERVICE -> WindowManager\n- PackageManagerService [该服务并非在SystemServiceRegistry中注册]\n \n![android start 1](/images/android-start-1.png)\n \n![android start 2](/images/android-start-2.png)\n\n\n对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。\n<br/>\n<br/>\n\n再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。\n\n##### daemon #####\n- USB Daemon(usbd):管理USB连接\n- Android Debug Bridge Daemon(adbd):安卓调试桥链接管理\n- Debugger Daemon(debuggerd):启动Debugger系统\n- Radio Interface Layer Daemon(rild):管理无线通信连接\n\n##### Context Manager ##### \n管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。\n\nContext Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。\n\n同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。\n\n\n##### Media Server #####\n\nMedia Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.\n\n##### Zygote #####\n\nZygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。\n\n##### System Server #####\n\nSystem Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。\n\n##### Binder #####\n\nIPC(InterProcess Communication)进程间通信方式。<br/>\nRPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br/>\nBinder即支持IPC也支持RPC。\n\n#### android系统服务列表[基于7.0] ####\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 [传送](http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/)|\n| CAPTIONING_SERVICE | CaptioningManager | 弹幕、字幕管理[传送](http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/) |\n| ACCOUNT_SERVICE | AccountManager | 账户管理器[传送](http://xusx1024.com/2017/08/17/android-system-service-Account-Manager/) |\n| ACTIVITY_SERVICE | ActivityManager | 管理应用程序的系统状态[传送](http://xusx1024.com/2017/09/29/android-system-service-Activity-Manager/) |\n| ALARM_SERVICE | AlarmManager | 闹钟的服务[传送](https://github.com/xusx1024/AndroidSystemServiceSample/tree/master/alarmmanagersample) |\n| AUDIO_SERVICE | AudioManager | 声音管理 |\n| MEDIA_ROUTER_SERVICE | MediaRouter | 扩展屏幕 |\n| BLUETOOTH_SERVICE | BluetoothManager | 蓝牙 |\n| HDMI_CONTROL_SERVICE |  HdmiControlManager | 管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。|\n| CLIPBOARD_SERVICE | ClipboardManager | 剪贴板管理器 |\n| CONNECTIVITY_SERVICE | ConnectivityManager | 网络连接管理器 |\n| COUNTRY_DETECTOR | CountryDetector | 获取用户所在地国家码 |\n| DEVICE_POLICY_SERVICE | DevicePolicyManager | 设备管理器 |\n| DOWNLOAD_SERVICE | DownloadManager | 下载管理器 |\n| BATTERY_SERVICE | BatteryManager | 电池管理器 |\n| NFC_SERVICE | NfcManager | NFC管理器 |\n| DROPBOX_SERVICE | DropBoxManager | 持续化存储系统数据管理器 |\n| INPUT_SERVICE | InputManager | 输入事件管理器如触摸点击etc |\n| DISPLAY_SERVICE | DisplayManager | 显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。 |\n| INPUT_METHOD_SERVICE | InputMethodManager | 输入法管理器 |\n| TEXT_SERVICES_MANAGER_SERVICE | TextServicesManager | 检查拼写管理器 |\n| KEYGUARD_SERVICE | KeyguardManager | 屏保管理器 |\n| LAYOUT_INFLATER_SERVICE | [LayoutInflater](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) | 布局填充管理器 [传送](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) |\n| NETWORK_POLICY_SERVICE | NetworkPolicyManager | 网络链接策略管理器 |\n| NOTIFICATION_SERVICE | NotificationManager | 通知管理器 |\n| NSD_SERVICE | NsdManager | 网络服务发现协议管理器 |\n| POWER_SERVICE | PowerManager | 电源管理器 |\n| RECOVERY_SERVICE | RecoverySystem | 刷机相关的-恢复模式服务 |\n| SEARCH_SERVICE | SearchManager | 搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索 |\n| SENSOR_SERVICE | SensorManager | 传感器管理器 |\n| STATUS_BAR_SERVICE | StatusBarManager | 状态栏管理器 |\n| STORAGE_SERVICE | StorageManager | 磁盘管理器 |\n| TELEPHONY_SERVICE | TelephonyManager | 电话管理器 |\n| TELEPHONY_SUBSCRIPTION_SERVICE | SubscriptionManager | SIM卡管理器 |\n| CARRIER_CONFIG_SERVICE | CarrierConfigManager | 提供对特定于运营商的电话配置值的访问 |\n| TELECOM_SERVICE | TelecomManager | 电话管理器 |\n| UI_MODE_SERVICE | UiModeManager | 夜间模式这样的切换 |\n| USB_SERVICE | UsbManager | USB管理器 |\n| SERIAL_SERVICE | SerialManager | 端口管理器 |\n| VIBRATOR_SERVICE | Vibrator | 振动器管理器 |\n| WALLPAPER_SERVICE | WallpaperManager | 壁纸管理器 |\n| WIFI_SERVICE | WifiManager | 无线网络管理器 |\n| WIFI_P2P_SERVICE | WifiP2pManager | 点对点设备连接管理器，无需连接到网络 |\n| WIFI_NAN_SERVICE | WifiNanManager |  neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。 |\n| WIFI_SCANNING_SERVICE | WifiScanner | wifi扫描管理器 |\n| WIFI_RTT_SERVICE | RttManager | round-trip time (RTT)管理器 |\n| ETHERNET_SERVICE | EthernetManager | 以太网IP配置管理器 |\n| WINDOW_SERVICE | WindowManager | 窗口管理器 |\n| USER_SERVICE | UserManager | 多用户管理器 |\n| APP_OPS_SERVICE | AppOpsManager | Application Operations权限管理器 |\n| CAMERA_SERVICE | CameraManager | 相机管理器 |\n| LAUNCHER_APPS_SERVICE | LauncherApps | 不同用户的不同package管理器 |\n| RESTRICTIONS_SERVICE | RestrictionsManager | 限制管理器 |\n| PRINT_SERVICE | PrintManager | 打印管理器 |\n| CONSUMER_IR_SERVICE | ConsumerIrManager | 红外发射管理器 |\n| MEDIA_SESSION_SERVICE | MediaSessionManager | MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器 |\n| TRUST_SERVICE | TrustManager | 信任证书管理器 |\n| FINGERPRINT_SERVICE | FingerprintManager | 指纹管理器 |\n| TV_INPUT_SERVICE | TvInputManager | 电视管理器 |\n| NETWORK_SCORE_SERVICE | NetworkScoreManager | 网络子系统和网络记分器之间的通信管理器 |\n| USAGE_STATS_SERVICE | UsageStatsManager | 使用情况统计管理器 |\n| NETWORK_STATS_SERVICE | NetworkStatsManager | 流量统计管理器 |\n| JOB_SCHEDULER_SERVICE | JobScheduler | 定时任务管理器 |\n| PERSISTENT_DATA_BLOCK_SERVICE | PersistentDataBlockManager | 持久数据区管理器-出厂设置擦除数据相关 |\n| MEDIA_PROJECTION_SERVICE | MediaProjectionManager | 系统屏幕截图管理器 |\n| APPWIDGET_SERVICE | AppWidgetManager | 桌面组件管理器 |\n| MIDI_SERVICE | MidiManager | （Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。 |\n| RADIO_SERVICE | RadioManager | 收音机管理器 |\n| HARDWARE_PROPERTIES_SERVICE | HardwarePropertiesManager | 硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度 |\n| SOUND_TRIGGER_SERVICE | SoundTriggerManager | 语音识别管理器 |\n| SHORTCUT_SERVICE | ShortcutManager | App Shortcuts是指在桌面长按app图标而出现的快捷方式 |\n| SYSTEM_HEALTH_SERVICE | SystemHealthManager | 系统资源使用情况管理器 |\n| CONTEXTHUB_SERVICE | ContextHubManager | 上下文中心管理器 |\n\n\n \n ","source":"_posts/2017-02-22-android-system-service-all.md","raw":"---\nlayout: post\ntitle:  Android系统服务:服务概览\ndate:   2017-02-22\ncategories: Android System Framework\ntag: android\n---\n \n\n#### 一些说明 ####\n\n这个系列学习的系统服务，绝大多数是`android.app.SystemServiceRegistry`里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层`Application framework`。\n \n![application framework](/images/android-framework.png)\n\n其中核心平台服务包括：\n\n- Context.ACTIVITY_SERVICE -> ActivityManager\n- Context.WINDOW_SERVICE -> WindowManager\n- PackageManagerService [该服务并非在SystemServiceRegistry中注册]\n \n![android start 1](/images/android-start-1.png)\n \n![android start 2](/images/android-start-2.png)\n\n\n对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。\n<br/>\n<br/>\n\n再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。\n\n##### daemon #####\n- USB Daemon(usbd):管理USB连接\n- Android Debug Bridge Daemon(adbd):安卓调试桥链接管理\n- Debugger Daemon(debuggerd):启动Debugger系统\n- Radio Interface Layer Daemon(rild):管理无线通信连接\n\n##### Context Manager ##### \n管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。\n\nContext Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。\n\n同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。\n\n\n##### Media Server #####\n\nMedia Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.\n\n##### Zygote #####\n\nZygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。\n\n##### System Server #####\n\nSystem Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。\n\n##### Binder #####\n\nIPC(InterProcess Communication)进程间通信方式。<br/>\nRPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br/>\nBinder即支持IPC也支持RPC。\n\n#### android系统服务列表[基于7.0] ####\n\n| name | class | note |\n| ------------- |:-------------:| -----:|\n| ACCESSIBILITY_SERVICE | AccessibilityManager | 无障碍辅助服务 [传送](http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/)|\n| CAPTIONING_SERVICE | CaptioningManager | 弹幕、字幕管理[传送](http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/) |\n| ACCOUNT_SERVICE | AccountManager | 账户管理器[传送](http://xusx1024.com/2017/08/17/android-system-service-Account-Manager/) |\n| ACTIVITY_SERVICE | ActivityManager | 管理应用程序的系统状态[传送](http://xusx1024.com/2017/09/29/android-system-service-Activity-Manager/) |\n| ALARM_SERVICE | AlarmManager | 闹钟的服务[传送](https://github.com/xusx1024/AndroidSystemServiceSample/tree/master/alarmmanagersample) |\n| AUDIO_SERVICE | AudioManager | 声音管理 |\n| MEDIA_ROUTER_SERVICE | MediaRouter | 扩展屏幕 |\n| BLUETOOTH_SERVICE | BluetoothManager | 蓝牙 |\n| HDMI_CONTROL_SERVICE |  HdmiControlManager | 管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。|\n| CLIPBOARD_SERVICE | ClipboardManager | 剪贴板管理器 |\n| CONNECTIVITY_SERVICE | ConnectivityManager | 网络连接管理器 |\n| COUNTRY_DETECTOR | CountryDetector | 获取用户所在地国家码 |\n| DEVICE_POLICY_SERVICE | DevicePolicyManager | 设备管理器 |\n| DOWNLOAD_SERVICE | DownloadManager | 下载管理器 |\n| BATTERY_SERVICE | BatteryManager | 电池管理器 |\n| NFC_SERVICE | NfcManager | NFC管理器 |\n| DROPBOX_SERVICE | DropBoxManager | 持续化存储系统数据管理器 |\n| INPUT_SERVICE | InputManager | 输入事件管理器如触摸点击etc |\n| DISPLAY_SERVICE | DisplayManager | 显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。 |\n| INPUT_METHOD_SERVICE | InputMethodManager | 输入法管理器 |\n| TEXT_SERVICES_MANAGER_SERVICE | TextServicesManager | 检查拼写管理器 |\n| KEYGUARD_SERVICE | KeyguardManager | 屏保管理器 |\n| LAYOUT_INFLATER_SERVICE | [LayoutInflater](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) | 布局填充管理器 [传送](http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/) |\n| NETWORK_POLICY_SERVICE | NetworkPolicyManager | 网络链接策略管理器 |\n| NOTIFICATION_SERVICE | NotificationManager | 通知管理器 |\n| NSD_SERVICE | NsdManager | 网络服务发现协议管理器 |\n| POWER_SERVICE | PowerManager | 电源管理器 |\n| RECOVERY_SERVICE | RecoverySystem | 刷机相关的-恢复模式服务 |\n| SEARCH_SERVICE | SearchManager | 搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索 |\n| SENSOR_SERVICE | SensorManager | 传感器管理器 |\n| STATUS_BAR_SERVICE | StatusBarManager | 状态栏管理器 |\n| STORAGE_SERVICE | StorageManager | 磁盘管理器 |\n| TELEPHONY_SERVICE | TelephonyManager | 电话管理器 |\n| TELEPHONY_SUBSCRIPTION_SERVICE | SubscriptionManager | SIM卡管理器 |\n| CARRIER_CONFIG_SERVICE | CarrierConfigManager | 提供对特定于运营商的电话配置值的访问 |\n| TELECOM_SERVICE | TelecomManager | 电话管理器 |\n| UI_MODE_SERVICE | UiModeManager | 夜间模式这样的切换 |\n| USB_SERVICE | UsbManager | USB管理器 |\n| SERIAL_SERVICE | SerialManager | 端口管理器 |\n| VIBRATOR_SERVICE | Vibrator | 振动器管理器 |\n| WALLPAPER_SERVICE | WallpaperManager | 壁纸管理器 |\n| WIFI_SERVICE | WifiManager | 无线网络管理器 |\n| WIFI_P2P_SERVICE | WifiP2pManager | 点对点设备连接管理器，无需连接到网络 |\n| WIFI_NAN_SERVICE | WifiNanManager |  neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。 |\n| WIFI_SCANNING_SERVICE | WifiScanner | wifi扫描管理器 |\n| WIFI_RTT_SERVICE | RttManager | round-trip time (RTT)管理器 |\n| ETHERNET_SERVICE | EthernetManager | 以太网IP配置管理器 |\n| WINDOW_SERVICE | WindowManager | 窗口管理器 |\n| USER_SERVICE | UserManager | 多用户管理器 |\n| APP_OPS_SERVICE | AppOpsManager | Application Operations权限管理器 |\n| CAMERA_SERVICE | CameraManager | 相机管理器 |\n| LAUNCHER_APPS_SERVICE | LauncherApps | 不同用户的不同package管理器 |\n| RESTRICTIONS_SERVICE | RestrictionsManager | 限制管理器 |\n| PRINT_SERVICE | PrintManager | 打印管理器 |\n| CONSUMER_IR_SERVICE | ConsumerIrManager | 红外发射管理器 |\n| MEDIA_SESSION_SERVICE | MediaSessionManager | MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器 |\n| TRUST_SERVICE | TrustManager | 信任证书管理器 |\n| FINGERPRINT_SERVICE | FingerprintManager | 指纹管理器 |\n| TV_INPUT_SERVICE | TvInputManager | 电视管理器 |\n| NETWORK_SCORE_SERVICE | NetworkScoreManager | 网络子系统和网络记分器之间的通信管理器 |\n| USAGE_STATS_SERVICE | UsageStatsManager | 使用情况统计管理器 |\n| NETWORK_STATS_SERVICE | NetworkStatsManager | 流量统计管理器 |\n| JOB_SCHEDULER_SERVICE | JobScheduler | 定时任务管理器 |\n| PERSISTENT_DATA_BLOCK_SERVICE | PersistentDataBlockManager | 持久数据区管理器-出厂设置擦除数据相关 |\n| MEDIA_PROJECTION_SERVICE | MediaProjectionManager | 系统屏幕截图管理器 |\n| APPWIDGET_SERVICE | AppWidgetManager | 桌面组件管理器 |\n| MIDI_SERVICE | MidiManager | （Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。 |\n| RADIO_SERVICE | RadioManager | 收音机管理器 |\n| HARDWARE_PROPERTIES_SERVICE | HardwarePropertiesManager | 硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度 |\n| SOUND_TRIGGER_SERVICE | SoundTriggerManager | 语音识别管理器 |\n| SHORTCUT_SERVICE | ShortcutManager | App Shortcuts是指在桌面长按app图标而出现的快捷方式 |\n| SYSTEM_HEALTH_SERVICE | SystemHealthManager | 系统资源使用情况管理器 |\n| CONTEXTHUB_SERVICE | ContextHubManager | 上下文中心管理器 |\n\n\n \n ","slug":"android-system-service-all","published":1,"updated":"2017-12-19T06:10:27.237Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1cg001n2sivba317muo","content":"<h4 id=\"一些说明\"><a href=\"#一些说明\" class=\"headerlink\" title=\"一些说明\"></a>一些说明</h4><p>这个系列学习的系统服务，绝大多数是<code>android.app.SystemServiceRegistry</code>里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层<code>Application framework</code>。</p>\n<p><img src=\"/images/android-framework.png\" alt=\"application framework\"></p>\n<p>其中核心平台服务包括：</p>\n<ul>\n<li>Context.ACTIVITY_SERVICE -&gt; ActivityManager</li>\n<li>Context.WINDOW_SERVICE -&gt; WindowManager</li>\n<li>PackageManagerService [该服务并非在SystemServiceRegistry中注册]</li>\n</ul>\n<p><img src=\"/images/android-start-1.png\" alt=\"android start 1\"></p>\n<p><img src=\"/images/android-start-2.png\" alt=\"android start 2\"></p>\n<p>对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。<br><br><br><br></p>\n<p>再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。</p>\n<h5 id=\"daemon\"><a href=\"#daemon\" class=\"headerlink\" title=\"daemon\"></a>daemon</h5><ul>\n<li>USB Daemon(usbd):管理USB连接</li>\n<li>Android Debug Bridge Daemon(adbd):安卓调试桥链接管理</li>\n<li>Debugger Daemon(debuggerd):启动Debugger系统</li>\n<li>Radio Interface Layer Daemon(rild):管理无线通信连接</li>\n</ul>\n<h5 id=\"Context-Manager\"><a href=\"#Context-Manager\" class=\"headerlink\" title=\"Context Manager\"></a>Context Manager</h5><p>管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。</p>\n<p>Context Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。</p>\n<p>同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。</p>\n<h5 id=\"Media-Server\"><a href=\"#Media-Server\" class=\"headerlink\" title=\"Media Server\"></a>Media Server</h5><p>Media Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.</p>\n<h5 id=\"Zygote\"><a href=\"#Zygote\" class=\"headerlink\" title=\"Zygote\"></a>Zygote</h5><p>Zygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。</p>\n<h5 id=\"System-Server\"><a href=\"#System-Server\" class=\"headerlink\" title=\"System Server\"></a>System Server</h5><p>System Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。</p>\n<h5 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h5><p>IPC(InterProcess Communication)进程间通信方式。<br><br>RPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br><br>Binder即支持IPC也支持RPC。</p>\n<h4 id=\"android系统服务列表-基于7-0\"><a href=\"#android系统服务列表-基于7-0\" class=\"headerlink\" title=\"android系统服务列表[基于7.0]\"></a>android系统服务列表[基于7.0]</h4><table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务 <a href=\"http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>CAPTIONING_SERVICE</td>\n<td style=\"text-align:center\">CaptioningManager</td>\n<td style=\"text-align:right\">弹幕、字幕管理<a href=\"http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ACCOUNT_SERVICE</td>\n<td style=\"text-align:center\">AccountManager</td>\n<td style=\"text-align:right\">账户管理器<a href=\"http://xusx1024.com/2017/08/17/android-system-service-Account-Manager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ActivityManager</td>\n<td style=\"text-align:right\">管理应用程序的系统状态<a href=\"http://xusx1024.com/2017/09/29/android-system-service-Activity-Manager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td style=\"text-align:center\">AlarmManager</td>\n<td style=\"text-align:right\">闹钟的服务<a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/tree/master/alarmmanagersample\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>AUDIO_SERVICE</td>\n<td style=\"text-align:center\">AudioManager</td>\n<td style=\"text-align:right\">声音管理</td>\n</tr>\n<tr>\n<td>MEDIA_ROUTER_SERVICE</td>\n<td style=\"text-align:center\">MediaRouter</td>\n<td style=\"text-align:right\">扩展屏幕</td>\n</tr>\n<tr>\n<td>BLUETOOTH_SERVICE</td>\n<td style=\"text-align:center\">BluetoothManager</td>\n<td style=\"text-align:right\">蓝牙</td>\n</tr>\n<tr>\n<td>HDMI_CONTROL_SERVICE</td>\n<td style=\"text-align:center\">HdmiControlManager</td>\n<td style=\"text-align:right\">管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。</td>\n</tr>\n<tr>\n<td>CLIPBOARD_SERVICE</td>\n<td style=\"text-align:center\">ClipboardManager</td>\n<td style=\"text-align:right\">剪贴板管理器</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ConnectivityManager</td>\n<td style=\"text-align:right\">网络连接管理器</td>\n</tr>\n<tr>\n<td>COUNTRY_DETECTOR</td>\n<td style=\"text-align:center\">CountryDetector</td>\n<td style=\"text-align:right\">获取用户所在地国家码</td>\n</tr>\n<tr>\n<td>DEVICE_POLICY_SERVICE</td>\n<td style=\"text-align:center\">DevicePolicyManager</td>\n<td style=\"text-align:right\">设备管理器</td>\n</tr>\n<tr>\n<td>DOWNLOAD_SERVICE</td>\n<td style=\"text-align:center\">DownloadManager</td>\n<td style=\"text-align:right\">下载管理器</td>\n</tr>\n<tr>\n<td>BATTERY_SERVICE</td>\n<td style=\"text-align:center\">BatteryManager</td>\n<td style=\"text-align:right\">电池管理器</td>\n</tr>\n<tr>\n<td>NFC_SERVICE</td>\n<td style=\"text-align:center\">NfcManager</td>\n<td style=\"text-align:right\">NFC管理器</td>\n</tr>\n<tr>\n<td>DROPBOX_SERVICE</td>\n<td style=\"text-align:center\">DropBoxManager</td>\n<td style=\"text-align:right\">持续化存储系统数据管理器</td>\n</tr>\n<tr>\n<td>INPUT_SERVICE</td>\n<td style=\"text-align:center\">InputManager</td>\n<td style=\"text-align:right\">输入事件管理器如触摸点击etc</td>\n</tr>\n<tr>\n<td>DISPLAY_SERVICE</td>\n<td style=\"text-align:center\">DisplayManager</td>\n<td style=\"text-align:right\">显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。</td>\n</tr>\n<tr>\n<td>INPUT_METHOD_SERVICE</td>\n<td style=\"text-align:center\">InputMethodManager</td>\n<td style=\"text-align:right\">输入法管理器</td>\n</tr>\n<tr>\n<td>TEXT_SERVICES_MANAGER_SERVICE</td>\n<td style=\"text-align:center\">TextServicesManager</td>\n<td style=\"text-align:right\">检查拼写管理器</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td style=\"text-align:center\">KeyguardManager</td>\n<td style=\"text-align:right\">屏保管理器</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td style=\"text-align:center\"><a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">LayoutInflater</a></td>\n<td style=\"text-align:right\">布局填充管理器 <a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>NETWORK_POLICY_SERVICE</td>\n<td style=\"text-align:center\">NetworkPolicyManager</td>\n<td style=\"text-align:right\">网络链接策略管理器</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td style=\"text-align:center\">NotificationManager</td>\n<td style=\"text-align:right\">通知管理器</td>\n</tr>\n<tr>\n<td>NSD_SERVICE</td>\n<td style=\"text-align:center\">NsdManager</td>\n<td style=\"text-align:right\">网络服务发现协议管理器</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td style=\"text-align:center\">PowerManager</td>\n<td style=\"text-align:right\">电源管理器</td>\n</tr>\n<tr>\n<td>RECOVERY_SERVICE</td>\n<td style=\"text-align:center\">RecoverySystem</td>\n<td style=\"text-align:right\">刷机相关的-恢复模式服务</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td style=\"text-align:center\">SearchManager</td>\n<td style=\"text-align:right\">搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索</td>\n</tr>\n<tr>\n<td>SENSOR_SERVICE</td>\n<td style=\"text-align:center\">SensorManager</td>\n<td style=\"text-align:right\">传感器管理器</td>\n</tr>\n<tr>\n<td>STATUS_BAR_SERVICE</td>\n<td style=\"text-align:center\">StatusBarManager</td>\n<td style=\"text-align:right\">状态栏管理器</td>\n</tr>\n<tr>\n<td>STORAGE_SERVICE</td>\n<td style=\"text-align:center\">StorageManager</td>\n<td style=\"text-align:right\">磁盘管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td style=\"text-align:center\">TelephonyManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SUBSCRIPTION_SERVICE</td>\n<td style=\"text-align:center\">SubscriptionManager</td>\n<td style=\"text-align:right\">SIM卡管理器</td>\n</tr>\n<tr>\n<td>CARRIER_CONFIG_SERVICE</td>\n<td style=\"text-align:center\">CarrierConfigManager</td>\n<td style=\"text-align:right\">提供对特定于运营商的电话配置值的访问</td>\n</tr>\n<tr>\n<td>TELECOM_SERVICE</td>\n<td style=\"text-align:center\">TelecomManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>UI_MODE_SERVICE</td>\n<td style=\"text-align:center\">UiModeManager</td>\n<td style=\"text-align:right\">夜间模式这样的切换</td>\n</tr>\n<tr>\n<td>USB_SERVICE</td>\n<td style=\"text-align:center\">UsbManager</td>\n<td style=\"text-align:right\">USB管理器</td>\n</tr>\n<tr>\n<td>SERIAL_SERVICE</td>\n<td style=\"text-align:center\">SerialManager</td>\n<td style=\"text-align:right\">端口管理器</td>\n</tr>\n<tr>\n<td>VIBRATOR_SERVICE</td>\n<td style=\"text-align:center\">Vibrator</td>\n<td style=\"text-align:right\">振动器管理器</td>\n</tr>\n<tr>\n<td>WALLPAPER_SERVICE</td>\n<td style=\"text-align:center\">WallpaperManager</td>\n<td style=\"text-align:right\">壁纸管理器</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td style=\"text-align:center\">WifiManager</td>\n<td style=\"text-align:right\">无线网络管理器</td>\n</tr>\n<tr>\n<td>WIFI_P2P_SERVICE</td>\n<td style=\"text-align:center\">WifiP2pManager</td>\n<td style=\"text-align:right\">点对点设备连接管理器，无需连接到网络</td>\n</tr>\n<tr>\n<td>WIFI_NAN_SERVICE</td>\n<td style=\"text-align:center\">WifiNanManager</td>\n<td style=\"text-align:right\">neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。</td>\n</tr>\n<tr>\n<td>WIFI_SCANNING_SERVICE</td>\n<td style=\"text-align:center\">WifiScanner</td>\n<td style=\"text-align:right\">wifi扫描管理器</td>\n</tr>\n<tr>\n<td>WIFI_RTT_SERVICE</td>\n<td style=\"text-align:center\">RttManager</td>\n<td style=\"text-align:right\">round-trip time (RTT)管理器</td>\n</tr>\n<tr>\n<td>ETHERNET_SERVICE</td>\n<td style=\"text-align:center\">EthernetManager</td>\n<td style=\"text-align:right\">以太网IP配置管理器</td>\n</tr>\n<tr>\n<td>WINDOW_SERVICE</td>\n<td style=\"text-align:center\">WindowManager</td>\n<td style=\"text-align:right\">窗口管理器</td>\n</tr>\n<tr>\n<td>USER_SERVICE</td>\n<td style=\"text-align:center\">UserManager</td>\n<td style=\"text-align:right\">多用户管理器</td>\n</tr>\n<tr>\n<td>APP_OPS_SERVICE</td>\n<td style=\"text-align:center\">AppOpsManager</td>\n<td style=\"text-align:right\">Application Operations权限管理器</td>\n</tr>\n<tr>\n<td>CAMERA_SERVICE</td>\n<td style=\"text-align:center\">CameraManager</td>\n<td style=\"text-align:right\">相机管理器</td>\n</tr>\n<tr>\n<td>LAUNCHER_APPS_SERVICE</td>\n<td style=\"text-align:center\">LauncherApps</td>\n<td style=\"text-align:right\">不同用户的不同package管理器</td>\n</tr>\n<tr>\n<td>RESTRICTIONS_SERVICE</td>\n<td style=\"text-align:center\">RestrictionsManager</td>\n<td style=\"text-align:right\">限制管理器</td>\n</tr>\n<tr>\n<td>PRINT_SERVICE</td>\n<td style=\"text-align:center\">PrintManager</td>\n<td style=\"text-align:right\">打印管理器</td>\n</tr>\n<tr>\n<td>CONSUMER_IR_SERVICE</td>\n<td style=\"text-align:center\">ConsumerIrManager</td>\n<td style=\"text-align:right\">红外发射管理器</td>\n</tr>\n<tr>\n<td>MEDIA_SESSION_SERVICE</td>\n<td style=\"text-align:center\">MediaSessionManager</td>\n<td style=\"text-align:right\">MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器</td>\n</tr>\n<tr>\n<td>TRUST_SERVICE</td>\n<td style=\"text-align:center\">TrustManager</td>\n<td style=\"text-align:right\">信任证书管理器</td>\n</tr>\n<tr>\n<td>FINGERPRINT_SERVICE</td>\n<td style=\"text-align:center\">FingerprintManager</td>\n<td style=\"text-align:right\">指纹管理器</td>\n</tr>\n<tr>\n<td>TV_INPUT_SERVICE</td>\n<td style=\"text-align:center\">TvInputManager</td>\n<td style=\"text-align:right\">电视管理器</td>\n</tr>\n<tr>\n<td>NETWORK_SCORE_SERVICE</td>\n<td style=\"text-align:center\">NetworkScoreManager</td>\n<td style=\"text-align:right\">网络子系统和网络记分器之间的通信管理器</td>\n</tr>\n<tr>\n<td>USAGE_STATS_SERVICE</td>\n<td style=\"text-align:center\">UsageStatsManager</td>\n<td style=\"text-align:right\">使用情况统计管理器</td>\n</tr>\n<tr>\n<td>NETWORK_STATS_SERVICE</td>\n<td style=\"text-align:center\">NetworkStatsManager</td>\n<td style=\"text-align:right\">流量统计管理器</td>\n</tr>\n<tr>\n<td>JOB_SCHEDULER_SERVICE</td>\n<td style=\"text-align:center\">JobScheduler</td>\n<td style=\"text-align:right\">定时任务管理器</td>\n</tr>\n<tr>\n<td>PERSISTENT_DATA_BLOCK_SERVICE</td>\n<td style=\"text-align:center\">PersistentDataBlockManager</td>\n<td style=\"text-align:right\">持久数据区管理器-出厂设置擦除数据相关</td>\n</tr>\n<tr>\n<td>MEDIA_PROJECTION_SERVICE</td>\n<td style=\"text-align:center\">MediaProjectionManager</td>\n<td style=\"text-align:right\">系统屏幕截图管理器</td>\n</tr>\n<tr>\n<td>APPWIDGET_SERVICE</td>\n<td style=\"text-align:center\">AppWidgetManager</td>\n<td style=\"text-align:right\">桌面组件管理器</td>\n</tr>\n<tr>\n<td>MIDI_SERVICE</td>\n<td style=\"text-align:center\">MidiManager</td>\n<td style=\"text-align:right\">（Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。</td>\n</tr>\n<tr>\n<td>RADIO_SERVICE</td>\n<td style=\"text-align:center\">RadioManager</td>\n<td style=\"text-align:right\">收音机管理器</td>\n</tr>\n<tr>\n<td>HARDWARE_PROPERTIES_SERVICE</td>\n<td style=\"text-align:center\">HardwarePropertiesManager</td>\n<td style=\"text-align:right\">硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度</td>\n</tr>\n<tr>\n<td>SOUND_TRIGGER_SERVICE</td>\n<td style=\"text-align:center\">SoundTriggerManager</td>\n<td style=\"text-align:right\">语音识别管理器</td>\n</tr>\n<tr>\n<td>SHORTCUT_SERVICE</td>\n<td style=\"text-align:center\">ShortcutManager</td>\n<td style=\"text-align:right\">App Shortcuts是指在桌面长按app图标而出现的快捷方式</td>\n</tr>\n<tr>\n<td>SYSTEM_HEALTH_SERVICE</td>\n<td style=\"text-align:center\">SystemHealthManager</td>\n<td style=\"text-align:right\">系统资源使用情况管理器</td>\n</tr>\n<tr>\n<td>CONTEXTHUB_SERVICE</td>\n<td style=\"text-align:center\">ContextHubManager</td>\n<td style=\"text-align:right\">上下文中心管理器</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"一些说明\"><a href=\"#一些说明\" class=\"headerlink\" title=\"一些说明\"></a>一些说明</h4><p>这个系列学习的系统服务，绝大多数是<code>android.app.SystemServiceRegistry</code>里面注册的，包括核心平台服务以及硬件服务。如图，集中在第二层<code>Application framework</code>。</p>\n<p><img src=\"/images/android-framework.png\" alt=\"application framework\"></p>\n<p>其中核心平台服务包括：</p>\n<ul>\n<li>Context.ACTIVITY_SERVICE -&gt; ActivityManager</li>\n<li>Context.WINDOW_SERVICE -&gt; WindowManager</li>\n<li>PackageManagerService [该服务并非在SystemServiceRegistry中注册]</li>\n</ul>\n<p><img src=\"/images/android-start-1.png\" alt=\"android start 1\"></p>\n<p><img src=\"/images/android-start-2.png\" alt=\"android start 2\"></p>\n<p>对比图一和图二，发现对本地系统服务和java系统服务定义是相反的，由于本地系统服务由C/C++编写，所以判定图一的定义是正确的。保留图二的原因是，图二展示了android系统init后的更多信息。<br><br><br><br></p>\n<p>再来看图二，android init进程是对各种设备进行初始化，运行android framework所需要的各种daemon ，Context Manager，Media Serve, Zygote。</p>\n<h5 id=\"daemon\"><a href=\"#daemon\" class=\"headerlink\" title=\"daemon\"></a>daemon</h5><ul>\n<li>USB Daemon(usbd):管理USB连接</li>\n<li>Android Debug Bridge Daemon(adbd):安卓调试桥链接管理</li>\n<li>Debugger Daemon(debuggerd):启动Debugger系统</li>\n<li>Radio Interface Layer Daemon(rild):管理无线通信连接</li>\n</ul>\n<h5 id=\"Context-Manager\"><a href=\"#Context-Manager\" class=\"headerlink\" title=\"Context Manager\"></a>Context Manager</h5><p>管理android系统服务的重要进程。系统服务是组成Android Framework的重要组件，提供从相机、音频、视频处理到应用程序制作所有重要API。</p>\n<p>Context Manager提供运行与Android的各种系统服务的查询信息。应用程序或者Framework模块调用系统服务时，都要通过Binder IPC向Context Manager进行查询申请，获得相应的系统服务的信息。</p>\n<p>同样，Android的系统服务也要通过Bindr IPC向Context Manager注册自己的Handle信息，以供查询。</p>\n<h5 id=\"Media-Server\"><a href=\"#Media-Server\" class=\"headerlink\" title=\"Media Server\"></a>Media Server</h5><p>Media Server运行基于C/C++的本地系统服务，如Audio Flinger,Camera,Media play service.</p>\n<h5 id=\"Zygote\"><a href=\"#Zygote\" class=\"headerlink\" title=\"Zygote\"></a>Zygote</h5><p>Zygote用于缩短android应用程序的加载时间，每当执行java应用程序时候，Zygote就会派生一个子进程，这个子进程就是用来执行java程序的虚拟机。</p>\n<h5 id=\"System-Server\"><a href=\"#System-Server\" class=\"headerlink\" title=\"System Server\"></a>System Server</h5><p>System Server是Android的一个系统进程，它是由Zygote创建的，在Android的启动过程中，位于Zygote之后。在System Server中可以看到它建立了android中的大部分服务，这些java层的系统服务需要通过JNI注册到ContextManager中去。</p>\n<h5 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h5><p>IPC(InterProcess Communication)进程间通信方式。<br><br>RPC:远程过程调用就是一种在两个原本相互独立的进程间建立一种类似于单个程序内函数间调用的函数调用机制。<br><br>Binder即支持IPC也支持RPC。</p>\n<h4 id=\"android系统服务列表-基于7-0\"><a href=\"#android系统服务列表-基于7-0\" class=\"headerlink\" title=\"android系统服务列表[基于7.0]\"></a>android系统服务列表[基于7.0]</h4><table>\n<thead>\n<tr>\n<th>name</th>\n<th style=\"text-align:center\">class</th>\n<th style=\"text-align:right\">note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACCESSIBILITY_SERVICE</td>\n<td style=\"text-align:center\">AccessibilityManager</td>\n<td style=\"text-align:right\">无障碍辅助服务 <a href=\"http://xusx1024.com/2017/04/20/android-system-service-AccessibilityManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>CAPTIONING_SERVICE</td>\n<td style=\"text-align:center\">CaptioningManager</td>\n<td style=\"text-align:right\">弹幕、字幕管理<a href=\"http://xusx1024.com/2017/05/18/android-system-service-CaptioningManager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ACCOUNT_SERVICE</td>\n<td style=\"text-align:center\">AccountManager</td>\n<td style=\"text-align:right\">账户管理器<a href=\"http://xusx1024.com/2017/08/17/android-system-service-Account-Manager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ACTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ActivityManager</td>\n<td style=\"text-align:right\">管理应用程序的系统状态<a href=\"http://xusx1024.com/2017/09/29/android-system-service-Activity-Manager/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>ALARM_SERVICE</td>\n<td style=\"text-align:center\">AlarmManager</td>\n<td style=\"text-align:right\">闹钟的服务<a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/tree/master/alarmmanagersample\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>AUDIO_SERVICE</td>\n<td style=\"text-align:center\">AudioManager</td>\n<td style=\"text-align:right\">声音管理</td>\n</tr>\n<tr>\n<td>MEDIA_ROUTER_SERVICE</td>\n<td style=\"text-align:center\">MediaRouter</td>\n<td style=\"text-align:right\">扩展屏幕</td>\n</tr>\n<tr>\n<td>BLUETOOTH_SERVICE</td>\n<td style=\"text-align:center\">BluetoothManager</td>\n<td style=\"text-align:right\">蓝牙</td>\n</tr>\n<tr>\n<td>HDMI_CONTROL_SERVICE</td>\n<td style=\"text-align:center\">HdmiControlManager</td>\n<td style=\"text-align:right\">管理所有的HDMI-CEC设备  HDMI-CEC标准允许多媒体消费产品之间沟通和交换信息， HDMI-CEC支持许多功能，比如遥控器直通，系统音频控制，一键播放等等。</td>\n</tr>\n<tr>\n<td>CLIPBOARD_SERVICE</td>\n<td style=\"text-align:center\">ClipboardManager</td>\n<td style=\"text-align:right\">剪贴板管理器</td>\n</tr>\n<tr>\n<td>CONNECTIVITY_SERVICE</td>\n<td style=\"text-align:center\">ConnectivityManager</td>\n<td style=\"text-align:right\">网络连接管理器</td>\n</tr>\n<tr>\n<td>COUNTRY_DETECTOR</td>\n<td style=\"text-align:center\">CountryDetector</td>\n<td style=\"text-align:right\">获取用户所在地国家码</td>\n</tr>\n<tr>\n<td>DEVICE_POLICY_SERVICE</td>\n<td style=\"text-align:center\">DevicePolicyManager</td>\n<td style=\"text-align:right\">设备管理器</td>\n</tr>\n<tr>\n<td>DOWNLOAD_SERVICE</td>\n<td style=\"text-align:center\">DownloadManager</td>\n<td style=\"text-align:right\">下载管理器</td>\n</tr>\n<tr>\n<td>BATTERY_SERVICE</td>\n<td style=\"text-align:center\">BatteryManager</td>\n<td style=\"text-align:right\">电池管理器</td>\n</tr>\n<tr>\n<td>NFC_SERVICE</td>\n<td style=\"text-align:center\">NfcManager</td>\n<td style=\"text-align:right\">NFC管理器</td>\n</tr>\n<tr>\n<td>DROPBOX_SERVICE</td>\n<td style=\"text-align:center\">DropBoxManager</td>\n<td style=\"text-align:right\">持续化存储系统数据管理器</td>\n</tr>\n<tr>\n<td>INPUT_SERVICE</td>\n<td style=\"text-align:center\">InputManager</td>\n<td style=\"text-align:right\">输入事件管理器如触摸点击etc</td>\n</tr>\n<tr>\n<td>DISPLAY_SERVICE</td>\n<td style=\"text-align:center\">DisplayManager</td>\n<td style=\"text-align:right\">显示管理，支持多种显示类型的多个显示器的镜像显示，包括内建的显示类型（本地）、HDMI显示类型以及支持WIFI Display 协议( MIRACAST)，实现本地设备在远程显示器上的镜像显示。</td>\n</tr>\n<tr>\n<td>INPUT_METHOD_SERVICE</td>\n<td style=\"text-align:center\">InputMethodManager</td>\n<td style=\"text-align:right\">输入法管理器</td>\n</tr>\n<tr>\n<td>TEXT_SERVICES_MANAGER_SERVICE</td>\n<td style=\"text-align:center\">TextServicesManager</td>\n<td style=\"text-align:right\">检查拼写管理器</td>\n</tr>\n<tr>\n<td>KEYGUARD_SERVICE</td>\n<td style=\"text-align:center\">KeyguardManager</td>\n<td style=\"text-align:right\">屏保管理器</td>\n</tr>\n<tr>\n<td>LAYOUT_INFLATER_SERVICE</td>\n<td style=\"text-align:center\"><a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">LayoutInflater</a></td>\n<td style=\"text-align:right\">布局填充管理器 <a href=\"http://xusx1024.com/2017/02/23/android-system-service-LayoutInflater/\" target=\"_blank\" rel=\"external\">传送</a></td>\n</tr>\n<tr>\n<td>NETWORK_POLICY_SERVICE</td>\n<td style=\"text-align:center\">NetworkPolicyManager</td>\n<td style=\"text-align:right\">网络链接策略管理器</td>\n</tr>\n<tr>\n<td>NOTIFICATION_SERVICE</td>\n<td style=\"text-align:center\">NotificationManager</td>\n<td style=\"text-align:right\">通知管理器</td>\n</tr>\n<tr>\n<td>NSD_SERVICE</td>\n<td style=\"text-align:center\">NsdManager</td>\n<td style=\"text-align:right\">网络服务发现协议管理器</td>\n</tr>\n<tr>\n<td>POWER_SERVICE</td>\n<td style=\"text-align:center\">PowerManager</td>\n<td style=\"text-align:right\">电源管理器</td>\n</tr>\n<tr>\n<td>RECOVERY_SERVICE</td>\n<td style=\"text-align:center\">RecoverySystem</td>\n<td style=\"text-align:right\">刷机相关的-恢复模式服务</td>\n</tr>\n<tr>\n<td>SEARCH_SERVICE</td>\n<td style=\"text-align:center\">SearchManager</td>\n<td style=\"text-align:right\">搜索服务，利用此服务可以实现对系统中的应用、联系人、SMS等进行搜索，也提供转入浏览器中的搜索</td>\n</tr>\n<tr>\n<td>SENSOR_SERVICE</td>\n<td style=\"text-align:center\">SensorManager</td>\n<td style=\"text-align:right\">传感器管理器</td>\n</tr>\n<tr>\n<td>STATUS_BAR_SERVICE</td>\n<td style=\"text-align:center\">StatusBarManager</td>\n<td style=\"text-align:right\">状态栏管理器</td>\n</tr>\n<tr>\n<td>STORAGE_SERVICE</td>\n<td style=\"text-align:center\">StorageManager</td>\n<td style=\"text-align:right\">磁盘管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SERVICE</td>\n<td style=\"text-align:center\">TelephonyManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>TELEPHONY_SUBSCRIPTION_SERVICE</td>\n<td style=\"text-align:center\">SubscriptionManager</td>\n<td style=\"text-align:right\">SIM卡管理器</td>\n</tr>\n<tr>\n<td>CARRIER_CONFIG_SERVICE</td>\n<td style=\"text-align:center\">CarrierConfigManager</td>\n<td style=\"text-align:right\">提供对特定于运营商的电话配置值的访问</td>\n</tr>\n<tr>\n<td>TELECOM_SERVICE</td>\n<td style=\"text-align:center\">TelecomManager</td>\n<td style=\"text-align:right\">电话管理器</td>\n</tr>\n<tr>\n<td>UI_MODE_SERVICE</td>\n<td style=\"text-align:center\">UiModeManager</td>\n<td style=\"text-align:right\">夜间模式这样的切换</td>\n</tr>\n<tr>\n<td>USB_SERVICE</td>\n<td style=\"text-align:center\">UsbManager</td>\n<td style=\"text-align:right\">USB管理器</td>\n</tr>\n<tr>\n<td>SERIAL_SERVICE</td>\n<td style=\"text-align:center\">SerialManager</td>\n<td style=\"text-align:right\">端口管理器</td>\n</tr>\n<tr>\n<td>VIBRATOR_SERVICE</td>\n<td style=\"text-align:center\">Vibrator</td>\n<td style=\"text-align:right\">振动器管理器</td>\n</tr>\n<tr>\n<td>WALLPAPER_SERVICE</td>\n<td style=\"text-align:center\">WallpaperManager</td>\n<td style=\"text-align:right\">壁纸管理器</td>\n</tr>\n<tr>\n<td>WIFI_SERVICE</td>\n<td style=\"text-align:center\">WifiManager</td>\n<td style=\"text-align:right\">无线网络管理器</td>\n</tr>\n<tr>\n<td>WIFI_P2P_SERVICE</td>\n<td style=\"text-align:center\">WifiP2pManager</td>\n<td style=\"text-align:right\">点对点设备连接管理器，无需连接到网络</td>\n</tr>\n<tr>\n<td>WIFI_NAN_SERVICE</td>\n<td style=\"text-align:center\">WifiNanManager</td>\n<td style=\"text-align:right\">neighborhood area network (NAN)的管理器- 邻区网（NAN）是Wi-Fi热点和无线局域网（WLAN）的分支，使用户能够以非常小的费用快速连接到互联网。</td>\n</tr>\n<tr>\n<td>WIFI_SCANNING_SERVICE</td>\n<td style=\"text-align:center\">WifiScanner</td>\n<td style=\"text-align:right\">wifi扫描管理器</td>\n</tr>\n<tr>\n<td>WIFI_RTT_SERVICE</td>\n<td style=\"text-align:center\">RttManager</td>\n<td style=\"text-align:right\">round-trip time (RTT)管理器</td>\n</tr>\n<tr>\n<td>ETHERNET_SERVICE</td>\n<td style=\"text-align:center\">EthernetManager</td>\n<td style=\"text-align:right\">以太网IP配置管理器</td>\n</tr>\n<tr>\n<td>WINDOW_SERVICE</td>\n<td style=\"text-align:center\">WindowManager</td>\n<td style=\"text-align:right\">窗口管理器</td>\n</tr>\n<tr>\n<td>USER_SERVICE</td>\n<td style=\"text-align:center\">UserManager</td>\n<td style=\"text-align:right\">多用户管理器</td>\n</tr>\n<tr>\n<td>APP_OPS_SERVICE</td>\n<td style=\"text-align:center\">AppOpsManager</td>\n<td style=\"text-align:right\">Application Operations权限管理器</td>\n</tr>\n<tr>\n<td>CAMERA_SERVICE</td>\n<td style=\"text-align:center\">CameraManager</td>\n<td style=\"text-align:right\">相机管理器</td>\n</tr>\n<tr>\n<td>LAUNCHER_APPS_SERVICE</td>\n<td style=\"text-align:center\">LauncherApps</td>\n<td style=\"text-align:right\">不同用户的不同package管理器</td>\n</tr>\n<tr>\n<td>RESTRICTIONS_SERVICE</td>\n<td style=\"text-align:center\">RestrictionsManager</td>\n<td style=\"text-align:right\">限制管理器</td>\n</tr>\n<tr>\n<td>PRINT_SERVICE</td>\n<td style=\"text-align:center\">PrintManager</td>\n<td style=\"text-align:right\">打印管理器</td>\n</tr>\n<tr>\n<td>CONSUMER_IR_SERVICE</td>\n<td style=\"text-align:center\">ConsumerIrManager</td>\n<td style=\"text-align:right\">红外发射管理器</td>\n</tr>\n<tr>\n<td>MEDIA_SESSION_SERVICE</td>\n<td style=\"text-align:center\">MediaSessionManager</td>\n<td style=\"text-align:right\">MediaSession概念用于播放器与控制器之间进行交互，媒体回话管理器</td>\n</tr>\n<tr>\n<td>TRUST_SERVICE</td>\n<td style=\"text-align:center\">TrustManager</td>\n<td style=\"text-align:right\">信任证书管理器</td>\n</tr>\n<tr>\n<td>FINGERPRINT_SERVICE</td>\n<td style=\"text-align:center\">FingerprintManager</td>\n<td style=\"text-align:right\">指纹管理器</td>\n</tr>\n<tr>\n<td>TV_INPUT_SERVICE</td>\n<td style=\"text-align:center\">TvInputManager</td>\n<td style=\"text-align:right\">电视管理器</td>\n</tr>\n<tr>\n<td>NETWORK_SCORE_SERVICE</td>\n<td style=\"text-align:center\">NetworkScoreManager</td>\n<td style=\"text-align:right\">网络子系统和网络记分器之间的通信管理器</td>\n</tr>\n<tr>\n<td>USAGE_STATS_SERVICE</td>\n<td style=\"text-align:center\">UsageStatsManager</td>\n<td style=\"text-align:right\">使用情况统计管理器</td>\n</tr>\n<tr>\n<td>NETWORK_STATS_SERVICE</td>\n<td style=\"text-align:center\">NetworkStatsManager</td>\n<td style=\"text-align:right\">流量统计管理器</td>\n</tr>\n<tr>\n<td>JOB_SCHEDULER_SERVICE</td>\n<td style=\"text-align:center\">JobScheduler</td>\n<td style=\"text-align:right\">定时任务管理器</td>\n</tr>\n<tr>\n<td>PERSISTENT_DATA_BLOCK_SERVICE</td>\n<td style=\"text-align:center\">PersistentDataBlockManager</td>\n<td style=\"text-align:right\">持久数据区管理器-出厂设置擦除数据相关</td>\n</tr>\n<tr>\n<td>MEDIA_PROJECTION_SERVICE</td>\n<td style=\"text-align:center\">MediaProjectionManager</td>\n<td style=\"text-align:right\">系统屏幕截图管理器</td>\n</tr>\n<tr>\n<td>APPWIDGET_SERVICE</td>\n<td style=\"text-align:center\">AppWidgetManager</td>\n<td style=\"text-align:right\">桌面组件管理器</td>\n</tr>\n<tr>\n<td>MIDI_SERVICE</td>\n<td style=\"text-align:center\">MidiManager</td>\n<td style=\"text-align:right\">（Musical Instrument Digital Interface，简称MIDI）是一个工业标准的电子通信协议.为电子乐器等演奏设备（如合成器）定义各种音符或弹奏码，容许电子乐器、电脑、手机或其它的舞台演出配备彼此连接，调整和同步，得以即时交换演奏数据。MIDI不发送声音，只发送像是音调和音乐强度的数据，音量，颤音和相位[1]等参数的控制信号，还有设置节奏的时钟信号。 比如钢琴学习应用。</td>\n</tr>\n<tr>\n<td>RADIO_SERVICE</td>\n<td style=\"text-align:center\">RadioManager</td>\n<td style=\"text-align:right\">收音机管理器</td>\n</tr>\n<tr>\n<td>HARDWARE_PROPERTIES_SERVICE</td>\n<td style=\"text-align:center\">HardwarePropertiesManager</td>\n<td style=\"text-align:right\">硬件属性管理器-CPU,GPU,电池温度,CPU各个核的使用,风扇速度</td>\n</tr>\n<tr>\n<td>SOUND_TRIGGER_SERVICE</td>\n<td style=\"text-align:center\">SoundTriggerManager</td>\n<td style=\"text-align:right\">语音识别管理器</td>\n</tr>\n<tr>\n<td>SHORTCUT_SERVICE</td>\n<td style=\"text-align:center\">ShortcutManager</td>\n<td style=\"text-align:right\">App Shortcuts是指在桌面长按app图标而出现的快捷方式</td>\n</tr>\n<tr>\n<td>SYSTEM_HEALTH_SERVICE</td>\n<td style=\"text-align:center\">SystemHealthManager</td>\n<td style=\"text-align:right\">系统资源使用情况管理器</td>\n</tr>\n<tr>\n<td>CONTEXTHUB_SERVICE</td>\n<td style=\"text-align:center\">ContextHubManager</td>\n<td style=\"text-align:right\">上下文中心管理器</td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"Java并发中的关键字：volatile","date":"2017-02-23T00:00:00.000Z","_content":" \n\n \n#### 基础知识 ####\n\n第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br/>\n\n##### 为什么需要锁 #####\n\n![为什么需要锁](/images/why_need_lock.jpg)\n\n由上图，两颗CPU都在修改内存的变量，导致其计数有误。\n\n##### 锁(lock) #####\n锁是用来做并发最简单的方式，当然其代价也是最高的。`内核态的锁`的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。`用户态的锁`避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br/>\n\nJDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用`独占的方式`来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。\n\n###### 悲观锁 ######\n\n独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。\n\n###### 乐观锁 ######\n\n比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。\nCAS乐观锁算法如图：\nCAS比较与交换的伪代码可以表示为：\n\n\tdo{\n\t备份旧数据\n\t基于旧数据构造新数据\n\t}while(!CAS(内存地址，备份的旧数据，新数据))\n\n![CAS乐观锁](/images/cas.png)\n\n##### 原子操作(atomic operations) #####\n\n- 所有的原始类型的赋值，long和double除外；\n- 所有引用的赋值；\n- 所有java.concurrent.Atomic*中类中的操作\n- 所有volatile修饰的long和double\n\n为什么long型赋值不是原子操作呢？\n\n事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：\n\t\n\tprivate volatile long foo;\n\n因为volatile内部已经做了synchronized.\n\n\n##### 线程与内存的交互 #####\n\n每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：\n\n![线程与内存的交互](/images/thread-read-write.jpg)\n其中use and assign 可以多次出现\n\n\n##### volatile #####\n\nvolatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br/>\nvolatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br/>\nvolatile能替代简单的锁，却不能保证原子性。<br/>\n\n##### 内存屏障-Memory Barrier #####\n\n内存屏障是一个CPU指令。\n1.  确保一些特定操作执行的顺序；\n2.  影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。\n\n<br/>\n\n如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br/>\n\n由`线程和内存交互的图`，可得：\n\n\t[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n \n可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说`volatile不能保证原子性。`这同时说明：`volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的`。\n\n#### voaltile 使用场景及模式 ####\n\t\n\t要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\t \n\tAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n\n##### 模式1：状态标志 #####\n\n也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。\n\t\n\tvolatile boolean shutdownRequested;\n\t\n\t...\n\t\n\tpublic void shutdown() { shutdownRequested = true; }\n\t\n\tpublic void doWork() { \n\t    while (!shutdownRequested) { \n\t        // do stuff\n\t    }\n\t}\n\n这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。\n\n\n##### 模式2：一次性安全发布(one time safe publication) #####\n\n缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。\n\n实现安全发布对象的一种技术就是将对象引用定义为volatile类型。\n\t\n\tpublic class BackgroundFloobleLoader {\n\t    public volatile Flooble theFlooble;\n\t    public void initInBackground() {\n\t        // do lots of stuff\n\t        theFlooble = new Flooble();  // this is the only write to theFlooble\n\t    }\n\t}\n\t\n\tpublic class SomeOtherClass {\n\t    public void doWork() {\n\t        while (true) { \n\t            // do some stuff...\n\t            // use the Flooble, but only if it is ready\n\t            if (floobleLoader.theFlooble != null) \n\t                doSomething(floobleLoader.theFlooble);\n\t        }\n\t    }\n\t}\n\n\n该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。\n\n\n##### 模式3：独立观察(independent observation) #####\n\n安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。\n\t\n\tpublic class UserManager {\n\t    public volatile String lastUser;\n\t\n\t    public boolean authenticate(String user, String password) {\n\t        boolean valid = passwordIsValid(user, password);\n\t        if (valid) {\n\t            User u = new User();\n\t            activeUsers.add(u);\n\t            lastUser = user;\n\t        }\n\t        return valid;\n\t    }\n\t}\n\n该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。\n\n##### 模式4：volatile bean 模式 #####\n\nvolatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br/>\n在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。\n\n\t@ThreadSafe\n\tpublic class Person {\n\t    private volatile String firstName;\n\t    private volatile String lastName;\n\t    private volatile int age;\n\t\n\t    public String getFirstName() { return firstName; }\n\t    public String getLastName() { return lastName; }\n\t    public int getAge() { return age; }\n\t\n\t    public void setFirstName(String firstName) { \n\t        this.firstName = firstName;\n\t    }\n\t\n\t    public void setLastName(String lastName) { \n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public void setAge(int age) { \n\t        this.age = age;\n\t    }\n\t}\n\n##### 模式5：volatile 高级模式，开销较低的读-写锁策略 #####\n\n如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。\n\n\t@ThreadSafe\n\tpublic class CheesyCounter {\n\t    // Employs the cheap read-write lock trick\n\t    // All mutative operations MUST be done with the 'this' lock held\n\t    @GuardedBy(\"this\") private volatile int value;\n\t\n\t    public int getValue() { return value; }\n\t\n\t    public synchronized int increment() {\n\t        return value++;\n\t    }\n\t}\n\n上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。\n\n\n#### voaltile 与 static ####\n\nvolatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；\n\nstatic，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。\n\n ","source":"_posts/2017-02-23-java-volatile.md","raw":"---\nlayout: post\ntitle:  Java并发中的关键字：volatile\ndate:   2017-02-23\ncategories: JAVA & kotlin\ntag: 杂项\n---\n \n\n \n#### 基础知识 ####\n\n第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br/>\n\n##### 为什么需要锁 #####\n\n![为什么需要锁](/images/why_need_lock.jpg)\n\n由上图，两颗CPU都在修改内存的变量，导致其计数有误。\n\n##### 锁(lock) #####\n锁是用来做并发最简单的方式，当然其代价也是最高的。`内核态的锁`的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。`用户态的锁`避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br/>\n\nJDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用`独占的方式`来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。\n\n###### 悲观锁 ######\n\n独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。\n\n###### 乐观锁 ######\n\n比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。\nCAS乐观锁算法如图：\nCAS比较与交换的伪代码可以表示为：\n\n\tdo{\n\t备份旧数据\n\t基于旧数据构造新数据\n\t}while(!CAS(内存地址，备份的旧数据，新数据))\n\n![CAS乐观锁](/images/cas.png)\n\n##### 原子操作(atomic operations) #####\n\n- 所有的原始类型的赋值，long和double除外；\n- 所有引用的赋值；\n- 所有java.concurrent.Atomic*中类中的操作\n- 所有volatile修饰的long和double\n\n为什么long型赋值不是原子操作呢？\n\n事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：\n\t\n\tprivate volatile long foo;\n\n因为volatile内部已经做了synchronized.\n\n\n##### 线程与内存的交互 #####\n\n每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：\n\n![线程与内存的交互](/images/thread-read-write.jpg)\n其中use and assign 可以多次出现\n\n\n##### volatile #####\n\nvolatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br/>\nvolatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br/>\nvolatile能替代简单的锁，却不能保证原子性。<br/>\n\n##### 内存屏障-Memory Barrier #####\n\n内存屏障是一个CPU指令。\n1.  确保一些特定操作执行的顺序；\n2.  影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。\n\n<br/>\n\n如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br/>\n\n由`线程和内存交互的图`，可得：\n\n\t[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n \n可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说`volatile不能保证原子性。`这同时说明：`volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的`。\n\n#### voaltile 使用场景及模式 ####\n\t\n\t要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\t \n\tAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n\n##### 模式1：状态标志 #####\n\n也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。\n\t\n\tvolatile boolean shutdownRequested;\n\t\n\t...\n\t\n\tpublic void shutdown() { shutdownRequested = true; }\n\t\n\tpublic void doWork() { \n\t    while (!shutdownRequested) { \n\t        // do stuff\n\t    }\n\t}\n\n这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。\n\n\n##### 模式2：一次性安全发布(one time safe publication) #####\n\n缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。\n\n实现安全发布对象的一种技术就是将对象引用定义为volatile类型。\n\t\n\tpublic class BackgroundFloobleLoader {\n\t    public volatile Flooble theFlooble;\n\t    public void initInBackground() {\n\t        // do lots of stuff\n\t        theFlooble = new Flooble();  // this is the only write to theFlooble\n\t    }\n\t}\n\t\n\tpublic class SomeOtherClass {\n\t    public void doWork() {\n\t        while (true) { \n\t            // do some stuff...\n\t            // use the Flooble, but only if it is ready\n\t            if (floobleLoader.theFlooble != null) \n\t                doSomething(floobleLoader.theFlooble);\n\t        }\n\t    }\n\t}\n\n\n该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。\n\n\n##### 模式3：独立观察(independent observation) #####\n\n安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。\n\t\n\tpublic class UserManager {\n\t    public volatile String lastUser;\n\t\n\t    public boolean authenticate(String user, String password) {\n\t        boolean valid = passwordIsValid(user, password);\n\t        if (valid) {\n\t            User u = new User();\n\t            activeUsers.add(u);\n\t            lastUser = user;\n\t        }\n\t        return valid;\n\t    }\n\t}\n\n该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。\n\n##### 模式4：volatile bean 模式 #####\n\nvolatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br/>\n在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。\n\n\t@ThreadSafe\n\tpublic class Person {\n\t    private volatile String firstName;\n\t    private volatile String lastName;\n\t    private volatile int age;\n\t\n\t    public String getFirstName() { return firstName; }\n\t    public String getLastName() { return lastName; }\n\t    public int getAge() { return age; }\n\t\n\t    public void setFirstName(String firstName) { \n\t        this.firstName = firstName;\n\t    }\n\t\n\t    public void setLastName(String lastName) { \n\t        this.lastName = lastName;\n\t    }\n\t\n\t    public void setAge(int age) { \n\t        this.age = age;\n\t    }\n\t}\n\n##### 模式5：volatile 高级模式，开销较低的读-写锁策略 #####\n\n如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。\n\n\t@ThreadSafe\n\tpublic class CheesyCounter {\n\t    // Employs the cheap read-write lock trick\n\t    // All mutative operations MUST be done with the 'this' lock held\n\t    @GuardedBy(\"this\") private volatile int value;\n\t\n\t    public int getValue() { return value; }\n\t\n\t    public synchronized int increment() {\n\t        return value++;\n\t    }\n\t}\n\n上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。\n\n\n#### voaltile 与 static ####\n\nvolatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；\n\nstatic，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。\n\n ","slug":"java-volatile","published":1,"updated":"2017-08-17T02:41:57.444Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1cn001q2sivpl2nl140","content":"<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br></p>\n<h5 id=\"为什么需要锁\"><a href=\"#为什么需要锁\" class=\"headerlink\" title=\"为什么需要锁\"></a>为什么需要锁</h5><p><img src=\"/images/why_need_lock.jpg\" alt=\"为什么需要锁\"></p>\n<p>由上图，两颗CPU都在修改内存的变量，导致其计数有误。</p>\n<h5 id=\"锁-lock\"><a href=\"#锁-lock\" class=\"headerlink\" title=\"锁(lock)\"></a>锁(lock)</h5><p>锁是用来做并发最简单的方式，当然其代价也是最高的。<code>内核态的锁</code>的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。<code>用户态的锁</code>避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br></p>\n<p>JDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用<code>独占的方式</code>来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。</p>\n<h6 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h6><p>独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p>\n<h6 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h6><p>比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。<br>CAS乐观锁算法如图：<br>CAS比较与交换的伪代码可以表示为：</p>\n<pre><code>do{\n备份旧数据\n基于旧数据构造新数据\n}while(!CAS(内存地址，备份的旧数据，新数据))\n</code></pre><p><img src=\"/images/cas.png\" alt=\"CAS乐观锁\"></p>\n<h5 id=\"原子操作-atomic-operations\"><a href=\"#原子操作-atomic-operations\" class=\"headerlink\" title=\"原子操作(atomic operations)\"></a>原子操作(atomic operations)</h5><ul>\n<li>所有的原始类型的赋值，long和double除外；</li>\n<li>所有引用的赋值；</li>\n<li>所有java.concurrent.Atomic*中类中的操作</li>\n<li>所有volatile修饰的long和double</li>\n</ul>\n<p>为什么long型赋值不是原子操作呢？</p>\n<p>事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：</p>\n<pre><code>private volatile long foo;\n</code></pre><p>因为volatile内部已经做了synchronized.</p>\n<h5 id=\"线程与内存的交互\"><a href=\"#线程与内存的交互\" class=\"headerlink\" title=\"线程与内存的交互\"></a>线程与内存的交互</h5><p>每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：</p>\n<p><img src=\"/images/thread-read-write.jpg\" alt=\"线程与内存的交互\"><br>其中use and assign 可以多次出现</p>\n<h5 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h5><p>volatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br><br>volatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br><br>volatile能替代简单的锁，却不能保证原子性。<br></p>\n<h5 id=\"内存屏障-Memory-Barrier\"><a href=\"#内存屏障-Memory-Barrier\" class=\"headerlink\" title=\"内存屏障-Memory Barrier\"></a>内存屏障-Memory Barrier</h5><p>内存屏障是一个CPU指令。</p>\n<ol>\n<li>确保一些特定操作执行的顺序；</li>\n<li>影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。</li>\n</ol>\n<p><br></p>\n<p>如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br></p>\n<p>由<code>线程和内存交互的图</code>，可得：</p>\n<pre><code>[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n</code></pre><p>可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说<code>volatile不能保证原子性。</code>这同时说明：<code>volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的</code>。</p>\n<h4 id=\"voaltile-使用场景及模式\"><a href=\"#voaltile-使用场景及模式\" class=\"headerlink\" title=\"voaltile 使用场景及模式\"></a>voaltile 使用场景及模式</h4><pre><code>要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\nAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n</code></pre><h5 id=\"模式1：状态标志\"><a href=\"#模式1：状态标志\" class=\"headerlink\" title=\"模式1：状态标志\"></a>模式1：状态标志</h5><p>也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。</p>\n<pre><code>volatile boolean shutdownRequested;\n\n...\n\npublic void shutdown() { shutdownRequested = true; }\n\npublic void doWork() { \n    while (!shutdownRequested) { \n        // do stuff\n    }\n}\n</code></pre><p>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。</p>\n<h5 id=\"模式2：一次性安全发布-one-time-safe-publication\"><a href=\"#模式2：一次性安全发布-one-time-safe-publication\" class=\"headerlink\" title=\"模式2：一次性安全发布(one time safe publication)\"></a>模式2：一次性安全发布(one time safe publication)</h5><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。</p>\n<p>实现安全发布对象的一种技术就是将对象引用定义为volatile类型。</p>\n<pre><code>public class BackgroundFloobleLoader {\n    public volatile Flooble theFlooble;\n    public void initInBackground() {\n        // do lots of stuff\n        theFlooble = new Flooble();  // this is the only write to theFlooble\n    }\n}\n\npublic class SomeOtherClass {\n    public void doWork() {\n        while (true) { \n            // do some stuff...\n            // use the Flooble, but only if it is ready\n            if (floobleLoader.theFlooble != null) \n                doSomething(floobleLoader.theFlooble);\n        }\n    }\n}\n</code></pre><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>\n<h5 id=\"模式3：独立观察-independent-observation\"><a href=\"#模式3：独立观察-independent-observation\" class=\"headerlink\" title=\"模式3：独立观察(independent observation)\"></a>模式3：独立观察(independent observation)</h5><p>安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>\n<pre><code>public class UserManager {\n    public volatile String lastUser;\n\n    public boolean authenticate(String user, String password) {\n        boolean valid = passwordIsValid(user, password);\n        if (valid) {\n            User u = new User();\n            activeUsers.add(u);\n            lastUser = user;\n        }\n        return valid;\n    }\n}\n</code></pre><p>该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。</p>\n<h5 id=\"模式4：volatile-bean-模式\"><a href=\"#模式4：volatile-bean-模式\" class=\"headerlink\" title=\"模式4：volatile bean 模式\"></a>模式4：volatile bean 模式</h5><p>volatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br><br>在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。</p>\n<pre><code>@ThreadSafe\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n\n    public void setFirstName(String firstName) { \n        this.firstName = firstName;\n    }\n\n    public void setLastName(String lastName) { \n        this.lastName = lastName;\n    }\n\n    public void setAge(int age) { \n        this.age = age;\n    }\n}\n</code></pre><h5 id=\"模式5：volatile-高级模式，开销较低的读-写锁策略\"><a href=\"#模式5：volatile-高级模式，开销较低的读-写锁策略\" class=\"headerlink\" title=\"模式5：volatile 高级模式，开销较低的读-写锁策略\"></a>模式5：volatile 高级模式，开销较低的读-写锁策略</h5><p>如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。</p>\n<pre><code>@ThreadSafe\npublic class CheesyCounter {\n    // Employs the cheap read-write lock trick\n    // All mutative operations MUST be done with the &apos;this&apos; lock held\n    @GuardedBy(&quot;this&quot;) private volatile int value;\n\n    public int getValue() { return value; }\n\n    public synchronized int increment() {\n        return value++;\n    }\n}\n</code></pre><p>上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。</p>\n<h4 id=\"voaltile-与-static\"><a href=\"#voaltile-与-static\" class=\"headerlink\" title=\"voaltile 与 static\"></a>voaltile 与 static</h4><p>volatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；</p>\n<p>static，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><p>第一次与volatile相识，是在单例模式的介绍中，一个DCL的单例，是如何因为非原子性操作而导致在多线程环境下破坏了单例的唯一性。volatile就在此时挺身而出，搞得人对之好感满满。于此时，我又认识到了锁、同步、原子性，这些概念，下面做一个简单的基础知识科普。<br></p>\n<h5 id=\"为什么需要锁\"><a href=\"#为什么需要锁\" class=\"headerlink\" title=\"为什么需要锁\"></a>为什么需要锁</h5><p><img src=\"/images/why_need_lock.jpg\" alt=\"为什么需要锁\"></p>\n<p>由上图，两颗CPU都在修改内存的变量，导致其计数有误。</p>\n<h5 id=\"锁-lock\"><a href=\"#锁-lock\" class=\"headerlink\" title=\"锁(lock)\"></a>锁(lock)</h5><p>锁是用来做并发最简单的方式，当然其代价也是最高的。<code>内核态的锁</code>的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。<code>用户态的锁</code>避免了这些问题，但是他们只是在没有真实的竞争时才有效。<br></p>\n<p>JDK之前，都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用<code>独占的方式</code>来访问这些变量，如果出现多个线程同时访问锁，一些线程将被挂起，必须等待其他线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它的一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转。</p>\n<h6 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h6><p>独占锁是一种悲观锁，synchronized就是一种独占锁，他假设最坏的情况，并且只有在确保其他线程不会造成干扰的情况下执行，会导致其他所有需要锁的线程挂起，等待持有锁的线程释放锁。</p>\n<h6 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h6><p>比悲观锁更加有效，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突失败就重试，直到成功为止。<br>CAS乐观锁算法如图：<br>CAS比较与交换的伪代码可以表示为：</p>\n<pre><code>do{\n备份旧数据\n基于旧数据构造新数据\n}while(!CAS(内存地址，备份的旧数据，新数据))\n</code></pre><p><img src=\"/images/cas.png\" alt=\"CAS乐观锁\"></p>\n<h5 id=\"原子操作-atomic-operations\"><a href=\"#原子操作-atomic-operations\" class=\"headerlink\" title=\"原子操作(atomic operations)\"></a>原子操作(atomic operations)</h5><ul>\n<li>所有的原始类型的赋值，long和double除外；</li>\n<li>所有引用的赋值；</li>\n<li>所有java.concurrent.Atomic*中类中的操作</li>\n<li>所有volatile修饰的long和double</li>\n</ul>\n<p>为什么long型赋值不是原子操作呢？</p>\n<p>事实上java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：</p>\n<pre><code>private volatile long foo;\n</code></pre><p>因为volatile内部已经做了synchronized.</p>\n<h5 id=\"线程与内存的交互\"><a href=\"#线程与内存的交互\" class=\"headerlink\" title=\"线程与内存的交互\"></a>线程与内存的交互</h5><p>每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象的值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻，自动把线程变量副本的值回写到对象在堆中的变量。如图：</p>\n<p><img src=\"/images/thread-read-write.jpg\" alt=\"线程与内存的交互\"><br>其中use and assign 可以多次出现</p>\n<h5 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h5><p>volatile，声明其修饰的字段易变（可能被多个线程使用），Java内存模型负责各个线程的工作区与主存区的该字段的值保持同步。<br><br>volatile的同步，不同于synchronized，前者是内存同步，后者不仅包含内存同步，并且保证线程互斥。<br><br>volatile能替代简单的锁，却不能保证原子性。<br></p>\n<h5 id=\"内存屏障-Memory-Barrier\"><a href=\"#内存屏障-Memory-Barrier\" class=\"headerlink\" title=\"内存屏障-Memory Barrier\"></a>内存屏障-Memory Barrier</h5><p>内存屏障是一个CPU指令。</p>\n<ol>\n<li>确保一些特定操作执行的顺序；</li>\n<li>影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障的另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程都将得到最新值，而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的。</li>\n</ol>\n<p><br></p>\n<p>如果你的字段是volatile，java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。<br></p>\n<p>由<code>线程和内存交互的图</code>，可得：</p>\n<pre><code>[读屏障指令] - read - load - use - asign - store - write - [写屏障指令].\n</code></pre><p>可以看到，从load到store是不安全的，这期间，如果别的CPU修改了值，将会丢失。因此，我们说<code>volatile不能保证原子性。</code>这同时说明：<code>volatile不能用在getAndOperate场合，仅仅set/get场景是适合volatile的</code>。</p>\n<h4 id=\"voaltile-使用场景及模式\"><a href=\"#voaltile-使用场景及模式\" class=\"headerlink\" title=\"voaltile 使用场景及模式\"></a>voaltile 使用场景及模式</h4><pre><code>要始终牢记使用volatile的限制——只有在状态真正独立于程序内其他内容时才能使用volatile——这条规则能够避免将这些模式扩展到不安全的用例。 \n\nAlways keep in mind the rules about the limits of where volatile can be used -- only use volatile for state that is truly independent of everything else in your program -- and this should keep you from trying to extend these patterns into dangerous territory.\n</code></pre><h5 id=\"模式1：状态标志\"><a href=\"#模式1：状态标志\" class=\"headerlink\" title=\"模式1：状态标志\"></a>模式1：状态标志</h5><p>也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。很多应用程序包含了一种控制结构，形式为“在还没有准备好停止程序时再执行一些工作”。</p>\n<pre><code>volatile boolean shutdownRequested;\n\n...\n\npublic void shutdown() { shutdownRequested = true; }\n\npublic void doWork() { \n    while (!shutdownRequested) { \n        // do stuff\n    }\n}\n</code></pre><p>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequest标志从false转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展。</p>\n<h5 id=\"模式2：一次性安全发布-one-time-safe-publication\"><a href=\"#模式2：一次性安全发布-one-time-safe-publication\" class=\"headerlink\" title=\"模式2：一次性安全发布(one time safe publication)\"></a>模式2：一次性安全发布(one time safe publication)</h5><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值和该对象状态的旧值同时存在。这就是造成著名的双重检查锁定(double checked locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。</p>\n<p>实现安全发布对象的一种技术就是将对象引用定义为volatile类型。</p>\n<pre><code>public class BackgroundFloobleLoader {\n    public volatile Flooble theFlooble;\n    public void initInBackground() {\n        // do lots of stuff\n        theFlooble = new Flooble();  // this is the only write to theFlooble\n    }\n}\n\npublic class SomeOtherClass {\n    public void doWork() {\n        while (true) { \n            // do some stuff...\n            // use the Flooble, but only if it is ready\n            if (floobleLoader.theFlooble != null) \n                doSomething(floobleLoader.theFlooble);\n        }\n    }\n}\n</code></pre><p>该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象(有效不可变意味着对象的状态在发布之后永远不会被修改)。volatile类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。</p>\n<h5 id=\"模式3：独立观察-independent-observation\"><a href=\"#模式3：独立观察-independent-observation\" class=\"headerlink\" title=\"模式3：独立观察(independent observation)\"></a>模式3：独立观察(independent observation)</h5><p>安全使用volatile的另一种简单模式是：定期“发布”观察结果供程序内部使用。例如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的volatile变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p>\n<pre><code>public class UserManager {\n    public volatile String lastUser;\n\n    public boolean authenticate(String user, String password) {\n        boolean valid = passwordIsValid(user, password);\n        if (valid) {\n            User u = new User();\n            activeUsers.add(u);\n            lastUser = user;\n        }\n        return valid;\n    }\n}\n</code></pre><p>该模式是一次性安全发布的扩展，将某个值发布，以在程序内的其他地方使用，但是这与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的——即值的状态在发布后不会更改。使用该值的代码需要清除该值可能随时发生变化。</p>\n<h5 id=\"模式4：volatile-bean-模式\"><a href=\"#模式4：volatile-bean-模式\" class=\"headerlink\" title=\"模式4：volatile bean 模式\"></a>模式4：volatile bean 模式</h5><p>volatile bean模式适用于将JavaBeans作为“荣誉结构”使用的框架。在volatile bean模式中，JavaBean被用作一组具有getter/setter方法的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者(例如HttpSession)提供了容器，但是放入这些容器中的对象必须是线程安全的。<br><br>在volatile bean模式中，JavaBean的所有数据成员都是volatile类型的，并且getter/setter方法必须非常普通——除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为volatile时，只有引用而不是数组本身具有volatile语义)。对于任何volatile变量，不变式或约束都不能包含JavaBean属性。</p>\n<pre><code>@ThreadSafe\npublic class Person {\n    private volatile String firstName;\n    private volatile String lastName;\n    private volatile int age;\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n\n    public void setFirstName(String firstName) { \n        this.firstName = firstName;\n    }\n\n    public void setLastName(String lastName) { \n        this.lastName = lastName;\n    }\n\n    public void setAge(int age) { \n        this.age = age;\n    }\n}\n</code></pre><h5 id=\"模式5：volatile-高级模式，开销较低的读-写锁策略\"><a href=\"#模式5：volatile-高级模式，开销较低的读-写锁策略\" class=\"headerlink\" title=\"模式5：volatile 高级模式，开销较低的读-写锁策略\"></a>模式5：volatile 高级模式，开销较低的读-写锁策略</h5><p>如果读操作远远超过写操作，您可以结合使用内部锁和volatile变量来减少公共代码路径的开销。</p>\n<pre><code>@ThreadSafe\npublic class CheesyCounter {\n    // Employs the cheap read-write lock trick\n    // All mutative operations MUST be done with the &apos;this&apos; lock held\n    @GuardedBy(&quot;this&quot;) private volatile int value;\n\n    public int getValue() { return value; }\n\n    public synchronized int increment() {\n        return value++;\n    }\n}\n</code></pre><p>上述中显示的线程安全的计数器使用synchronized确保增量操作是原子的，并使用volatile保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及volatile读操作，这通常要优于一个无竞争的锁获取的开销。</p>\n<h4 id=\"voaltile-与-static\"><a href=\"#voaltile-与-static\" class=\"headerlink\" title=\"voaltile 与 static\"></a>voaltile 与 static</h4><p>volatile，声明这个字段易变(可能被多个线程使用)，java内存模型负责各个线程的工作区与主存区的该字段的值保持同步，即一致性；强调变量值的唯一性；</p>\n<p>static，声明这个字段是静态的(可能被多个实例共享)，在主存区上该类的所有实例的该字段为同一个变量，即唯一性；强调变量的唯一性。</p>\n"},{"layout":"post","title":"Android系统服务：LayoutInflater","date":"2017-02-23T00:00:00.000Z","_content":" \n\n#### 起源 ####\n \nactivity是android中最常用的UI容器。把写好的xml布局通过`setContentView(int ResId)`，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务`LayoutInflater`的工作了。\n\n##### 追踪android.app.Activity #####\n  \nActivity源码中有3个`setContentView`的重载方法。\n\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n        initWindowDecorActionBar();\n    }\n\n可以看到，调用当前Activity的window的`setContentView`来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：\n\n![activity、window层级关系图](/images/activity-window-layer.jpg)\n\n其中`com.android.internal.policy.PhoneWindow`是`android.view.Window`的子类。<br/>\nDecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br/>\nTitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br/>\nContentView即需要展示在UI上的xml布局文件。<br/>\n\n继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br/>\n`initWindowDecorActionBar();`里面主要是设置ActionBar。\n\n \n##### 追踪com.android.internal.policy.PhoneWindow #####\n\n先简后繁，看一下现成的view如何添加到ContentView的：\n\t\n\t\t @Override\n\t\t    public void setContentView(View view) {\n\t\t        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\t\t    }\n\t\n\t \t@Override\n\t    public void setContentView(View view, ViewGroup.LayoutParams params) {\n\t        \n\t\t\t...\n\t\n\t\t\tmContentParent.addView(view, params);\n\t\n\t\t\t...\n\t\n\t     }\n\n把已有的view设置进入`ContentView`，只需要调用`ViewGroup.addView(View view)`添加到DecorView即可。<br/>\n这里提一句：view都是要添加到父view上的。 \n\n\tpublic static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n\n这个ID对应的ViewGroup，即xml布局的父view。其源码注释：\n\n>    This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.\n>    这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。\n\n总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。\n     \n\n下面，来看一下xml文件如何变成view的：\n\n\n\t@Override\n\t    public void setContentView(int layoutResID) {\n\t        \n\t\t...\n\n\t            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n\t\t...\n\t        \n\t    }\n\n一目了然，调用系统服务LayoutInflater的inflate方法。\n\n#### 追踪LayoutInflater源码 ####\n\n关键方法：\n\n- inflate * n\n- rInflate\n- createViewFromTag\n- createView\n\n\n\n##### inflate #####\n\n    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n        final Resources res = getContext().getResources();\n        if (DEBUG) {\n            Log.d(TAG, \"INFLATING from resource: \\\"\" + res.getResourceName(resource) + \"\\\" (\"\n                    + Integer.toHexString(resource) + \")\");\n        }\n\n        final XmlResourceParser parser = res.getLayout(resource);\n        try {\n            return inflate(parser, root, attachToRoot);\n        } finally {\n            parser.close();\n        }\n    }\n\n获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。\n\n\t\n\t    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n\t        synchronized (mConstructorArgs) {\n\t\n\t\t...\n\t\t\n\t\t final String name = parser.getName();\n\t\t if (TAG_MERGE.equals(name)) {\n\t\t                    \n\t\t...\n\t\t\n\t    rInflate(parser, root, inflaterContext, attrs, false);\n\t\n\t\t...\n\t\n\t    } else {\n\t\n\t\t...\n\t\n\t \trInflateChildren(parser, temp, attrs, true);\n\t\n\t\t...\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n由于merge标签，只能作为xml根标签使用，所以分开处理。\n\n\n##### rInflate #####\n\n\t void rInflate(XmlPullParser parser, View parent, Context context,\n\t            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\t\n\t        final int depth = parser.getDepth();\n\t        int type;\n\t\n\t        while (((type = parser.next()) != XmlPullParser.END_TAG ||\n\t                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n\t\n\t            if (type != XmlPullParser.START_TAG) {\n\t                continue;\n\t            }\n\t\n\t            final String name = parser.getName();\n\t            \n\t            if (TAG_REQUEST_FOCUS.equals(name)) {\n\t                parseRequestFocus(parser, parent);\n\t            } else if (TAG_TAG.equals(name)) {\n\t                parseViewTag(parser, parent, attrs);\n\t            } else if (TAG_INCLUDE.equals(name)) {\n\t                if (parser.getDepth() == 0) {\n\t                    throw new InflateException(\"<include /> cannot be the root element\");\n\t                }\n\t                parseInclude(parser, context, parent, attrs);\n\t            } else if (TAG_MERGE.equals(name)) {\n\t                throw new InflateException(\"<merge /> must be the root element\");\n\t            } else {\n\t                final View view = createViewFromTag(parent, name, context, attrs);\n\t                final ViewGroup viewGroup = (ViewGroup) parent;\n\t                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n\t                rInflateChildren(parser, view, attrs, true);\n\t                viewGroup.addView(view, params);\n\t            }\n\t        }\n\t\n\t        if (finishInflate) {\n\t            parent.onFinishInflate();\n\t        }\n\t    }\n\n深度优先遍历xml树，判断标签类型，循环递归直至`XmlPullParser.END_DOCUMENT`。\n\n##### createViewFromTag #####\n\t\t\n\t\tView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n\t\t            boolean ignoreThemeAttr) {\n\t\t        if (name.equals(\"view\")) {\n\t\t            name = attrs.getAttributeValue(null, \"class\");\n\t\t        }\n\t\t\n\t\t...\n\t\n\t  \t\t\t\tif (name.equals(TAG_1995)) {\n\t            // Let's party like it's 1995!\n\t            return new BlinkLayout(context, attrs);\n\t        }\n\t\n\t\t...\n\n\ttry {\n            View view;\n            if (mFactory2 != null) {\n                view = mFactory2.onCreateView(parent, name, context, attrs);\n            } else if (mFactory != null) {\n                view = mFactory.onCreateView(name, context, attrs);\n            } else {\n                view = null;\n            }\n\n            if (view == null && mPrivateFactory != null) {\n                view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n            }\n\n            if (view == null) {\n                final Object lastContext = mConstructorArgs[0];\n                mConstructorArgs[0] = context;\n                try {\n                    if (-1 == name.indexOf('.')) {\n                        view = onCreateView(parent, name, attrs);\n                    } else {\n                        view = createView(name, null, attrs);\n                    }\n                } finally {\n                    mConstructorArgs[0] = lastContext;\n                }\n            }\n\n            return view;\n        } \n\n\t...\n\n\t}\n\n如果view为属性标签，那么name就是属性的值。<br/>\n如果TAG_1995，做出来的布局会一闪一闪的。<br/>\n如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br/>\n如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如`android.widget`。<br/>\n\n##### createView #####\n\n    public final View createView(String name, String prefix, AttributeSet attrs)\n            throws ClassNotFoundException, InflateException {\n        Constructor<? extends View> constructor = sConstructorMap.get(name);\n        if (constructor != null && !verifyClassLoader(constructor)) {\n            constructor = null;\n            sConstructorMap.remove(name);\n        }\n        Class<? extends View> clazz = null;\n\n        try {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n            if (constructor == null) {\n                // Class not found in the cache, see if it's real, and try to add it\n                clazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \n                if (mFilter != null && clazz != null) {\n                    boolean allowed = mFilter.onLoadClass(clazz);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n                constructor = clazz.getConstructor(mConstructorSignature);\n                constructor.setAccessible(true);\n                sConstructorMap.put(name, constructor);\n            } else {\n                // If we have a filter, apply it to cached constructor\n                if (mFilter != null) {\n                    // Have we seen this name before?\n                    Boolean allowedState = mFilterMap.get(name);\n                    if (allowedState == null) {\n                        // New class -- remember whether it is allowed\n                        clazz = mContext.getClassLoader().loadClass(\n                                prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                        \n                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                        mFilterMap.put(name, allowed);\n                        if (!allowed) {\n                            failNotAllowed(name, prefix, attrs);\n                        }\n                    } else if (allowedState.equals(Boolean.FALSE)) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n            }\n\n            Object[] args = mConstructorArgs;\n            args[1] = attrs;\n\n            final View view = constructor.newInstance(args);\n            if (view instanceof ViewStub) {\n                // Use the same context when inflating ViewStub later.\n                final ViewStub viewStub = (ViewStub) view;\n                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n            }\n            return view;\n\n        } \n    }\n\n- 根据view的名字，缓存的构造器map中是否存在；\n- 如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；\n- 通过其构造生成view。\n\n\n\n\n\n\n\n\n \n\n \n ","source":"_posts/2017-02-23-android-system-service-LayoutInflater.md","raw":"---\nlayout: post\ntitle:  Android系统服务：LayoutInflater\ndate:   2017-02-23\ncategories: Android System Framework\ntag: android\n---\n \n\n#### 起源 ####\n \nactivity是android中最常用的UI容器。把写好的xml布局通过`setContentView(int ResId)`，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务`LayoutInflater`的工作了。\n\n##### 追踪android.app.Activity #####\n  \nActivity源码中有3个`setContentView`的重载方法。\n\n    public void setContentView(@LayoutRes int layoutResID) {\n        getWindow().setContentView(layoutResID);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view) {\n        getWindow().setContentView(view);\n        initWindowDecorActionBar();\n    }\n\n    public void setContentView(View view, ViewGroup.LayoutParams params) {\n        getWindow().setContentView(view, params);\n        initWindowDecorActionBar();\n    }\n\n可以看到，调用当前Activity的window的`setContentView`来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：\n\n![activity、window层级关系图](/images/activity-window-layer.jpg)\n\n其中`com.android.internal.policy.PhoneWindow`是`android.view.Window`的子类。<br/>\nDecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br/>\nTitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br/>\nContentView即需要展示在UI上的xml布局文件。<br/>\n\n继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br/>\n`initWindowDecorActionBar();`里面主要是设置ActionBar。\n\n \n##### 追踪com.android.internal.policy.PhoneWindow #####\n\n先简后繁，看一下现成的view如何添加到ContentView的：\n\t\n\t\t @Override\n\t\t    public void setContentView(View view) {\n\t\t        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\t\t    }\n\t\n\t \t@Override\n\t    public void setContentView(View view, ViewGroup.LayoutParams params) {\n\t        \n\t\t\t...\n\t\n\t\t\tmContentParent.addView(view, params);\n\t\n\t\t\t...\n\t\n\t     }\n\n把已有的view设置进入`ContentView`，只需要调用`ViewGroup.addView(View view)`添加到DecorView即可。<br/>\n这里提一句：view都是要添加到父view上的。 \n\n\tpublic static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n\n这个ID对应的ViewGroup，即xml布局的父view。其源码注释：\n\n>    This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.\n>    这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。\n\n总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。\n     \n\n下面，来看一下xml文件如何变成view的：\n\n\n\t@Override\n\t    public void setContentView(int layoutResID) {\n\t        \n\t\t...\n\n\t            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n\t\t...\n\t        \n\t    }\n\n一目了然，调用系统服务LayoutInflater的inflate方法。\n\n#### 追踪LayoutInflater源码 ####\n\n关键方法：\n\n- inflate * n\n- rInflate\n- createViewFromTag\n- createView\n\n\n\n##### inflate #####\n\n    public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n        final Resources res = getContext().getResources();\n        if (DEBUG) {\n            Log.d(TAG, \"INFLATING from resource: \\\"\" + res.getResourceName(resource) + \"\\\" (\"\n                    + Integer.toHexString(resource) + \")\");\n        }\n\n        final XmlResourceParser parser = res.getLayout(resource);\n        try {\n            return inflate(parser, root, attachToRoot);\n        } finally {\n            parser.close();\n        }\n    }\n\n获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。\n\n\t\n\t    public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n\t        synchronized (mConstructorArgs) {\n\t\n\t\t...\n\t\t\n\t\t final String name = parser.getName();\n\t\t if (TAG_MERGE.equals(name)) {\n\t\t                    \n\t\t...\n\t\t\n\t    rInflate(parser, root, inflaterContext, attrs, false);\n\t\n\t\t...\n\t\n\t    } else {\n\t\n\t\t...\n\t\n\t \trInflateChildren(parser, temp, attrs, true);\n\t\n\t\t...\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n由于merge标签，只能作为xml根标签使用，所以分开处理。\n\n\n##### rInflate #####\n\n\t void rInflate(XmlPullParser parser, View parent, Context context,\n\t            AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\t\n\t        final int depth = parser.getDepth();\n\t        int type;\n\t\n\t        while (((type = parser.next()) != XmlPullParser.END_TAG ||\n\t                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\n\t\n\t            if (type != XmlPullParser.START_TAG) {\n\t                continue;\n\t            }\n\t\n\t            final String name = parser.getName();\n\t            \n\t            if (TAG_REQUEST_FOCUS.equals(name)) {\n\t                parseRequestFocus(parser, parent);\n\t            } else if (TAG_TAG.equals(name)) {\n\t                parseViewTag(parser, parent, attrs);\n\t            } else if (TAG_INCLUDE.equals(name)) {\n\t                if (parser.getDepth() == 0) {\n\t                    throw new InflateException(\"<include /> cannot be the root element\");\n\t                }\n\t                parseInclude(parser, context, parent, attrs);\n\t            } else if (TAG_MERGE.equals(name)) {\n\t                throw new InflateException(\"<merge /> must be the root element\");\n\t            } else {\n\t                final View view = createViewFromTag(parent, name, context, attrs);\n\t                final ViewGroup viewGroup = (ViewGroup) parent;\n\t                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n\t                rInflateChildren(parser, view, attrs, true);\n\t                viewGroup.addView(view, params);\n\t            }\n\t        }\n\t\n\t        if (finishInflate) {\n\t            parent.onFinishInflate();\n\t        }\n\t    }\n\n深度优先遍历xml树，判断标签类型，循环递归直至`XmlPullParser.END_DOCUMENT`。\n\n##### createViewFromTag #####\n\t\t\n\t\tView createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n\t\t            boolean ignoreThemeAttr) {\n\t\t        if (name.equals(\"view\")) {\n\t\t            name = attrs.getAttributeValue(null, \"class\");\n\t\t        }\n\t\t\n\t\t...\n\t\n\t  \t\t\t\tif (name.equals(TAG_1995)) {\n\t            // Let's party like it's 1995!\n\t            return new BlinkLayout(context, attrs);\n\t        }\n\t\n\t\t...\n\n\ttry {\n            View view;\n            if (mFactory2 != null) {\n                view = mFactory2.onCreateView(parent, name, context, attrs);\n            } else if (mFactory != null) {\n                view = mFactory.onCreateView(name, context, attrs);\n            } else {\n                view = null;\n            }\n\n            if (view == null && mPrivateFactory != null) {\n                view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n            }\n\n            if (view == null) {\n                final Object lastContext = mConstructorArgs[0];\n                mConstructorArgs[0] = context;\n                try {\n                    if (-1 == name.indexOf('.')) {\n                        view = onCreateView(parent, name, attrs);\n                    } else {\n                        view = createView(name, null, attrs);\n                    }\n                } finally {\n                    mConstructorArgs[0] = lastContext;\n                }\n            }\n\n            return view;\n        } \n\n\t...\n\n\t}\n\n如果view为属性标签，那么name就是属性的值。<br/>\n如果TAG_1995，做出来的布局会一闪一闪的。<br/>\n如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br/>\n如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如`android.widget`。<br/>\n\n##### createView #####\n\n    public final View createView(String name, String prefix, AttributeSet attrs)\n            throws ClassNotFoundException, InflateException {\n        Constructor<? extends View> constructor = sConstructorMap.get(name);\n        if (constructor != null && !verifyClassLoader(constructor)) {\n            constructor = null;\n            sConstructorMap.remove(name);\n        }\n        Class<? extends View> clazz = null;\n\n        try {\n            Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n            if (constructor == null) {\n                // Class not found in the cache, see if it's real, and try to add it\n                clazz = mContext.getClassLoader().loadClass(\n                        prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                \n                if (mFilter != null && clazz != null) {\n                    boolean allowed = mFilter.onLoadClass(clazz);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n                constructor = clazz.getConstructor(mConstructorSignature);\n                constructor.setAccessible(true);\n                sConstructorMap.put(name, constructor);\n            } else {\n                // If we have a filter, apply it to cached constructor\n                if (mFilter != null) {\n                    // Have we seen this name before?\n                    Boolean allowedState = mFilterMap.get(name);\n                    if (allowedState == null) {\n                        // New class -- remember whether it is allowed\n                        clazz = mContext.getClassLoader().loadClass(\n                                prefix != null ? (prefix + name) : name).asSubclass(View.class);\n                        \n                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);\n                        mFilterMap.put(name, allowed);\n                        if (!allowed) {\n                            failNotAllowed(name, prefix, attrs);\n                        }\n                    } else if (allowedState.equals(Boolean.FALSE)) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                }\n            }\n\n            Object[] args = mConstructorArgs;\n            args[1] = attrs;\n\n            final View view = constructor.newInstance(args);\n            if (view instanceof ViewStub) {\n                // Use the same context when inflating ViewStub later.\n                final ViewStub viewStub = (ViewStub) view;\n                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n            }\n            return view;\n\n        } \n    }\n\n- 根据view的名字，缓存的构造器map中是否存在；\n- 如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；\n- 通过其构造生成view。\n\n\n\n\n\n\n\n\n \n\n \n ","slug":"android-system-service-LayoutInflater","published":1,"updated":"2017-08-17T02:42:53.095Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1cv001u2siv8szfnhnf","content":"<h4 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h4><p>activity是android中最常用的UI容器。把写好的xml布局通过<code>setContentView(int ResId)</code>，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务<code>LayoutInflater</code>的工作了。</p>\n<h5 id=\"追踪android-app-Activity\"><a href=\"#追踪android-app-Activity\" class=\"headerlink\" title=\"追踪android.app.Activity\"></a>追踪android.app.Activity</h5><p>Activity源码中有3个<code>setContentView</code>的重载方法。</p>\n<pre><code>public void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view) {\n    getWindow().setContentView(view);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n    getWindow().setContentView(view, params);\n    initWindowDecorActionBar();\n}\n</code></pre><p>可以看到，调用当前Activity的window的<code>setContentView</code>来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：</p>\n<p><img src=\"/images/activity-window-layer.jpg\" alt=\"activity、window层级关系图\"></p>\n<p>其中<code>com.android.internal.policy.PhoneWindow</code>是<code>android.view.Window</code>的子类。<br><br>DecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br><br>TitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br><br>ContentView即需要展示在UI上的xml布局文件。<br></p>\n<p>继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br><br><code>initWindowDecorActionBar();</code>里面主要是设置ActionBar。</p>\n<h5 id=\"追踪com-android-internal-policy-PhoneWindow\"><a href=\"#追踪com-android-internal-policy-PhoneWindow\" class=\"headerlink\" title=\"追踪com.android.internal.policy.PhoneWindow\"></a>追踪com.android.internal.policy.PhoneWindow</h5><p>先简后繁，看一下现成的view如何添加到ContentView的：</p>\n<pre><code> @Override\n    public void setContentView(View view) {\n        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n    }\n\n @Override\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n\n    ...\n\n    mContentParent.addView(view, params);\n\n    ...\n\n }\n</code></pre><p>把已有的view设置进入<code>ContentView</code>，只需要调用<code>ViewGroup.addView(View view)</code>添加到DecorView即可。<br><br>这里提一句：view都是要添加到父view上的。 </p>\n<pre><code>public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n</code></pre><p>这个ID对应的ViewGroup，即xml布局的父view。其源码注释：</p>\n<blockquote>\n<p>   This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.<br>   这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。</p>\n</blockquote>\n<p>总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。</p>\n<p>下面，来看一下xml文件如何变成view的：</p>\n<pre><code>@Override\n    public void setContentView(int layoutResID) {\n\n    ...\n\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n    ...\n\n    }\n</code></pre><p>一目了然，调用系统服务LayoutInflater的inflate方法。</p>\n<h4 id=\"追踪LayoutInflater源码\"><a href=\"#追踪LayoutInflater源码\" class=\"headerlink\" title=\"追踪LayoutInflater源码\"></a>追踪LayoutInflater源码</h4><p>关键方法：</p>\n<ul>\n<li>inflate * n</li>\n<li>rInflate</li>\n<li>createViewFromTag</li>\n<li>createView</li>\n</ul>\n<h5 id=\"inflate\"><a href=\"#inflate\" class=\"headerlink\" title=\"inflate\"></a>inflate</h5><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    if (DEBUG) {\n        Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;\n                + Integer.toHexString(resource) + &quot;)&quot;);\n    }\n\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n</code></pre><p>获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。</p>\n<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n\n...\n\n final String name = parser.getName();\n if (TAG_MERGE.equals(name)) {\n\n...\n\nrInflate(parser, root, inflaterContext, attrs, false);\n\n...\n\n} else {\n\n...\n\n rInflateChildren(parser, temp, attrs, true);\n\n...\n\n        }\n    }\n}\n</code></pre><p>由于merge标签，只能作为xml根标签使用，所以分开处理。</p>\n<h5 id=\"rInflate\"><a href=\"#rInflate\" class=\"headerlink\" title=\"rInflate\"></a>rInflate</h5><pre><code>void rInflate(XmlPullParser parser, View parent, Context context,\n           AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\n       final int depth = parser.getDepth();\n       int type;\n\n       while (((type = parser.next()) != XmlPullParser.END_TAG ||\n               parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {\n\n           if (type != XmlPullParser.START_TAG) {\n               continue;\n           }\n\n           final String name = parser.getName();\n\n           if (TAG_REQUEST_FOCUS.equals(name)) {\n               parseRequestFocus(parser, parent);\n           } else if (TAG_TAG.equals(name)) {\n               parseViewTag(parser, parent, attrs);\n           } else if (TAG_INCLUDE.equals(name)) {\n               if (parser.getDepth() == 0) {\n                   throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);\n               }\n               parseInclude(parser, context, parent, attrs);\n           } else if (TAG_MERGE.equals(name)) {\n               throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);\n           } else {\n               final View view = createViewFromTag(parent, name, context, attrs);\n               final ViewGroup viewGroup = (ViewGroup) parent;\n               final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n               rInflateChildren(parser, view, attrs, true);\n               viewGroup.addView(view, params);\n           }\n       }\n\n       if (finishInflate) {\n           parent.onFinishInflate();\n       }\n   }\n</code></pre><p>深度优先遍历xml树，判断标签类型，循环递归直至<code>XmlPullParser.END_DOCUMENT</code>。</p>\n<h5 id=\"createViewFromTag\"><a href=\"#createViewFromTag\" class=\"headerlink\" title=\"createViewFromTag\"></a>createViewFromTag</h5><pre><code>    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n                boolean ignoreThemeAttr) {\n            if (name.equals(&quot;view&quot;)) {\n                name = attrs.getAttributeValue(null, &quot;class&quot;);\n            }\n\n    ...\n\n                  if (name.equals(TAG_1995)) {\n            // Let&apos;s party like it&apos;s 1995!\n            return new BlinkLayout(context, attrs);\n        }\n\n    ...\n\ntry {\n        View view;\n        if (mFactory2 != null) {\n            view = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n\n        if (view == null &amp;&amp; mPrivateFactory != null) {\n            view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n\n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf(&apos;.&apos;)) {\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n\n        return view;\n    } \n\n...\n\n}\n</code></pre><p>如果view为属性标签，那么name就是属性的值。<br><br>如果TAG_1995，做出来的布局会一闪一闪的。<br><br>如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br><br>如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如<code>android.widget</code>。<br></p>\n<h5 id=\"createView\"><a href=\"#createView\" class=\"headerlink\" title=\"createView\"></a>createView</h5><pre><code>public final View createView(String name, String prefix, AttributeSet attrs)\n        throws ClassNotFoundException, InflateException {\n    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);\n    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class&lt;? extends View&gt; clazz = null;\n\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n        if (constructor == null) {\n            // Class not found in the cache, see if it&apos;s real, and try to add it\n            clazz = mContext.getClassLoader().loadClass(\n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n            if (mFilter != null &amp;&amp; clazz != null) {\n                boolean allowed = mFilter.onLoadClass(clazz);\n                if (!allowed) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            // If we have a filter, apply it to cached constructor\n            if (mFilter != null) {\n                // Have we seen this name before?\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // New class -- remember whether it is allowed\n                    clazz = mContext.getClassLoader().loadClass(\n                            prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);\n                    mFilterMap.put(name, allowed);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n        }\n\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n\n        final View view = constructor.newInstance(args);\n        if (view instanceof ViewStub) {\n            // Use the same context when inflating ViewStub later.\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        return view;\n\n    } \n}\n</code></pre><ul>\n<li>根据view的名字，缓存的构造器map中是否存在；</li>\n<li>如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；</li>\n<li>通过其构造生成view。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h4><p>activity是android中最常用的UI容器。把写好的xml布局通过<code>setContentView(int ResId)</code>，就可以实现页面的绑定，然后我们根据控件的ID，根据业务代码展示UI就可以了。关于xml的解析和绘制，就是系统服务<code>LayoutInflater</code>的工作了。</p>\n<h5 id=\"追踪android-app-Activity\"><a href=\"#追踪android-app-Activity\" class=\"headerlink\" title=\"追踪android.app.Activity\"></a>追踪android.app.Activity</h5><p>Activity源码中有3个<code>setContentView</code>的重载方法。</p>\n<pre><code>public void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view) {\n    getWindow().setContentView(view);\n    initWindowDecorActionBar();\n}\n\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n    getWindow().setContentView(view, params);\n    initWindowDecorActionBar();\n}\n</code></pre><p>可以看到，调用当前Activity的window的<code>setContentView</code>来布局，这里我们上一张图看一下activity，window，view(xml布局)的关系：</p>\n<p><img src=\"/images/activity-window-layer.jpg\" alt=\"activity、window层级关系图\"></p>\n<p>其中<code>com.android.internal.policy.PhoneWindow</code>是<code>android.view.Window</code>的子类。<br><br>DecorView是的PhoneWindow的顶级view，继承自FrameLayout，其内部包含一个竖直的LinearLayout。<br><br>TitleView即ActionBar所在位置，通常使用Theme来配置其状态，一般开发会屏蔽该ActionBar，使用自定义顶部栏。<br><br>ContentView即需要展示在UI上的xml布局文件。<br></p>\n<p>继续看源码，getWindow()方法获取的是一个PhoneWindow的实例。所以setContentView可以去PhoneWindow中去查看其实现。<br><br><code>initWindowDecorActionBar();</code>里面主要是设置ActionBar。</p>\n<h5 id=\"追踪com-android-internal-policy-PhoneWindow\"><a href=\"#追踪com-android-internal-policy-PhoneWindow\" class=\"headerlink\" title=\"追踪com.android.internal.policy.PhoneWindow\"></a>追踪com.android.internal.policy.PhoneWindow</h5><p>先简后繁，看一下现成的view如何添加到ContentView的：</p>\n<pre><code> @Override\n    public void setContentView(View view) {\n        setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n    }\n\n @Override\npublic void setContentView(View view, ViewGroup.LayoutParams params) {\n\n    ...\n\n    mContentParent.addView(view, params);\n\n    ...\n\n }\n</code></pre><p>把已有的view设置进入<code>ContentView</code>，只需要调用<code>ViewGroup.addView(View view)</code>添加到DecorView即可。<br><br>这里提一句：view都是要添加到父view上的。 </p>\n<pre><code>public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;\n</code></pre><p>这个ID对应的ViewGroup，即xml布局的父view。其源码注释：</p>\n<blockquote>\n<p>   This is the view in which the window contents are placed. It is either mDecor itself, or a child of mDecor where the contents go.<br>   这是要放置window内容的view。是DecorView本身，或是DecorView的孩子。</p>\n</blockquote>\n<p>总之，一句话，现成的view，亦或是将来的LayoutInflater生成的view，都要添加到ID_ANDROID_CONTENT之内。</p>\n<p>下面，来看一下xml文件如何变成view的：</p>\n<pre><code>@Override\n    public void setContentView(int layoutResID) {\n\n    ...\n\n            mLayoutInflater.inflate(layoutResID, mContentParent);\n\n    ...\n\n    }\n</code></pre><p>一目了然，调用系统服务LayoutInflater的inflate方法。</p>\n<h4 id=\"追踪LayoutInflater源码\"><a href=\"#追踪LayoutInflater源码\" class=\"headerlink\" title=\"追踪LayoutInflater源码\"></a>追踪LayoutInflater源码</h4><p>关键方法：</p>\n<ul>\n<li>inflate * n</li>\n<li>rInflate</li>\n<li>createViewFromTag</li>\n<li>createView</li>\n</ul>\n<h5 id=\"inflate\"><a href=\"#inflate\" class=\"headerlink\" title=\"inflate\"></a>inflate</h5><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {\n    final Resources res = getContext().getResources();\n    if (DEBUG) {\n        Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot;\n                + Integer.toHexString(resource) + &quot;)&quot;);\n    }\n\n    final XmlResourceParser parser = res.getLayout(resource);\n    try {\n        return inflate(parser, root, attachToRoot);\n    } finally {\n        parser.close();\n    }\n}\n</code></pre><p>获取XmlResourceParser(XmlPullParser的子类)的实例，用于待会遍历xml文件结点。</p>\n<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {\n    synchronized (mConstructorArgs) {\n\n...\n\n final String name = parser.getName();\n if (TAG_MERGE.equals(name)) {\n\n...\n\nrInflate(parser, root, inflaterContext, attrs, false);\n\n...\n\n} else {\n\n...\n\n rInflateChildren(parser, temp, attrs, true);\n\n...\n\n        }\n    }\n}\n</code></pre><p>由于merge标签，只能作为xml根标签使用，所以分开处理。</p>\n<h5 id=\"rInflate\"><a href=\"#rInflate\" class=\"headerlink\" title=\"rInflate\"></a>rInflate</h5><pre><code>void rInflate(XmlPullParser parser, View parent, Context context,\n           AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {\n\n       final int depth = parser.getDepth();\n       int type;\n\n       while (((type = parser.next()) != XmlPullParser.END_TAG ||\n               parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {\n\n           if (type != XmlPullParser.START_TAG) {\n               continue;\n           }\n\n           final String name = parser.getName();\n\n           if (TAG_REQUEST_FOCUS.equals(name)) {\n               parseRequestFocus(parser, parent);\n           } else if (TAG_TAG.equals(name)) {\n               parseViewTag(parser, parent, attrs);\n           } else if (TAG_INCLUDE.equals(name)) {\n               if (parser.getDepth() == 0) {\n                   throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);\n               }\n               parseInclude(parser, context, parent, attrs);\n           } else if (TAG_MERGE.equals(name)) {\n               throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);\n           } else {\n               final View view = createViewFromTag(parent, name, context, attrs);\n               final ViewGroup viewGroup = (ViewGroup) parent;\n               final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);\n               rInflateChildren(parser, view, attrs, true);\n               viewGroup.addView(view, params);\n           }\n       }\n\n       if (finishInflate) {\n           parent.onFinishInflate();\n       }\n   }\n</code></pre><p>深度优先遍历xml树，判断标签类型，循环递归直至<code>XmlPullParser.END_DOCUMENT</code>。</p>\n<h5 id=\"createViewFromTag\"><a href=\"#createViewFromTag\" class=\"headerlink\" title=\"createViewFromTag\"></a>createViewFromTag</h5><pre><code>    View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,\n                boolean ignoreThemeAttr) {\n            if (name.equals(&quot;view&quot;)) {\n                name = attrs.getAttributeValue(null, &quot;class&quot;);\n            }\n\n    ...\n\n                  if (name.equals(TAG_1995)) {\n            // Let&apos;s party like it&apos;s 1995!\n            return new BlinkLayout(context, attrs);\n        }\n\n    ...\n\ntry {\n        View view;\n        if (mFactory2 != null) {\n            view = mFactory2.onCreateView(parent, name, context, attrs);\n        } else if (mFactory != null) {\n            view = mFactory.onCreateView(name, context, attrs);\n        } else {\n            view = null;\n        }\n\n        if (view == null &amp;&amp; mPrivateFactory != null) {\n            view = mPrivateFactory.onCreateView(parent, name, context, attrs);\n        }\n\n        if (view == null) {\n            final Object lastContext = mConstructorArgs[0];\n            mConstructorArgs[0] = context;\n            try {\n                if (-1 == name.indexOf(&apos;.&apos;)) {\n                    view = onCreateView(parent, name, attrs);\n                } else {\n                    view = createView(name, null, attrs);\n                }\n            } finally {\n                mConstructorArgs[0] = lastContext;\n            }\n        }\n\n        return view;\n    } \n\n...\n\n}\n</code></pre><p>如果view为属性标签，那么name就是属性的值。<br><br>如果TAG_1995，做出来的布局会一闪一闪的。<br><br>如果该LayoutInflater被复制过，比如用于做换肤之类的功能，那么通过调用复制后的LayoutInflater的Factory定义的onCreateView——主要是看其定义的view的属性，最后还是调用的createView——生成view<br><br>如果是普通的view，标签名里如果含有“.”，那么说明是自定义view，不需要往createView中添加name的前缀，直接name就带有包名了；否则是系统的view，需要往createView中添加name的前缀，比如<code>android.widget</code>。<br></p>\n<h5 id=\"createView\"><a href=\"#createView\" class=\"headerlink\" title=\"createView\"></a>createView</h5><pre><code>public final View createView(String name, String prefix, AttributeSet attrs)\n        throws ClassNotFoundException, InflateException {\n    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);\n    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {\n        constructor = null;\n        sConstructorMap.remove(name);\n    }\n    Class&lt;? extends View&gt; clazz = null;\n\n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);\n\n        if (constructor == null) {\n            // Class not found in the cache, see if it&apos;s real, and try to add it\n            clazz = mContext.getClassLoader().loadClass(\n                    prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n            if (mFilter != null &amp;&amp; clazz != null) {\n                boolean allowed = mFilter.onLoadClass(clazz);\n                if (!allowed) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n            constructor = clazz.getConstructor(mConstructorSignature);\n            constructor.setAccessible(true);\n            sConstructorMap.put(name, constructor);\n        } else {\n            // If we have a filter, apply it to cached constructor\n            if (mFilter != null) {\n                // Have we seen this name before?\n                Boolean allowedState = mFilterMap.get(name);\n                if (allowedState == null) {\n                    // New class -- remember whether it is allowed\n                    clazz = mContext.getClassLoader().loadClass(\n                            prefix != null ? (prefix + name) : name).asSubclass(View.class);\n\n                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);\n                    mFilterMap.put(name, allowed);\n                    if (!allowed) {\n                        failNotAllowed(name, prefix, attrs);\n                    }\n                } else if (allowedState.equals(Boolean.FALSE)) {\n                    failNotAllowed(name, prefix, attrs);\n                }\n            }\n        }\n\n        Object[] args = mConstructorArgs;\n        args[1] = attrs;\n\n        final View view = constructor.newInstance(args);\n        if (view instanceof ViewStub) {\n            // Use the same context when inflating ViewStub later.\n            final ViewStub viewStub = (ViewStub) view;\n            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));\n        }\n        return view;\n\n    } \n}\n</code></pre><ul>\n<li>根据view的名字，缓存的构造器map中是否存在；</li>\n<li>如果不存在或者存在但没通过验证，就重新生成并缓存，生成时如果name有前缀就拼装上，通过反射获取其构造函数；</li>\n<li>通过其构造生成view。</li>\n</ul>\n"},{"layout":"post","title":"kotlin在实际使用中的一些问题解决","date":"2017-03-01T00:00:00.000Z","_content":" \n\n#### 引起build false ####\n\n##### 提示信息 #####\n>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can't find referenced method 'int getThemeResId()' in library class android.view.ContextThemeWrapper\n\n##### 原因&解决 #####\n\n>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.\n\n\n>解决：compile 'org.jetbrains.anko:anko-common:0.9.1' \n\n\n注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。[传送](https://github.com/Kotlin/anko/issues/206)。\n\n<br/>\n<br/>\n\n\n#### fragment中没有使用findViewById，报null异常 ####\n\n##### 提示信息 #####\n\n>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.View android.view.View.findViewById(int)' on a null object reference\n\n##### 原因&解决 #####\n\n>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.\n\n[传送。](http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments)\n\n#### companion object ####\n\ncompanion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.\n\n#### 对一个可能为null对象的处理 ####\n\n- surround with null check: `if (item != null)`\n- Add non-null asserted:`obj!!`\n- replace with safe  (?.) call:`obj?`\n\n对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。\n\n\n#### kotlin中的操作符重载 ####\n\n[官方传送](https://kotlinlang.org/docs/reference/basic-types.html) <br/>\n[优秀blog传送](http://blog.csdn.net/io_field/article/details/52817471)\n\n要用到的是java中的&操作，在kotlin中是and方法。\n\n#### 一个对象在改变属性时，可能为null的提示 ####  \n\n>Smart cast to 'Drawable' is impossible , because 'goldSwBean' is a mutable property that could have been change by this time\n\n在每一步build的时候，都加上确认对象不会为空的判定,如下：<br/>\nAdd non-null asserted:`obj!!`\n\n#### instanceof  ####\n\ninstanceof 使用is替代了  \n\n#### 类型强制转换  ####\n\n使用as。` (view as TextView)`\n\n#### 集合操作  ####\n\n[官方传送](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)<br/>\n[民间传送](http://www.cnblogs.com/figozhg/p/5031398.html)<br/>\n很多封装，方便。<br/>\n注意`map``foreach`，好用的。\n\n#### swithc-case的default ####\n \n已知switch-case被when取代了，那么default是啥？如下：\n\t\n\twhen (x) {\n\t    1 -> print(\"x == 1\")\n\t    2 -> print(\"x == 2\")\n\t    else -> { // Note the block\n\t        print(\"x is neither 1 nor 2\")\n\t    }\n\t}\n\n\n#### adapter中的getView问题 ####\n\n>Parameter specified as non-null is null\n\n语义比较明白：检测到非空参数为空。\n<br/>\n \n事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。\n\n[kotlin空安全扩展](http://kotlinlang.org/docs/reference/null-safety.html)\n\n#### name  shadowed 警告 ####\n\n>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning -- but it is allowed.\n\n#### 开启子线程 ####\n\n如果需要UI线程之外做些事情：\n\t\n\t doAsync {\n                Thread.sleep(1000)\n                uiThread {  }//回到UI线程\n\t          }\n\n\n#### xml or text declaration not at start ####\n\n这个是kotlin无关的问题，仅做记录:\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n这行代码在xml中，不要多不要少就要一行，放在首行。\n\n#### open class ####\n\nKotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。\n\n#### return null ####\n有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：\n\n\tfun method():String ? {\n            return null\n        }\n\n#### 可变参数使用关键字：vararg ####\n\n    fun demo(vararg texts : String){\n\n     }\n\n#### 究极快速方法 ####\n如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。\n\n#### Unresolved reference: rem ####\n1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br/>\n1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(\"DEPRECATION\")\n\n#### for 循环 ####\n##### 循环遍历对象 ####\n\tfor (item in collection) {\n    print(item)\n}\n\n##### 循环计数 #####\n\tfor (index in 0..viewGroup.getChildCount() - 1) {\n    val view = viewGroup.getChildAt(index)\n    view.visibility = View.VISIBLE\n}\n\n##### 循环遍历对象数组 #####\n\n\tfor (i in array.indices)\n    print(array[i])\n\n#### 延时执行任务 ####\njava<br/>\n\n\t mHandler.postDelayed(new Runnable() {\n\t                    @Override\n\t                    public void run() {\n\t                       //do something\n\t                    }\n\t                }, 3000);\n\nkotlin<br/>\n\n\tmHandler.postDelayed(Runnable { //do something }, 3000)\n\n#### lambda ####\n\n##### android提示框 #####\n\t\n\tbuilder.setPositiveButton(\"同意\", object : DialogInterface.OnClickListener {\n\t            override fun onClick(dialog: DialogInterface?, which: Int) {\n\t\n\t            }\n\t\n\t        })\n    builder.setPositiveButton(\"同意\") { dialog, which ->\n        \n    }\n\n#### 覆盖父类的方法 ####\n\n>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final\n\n#### 构造函数 ####\n\n一级构造：\n\n\tclass Person constructor(firstName: String) {\n\t}\n\t或\n\tclass Person(firstName: String){\n\t}\t\n\n二级构造：\n\n\tclass Person {\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\t\n\t}\t\n\n私有构造：\n\n\tclass DontCreateMe private constructor () {\n\t}\n\n类初始化操作：\n\n\tclass Customer(name: String) {\n    init {\n        logger,info(\"Customer initialized with value ${name}\")\n    }\n\t}\n\n#### 接口 ####\n\n\n\tinterface MyInterface {\n\t    var name:String //name 属性, 抽象的\n\t    fun bar()\n\t    fun foo() {\n\t        // 可选的方法体\n\t        println(\"foo\")\n\t    }\n\t}\n\tclass Child : MyInterface {\n\t    override var name: String = \"runoob\" //重载属性\n\t    override fun bar() {\n\t        // 方法体\n\t        println(\"bar\")\n\t    }\n\t}\n\tfun main(args: Array<String>) {\n\t    val c =  Child()\n\t    c.foo();\n\t    c.bar();\n\t    println(c.name)\n\t \n\t}\n\n`update @ 2017年7月14日18:51:09`\n\n#### list 如何添加元素 ####\n\n声明list，则使用plus\n声明ArrayList，则使用add\n\n#### 可见性修饰词 ####\n\n- 默认public\n- private\n- private\n- internal\n- protected","source":"_posts/2017-03-01-kotlin-in-project.md","raw":"---\nlayout: post\ntitle:  kotlin在实际使用中的一些问题解决\ndate:   2017-03-01\ncategories: JAVA & kotlin\ntag: 杂项\n---\n \n\n#### 引起build false ####\n\n##### 提示信息 #####\n>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can't find referenced method 'int getThemeResId()' in library class android.view.ContextThemeWrapper\n\n##### 原因&解决 #####\n\n>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.\n\n\n>解决：compile 'org.jetbrains.anko:anko-common:0.9.1' \n\n\n注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。[传送](https://github.com/Kotlin/anko/issues/206)。\n\n<br/>\n<br/>\n\n\n#### fragment中没有使用findViewById，报null异常 ####\n\n##### 提示信息 #####\n\n>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'android.view.View android.view.View.findViewById(int)' on a null object reference\n\n##### 原因&解决 #####\n\n>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.\n\n[传送。](http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments)\n\n#### companion object ####\n\ncompanion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.\n\n#### 对一个可能为null对象的处理 ####\n\n- surround with null check: `if (item != null)`\n- Add non-null asserted:`obj!!`\n- replace with safe  (?.) call:`obj?`\n\n对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。\n\n\n#### kotlin中的操作符重载 ####\n\n[官方传送](https://kotlinlang.org/docs/reference/basic-types.html) <br/>\n[优秀blog传送](http://blog.csdn.net/io_field/article/details/52817471)\n\n要用到的是java中的&操作，在kotlin中是and方法。\n\n#### 一个对象在改变属性时，可能为null的提示 ####  \n\n>Smart cast to 'Drawable' is impossible , because 'goldSwBean' is a mutable property that could have been change by this time\n\n在每一步build的时候，都加上确认对象不会为空的判定,如下：<br/>\nAdd non-null asserted:`obj!!`\n\n#### instanceof  ####\n\ninstanceof 使用is替代了  \n\n#### 类型强制转换  ####\n\n使用as。` (view as TextView)`\n\n#### 集合操作  ####\n\n[官方传送](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html)<br/>\n[民间传送](http://www.cnblogs.com/figozhg/p/5031398.html)<br/>\n很多封装，方便。<br/>\n注意`map``foreach`，好用的。\n\n#### swithc-case的default ####\n \n已知switch-case被when取代了，那么default是啥？如下：\n\t\n\twhen (x) {\n\t    1 -> print(\"x == 1\")\n\t    2 -> print(\"x == 2\")\n\t    else -> { // Note the block\n\t        print(\"x is neither 1 nor 2\")\n\t    }\n\t}\n\n\n#### adapter中的getView问题 ####\n\n>Parameter specified as non-null is null\n\n语义比较明白：检测到非空参数为空。\n<br/>\n \n事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。\n\n[kotlin空安全扩展](http://kotlinlang.org/docs/reference/null-safety.html)\n\n#### name  shadowed 警告 ####\n\n>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning -- but it is allowed.\n\n#### 开启子线程 ####\n\n如果需要UI线程之外做些事情：\n\t\n\t doAsync {\n                Thread.sleep(1000)\n                uiThread {  }//回到UI线程\n\t          }\n\n\n#### xml or text declaration not at start ####\n\n这个是kotlin无关的问题，仅做记录:\n\n`<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n\n这行代码在xml中，不要多不要少就要一行，放在首行。\n\n#### open class ####\n\nKotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。\n\n#### return null ####\n有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：\n\n\tfun method():String ? {\n            return null\n        }\n\n#### 可变参数使用关键字：vararg ####\n\n    fun demo(vararg texts : String){\n\n     }\n\n#### 究极快速方法 ####\n如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。\n\n#### Unresolved reference: rem ####\n1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br/>\n1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(\"DEPRECATION\")\n\n#### for 循环 ####\n##### 循环遍历对象 ####\n\tfor (item in collection) {\n    print(item)\n}\n\n##### 循环计数 #####\n\tfor (index in 0..viewGroup.getChildCount() - 1) {\n    val view = viewGroup.getChildAt(index)\n    view.visibility = View.VISIBLE\n}\n\n##### 循环遍历对象数组 #####\n\n\tfor (i in array.indices)\n    print(array[i])\n\n#### 延时执行任务 ####\njava<br/>\n\n\t mHandler.postDelayed(new Runnable() {\n\t                    @Override\n\t                    public void run() {\n\t                       //do something\n\t                    }\n\t                }, 3000);\n\nkotlin<br/>\n\n\tmHandler.postDelayed(Runnable { //do something }, 3000)\n\n#### lambda ####\n\n##### android提示框 #####\n\t\n\tbuilder.setPositiveButton(\"同意\", object : DialogInterface.OnClickListener {\n\t            override fun onClick(dialog: DialogInterface?, which: Int) {\n\t\n\t            }\n\t\n\t        })\n    builder.setPositiveButton(\"同意\") { dialog, which ->\n        \n    }\n\n#### 覆盖父类的方法 ####\n\n>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final\n\n#### 构造函数 ####\n\n一级构造：\n\n\tclass Person constructor(firstName: String) {\n\t}\n\t或\n\tclass Person(firstName: String){\n\t}\t\n\n二级构造：\n\n\tclass Person {\n    constructor(parent: Person) {\n        parent.children.add(this)\n    }\t\n\t}\t\n\n私有构造：\n\n\tclass DontCreateMe private constructor () {\n\t}\n\n类初始化操作：\n\n\tclass Customer(name: String) {\n    init {\n        logger,info(\"Customer initialized with value ${name}\")\n    }\n\t}\n\n#### 接口 ####\n\n\n\tinterface MyInterface {\n\t    var name:String //name 属性, 抽象的\n\t    fun bar()\n\t    fun foo() {\n\t        // 可选的方法体\n\t        println(\"foo\")\n\t    }\n\t}\n\tclass Child : MyInterface {\n\t    override var name: String = \"runoob\" //重载属性\n\t    override fun bar() {\n\t        // 方法体\n\t        println(\"bar\")\n\t    }\n\t}\n\tfun main(args: Array<String>) {\n\t    val c =  Child()\n\t    c.foo();\n\t    c.bar();\n\t    println(c.name)\n\t \n\t}\n\n`update @ 2017年7月14日18:51:09`\n\n#### list 如何添加元素 ####\n\n声明list，则使用plus\n声明ArrayList，则使用add\n\n#### 可见性修饰词 ####\n\n- 默认public\n- private\n- private\n- internal\n- protected","slug":"kotlin-in-project","published":1,"updated":"2017-08-17T02:42:04.458Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1cz001x2sivybpmdses","content":"<h4 id=\"引起build-false\"><a href=\"#引起build-false\" class=\"headerlink\" title=\"引起build false\"></a>引起build false</h4><h5 id=\"提示信息\"><a href=\"#提示信息\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can’t find referenced method ‘int getThemeResId()’ in library class android.view.ContextThemeWrapper</p>\n</blockquote>\n<h5 id=\"原因-amp-解决\"><a href=\"#原因-amp-解决\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.</p>\n<p>解决：compile ‘org.jetbrains.anko:anko-common:0.9.1’ </p>\n</blockquote>\n<p>注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。<a href=\"https://github.com/Kotlin/anko/issues/206\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p><br><br><br></p>\n<h4 id=\"fragment中没有使用findViewById，报null异常\"><a href=\"#fragment中没有使用findViewById，报null异常\" class=\"headerlink\" title=\"fragment中没有使用findViewById，报null异常\"></a>fragment中没有使用findViewById，报null异常</h4><h5 id=\"提示信息-1\"><a href=\"#提示信息-1\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method ‘android.view.View android.view.View.findViewById(int)’ on a null object reference</p>\n</blockquote>\n<h5 id=\"原因-amp-解决-1\"><a href=\"#原因-amp-解决-1\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.</p>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments\" target=\"_blank\" rel=\"external\">传送。</a></p>\n<h4 id=\"companion-object\"><a href=\"#companion-object\" class=\"headerlink\" title=\"companion object\"></a>companion object</h4><p>companion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.</p>\n<h4 id=\"对一个可能为null对象的处理\"><a href=\"#对一个可能为null对象的处理\" class=\"headerlink\" title=\"对一个可能为null对象的处理\"></a>对一个可能为null对象的处理</h4><ul>\n<li>surround with null check: <code>if (item != null)</code></li>\n<li>Add non-null asserted:<code>obj!!</code></li>\n<li>replace with safe  (?.) call:<code>obj?</code></li>\n</ul>\n<p>对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。</p>\n<h4 id=\"kotlin中的操作符重载\"><a href=\"#kotlin中的操作符重载\" class=\"headerlink\" title=\"kotlin中的操作符重载\"></a>kotlin中的操作符重载</h4><p><a href=\"https://kotlinlang.org/docs/reference/basic-types.html\" target=\"_blank\" rel=\"external\">官方传送</a> <br><br><a href=\"http://blog.csdn.net/io_field/article/details/52817471\" target=\"_blank\" rel=\"external\">优秀blog传送</a></p>\n<p>要用到的是java中的&amp;操作，在kotlin中是and方法。</p>\n<h4 id=\"一个对象在改变属性时，可能为null的提示\"><a href=\"#一个对象在改变属性时，可能为null的提示\" class=\"headerlink\" title=\"一个对象在改变属性时，可能为null的提示\"></a>一个对象在改变属性时，可能为null的提示</h4><blockquote>\n<p>Smart cast to ‘Drawable’ is impossible , because ‘goldSwBean’ is a mutable property that could have been change by this time</p>\n</blockquote>\n<p>在每一步build的时候，都加上确认对象不会为空的判定,如下：<br><br>Add non-null asserted:<code>obj!!</code></p>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><p>instanceof 使用is替代了  </p>\n<h4 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h4><p>使用as。<code>(view as TextView)</code></p>\n<h4 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h4><p><a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html\" target=\"_blank\" rel=\"external\">官方传送</a><br><br><a href=\"http://www.cnblogs.com/figozhg/p/5031398.html\" target=\"_blank\" rel=\"external\">民间传送</a><br><br>很多封装，方便。<br><br>注意<code>map``foreach</code>，好用的。</p>\n<h4 id=\"swithc-case的default\"><a href=\"#swithc-case的default\" class=\"headerlink\" title=\"swithc-case的default\"></a>swithc-case的default</h4><p>已知switch-case被when取代了，那么default是啥？如下：</p>\n<pre><code>when (x) {\n    1 -&gt; print(&quot;x == 1&quot;)\n    2 -&gt; print(&quot;x == 2&quot;)\n    else -&gt; { // Note the block\n        print(&quot;x is neither 1 nor 2&quot;)\n    }\n}\n</code></pre><h4 id=\"adapter中的getView问题\"><a href=\"#adapter中的getView问题\" class=\"headerlink\" title=\"adapter中的getView问题\"></a>adapter中的getView问题</h4><blockquote>\n<p>Parameter specified as non-null is null</p>\n</blockquote>\n<p>语义比较明白：检测到非空参数为空。<br><br></p>\n<p>事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。</p>\n<p><a href=\"http://kotlinlang.org/docs/reference/null-safety.html\" target=\"_blank\" rel=\"external\">kotlin空安全扩展</a></p>\n<h4 id=\"name-shadowed-警告\"><a href=\"#name-shadowed-警告\" class=\"headerlink\" title=\"name  shadowed 警告\"></a>name  shadowed 警告</h4><blockquote>\n<p>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning – but it is allowed.</p>\n</blockquote>\n<h4 id=\"开启子线程\"><a href=\"#开启子线程\" class=\"headerlink\" title=\"开启子线程\"></a>开启子线程</h4><p>如果需要UI线程之外做些事情：</p>\n<pre><code>doAsync {\n           Thread.sleep(1000)\n           uiThread {  }//回到UI线程\n         }\n</code></pre><h4 id=\"xml-or-text-declaration-not-at-start\"><a href=\"#xml-or-text-declaration-not-at-start\" class=\"headerlink\" title=\"xml or text declaration not at start\"></a>xml or text declaration not at start</h4><p>这个是kotlin无关的问题，仅做记录:</p>\n<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>\n<p>这行代码在xml中，不要多不要少就要一行，放在首行。</p>\n<h4 id=\"open-class\"><a href=\"#open-class\" class=\"headerlink\" title=\"open class\"></a>open class</h4><p>Kotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。</p>\n<h4 id=\"return-null\"><a href=\"#return-null\" class=\"headerlink\" title=\"return null\"></a>return null</h4><p>有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：</p>\n<pre><code>fun method():String ? {\n        return null\n    }\n</code></pre><h4 id=\"可变参数使用关键字：vararg\"><a href=\"#可变参数使用关键字：vararg\" class=\"headerlink\" title=\"可变参数使用关键字：vararg\"></a>可变参数使用关键字：vararg</h4><pre><code>fun demo(vararg texts : String){\n\n }\n</code></pre><h4 id=\"究极快速方法\"><a href=\"#究极快速方法\" class=\"headerlink\" title=\"究极快速方法\"></a>究极快速方法</h4><p>如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。</p>\n<h4 id=\"Unresolved-reference-rem\"><a href=\"#Unresolved-reference-rem\" class=\"headerlink\" title=\"Unresolved reference: rem\"></a>Unresolved reference: rem</h4><p>1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br><br>1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(“DEPRECATION”)</p>\n<h4 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h4><h5 id=\"循环遍历对象\"><a href=\"#循环遍历对象\" class=\"headerlink\" title=\"循环遍历对象\"></a>循环遍历对象</h5><pre><code>for (item in collection) {\nprint(item)\n</code></pre><p>}</p>\n<h5 id=\"循环计数\"><a href=\"#循环计数\" class=\"headerlink\" title=\"循环计数\"></a>循环计数</h5><pre><code>for (index in 0..viewGroup.getChildCount() - 1) {\nval view = viewGroup.getChildAt(index)\nview.visibility = View.VISIBLE\n</code></pre><p>}</p>\n<h5 id=\"循环遍历对象数组\"><a href=\"#循环遍历对象数组\" class=\"headerlink\" title=\"循环遍历对象数组\"></a>循环遍历对象数组</h5><pre><code>for (i in array.indices)\nprint(array[i])\n</code></pre><h4 id=\"延时执行任务\"><a href=\"#延时执行任务\" class=\"headerlink\" title=\"延时执行任务\"></a>延时执行任务</h4><p>java<br></p>\n<pre><code>mHandler.postDelayed(new Runnable() {\n                   @Override\n                   public void run() {\n                      //do something\n                   }\n               }, 3000);\n</code></pre><p>kotlin<br></p>\n<pre><code>mHandler.postDelayed(Runnable { //do something }, 3000)\n</code></pre><h4 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h4><h5 id=\"android提示框\"><a href=\"#android提示框\" class=\"headerlink\" title=\"android提示框\"></a>android提示框</h5><pre><code>builder.setPositiveButton(&quot;同意&quot;, object : DialogInterface.OnClickListener {\n            override fun onClick(dialog: DialogInterface?, which: Int) {\n\n            }\n\n        })\nbuilder.setPositiveButton(&quot;同意&quot;) { dialog, which -&gt;\n\n}\n</code></pre><h4 id=\"覆盖父类的方法\"><a href=\"#覆盖父类的方法\" class=\"headerlink\" title=\"覆盖父类的方法\"></a>覆盖父类的方法</h4><blockquote>\n<p>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final</p>\n</blockquote>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>一级构造：</p>\n<pre><code>class Person constructor(firstName: String) {\n}\n或\nclass Person(firstName: String){\n}    \n</code></pre><p>二级构造：</p>\n<pre><code>class Person {\nconstructor(parent: Person) {\n    parent.children.add(this)\n}    \n}    \n</code></pre><p>私有构造：</p>\n<pre><code>class DontCreateMe private constructor () {\n}\n</code></pre><p>类初始化操作：</p>\n<pre><code>class Customer(name: String) {\ninit {\n    logger,info(&quot;Customer initialized with value ${name}&quot;)\n}\n}\n</code></pre><h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><pre><code>interface MyInterface {\n    var name:String //name 属性, 抽象的\n    fun bar()\n    fun foo() {\n        // 可选的方法体\n        println(&quot;foo&quot;)\n    }\n}\nclass Child : MyInterface {\n    override var name: String = &quot;runoob&quot; //重载属性\n    override fun bar() {\n        // 方法体\n        println(&quot;bar&quot;)\n    }\n}\nfun main(args: Array&lt;String&gt;) {\n    val c =  Child()\n    c.foo();\n    c.bar();\n    println(c.name)\n\n}\n</code></pre><p><code>update @ 2017年7月14日18:51:09</code></p>\n<h4 id=\"list-如何添加元素\"><a href=\"#list-如何添加元素\" class=\"headerlink\" title=\"list 如何添加元素\"></a>list 如何添加元素</h4><p>声明list，则使用plus<br>声明ArrayList，则使用add</p>\n<h4 id=\"可见性修饰词\"><a href=\"#可见性修饰词\" class=\"headerlink\" title=\"可见性修饰词\"></a>可见性修饰词</h4><ul>\n<li>默认public</li>\n<li>private</li>\n<li>private</li>\n<li>internal</li>\n<li>protected</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引起build-false\"><a href=\"#引起build-false\" class=\"headerlink\" title=\"引起build false\"></a>引起build false</h4><h5 id=\"提示信息\"><a href=\"#提示信息\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Proguard Warning: org.jetbrains.anko.internals.AnkoInternals: can’t find referenced method ‘int getThemeResId()’ in library class android.view.ContextThemeWrapper</p>\n</blockquote>\n<h5 id=\"原因-amp-解决\"><a href=\"#原因-amp-解决\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>原因：This call only works with android.support.v7.view.ContextThemeWrapper because in system framework base ContextThemeWrapper is hide this call and the existence of getThemeResId not guaranteed.</p>\n<p>解决：compile ‘org.jetbrains.anko:anko-common:0.9.1’ </p>\n</blockquote>\n<p>注意，只要不使用0.9就可以，比如使用0.8.3也是可用的。<a href=\"https://github.com/Kotlin/anko/issues/206\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p><br><br><br></p>\n<h4 id=\"fragment中没有使用findViewById，报null异常\"><a href=\"#fragment中没有使用findViewById，报null异常\" class=\"headerlink\" title=\"fragment中没有使用findViewById，报null异常\"></a>fragment中没有使用findViewById，报null异常</h4><h5 id=\"提示信息-1\"><a href=\"#提示信息-1\" class=\"headerlink\" title=\"提示信息\"></a>提示信息</h5><blockquote>\n<p>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method ‘android.view.View android.view.View.findViewById(int)’ on a null object reference</p>\n</blockquote>\n<h5 id=\"原因-amp-解决-1\"><a href=\"#原因-amp-解决-1\" class=\"headerlink\" title=\"原因&amp;解决\"></a>原因&amp;解决</h5><blockquote>\n<p>The problem is that you are accessing it too soon. getView() returns null in onCreateView. Try doing it in the onViewCreated method.</p>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/34541650/kotlin-android-extensions-and-fragments\" target=\"_blank\" rel=\"external\">传送。</a></p>\n<h4 id=\"companion-object\"><a href=\"#companion-object\" class=\"headerlink\" title=\"companion object\"></a>companion object</h4><p>companion object只能在类中使用，相当于java中的静态内部类（kotlin没有static关键字）.</p>\n<h4 id=\"对一个可能为null对象的处理\"><a href=\"#对一个可能为null对象的处理\" class=\"headerlink\" title=\"对一个可能为null对象的处理\"></a>对一个可能为null对象的处理</h4><ul>\n<li>surround with null check: <code>if (item != null)</code></li>\n<li>Add non-null asserted:<code>obj!!</code></li>\n<li>replace with safe  (?.) call:<code>obj?</code></li>\n</ul>\n<p>对象后跟一个问号，表明其可能为空，如果跟两个感叹号，表明确定该对象不为空。</p>\n<h4 id=\"kotlin中的操作符重载\"><a href=\"#kotlin中的操作符重载\" class=\"headerlink\" title=\"kotlin中的操作符重载\"></a>kotlin中的操作符重载</h4><p><a href=\"https://kotlinlang.org/docs/reference/basic-types.html\" target=\"_blank\" rel=\"external\">官方传送</a> <br><br><a href=\"http://blog.csdn.net/io_field/article/details/52817471\" target=\"_blank\" rel=\"external\">优秀blog传送</a></p>\n<p>要用到的是java中的&amp;操作，在kotlin中是and方法。</p>\n<h4 id=\"一个对象在改变属性时，可能为null的提示\"><a href=\"#一个对象在改变属性时，可能为null的提示\" class=\"headerlink\" title=\"一个对象在改变属性时，可能为null的提示\"></a>一个对象在改变属性时，可能为null的提示</h4><blockquote>\n<p>Smart cast to ‘Drawable’ is impossible , because ‘goldSwBean’ is a mutable property that could have been change by this time</p>\n</blockquote>\n<p>在每一步build的时候，都加上确认对象不会为空的判定,如下：<br><br>Add non-null asserted:<code>obj!!</code></p>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><p>instanceof 使用is替代了  </p>\n<h4 id=\"类型强制转换\"><a href=\"#类型强制转换\" class=\"headerlink\" title=\"类型强制转换\"></a>类型强制转换</h4><p>使用as。<code>(view as TextView)</code></p>\n<h4 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h4><p><a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html\" target=\"_blank\" rel=\"external\">官方传送</a><br><br><a href=\"http://www.cnblogs.com/figozhg/p/5031398.html\" target=\"_blank\" rel=\"external\">民间传送</a><br><br>很多封装，方便。<br><br>注意<code>map``foreach</code>，好用的。</p>\n<h4 id=\"swithc-case的default\"><a href=\"#swithc-case的default\" class=\"headerlink\" title=\"swithc-case的default\"></a>swithc-case的default</h4><p>已知switch-case被when取代了，那么default是啥？如下：</p>\n<pre><code>when (x) {\n    1 -&gt; print(&quot;x == 1&quot;)\n    2 -&gt; print(&quot;x == 2&quot;)\n    else -&gt; { // Note the block\n        print(&quot;x is neither 1 nor 2&quot;)\n    }\n}\n</code></pre><h4 id=\"adapter中的getView问题\"><a href=\"#adapter中的getView问题\" class=\"headerlink\" title=\"adapter中的getView问题\"></a>adapter中的getView问题</h4><blockquote>\n<p>Parameter specified as non-null is null</p>\n</blockquote>\n<p>语义比较明白：检测到非空参数为空。<br><br></p>\n<p>事实上，在getView中，该参数没有用到，不需要关系是否为空，因此，在该变量后加?，表示其可以为空即可。</p>\n<p><a href=\"http://kotlinlang.org/docs/reference/null-safety.html\" target=\"_blank\" rel=\"external\">kotlin空安全扩展</a></p>\n<h4 id=\"name-shadowed-警告\"><a href=\"#name-shadowed-警告\" class=\"headerlink\" title=\"name  shadowed 警告\"></a>name  shadowed 警告</h4><blockquote>\n<p>Any scope can shadow a variable used in another scope. It is NOT good practice and does produce a compiler warning – but it is allowed.</p>\n</blockquote>\n<h4 id=\"开启子线程\"><a href=\"#开启子线程\" class=\"headerlink\" title=\"开启子线程\"></a>开启子线程</h4><p>如果需要UI线程之外做些事情：</p>\n<pre><code>doAsync {\n           Thread.sleep(1000)\n           uiThread {  }//回到UI线程\n         }\n</code></pre><h4 id=\"xml-or-text-declaration-not-at-start\"><a href=\"#xml-or-text-declaration-not-at-start\" class=\"headerlink\" title=\"xml or text declaration not at start\"></a>xml or text declaration not at start</h4><p>这个是kotlin无关的问题，仅做记录:</p>\n<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>\n<p>这行代码在xml中，不要多不要少就要一行，放在首行。</p>\n<h4 id=\"open-class\"><a href=\"#open-class\" class=\"headerlink\" title=\"open class\"></a>open class</h4><p>Kotlin的类默认是final的，也就是不可继承的，如果让类可继承，使用open关键字。当类有abstract关键字时，不需要使用open了。</p>\n<h4 id=\"return-null\"><a href=\"#return-null\" class=\"headerlink\" title=\"return null\"></a>return null</h4><p>有时候需要返回某个对象的实例，如果不存在就返回空。在要返回的类型后追加“？”eg：</p>\n<pre><code>fun method():String ? {\n        return null\n    }\n</code></pre><h4 id=\"可变参数使用关键字：vararg\"><a href=\"#可变参数使用关键字：vararg\" class=\"headerlink\" title=\"可变参数使用关键字：vararg\"></a>可变参数使用关键字：vararg</h4><pre><code>fun demo(vararg texts : String){\n\n }\n</code></pre><h4 id=\"究极快速方法\"><a href=\"#究极快速方法\" class=\"headerlink\" title=\"究极快速方法\"></a>究极快速方法</h4><p>如果有的kotlin实现方式不知道，可以先写java的代码，然后copy、paste进入kotlin文件，AndroidStudio有插件即可自动转换。</p>\n<h4 id=\"Unresolved-reference-rem\"><a href=\"#Unresolved-reference-rem\" class=\"headerlink\" title=\"Unresolved reference: rem\"></a>Unresolved reference: rem</h4><p>1.1版本导致，1.1以前的版本，尽管没有此方法，依然会提示。<br><br>1.1把mod改成了rem但是导致了版本错误。建议使用mod+@Suppress(“DEPRECATION”)</p>\n<h4 id=\"for-循环\"><a href=\"#for-循环\" class=\"headerlink\" title=\"for 循环\"></a>for 循环</h4><h5 id=\"循环遍历对象\"><a href=\"#循环遍历对象\" class=\"headerlink\" title=\"循环遍历对象\"></a>循环遍历对象</h5><pre><code>for (item in collection) {\nprint(item)\n</code></pre><p>}</p>\n<h5 id=\"循环计数\"><a href=\"#循环计数\" class=\"headerlink\" title=\"循环计数\"></a>循环计数</h5><pre><code>for (index in 0..viewGroup.getChildCount() - 1) {\nval view = viewGroup.getChildAt(index)\nview.visibility = View.VISIBLE\n</code></pre><p>}</p>\n<h5 id=\"循环遍历对象数组\"><a href=\"#循环遍历对象数组\" class=\"headerlink\" title=\"循环遍历对象数组\"></a>循环遍历对象数组</h5><pre><code>for (i in array.indices)\nprint(array[i])\n</code></pre><h4 id=\"延时执行任务\"><a href=\"#延时执行任务\" class=\"headerlink\" title=\"延时执行任务\"></a>延时执行任务</h4><p>java<br></p>\n<pre><code>mHandler.postDelayed(new Runnable() {\n                   @Override\n                   public void run() {\n                      //do something\n                   }\n               }, 3000);\n</code></pre><p>kotlin<br></p>\n<pre><code>mHandler.postDelayed(Runnable { //do something }, 3000)\n</code></pre><h4 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h4><h5 id=\"android提示框\"><a href=\"#android提示框\" class=\"headerlink\" title=\"android提示框\"></a>android提示框</h5><pre><code>builder.setPositiveButton(&quot;同意&quot;, object : DialogInterface.OnClickListener {\n            override fun onClick(dialog: DialogInterface?, which: Int) {\n\n            }\n\n        })\nbuilder.setPositiveButton(&quot;同意&quot;) { dialog, which -&gt;\n\n}\n</code></pre><h4 id=\"覆盖父类的方法\"><a href=\"#覆盖父类的方法\" class=\"headerlink\" title=\"覆盖父类的方法\"></a>覆盖父类的方法</h4><blockquote>\n<p>标记为 override 的成员是 open的，它可以在子类中被复写。如果你不想被重写就要加 final</p>\n</blockquote>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>一级构造：</p>\n<pre><code>class Person constructor(firstName: String) {\n}\n或\nclass Person(firstName: String){\n}    \n</code></pre><p>二级构造：</p>\n<pre><code>class Person {\nconstructor(parent: Person) {\n    parent.children.add(this)\n}    \n}    \n</code></pre><p>私有构造：</p>\n<pre><code>class DontCreateMe private constructor () {\n}\n</code></pre><p>类初始化操作：</p>\n<pre><code>class Customer(name: String) {\ninit {\n    logger,info(&quot;Customer initialized with value ${name}&quot;)\n}\n}\n</code></pre><h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><pre><code>interface MyInterface {\n    var name:String //name 属性, 抽象的\n    fun bar()\n    fun foo() {\n        // 可选的方法体\n        println(&quot;foo&quot;)\n    }\n}\nclass Child : MyInterface {\n    override var name: String = &quot;runoob&quot; //重载属性\n    override fun bar() {\n        // 方法体\n        println(&quot;bar&quot;)\n    }\n}\nfun main(args: Array&lt;String&gt;) {\n    val c =  Child()\n    c.foo();\n    c.bar();\n    println(c.name)\n\n}\n</code></pre><p><code>update @ 2017年7月14日18:51:09</code></p>\n<h4 id=\"list-如何添加元素\"><a href=\"#list-如何添加元素\" class=\"headerlink\" title=\"list 如何添加元素\"></a>list 如何添加元素</h4><p>声明list，则使用plus<br>声明ArrayList，则使用add</p>\n<h4 id=\"可见性修饰词\"><a href=\"#可见性修饰词\" class=\"headerlink\" title=\"可见性修饰词\"></a>可见性修饰词</h4><ul>\n<li>默认public</li>\n<li>private</li>\n<li>private</li>\n<li>internal</li>\n<li>protected</li>\n</ul>\n"},{"layout":"post","title":"Android系统服务：WindowManager","date":"2017-03-02T00:00:00.000Z","_content":" \n\n#### 开发中使用 ####\n\n- 获取屏幕宽高\n- 代码设置全屏显示\n- 保持屏幕常亮\n- 悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)\n\n#### 需要的类 ####\n\n- `com.android.server.wm.WindowManagerService`\n- `android.view.WindowManager`\n- `android.view.Window`\n \n \n  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。 \nWindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。\n\nWindow的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。\n\n#### flag 参数 ####\nFlags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。\nFLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。\nFLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。\nFLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。\n\n#### type 参数 ####\n   \nType参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：\nmLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;\n同时声明权限：\n\n\t<uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n \n选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。\n实现的Window的demo，应该有两种类型。\n \nFramework定义了三种窗口类型，三种类型的定义在WindowManager类中。\n第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。\n第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。\n第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。\n\n<br/>\n注意：MIUI系统需要在设置->其他应用管理->应用信息->权限管理,中打开“显示悬浮窗”才能显示。\n\n\n<br/>\n\nwindow 诱导用户输入QQ号及密码：https://yq.aliyun.com/ziliao/160722\n\n<br/>\n视图是如何附加在Window上的,Window有是如何管理这些视图的.\n\n\n\nhttp://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=555\n\n\n\n\n\n\n","source":"_posts/2017-03-02-android-system-service-window-manager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：WindowManager\ndate:   2017-03-02\ncategories: Android System Framework\ntag: android\n---\n \n\n#### 开发中使用 ####\n\n- 获取屏幕宽高\n- 代码设置全屏显示\n- 保持屏幕常亮\n- 悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)\n\n#### 需要的类 ####\n\n- `com.android.server.wm.WindowManagerService`\n- `android.view.WindowManager`\n- `android.view.Window`\n \n \n  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。 \nWindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。\n\nWindow的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。\n\n#### flag 参数 ####\nFlags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。\nFLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。\nFLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。\nFLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。\n\n#### type 参数 ####\n   \nType参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：\nmLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;\n同时声明权限：\n\n\t<uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n \n选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。\n实现的Window的demo，应该有两种类型。\n \nFramework定义了三种窗口类型，三种类型的定义在WindowManager类中。\n第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。\n第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。\n第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。\n\n<br/>\n注意：MIUI系统需要在设置->其他应用管理->应用信息->权限管理,中打开“显示悬浮窗”才能显示。\n\n\n<br/>\n\nwindow 诱导用户输入QQ号及密码：https://yq.aliyun.com/ziliao/160722\n\n<br/>\n视图是如何附加在Window上的,Window有是如何管理这些视图的.\n\n\n\nhttp://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=555\n\n\n\n\n\n\n","slug":"android-system-service-window-manager","published":1,"updated":"2017-08-17T02:42:41.252Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1d200202sivn3tz095y","content":"<h4 id=\"开发中使用\"><a href=\"#开发中使用\" class=\"headerlink\" title=\"开发中使用\"></a>开发中使用</h4><ul>\n<li>获取屏幕宽高</li>\n<li>代码设置全屏显示</li>\n<li>保持屏幕常亮</li>\n<li>悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)</li>\n</ul>\n<h4 id=\"需要的类\"><a href=\"#需要的类\" class=\"headerlink\" title=\"需要的类\"></a>需要的类</h4><ul>\n<li><code>com.android.server.wm.WindowManagerService</code></li>\n<li><code>android.view.WindowManager</code></li>\n<li><code>android.view.Window</code></li>\n</ul>\n<p>  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。<br>WindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。</p>\n<p>Window的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。</p>\n<h4 id=\"flag-参数\"><a href=\"#flag-参数\" class=\"headerlink\" title=\"flag 参数\"></a>flag 参数</h4><p>Flags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。<br>FLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。<br>FLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。<br>FLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。</p>\n<h4 id=\"type-参数\"><a href=\"#type-参数\" class=\"headerlink\" title=\"type 参数\"></a>type 参数</h4><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：<br>mLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;<br>同时声明权限：</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;\n</code></pre><p>选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。<br>实现的Window的demo，应该有两种类型。</p>\n<p>Framework定义了三种窗口类型，三种类型的定义在WindowManager类中。<br>第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。<br>第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。<br>第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。</p>\n<p><br><br>注意：MIUI系统需要在设置-&gt;其他应用管理-&gt;应用信息-&gt;权限管理,中打开“显示悬浮窗”才能显示。</p>\n<p><br></p>\n<p>window 诱导用户输入QQ号及密码：<a href=\"https://yq.aliyun.com/ziliao/160722\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/ziliao/160722</a></p>\n<p><br><br>视图是如何附加在Window上的,Window有是如何管理这些视图的.</p>\n<p><a href=\"http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555\" target=\"_blank\" rel=\"external\">http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"开发中使用\"><a href=\"#开发中使用\" class=\"headerlink\" title=\"开发中使用\"></a>开发中使用</h4><ul>\n<li>获取屏幕宽高</li>\n<li>代码设置全屏显示</li>\n<li>保持屏幕常亮</li>\n<li>悬浮view(来电显示提醒，浮层引导，应用内悬浮按钮)</li>\n</ul>\n<h4 id=\"需要的类\"><a href=\"#需要的类\" class=\"headerlink\" title=\"需要的类\"></a>需要的类</h4><ul>\n<li><code>com.android.server.wm.WindowManagerService</code></li>\n<li><code>android.view.WindowManager</code></li>\n<li><code>android.view.Window</code></li>\n</ul>\n<p>  Window是一个抽象类，具体实现是PhoneWindow。不管是Activity、Dialog、Toast它们的视图都是附加在Window上的，因此Window实际上是View的直接管理者。<br>WindowManager是外界访问Window的入口，通过WindowManager可以创建Window，而Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。</p>\n<p>Window的添加、更新、移除是通过WindowManager接口管理的，在WindowManagerImpl中，调用了WindowManagerGlobal里的具体实现。</p>\n<h4 id=\"flag-参数\"><a href=\"#flag-参数\" class=\"headerlink\" title=\"flag 参数\"></a>flag 参数</h4><p>Flags参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性。<br>FLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL,最终事件会直接传递给下层的具有焦点的Window。<br>FLAG_NOT_TOUCH_MODAL: 在此模式下，系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法收到单击事件。<br>FLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上。</p>\n<h4 id=\"type-参数\"><a href=\"#type-参数\" class=\"headerlink\" title=\"type 参数\"></a>type 参数</h4><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window和系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的一些Dialog就是一个子Window。系统Window是需要声明权限才能创建的Window，比如Toast 和系统状态栏这些都是系统Window。Window是分层的，每个Window都有对应的z-ordered，层级大的会覆盖在层级小的Window的上面，这和HTML中的z-index的概念是完全一致的。在三类Window中，应用Window的层级范围是1-99，子Window的层级范围是1000-1999，系统Window的层级范围是2000-2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。很显然系统Window的层级是最大的，而且系统层级有很多值，一般我们可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR,如果采用TYPE_SYSTEM_ERROR，只需要为type参数指定这个层级即可：<br>mLayoutParams.flags = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;<br>同时声明权限：</p>\n<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;\n</code></pre><p>选择UI和状态最简单的Toast源码，避免陷入过深的逻辑代码。<br>实现的Window的demo，应该有两种类型。</p>\n<p>Framework定义了三种窗口类型，三种类型的定义在WindowManager类中。<br>第一种为应用窗口。所谓的应用窗口是指该窗口对应一个Activity,由于加载Activity是 由 AmS完成的，因此，对于应用程序来讲，要创建一个应用类窗口，只能在Activity内部完成。<br>第二种是子窗口。所谓的子窗口是指，该窗口必须有一个父窗口，父窗口可以是一个应用类型窗口，也可以是任何其他类型的窗口。<br>第三类是系统窗口。系统窗口不需要对应任何Activity,也不需要有父窗口。对于应用程序而言，理论上是无法创建系统窗口的，因为所有的应用程序都没有这个权限，然而系统进程却可以创建系统窗口。</p>\n<p><br><br>注意：MIUI系统需要在设置-&gt;其他应用管理-&gt;应用信息-&gt;权限管理,中打开“显示悬浮窗”才能显示。</p>\n<p><br></p>\n<p>window 诱导用户输入QQ号及密码：<a href=\"https://yq.aliyun.com/ziliao/160722\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/ziliao/160722</a></p>\n<p><br><br>视图是如何附加在Window上的,Window有是如何管理这些视图的.</p>\n<p><a href=\"http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555\" target=\"_blank\" rel=\"external\">http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555</a></p>\n"},{"layout":"post","title":"建造者设计模式(一) 基础知识","date":"2017-03-03T00:00:00.000Z","_content":" \n\n#### what ####\n\n一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。\n<br/>\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n#### 使用场景 ####\n\n1. 相同的方法，不同的执行顺序，产生不同的事件结果时；\n2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n3. 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n记住一句话:`遇到多个构造器参数时要考虑用构建器。`\n\n\n#### 为什么是builder模式 ####\n\n在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：\n\n1. 重叠构造器-telescoping constructor\n2. JavaBeans模式\n3. 构造器模式\n\n##### 重叠构造器 #####\n\n- 随着参数数目的增加，很难控制\n- 代码很难编写，难以阅读\n- 如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。\n\t\n\t\t\n\t\t/**\n\t\t * 重叠构造器Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class TeleScopDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tpublic TeleScopDemo(int param1) {\n\t\t\t\tthis(param1, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2) {\n\t\t\t\tthis(param1, param2, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3) {\n\t\t\t\tthis(param1, param2, param3, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4) {\n\t\t\t\tthis(param1, param2, param3, param4, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4,\n\t\t\t\t\tint param5) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t\tthis.param2 = param2;\n\t\t\t\tthis.param3 = param3;\n\t\t\t\tthis.param4 = param4;\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n##### JavaBeans #####\n\n由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 \n\t\t\n\t\t/**\n\t\t * JavaBeans模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class JavaBeansDemo {\n\t\t\n\t\t\tprivate int param1;\n\t\t\tprivate int param2;\n\t\t\tprivate int param3;\n\t\t\tprivate int param4;\n\t\t\tprivate int param5;\n\t\t\n\t\t\tpublic JavaBeansDemo() {\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam1(int param1) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam2(int param2) {\n\t\t\t\tthis.param2 = param2;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam3(int param3) {\n\t\t\t\tthis.param3 = param3;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam4(int param4) {\n\t\t\t\tthis.param4 = param4;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam5(int param5) {\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n\n\n##### Builder模式 #####\n\t\t\n既有重叠构造器的安全性，也有JavaBeans的可读性。\n \n\t\t/**\n\t\t * 构建器模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class BuilderPatternDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tprivate BuilderPatternDemo(Builder builder) {\n\t\t\t\tparam1 = builder.param1;\n\t\t\t\tparam2 = builder.param2;\n\t\t\t\tparam3 = builder.param3;\n\t\t\t\tparam4 = builder.param4;\n\t\t\t\tparam5 = builder.param5;\n\t\t\t}\n\t\t\n\t\t\tpublic static class Builder {\n\t\t\t\t// 必需的参数\n\t\t\t\tprivate final int param1;\n\t\t\n\t\t\t\t// 可选的参数，带有初始值\n\t\t\t\tprivate int param2 = 0;\n\t\t\t\tprivate int param3 = 0;\n\t\t\t\tprivate int param4 = 0;\n\t\t\t\tprivate int param5 = 0;\n\t\t\n\t\t\t\tpublic Builder(int param1) {\n\t\t\t\t\tthis.param1 = param1;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param2(int val) {\n\t\t\t\t\tparam2 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param3(int val) {\n\t\t\t\t\tparam3 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param4(int val) {\n\t\t\t\t\tparam4 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param5(int val) {\n\t\t\t\t\tparam5 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic BuilderPatternDemo build(){\n\t\t\t\t\treturn new BuilderPatternDemo(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t","source":"_posts/2017-03-03-design-patterns-builder-1.md","raw":"---\nlayout: post\ntitle:  建造者设计模式(一) 基础知识\ndate:   2017-03-03\ncategories: Design Pattern\ntag: 设计模式\n---\n \n\n#### what ####\n\n一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。\n<br/>\n\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n#### 使用场景 ####\n\n1. 相同的方法，不同的执行顺序，产生不同的事件结果时；\n2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；\n3. 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。\n\n记住一句话:`遇到多个构造器参数时要考虑用构建器。`\n\n\n#### 为什么是builder模式 ####\n\n在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：\n\n1. 重叠构造器-telescoping constructor\n2. JavaBeans模式\n3. 构造器模式\n\n##### 重叠构造器 #####\n\n- 随着参数数目的增加，很难控制\n- 代码很难编写，难以阅读\n- 如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。\n\t\n\t\t\n\t\t/**\n\t\t * 重叠构造器Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class TeleScopDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tpublic TeleScopDemo(int param1) {\n\t\t\t\tthis(param1, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2) {\n\t\t\t\tthis(param1, param2, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3) {\n\t\t\t\tthis(param1, param2, param3, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4) {\n\t\t\t\tthis(param1, param2, param3, param4, 0);\n\t\t\t}\n\t\t\n\t\t\tpublic TeleScopDemo(int param1, int param2, int param3, int param4,\n\t\t\t\t\tint param5) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t\tthis.param2 = param2;\n\t\t\t\tthis.param3 = param3;\n\t\t\t\tthis.param4 = param4;\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n##### JavaBeans #####\n\n由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 \n\t\t\n\t\t/**\n\t\t * JavaBeans模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class JavaBeansDemo {\n\t\t\n\t\t\tprivate int param1;\n\t\t\tprivate int param2;\n\t\t\tprivate int param3;\n\t\t\tprivate int param4;\n\t\t\tprivate int param5;\n\t\t\n\t\t\tpublic JavaBeansDemo() {\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam1(int param1) {\n\t\t\t\tthis.param1 = param1;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam2(int param2) {\n\t\t\t\tthis.param2 = param2;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam3(int param3) {\n\t\t\t\tthis.param3 = param3;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam4(int param4) {\n\t\t\t\tthis.param4 = param4;\n\t\t\t}\n\t\t\n\t\t\tpublic void setParam5(int param5) {\n\t\t\t\tthis.param5 = param5;\n\t\t\t}\n\t\t\n\t\t}\n\n\n\n##### Builder模式 #####\n\t\t\n既有重叠构造器的安全性，也有JavaBeans的可读性。\n \n\t\t/**\n\t\t * 构建器模式Demo\n\t\t * \n\t\t * @author Administrator\n\t\t * \n\t\t */\n\t\tpublic class BuilderPatternDemo {\n\t\t\n\t\t\tprivate final int param1;\n\t\t\tprivate final int param2;\n\t\t\tprivate final int param3;\n\t\t\tprivate final int param4;\n\t\t\tprivate final int param5;\n\t\t\n\t\t\tprivate BuilderPatternDemo(Builder builder) {\n\t\t\t\tparam1 = builder.param1;\n\t\t\t\tparam2 = builder.param2;\n\t\t\t\tparam3 = builder.param3;\n\t\t\t\tparam4 = builder.param4;\n\t\t\t\tparam5 = builder.param5;\n\t\t\t}\n\t\t\n\t\t\tpublic static class Builder {\n\t\t\t\t// 必需的参数\n\t\t\t\tprivate final int param1;\n\t\t\n\t\t\t\t// 可选的参数，带有初始值\n\t\t\t\tprivate int param2 = 0;\n\t\t\t\tprivate int param3 = 0;\n\t\t\t\tprivate int param4 = 0;\n\t\t\t\tprivate int param5 = 0;\n\t\t\n\t\t\t\tpublic Builder(int param1) {\n\t\t\t\t\tthis.param1 = param1;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param2(int val) {\n\t\t\t\t\tparam2 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param3(int val) {\n\t\t\t\t\tparam3 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param4(int val) {\n\t\t\t\t\tparam4 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic Builder param5(int val) {\n\t\t\t\t\tparam5 = val;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\n\t\t\t\tpublic BuilderPatternDemo build(){\n\t\t\t\t\treturn new BuilderPatternDemo(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t","slug":"design-patterns-builder-1","published":1,"updated":"2017-08-17T02:43:04.747Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1d400242sivh0o5jt9w","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。<br><br></p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li>相同的方法，不同的执行顺序，产生不同的事件结果时；</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；</li>\n<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。</li>\n</ol>\n<p>记住一句话:<code>遇到多个构造器参数时要考虑用构建器。</code></p>\n<h4 id=\"为什么是builder模式\"><a href=\"#为什么是builder模式\" class=\"headerlink\" title=\"为什么是builder模式\"></a>为什么是builder模式</h4><p>在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：</p>\n<ol>\n<li>重叠构造器-telescoping constructor</li>\n<li>JavaBeans模式</li>\n<li>构造器模式</li>\n</ol>\n<h5 id=\"重叠构造器\"><a href=\"#重叠构造器\" class=\"headerlink\" title=\"重叠构造器\"></a>重叠构造器</h5><ul>\n<li>随着参数数目的增加，很难控制</li>\n<li>代码很难编写，难以阅读</li>\n<li>如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。</li>\n</ul>\n<pre><code>/**\n * 重叠构造器Demo\n * \n * @author Administrator\n * \n */\npublic class TeleScopDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    public TeleScopDemo(int param1) {\n        this(param1, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2) {\n        this(param1, param2, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3) {\n        this(param1, param2, param3, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4) {\n        this(param1, param2, param3, param4, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4,\n            int param5) {\n        this.param1 = param1;\n        this.param2 = param2;\n        this.param3 = param3;\n        this.param4 = param4;\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"JavaBeans\"><a href=\"#JavaBeans\" class=\"headerlink\" title=\"JavaBeans\"></a>JavaBeans</h5><p>由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 </p>\n<pre><code>/**\n * JavaBeans模式Demo\n * \n * @author Administrator\n * \n */\npublic class JavaBeansDemo {\n\n    private int param1;\n    private int param2;\n    private int param3;\n    private int param4;\n    private int param5;\n\n    public JavaBeansDemo() {\n    }\n\n    public void setParam1(int param1) {\n        this.param1 = param1;\n    }\n\n    public void setParam2(int param2) {\n        this.param2 = param2;\n    }\n\n    public void setParam3(int param3) {\n        this.param3 = param3;\n    }\n\n    public void setParam4(int param4) {\n        this.param4 = param4;\n    }\n\n    public void setParam5(int param5) {\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"Builder模式\"><a href=\"#Builder模式\" class=\"headerlink\" title=\"Builder模式\"></a>Builder模式</h5><p>既有重叠构造器的安全性，也有JavaBeans的可读性。</p>\n<pre><code>/**\n * 构建器模式Demo\n * \n * @author Administrator\n * \n */\npublic class BuilderPatternDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    private BuilderPatternDemo(Builder builder) {\n        param1 = builder.param1;\n        param2 = builder.param2;\n        param3 = builder.param3;\n        param4 = builder.param4;\n        param5 = builder.param5;\n    }\n\n    public static class Builder {\n        // 必需的参数\n        private final int param1;\n\n        // 可选的参数，带有初始值\n        private int param2 = 0;\n        private int param3 = 0;\n        private int param4 = 0;\n        private int param5 = 0;\n\n        public Builder(int param1) {\n            this.param1 = param1;\n        }\n\n        public Builder param2(int val) {\n            param2 = val;\n            return this;\n        }\n\n        public Builder param3(int val) {\n            param3 = val;\n            return this;\n        }\n\n        public Builder param4(int val) {\n            param4 = val;\n            return this;\n        }\n\n        public Builder param5(int val) {\n            param5 = val;\n            return this;\n        }\n\n        public BuilderPatternDemo build(){\n            return new BuilderPatternDemo(this);\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细地控制对象的构造流程。<br><br></p>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li>相同的方法，不同的执行顺序，产生不同的事件结果时；</li>\n<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；</li>\n<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值。</li>\n</ol>\n<p>记住一句话:<code>遇到多个构造器参数时要考虑用构建器。</code></p>\n<h4 id=\"为什么是builder模式\"><a href=\"#为什么是builder模式\" class=\"headerlink\" title=\"为什么是builder模式\"></a>为什么是builder模式</h4><p>在创建一个对象时，如果有多个构造器参数，可选的方式有以下几种：</p>\n<ol>\n<li>重叠构造器-telescoping constructor</li>\n<li>JavaBeans模式</li>\n<li>构造器模式</li>\n</ol>\n<h5 id=\"重叠构造器\"><a href=\"#重叠构造器\" class=\"headerlink\" title=\"重叠构造器\"></a>重叠构造器</h5><ul>\n<li>随着参数数目的增加，很难控制</li>\n<li>代码很难编写，难以阅读</li>\n<li>如果参数的类型相同，那么调用时如果不小心颠倒了其中的俩。。</li>\n</ul>\n<pre><code>/**\n * 重叠构造器Demo\n * \n * @author Administrator\n * \n */\npublic class TeleScopDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    public TeleScopDemo(int param1) {\n        this(param1, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2) {\n        this(param1, param2, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3) {\n        this(param1, param2, param3, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4) {\n        this(param1, param2, param3, param4, 0);\n    }\n\n    public TeleScopDemo(int param1, int param2, int param3, int param4,\n            int param5) {\n        this.param1 = param1;\n        this.param2 = param2;\n        this.param3 = param3;\n        this.param4 = param4;\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"JavaBeans\"><a href=\"#JavaBeans\" class=\"headerlink\" title=\"JavaBeans\"></a>JavaBeans</h5><p>由于其构造过程被分到了几个调用中，在构造过程中可能处于不一致的状态。需要同步来保证其线程安全。 </p>\n<pre><code>/**\n * JavaBeans模式Demo\n * \n * @author Administrator\n * \n */\npublic class JavaBeansDemo {\n\n    private int param1;\n    private int param2;\n    private int param3;\n    private int param4;\n    private int param5;\n\n    public JavaBeansDemo() {\n    }\n\n    public void setParam1(int param1) {\n        this.param1 = param1;\n    }\n\n    public void setParam2(int param2) {\n        this.param2 = param2;\n    }\n\n    public void setParam3(int param3) {\n        this.param3 = param3;\n    }\n\n    public void setParam4(int param4) {\n        this.param4 = param4;\n    }\n\n    public void setParam5(int param5) {\n        this.param5 = param5;\n    }\n\n}\n</code></pre><h5 id=\"Builder模式\"><a href=\"#Builder模式\" class=\"headerlink\" title=\"Builder模式\"></a>Builder模式</h5><p>既有重叠构造器的安全性，也有JavaBeans的可读性。</p>\n<pre><code>/**\n * 构建器模式Demo\n * \n * @author Administrator\n * \n */\npublic class BuilderPatternDemo {\n\n    private final int param1;\n    private final int param2;\n    private final int param3;\n    private final int param4;\n    private final int param5;\n\n    private BuilderPatternDemo(Builder builder) {\n        param1 = builder.param1;\n        param2 = builder.param2;\n        param3 = builder.param3;\n        param4 = builder.param4;\n        param5 = builder.param5;\n    }\n\n    public static class Builder {\n        // 必需的参数\n        private final int param1;\n\n        // 可选的参数，带有初始值\n        private int param2 = 0;\n        private int param3 = 0;\n        private int param4 = 0;\n        private int param5 = 0;\n\n        public Builder(int param1) {\n            this.param1 = param1;\n        }\n\n        public Builder param2(int val) {\n            param2 = val;\n            return this;\n        }\n\n        public Builder param3(int val) {\n            param3 = val;\n            return this;\n        }\n\n        public Builder param4(int val) {\n            param4 = val;\n            return this;\n        }\n\n        public Builder param5(int val) {\n            param5 = val;\n            return this;\n        }\n\n        public BuilderPatternDemo build(){\n            return new BuilderPatternDemo(this);\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"建造者设计模式(二) Android中的应用","date":"2017-03-03T00:00:00.000Z","_content":"\n\n#### AlertDialog.Builder ####\n\n如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br/>\n那么AlertDialog中的参数，如何传递？<br/>\n\nAlertDialog 中有一个AlertController的实例。<br/>\nAlertController中有个AlertParams的静态类。<br/>\n在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br/>\nBuilder中的方法都把属性传入了AlertParams。<br/>\n在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br/>\n\n示意图如下：\n\n![示例图](/images/alertDialog.png)\n#### Uri.Builder ####\n\n\n\nUri.Builder; \nNotification.Builder;\nContentProviderOperation.Builder;\n ","source":"_posts/2017-03-03-design-patterns-builder-2.md","raw":"---\nlayout: post\ntitle:  建造者设计模式(二) Android中的应用\ndate:   2017-03-03\ncategories: Design Pattern\ntag: 设计模式\n---\n\n\n#### AlertDialog.Builder ####\n\n如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br/>\n那么AlertDialog中的参数，如何传递？<br/>\n\nAlertDialog 中有一个AlertController的实例。<br/>\nAlertController中有个AlertParams的静态类。<br/>\n在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br/>\nBuilder中的方法都把属性传入了AlertParams。<br/>\n在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br/>\n\n示意图如下：\n\n![示例图](/images/alertDialog.png)\n#### Uri.Builder ####\n\n\n\nUri.Builder; \nNotification.Builder;\nContentProviderOperation.Builder;\n ","slug":"design-patterns-builder-2","published":1,"updated":"2017-08-17T02:43:08.987Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1d700272sivyg0tn9ci","content":"<h4 id=\"AlertDialog-Builder\"><a href=\"#AlertDialog-Builder\" class=\"headerlink\" title=\"AlertDialog.Builder\"></a>AlertDialog.Builder</h4><p>如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br><br>那么AlertDialog中的参数，如何传递？<br></p>\n<p>AlertDialog 中有一个AlertController的实例。<br><br>AlertController中有个AlertParams的静态类。<br><br>在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br><br>Builder中的方法都把属性传入了AlertParams。<br><br>在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br></p>\n<p>示意图如下：</p>\n<p><img src=\"/images/alertDialog.png\" alt=\"示例图\"></p>\n<h4 id=\"Uri-Builder\"><a href=\"#Uri-Builder\" class=\"headerlink\" title=\"Uri.Builder\"></a>Uri.Builder</h4><p>Uri.Builder;<br>Notification.Builder;<br>ContentProviderOperation.Builder;</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"AlertDialog-Builder\"><a href=\"#AlertDialog-Builder\" class=\"headerlink\" title=\"AlertDialog.Builder\"></a>AlertDialog.Builder</h4><p>如何应用窗口主题，各种参数合法性检查，上下文切换，窗口创建内部流程，我们都略过，只看其参数的构建即可。<br><br>那么AlertDialog中的参数，如何传递？<br></p>\n<p>AlertDialog 中有一个AlertController的实例。<br><br>AlertController中有个AlertParams的静态类。<br><br>在AlertDialog中有一个静态类Builder，该Builder中持有AlertParams的一个实例。<br><br>Builder中的方法都把属性传入了AlertParams。<br><br>在Builder的create()方法，调用了AlertParams的applay，把参数传回了AlertController中。而AlertController的实例被AlertDialog持有。<br></p>\n<p>示意图如下：</p>\n<p><img src=\"/images/alertDialog.png\" alt=\"示例图\"></p>\n<h4 id=\"Uri-Builder\"><a href=\"#Uri-Builder\" class=\"headerlink\" title=\"Uri.Builder\"></a>Uri.Builder</h4><p>Uri.Builder;<br>Notification.Builder;<br>ContentProviderOperation.Builder;</p>\n"},{"layout":"post","title":"Tinker学习(一)热修复基础知识","date":"2017-03-15T00:00:00.000Z","_content":"  \n\n#### Dalvik ####\n \nDalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的`文件执行格式dex（dalvik executable）`，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。\n\n通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如[Apktool](https://ibotpeaches.github.io/Apktool/install/)或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。\n\n当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。\n\n但是在早期的 Android 系统中，DexOpt 有两个问题。<br/>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br/>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。\n<br/>\n#### ART ####\n\n即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.\n\n- 系统性能大幅提升\n- App启动、运行更快\n- 减少每次启动的编译增加电池续航\n- 存储占用更大\n- 安装时间更长\n\n还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。\n<br/>\n#### Dalvik vs ART ####\n\nDalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。\n\n在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。\n\nART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。\n \n![示例图](/images/dalvik&art.png)\n\n<br/>\n#### dex（dalvik executable） ####\n\nDex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br/>\n\n\n.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br/>\n\nodex（optimised dex）,优化后的dex。\n\n#### 主流修复方案：Native hook ####\n\n以[AndFix](https://github.com/alibaba/AndFix)最著名。原理如下图：\n \n![示例图](/images/andfix-yuanli.png)\n\n其修复过程如图：\n \n![示例图](/images/andfix-guocheng.png)\n\n这套方案直接使用`dalvik_replaceMethod`替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。\n\n#### 主流修复方案：基于android dex分包 ####\n\n详细原理介绍[传送](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a)。\n\n我用自己的话总结一下：<br/>\n1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br/>\n2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加`CLASS_ISPREVERIFIED`标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br/>\n3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。\n\n#### 主流修复方案：基于Instant Run的冷插拔原理的Dex替换 ####\n\n- 热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；\n- 温插拔：需要重建页面，典型代表：修改了Resource文件；\n- 冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。\n\n\nTinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。","source":"_posts/2017-03-15-tinker-source-code-1.md","raw":"---\nlayout: post\ntitle:  Tinker学习(一)热修复基础知识\ndate:   2017-03-15\ncategories: Android \ntag: hotfix\n---\n  \n\n#### Dalvik ####\n \nDalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的`文件执行格式dex（dalvik executable）`，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。\n\n通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如[Apktool](https://ibotpeaches.github.io/Apktool/install/)或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。\n\n当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。\n\n但是在早期的 Android 系统中，DexOpt 有两个问题。<br/>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br/>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。\n<br/>\n#### ART ####\n\n即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.\n\n- 系统性能大幅提升\n- App启动、运行更快\n- 减少每次启动的编译增加电池续航\n- 存储占用更大\n- 安装时间更长\n\n还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。\n<br/>\n#### Dalvik vs ART ####\n\nDalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。\n\n在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。\n\nART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。\n \n![示例图](/images/dalvik&art.png)\n\n<br/>\n#### dex（dalvik executable） ####\n\nDex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br/>\n\n\n.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br/>\n\nodex（optimised dex）,优化后的dex。\n\n#### 主流修复方案：Native hook ####\n\n以[AndFix](https://github.com/alibaba/AndFix)最著名。原理如下图：\n \n![示例图](/images/andfix-yuanli.png)\n\n其修复过程如图：\n \n![示例图](/images/andfix-guocheng.png)\n\n这套方案直接使用`dalvik_replaceMethod`替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。\n\n#### 主流修复方案：基于android dex分包 ####\n\n详细原理介绍[传送](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a)。\n\n我用自己的话总结一下：<br/>\n1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br/>\n2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加`CLASS_ISPREVERIFIED`标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br/>\n3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。\n\n#### 主流修复方案：基于Instant Run的冷插拔原理的Dex替换 ####\n\n- 热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；\n- 温插拔：需要重建页面，典型代表：修改了Resource文件；\n- 冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。\n\n\nTinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。","slug":"tinker-source-code-1","published":1,"updated":"2017-11-16T08:32:21.053Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1db002b2sivg507d99e","content":"<h4 id=\"Dalvik\"><a href=\"#Dalvik\" class=\"headerlink\" title=\"Dalvik\"></a>Dalvik</h4><p>Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的<code>文件执行格式dex（dalvik executable）</code>，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p>\n<p>通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如<a href=\"https://ibotpeaches.github.io/Apktool/install/\" target=\"_blank\" rel=\"external\">Apktool</a>或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。</p>\n<p>当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。</p>\n<p>但是在早期的 Android 系统中，DexOpt 有两个问题。<br>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。<br><br></p>\n<h4 id=\"ART\"><a href=\"#ART\" class=\"headerlink\" title=\"ART\"></a>ART</h4><p>即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.</p>\n<ul>\n<li>系统性能大幅提升</li>\n<li>App启动、运行更快</li>\n<li>减少每次启动的编译增加电池续航</li>\n<li>存储占用更大</li>\n<li>安装时间更长</li>\n</ul>\n<p>还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。<br><br></p>\n<h4 id=\"Dalvik-vs-ART\"><a href=\"#Dalvik-vs-ART\" class=\"headerlink\" title=\"Dalvik vs ART\"></a>Dalvik vs ART</h4><p>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>\n<p>在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。</p>\n<p>ART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。</p>\n<p><img src=\"/images/dalvik&amp;art.png\" alt=\"示例图\"></p>\n<p><br></p>\n<h4 id=\"dex（dalvik-executable）\"><a href=\"#dex（dalvik-executable）\" class=\"headerlink\" title=\"dex（dalvik executable）\"></a>dex（dalvik executable）</h4><p>Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br></p>\n<p>.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br></p>\n<p>odex（optimised dex）,优化后的dex。</p>\n<h4 id=\"主流修复方案：Native-hook\"><a href=\"#主流修复方案：Native-hook\" class=\"headerlink\" title=\"主流修复方案：Native hook\"></a>主流修复方案：Native hook</h4><p>以<a href=\"https://github.com/alibaba/AndFix\" target=\"_blank\" rel=\"external\">AndFix</a>最著名。原理如下图：</p>\n<p><img src=\"/images/andfix-yuanli.png\" alt=\"示例图\"></p>\n<p>其修复过程如图：</p>\n<p><img src=\"/images/andfix-guocheng.png\" alt=\"示例图\"></p>\n<p>这套方案直接使用<code>dalvik_replaceMethod</code>替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。</p>\n<h4 id=\"主流修复方案：基于android-dex分包\"><a href=\"#主流修复方案：基于android-dex分包\" class=\"headerlink\" title=\"主流修复方案：基于android dex分包\"></a>主流修复方案：基于android dex分包</h4><p>详细原理介绍<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p>我用自己的话总结一下：<br><br>1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br><br>2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加<code>CLASS_ISPREVERIFIED</code>标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br><br>3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。</p>\n<h4 id=\"主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\"><a href=\"#主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\" class=\"headerlink\" title=\"主流修复方案：基于Instant Run的冷插拔原理的Dex替换\"></a>主流修复方案：基于Instant Run的冷插拔原理的Dex替换</h4><ul>\n<li>热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；</li>\n<li>温插拔：需要重建页面，典型代表：修改了Resource文件；</li>\n<li>冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。</li>\n</ul>\n<p>Tinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Dalvik\"><a href=\"#Dalvik\" class=\"headerlink\" title=\"Dalvik\"></a>Dalvik</h4><p>Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的<code>文件执行格式dex（dalvik executable）</code>，而JVM则执行的是java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p>\n<p>通过Dalvik的字节码我们不能直接看到原来的逻辑代码，这时需要借助如<a href=\"https://ibotpeaches.github.io/Apktool/install/\" target=\"_blank\" rel=\"external\">Apktool</a>或dex2jar+jd-gui工具来帮助查看。但是，注意的是最终我们修改APK需要操作的文件是.smali文件，而不是导出来的Java文件重新编译（况且这基本上不可能）。</p>\n<p>当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的。这个过程会生成一个 ODEX 文件，即 Optimised Dex。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。</p>\n<p>但是在早期的 Android 系统中，DexOpt 有两个问题。<br>（一）：DexOpt 会把每一个类的方法 id 检索起来，存在一个链表结构里面，但是这个链表的长度是用一个 short 类型来保存的，导致了方法 id 的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。<br>（二）：Dexopt 使用 LinearAlloc 来存储应用的方法信息。Dalvik LinearAlloc 是一个固定大小的缓冲区。在Android 版本的历史上，LinearAlloc 分别经历了4M/5M/8M/16M限制。Android 2.2和2.3的缓冲区只有5MB，Android 4.x提高到了8MB 或16MB。当方法数量过多导致超出缓冲区大小时，也会造成dexopt崩溃。<br><br></p>\n<h4 id=\"ART\"><a href=\"#ART\" class=\"headerlink\" title=\"ART\"></a>ART</h4><p>即Android Runtime，google为了替代Dalvik专门为Android研发的。Android KK为开发者推出，L版本正式上线。比替代品更高效省电，执行的是本地机器码，依靠Ahead-Of-Time (AOT)机制.</p>\n<ul>\n<li>系统性能大幅提升</li>\n<li>App启动、运行更快</li>\n<li>减少每次启动的编译增加电池续航</li>\n<li>存储占用更大</li>\n<li>安装时间更长</li>\n</ul>\n<p>还有一个地方需要注意的是，应用程序的安装发生在两个时机，第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。在第一个时机中，系统除了会对/system/app和/data/app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对/system/framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。<br><br></p>\n<h4 id=\"Dalvik-vs-ART\"><a href=\"#Dalvik-vs-ART\" class=\"headerlink\" title=\"Dalvik vs ART\"></a>Dalvik vs ART</h4><p>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>\n<p>在计算机的世界里，与JIT相对的是AOT。AOT进Ahead-Of-Time的简称，它发生在程序运行之前。我们用静态语言（例如C/C++）来开发应用程序的时候，编译器直接就把它们翻译成目标机器码。这种静态语言的编译方式也是AOT的一种。</p>\n<p>ART虚拟机并不要求开发者将自己的应用直接编译成目标机器码。这样，将应用的dex字节码翻译成本地机器码的最恰当AOT时机就发生在应用安装的时候。</p>\n<p><img src=\"/images/dalvik&amp;art.png\" alt=\"示例图\"></p>\n<p><br></p>\n<h4 id=\"dex（dalvik-executable）\"><a href=\"#dex（dalvik-executable）\" class=\"headerlink\" title=\"dex（dalvik executable）\"></a>dex（dalvik executable）</h4><p>Dex字节码,一种对class文件优化的产物,传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并，优化，然后生成一个最终的class.dex,目的是把不同class文件重复的东西只需保留一份,如果我们的Android应用不进行分dex处理,最后一个应用的apk只会有一个dex文件。<br></p>\n<p>.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。执行的是字节码，它是依靠Just-In-Time (JIT)机制去解释字节码<br></p>\n<p>odex（optimised dex）,优化后的dex。</p>\n<h4 id=\"主流修复方案：Native-hook\"><a href=\"#主流修复方案：Native-hook\" class=\"headerlink\" title=\"主流修复方案：Native hook\"></a>主流修复方案：Native hook</h4><p>以<a href=\"https://github.com/alibaba/AndFix\" target=\"_blank\" rel=\"external\">AndFix</a>最著名。原理如下图：</p>\n<p><img src=\"/images/andfix-yuanli.png\" alt=\"示例图\"></p>\n<p>其修复过程如图：</p>\n<p><img src=\"/images/andfix-guocheng.png\" alt=\"示例图\"></p>\n<p>这套方案直接使用<code>dalvik_replaceMethod</code>替换class中方法的实现。由于它并没有整体替换class，而field在class中的相对地址在class加载时已确定，所以AndFix无法支持新增或者删除field的情况(通过替换init与clinit只可以修改field的数值)。</p>\n<h4 id=\"主流修复方案：基于android-dex分包\"><a href=\"#主流修复方案：基于android-dex分包\" class=\"headerlink\" title=\"主流修复方案：基于android dex分包\"></a>主流修复方案：基于android dex分包</h4><p>详细原理介绍<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a\" target=\"_blank\" rel=\"external\">传送</a>。</p>\n<p>我用自己的话总结一下：<br><br>1.分包方案中，把修改的补丁dex，插入dexElements数组的最前面，这样根据classLoader找寻一个类的机制，理论上会优先找寻补丁dex里的修改类，从而完成修复；<br><br>2.如果修复好的类和引用该类的类不在同一个dex中则会引发错误，需要防止dexopt给修改后的类增加<code>CLASS_ISPREVERIFIED</code>标志，具体的说明可以参考上述文章；需要注意，dexopt是优化dex的，如果给所有的类都做非preverify，势必会引起一些性能上的损耗。<br><br>3.上述问题发生在dalvik虚拟机，如果是art上，插桩对代码的执行效率没什么影响，因为art直接执行本地机器码。但是如果补丁中的类出现修改类变量或者方法，可能会导致内存地址错乱，为了解决该问题，需要将修改类的父类、引用类、都加入补丁包中，补丁包会急剧变大。</p>\n<h4 id=\"主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\"><a href=\"#主流修复方案：基于Instant-Run的冷插拔原理的Dex替换\" class=\"headerlink\" title=\"主流修复方案：基于Instant Run的冷插拔原理的Dex替换\"></a>主流修复方案：基于Instant Run的冷插拔原理的Dex替换</h4><ul>\n<li>热插拔：无需重启app，无需重建页面，适用与方法修改，变量修改；</li>\n<li>温插拔：需要重建页面，典型代表：修改了Resource文件；</li>\n<li>冷插拔：需要重启app，代表：涉及结构性变化的，比如修改了继承规则，方法签名等。</li>\n</ul>\n<p>Tinker的思路，使用差异dex文件和旧的dex文件，生成修复后的，新的dex文件，从而达到完全使用新的dex的修复效果。</p>\n"},{"layout":"post","title":"原型设计模式(一) 基础知识","date":"2017-03-18T00:00:00.000Z","_content":"\n* content\n{:toc}\n\n#### 定义 ####\n\n创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。\n\n>《设计模式》：<br/> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。\n\n\n\n#### 使用场景 ####\n\n-  创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限\n-  一个对象多个修改者-浅拷贝\n-  一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值\n-  在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者\n-  如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好\n\n\n#### 类图 ####\n\n![类图](/images/prototype_class_uml.png)\n\n#### 时序图 ####\n\n![时序图](/images/prototype_sequence_uml.png)\n\n#### 优点/缺点 ####\n\n- clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升\n- 逃避构造函数的约束(既是优点也是缺点)\n- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候\n- 必须实现cloneable接口(java)\n\n\n\n \n#### 深/浅复制 ####\n 浅复制：<br/>\n复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。\n<br/>\n深复制：<br/>\n对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br/>\n被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n \n\n#### 来自《effective java》的建议 ####\n\n>第11条：谨慎地覆盖clone\n\n克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。\n\n建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br/>\n\n\n","source":"_posts/2017-03-18-design-patterns-prototype-1.md","raw":"---\nlayout: post\ntitle:  原型设计模式(一) 基础知识\ndate:   2017-03-18\ncategories: Design Pattern\ntag: 设计模式\n---\n\n* content\n{:toc}\n\n#### 定义 ####\n\n创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。\n\n>《设计模式》：<br/> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。\n\n\n\n#### 使用场景 ####\n\n-  创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限\n-  一个对象多个修改者-浅拷贝\n-  一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值\n-  在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者\n-  如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好\n\n\n#### 类图 ####\n\n![类图](/images/prototype_class_uml.png)\n\n#### 时序图 ####\n\n![时序图](/images/prototype_sequence_uml.png)\n\n#### 优点/缺点 ####\n\n- clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升\n- 逃避构造函数的约束(既是优点也是缺点)\n- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候\n- 必须实现cloneable接口(java)\n\n\n\n \n#### 深/浅复制 ####\n 浅复制：<br/>\n复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。\n<br/>\n深复制：<br/>\n对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br/>\n被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。\n \n\n#### 来自《effective java》的建议 ####\n\n>第11条：谨慎地覆盖clone\n\n克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。\n\n建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br/>\n\n\n","slug":"design-patterns-prototype-1","published":1,"updated":"2017-08-17T02:43:37.365Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1dd002e2sivfoean49c","content":"<ul>\n<li>content<br>{:toc}</li>\n</ul>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。</p>\n<blockquote>\n<p>《设计模式》：<br> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p>\n</blockquote>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限</li>\n<li>一个对象多个修改者-浅拷贝</li>\n<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值</li>\n<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</li>\n<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好</li>\n</ul>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><p><img src=\"/images/prototype_class_uml.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/prototype_sequence_uml.png\" alt=\"时序图\"></p>\n<h4 id=\"优点-缺点\"><a href=\"#优点-缺点\" class=\"headerlink\" title=\"优点/缺点\"></a>优点/缺点</h4><ul>\n<li>clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升</li>\n<li>逃避构造函数的约束(既是优点也是缺点)</li>\n<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候</li>\n<li>必须实现cloneable接口(java)</li>\n</ul>\n<h4 id=\"深-浅复制\"><a href=\"#深-浅复制\" class=\"headerlink\" title=\"深/浅复制\"></a>深/浅复制</h4><p> 浅复制：<br><br>复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。<br><br><br>深复制：<br><br>对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br><br>被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>\n<h4 id=\"来自《effective-java》的建议\"><a href=\"#来自《effective-java》的建议\" class=\"headerlink\" title=\"来自《effective java》的建议\"></a>来自《effective java》的建议</h4><blockquote>\n<p>第11条：谨慎地覆盖clone</p>\n</blockquote>\n<p>克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。</p>\n<p>建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>content<br>{:toc}</li>\n</ul>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>创建型模式的一种。通过复制一个已经存在的实例来返回新的实例，而不是新建实例。</p>\n<blockquote>\n<p>《设计模式》：<br> 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p>\n</blockquote>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>创建重复的新对象的成本较大—— 创建复杂，初始化消耗资源过多，初始化耗时，繁琐的数据准备，访问权限</li>\n<li>一个对象多个修改者-浅拷贝</li>\n<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值</li>\n<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</li>\n<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好</li>\n</ul>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><p><img src=\"/images/prototype_class_uml.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/prototype_sequence_uml.png\" alt=\"时序图\"></p>\n<h4 id=\"优点-缺点\"><a href=\"#优点-缺点\" class=\"headerlink\" title=\"优点/缺点\"></a>优点/缺点</h4><ul>\n<li>clone并不一定比new一个对象速度快，只有new构造对象耗时或成功高时，clone才有明显的效率提升</li>\n<li>逃避构造函数的约束(既是优点也是缺点)</li>\n<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候</li>\n<li>必须实现cloneable接口(java)</li>\n</ul>\n<h4 id=\"深-浅复制\"><a href=\"#深-浅复制\" class=\"headerlink\" title=\"深/浅复制\"></a>深/浅复制</h4><p> 浅复制：<br><br>复制了值类型对象，对于引用类型对象，只复制了引用，它指向原来引用的对象。<br><br><br>深复制：<br><br>对值类型和引用类型的对象都生成一份新的拷贝，java中可以通过串行化来进行深复制，前提是对象以及其内部所引用的对象都是可串行化的，否则需要考虑把不可串行话的对象设为transient，排除在复制过程之外。<br><br>被复制对象的任何变量都含有和原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深复制把要复制的对象所引用的对象都复制了一遍。</p>\n<h4 id=\"来自《effective-java》的建议\"><a href=\"#来自《effective-java》的建议\" class=\"headerlink\" title=\"来自《effective java》的建议\"></a>来自《effective java》的建议</h4><blockquote>\n<p>第11条：谨慎地覆盖clone</p>\n</blockquote>\n<p>克隆复杂对象，可以使用deep copy，也可以先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调用高层的方法来重新产生对象的状态。</p>\n<p>建议使用拷贝构造器/拷贝工厂，确切地说是转换构造器/转换工厂。<br></p>\n"},{"layout":"post","title":"单例设计模式(三)真●单例唯一$反射","date":"2017-02-11T00:00:00.000Z","_content":" \n\n#### 反射对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\t\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\t\n\t\tpublic static volatile Singleton singleton;\n\t\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\t\n\t}\n\n然后看我们的测试代码：\n\t\n\t\n\timport java.lang.reflect.Constructor;\n\t\n\tpublic class ReflectAttackSingleton {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tClass<?> classType = Singleton.class;\n\t\t\t\tConstructor<?> c;\n\t\t\t\tc = classType.getDeclaredConstructor(null);\n\t\t\t\tc.setAccessible(true);\n\t\t\t\tSingleton instance1 = (Singleton) c.newInstance();\n\t\t\t\tSingleton instance2 = Singleton.getInstance();\n\t\t\t\tSystem.out.println(\"反射得到的实例与单例中的实例是否相等？\" +(instance1 == instance2));\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t}\n\t}\n\n> 运行后： ``` 反射得到的实例与单例中的实例是否相等？false ```\n\n> 通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。\n\n\n#### 修改构造器抵御攻击 ####\n\t\n\tprivate static boolean flag = false;\n\tprivate Singleton() {\n\t\tsynchronized (Singleton.class) {\n\t\t\tif(flag == false)\n\t\t\t\tflag = !flag;\n\t\t\telse\n\t\t\t\tthrow new RuntimeException(\"单例模式被攻击！\");\n\t\t}\n\t};\n \n\n#### 终极方法 ####\n \t\n\t使用枚举单例","source":"_posts/2017-02-11-design-patterns-singleton-3.md","raw":"---\nlayout: post\ntitle:  单例设计模式(三)真●单例唯一$反射\ndate:   2017-02-11\ncategories: Design Pattern\ntag: 设计模式\n---\n \n\n#### 反射对单例的破坏 ####\n\n先看一个DCL单例：\n\n\timport java.io.Serializable;\n\t\n\t/**\n\t * double check lock 实现单例\n\t */\n\tpublic class Singleton implements Serializable {\n\t\tprivate Singleton() {\n\t\t};\n\t\n\t\tpublic static volatile Singleton singleton;\n\t\n\t\tpublic static Singleton getInstance() {\n\t\t\tif (singleton == null) {\n\t\t\t\tsynchronized (Singleton.class) {\n\t\t\t\t\tif (singleton == null) {\n\t\t\t\t\t\tsingleton = new Singleton();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singleton;\n\t\t}\n\t\n\t}\n\n然后看我们的测试代码：\n\t\n\t\n\timport java.lang.reflect.Constructor;\n\t\n\tpublic class ReflectAttackSingleton {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\ttry {\n\t\t\t\tClass<?> classType = Singleton.class;\n\t\t\t\tConstructor<?> c;\n\t\t\t\tc = classType.getDeclaredConstructor(null);\n\t\t\t\tc.setAccessible(true);\n\t\t\t\tSingleton instance1 = (Singleton) c.newInstance();\n\t\t\t\tSingleton instance2 = Singleton.getInstance();\n\t\t\t\tSystem.out.println(\"反射得到的实例与单例中的实例是否相等？\" +(instance1 == instance2));\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\n\t\t}\n\t}\n\n> 运行后： ``` 反射得到的实例与单例中的实例是否相等？false ```\n\n> 通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。\n\n\n#### 修改构造器抵御攻击 ####\n\t\n\tprivate static boolean flag = false;\n\tprivate Singleton() {\n\t\tsynchronized (Singleton.class) {\n\t\t\tif(flag == false)\n\t\t\t\tflag = !flag;\n\t\t\telse\n\t\t\t\tthrow new RuntimeException(\"单例模式被攻击！\");\n\t\t}\n\t};\n \n\n#### 终极方法 ####\n \t\n\t使用枚举单例","slug":"design-patterns-singleton-3","published":1,"updated":"2017-08-17T02:39:28.616Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1dl002j2sivmnww122l","content":"<h4 id=\"反射对单例的破坏\"><a href=\"#反射对单例的破坏\" class=\"headerlink\" title=\"反射对单例的破坏\"></a>反射对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.lang.reflect.Constructor;\n\npublic class ReflectAttackSingleton {\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; classType = Singleton.class;\n            Constructor&lt;?&gt; c;\n            c = classType.getDeclaredConstructor(null);\n            c.setAccessible(true);\n            Singleton instance1 = (Singleton) c.newInstance();\n            Singleton instance2 = Singleton.getInstance();\n            System.out.println(&quot;反射得到的实例与单例中的实例是否相等？&quot; +(instance1 == instance2));\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <code>反射得到的实例与单例中的实例是否相等？false</code></p>\n<p>通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。</p>\n</blockquote>\n<h4 id=\"修改构造器抵御攻击\"><a href=\"#修改构造器抵御攻击\" class=\"headerlink\" title=\"修改构造器抵御攻击\"></a>修改构造器抵御攻击</h4><pre><code>private static boolean flag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if(flag == false)\n            flag = !flag;\n        else\n            throw new RuntimeException(&quot;单例模式被攻击！&quot;);\n    }\n};\n</code></pre><h4 id=\"终极方法\"><a href=\"#终极方法\" class=\"headerlink\" title=\"终极方法\"></a>终极方法</h4><pre><code>使用枚举单例\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"反射对单例的破坏\"><a href=\"#反射对单例的破坏\" class=\"headerlink\" title=\"反射对单例的破坏\"></a>反射对单例的破坏</h4><p>先看一个DCL单例：</p>\n<pre><code>import java.io.Serializable;\n\n/**\n * double check lock 实现单例\n */\npublic class Singleton implements Serializable {\n    private Singleton() {\n    };\n\n    public static volatile Singleton singleton;\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n\n}\n</code></pre><p>然后看我们的测试代码：</p>\n<pre><code>import java.lang.reflect.Constructor;\n\npublic class ReflectAttackSingleton {\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; classType = Singleton.class;\n            Constructor&lt;?&gt; c;\n            c = classType.getDeclaredConstructor(null);\n            c.setAccessible(true);\n            Singleton instance1 = (Singleton) c.newInstance();\n            Singleton instance2 = Singleton.getInstance();\n            System.out.println(&quot;反射得到的实例与单例中的实例是否相等？&quot; +(instance1 == instance2));\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n}\n</code></pre><blockquote>\n<p>运行后： <code>反射得到的实例与单例中的实例是否相等？false</code></p>\n<p>通过反射获取构造函数，然后调用即可获取新的单例的实例，这就破坏了Singleton的单例性。</p>\n</blockquote>\n<h4 id=\"修改构造器抵御攻击\"><a href=\"#修改构造器抵御攻击\" class=\"headerlink\" title=\"修改构造器抵御攻击\"></a>修改构造器抵御攻击</h4><pre><code>private static boolean flag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if(flag == false)\n            flag = !flag;\n        else\n            throw new RuntimeException(&quot;单例模式被攻击！&quot;);\n    }\n};\n</code></pre><h4 id=\"终极方法\"><a href=\"#终极方法\" class=\"headerlink\" title=\"终极方法\"></a>终极方法</h4><pre><code>使用枚举单例\n</code></pre>"},{"layout":"post","title":"原型设计模式(二) Android中的应用","date":"2017-03-19T00:00:00.000Z","_content":" \n\n#### Intent/Bundle ####\n \n\n    /**\n     * Copy constructor.\n     */\n    public Intent(Intent o) {\n        this.mAction = o.mAction;\n        this.mData = o.mData;\n        this.mType = o.mType;\n        this.mPackage = o.mPackage;\n        this.mComponent = o.mComponent;\n        this.mFlags = o.mFlags;\n        this.mContentUserHint = o.mContentUserHint;\n        if (o.mCategories != null) {\n            this.mCategories = new ArraySet<String>(o.mCategories);\n        }\n        if (o.mExtras != null) {\n            this.mExtras = new Bundle(o.mExtras);\n        }\n        if (o.mSourceBounds != null) {\n            this.mSourceBounds = new Rect(o.mSourceBounds);\n        }\n        if (o.mSelector != null) {\n            this.mSelector = new Intent(o.mSelector);\n        }\n        if (o.mClipData != null) {\n            this.mClipData = new ClipData(o.mClipData);\n        }\n    }\n\n    @Override\n    public Object clone() {\n        return new Intent(this);\n    }\n\n发现并没有调用`super.clone()`，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。\n\n\n\n","source":"_posts/2017-03-19-design-patterns-prototype-2.md","raw":"---\nlayout: post\ntitle:  原型设计模式(二) Android中的应用\ndate:   2017-03-19\ncategories: Design Pattern\ntag: 设计模式\n---\n \n\n#### Intent/Bundle ####\n \n\n    /**\n     * Copy constructor.\n     */\n    public Intent(Intent o) {\n        this.mAction = o.mAction;\n        this.mData = o.mData;\n        this.mType = o.mType;\n        this.mPackage = o.mPackage;\n        this.mComponent = o.mComponent;\n        this.mFlags = o.mFlags;\n        this.mContentUserHint = o.mContentUserHint;\n        if (o.mCategories != null) {\n            this.mCategories = new ArraySet<String>(o.mCategories);\n        }\n        if (o.mExtras != null) {\n            this.mExtras = new Bundle(o.mExtras);\n        }\n        if (o.mSourceBounds != null) {\n            this.mSourceBounds = new Rect(o.mSourceBounds);\n        }\n        if (o.mSelector != null) {\n            this.mSelector = new Intent(o.mSelector);\n        }\n        if (o.mClipData != null) {\n            this.mClipData = new ClipData(o.mClipData);\n        }\n    }\n\n    @Override\n    public Object clone() {\n        return new Intent(this);\n    }\n\n发现并没有调用`super.clone()`，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。\n\n\n\n","slug":"design-patterns-prototype-2","published":1,"updated":"2017-08-17T02:43:58.317Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1do002m2sivws22j3zr","content":"<h4 id=\"Intent-Bundle\"><a href=\"#Intent-Bundle\" class=\"headerlink\" title=\"Intent/Bundle\"></a>Intent/Bundle</h4><pre><code>/**\n * Copy constructor.\n */\npublic Intent(Intent o) {\n    this.mAction = o.mAction;\n    this.mData = o.mData;\n    this.mType = o.mType;\n    this.mPackage = o.mPackage;\n    this.mComponent = o.mComponent;\n    this.mFlags = o.mFlags;\n    this.mContentUserHint = o.mContentUserHint;\n    if (o.mCategories != null) {\n        this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);\n    }\n    if (o.mExtras != null) {\n        this.mExtras = new Bundle(o.mExtras);\n    }\n    if (o.mSourceBounds != null) {\n        this.mSourceBounds = new Rect(o.mSourceBounds);\n    }\n    if (o.mSelector != null) {\n        this.mSelector = new Intent(o.mSelector);\n    }\n    if (o.mClipData != null) {\n        this.mClipData = new ClipData(o.mClipData);\n    }\n}\n\n@Override\npublic Object clone() {\n    return new Intent(this);\n}\n</code></pre><p>发现并没有调用<code>super.clone()</code>，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Intent-Bundle\"><a href=\"#Intent-Bundle\" class=\"headerlink\" title=\"Intent/Bundle\"></a>Intent/Bundle</h4><pre><code>/**\n * Copy constructor.\n */\npublic Intent(Intent o) {\n    this.mAction = o.mAction;\n    this.mData = o.mData;\n    this.mType = o.mType;\n    this.mPackage = o.mPackage;\n    this.mComponent = o.mComponent;\n    this.mFlags = o.mFlags;\n    this.mContentUserHint = o.mContentUserHint;\n    if (o.mCategories != null) {\n        this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);\n    }\n    if (o.mExtras != null) {\n        this.mExtras = new Bundle(o.mExtras);\n    }\n    if (o.mSourceBounds != null) {\n        this.mSourceBounds = new Rect(o.mSourceBounds);\n    }\n    if (o.mSelector != null) {\n        this.mSelector = new Intent(o.mSelector);\n    }\n    if (o.mClipData != null) {\n        this.mClipData = new ClipData(o.mClipData);\n    }\n}\n\n@Override\npublic Object clone() {\n    return new Intent(this);\n}\n</code></pre><p>发现并没有调用<code>super.clone()</code>，《effective java》建议使用拷贝构造器，看来Intent即采用了此种方式。</p>\n"},{"layout":"post","title":"Linux基础知识：内核空间和用户空间","date":"2017-03-27T00:00:00.000Z","_content":" \n \n1. 内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间\n2. 内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表\n3. 用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干\n \n\n\n操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。\n\n在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br/>\n- 首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；\n- 然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；\n\n\n虚拟空间读取数据伪代码：\n\t\n\tif(数据在物理内存中) \n\t        {        虚拟地址转换成物理地址 \n\t                 读数据 } \n\t        else \n\t        {     if(数据在磁盘中) \n\t              { \n\t                     if(物理内存还有空闲) \n\t                     {          把数据从磁盘中读到物理内存 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t                     else \n\t                     {          把物理内存中某页的数据存入磁盘 \n\t                                 把要读的数据从磁盘读到该页的物理内存中 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t              } \n\t              else \n\t              {     报错        } }\n\t\n\t    ","source":"_posts/2017-03-27-kernel-user-space.md","raw":"---\nlayout: post\ntitle:  Linux基础知识：内核空间和用户空间\ndate:   2017-03-27\ncategories: Operation System\ntag: 杂项\n---\n \n \n1. 内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间\n2. 内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表\n3. 用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干\n \n\n\n操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。\n\n在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br/>\n- 首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；\n- 然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；\n\n\n虚拟空间读取数据伪代码：\n\t\n\tif(数据在物理内存中) \n\t        {        虚拟地址转换成物理地址 \n\t                 读数据 } \n\t        else \n\t        {     if(数据在磁盘中) \n\t              { \n\t                     if(物理内存还有空闲) \n\t                     {          把数据从磁盘中读到物理内存 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t                     else \n\t                     {          把物理内存中某页的数据存入磁盘 \n\t                                 把要读的数据从磁盘读到该页的物理内存中 \n\t                                 虚拟地址转换成物理地址 \n\t                                 读数据 \n\t                     } \n\t              } \n\t              else \n\t              {     报错        } }\n\t\n\t    ","slug":"kernel-user-space","published":1,"updated":"2017-08-17T02:44:12.328Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1dq002p2sivkwhl2y96","content":"<ol>\n<li>内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间</li>\n<li>内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表</li>\n<li>用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干</li>\n</ol>\n<p>操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。</p>\n<p>在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br></p>\n<ul>\n<li>首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；</li>\n<li>然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；</li>\n</ul>\n<p>虚拟空间读取数据伪代码：</p>\n<pre><code>if(数据在物理内存中) \n        {        虚拟地址转换成物理地址 \n                 读数据 } \n        else \n        {     if(数据在磁盘中) \n              { \n                     if(物理内存还有空闲) \n                     {          把数据从磁盘中读到物理内存 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n                     else \n                     {          把物理内存中某页的数据存入磁盘 \n                                 把要读的数据从磁盘读到该页的物理内存中 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n              } \n              else \n              {     报错        } }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>内核空间和用户空间都是指虚拟空间即虚拟地址。目前32位系统共有4G的虚拟地址空间</li>\n<li>内核空间即操作系统内核工作的空间，由内核负责映射，有固定的页表</li>\n<li>用户空间对应进程，进程切换，用户空间会跟着变化；每个进程的用户空间完全独立互不相干</li>\n</ol>\n<p>操作系统为了保护自己不被普通程序破坏，对内核空间进行了一些定义，比如访问权限，换入换出，优先级等。内核空间的页表是常驻内存的，不会被虚拟内存管理模块换出到磁盘上。内核空间的程序一旦出错，系统会立即死机。</p>\n<p>在开发驱动时需要用到内核空间和用户空间之间的接口，即内核空间和用户空间相互左右。一般模式为：<br></p>\n<ul>\n<li>首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；</li>\n<li>然后，编写用户程序来配置内核服务程序的参数，输入待处理数据，提取内核服务程序提供的数据；</li>\n</ul>\n<p>虚拟空间读取数据伪代码：</p>\n<pre><code>if(数据在物理内存中) \n        {        虚拟地址转换成物理地址 \n                 读数据 } \n        else \n        {     if(数据在磁盘中) \n              { \n                     if(物理内存还有空闲) \n                     {          把数据从磁盘中读到物理内存 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n                     else \n                     {          把物理内存中某页的数据存入磁盘 \n                                 把要读的数据从磁盘读到该页的物理内存中 \n                                 虚拟地址转换成物理地址 \n                                 读数据 \n                     } \n              } \n              else \n              {     报错        } }\n</code></pre>"},{"layout":"post","title":"Tinker学习(三) 核心的算法BSDiff、BSPatch","date":"2017-03-30T00:00:00.000Z","_content":" \n\n#### 简介 ####\n\nBSDiff，用于服务端比较二进制文件并生成差异补丁；<br>\nBSPatch，将旧文件和补丁文件合并生成新的文件。\n\n比较差异使用的算法是`suffix sort`后缀排序算法。其中：<br>\n\n- C实现可以参照：[Colin Percival](https://github.com/cperciva)的[bsdiff](https://github.com/cperciva/bsdiff)\n- Java实现可以参照：[Joe Desbonnet](https://github.com/jdesbonnet)的[jbdiff](https://github.com/jdesbonnet/jbdiff)<br>\n\nTinker的`com.tencent.tinker.bsdiff`实现基本上和Joe Desbonnet的实现并无两样。\n\n\n#### BSDiff基本步骤 ####\n\n1. 将old文件中所有子字符串形成一个字典 \n2. 对比old文件和new文件，产生diff string 和 extra string\n3. 将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。\n \n所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br>\n关于后缀数组概念，需要懂得非比较排序算法：<br>\n\n- [非比较排序之计数排序](http://xusx1024.com/2017/04/11/counting-sort/)\n- [非比较排序之桶/箱排序](http://xusx1024.com/2017/04/10/bucket-sort/)\n- [非比较排序之基数排序](http://xusx1024.com/2017/04/10/radix-sort/)\n\n需要懂得生成后缀数组算法：<br>\n\n- [基于倍增算法实现后缀数组](http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/)\n- [基于DC3算法实现后缀数组](http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/)","source":"_posts/2017-03-30-tinker-source-code-3.md","raw":"---\nlayout: post\ntitle:  Tinker学习(三) 核心的算法BSDiff、BSPatch\ndate:   2017-03-30\ncategories: Android \ntag: [算法,hotfix]\n---\n \n\n#### 简介 ####\n\nBSDiff，用于服务端比较二进制文件并生成差异补丁；<br>\nBSPatch，将旧文件和补丁文件合并生成新的文件。\n\n比较差异使用的算法是`suffix sort`后缀排序算法。其中：<br>\n\n- C实现可以参照：[Colin Percival](https://github.com/cperciva)的[bsdiff](https://github.com/cperciva/bsdiff)\n- Java实现可以参照：[Joe Desbonnet](https://github.com/jdesbonnet)的[jbdiff](https://github.com/jdesbonnet/jbdiff)<br>\n\nTinker的`com.tencent.tinker.bsdiff`实现基本上和Joe Desbonnet的实现并无两样。\n\n\n#### BSDiff基本步骤 ####\n\n1. 将old文件中所有子字符串形成一个字典 \n2. 对比old文件和new文件，产生diff string 和 extra string\n3. 将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。\n \n所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br>\n关于后缀数组概念，需要懂得非比较排序算法：<br>\n\n- [非比较排序之计数排序](http://xusx1024.com/2017/04/11/counting-sort/)\n- [非比较排序之桶/箱排序](http://xusx1024.com/2017/04/10/bucket-sort/)\n- [非比较排序之基数排序](http://xusx1024.com/2017/04/10/radix-sort/)\n\n需要懂得生成后缀数组算法：<br>\n\n- [基于倍增算法实现后缀数组](http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/)\n- [基于DC3算法实现后缀数组](http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/)","slug":"tinker-source-code-3","published":1,"updated":"2018-01-31T09:54:24.753Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1dv002s2sivl3dj86jt","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>BSDiff，用于服务端比较二进制文件并生成差异补丁；<br><br>BSPatch，将旧文件和补丁文件合并生成新的文件。</p>\n<p>比较差异使用的算法是<code>suffix sort</code>后缀排序算法。其中：<br></p>\n<ul>\n<li>C实现可以参照：<a href=\"https://github.com/cperciva\" target=\"_blank\" rel=\"external\">Colin Percival</a>的<a href=\"https://github.com/cperciva/bsdiff\" target=\"_blank\" rel=\"external\">bsdiff</a></li>\n<li>Java实现可以参照：<a href=\"https://github.com/jdesbonnet\" target=\"_blank\" rel=\"external\">Joe Desbonnet</a>的<a href=\"https://github.com/jdesbonnet/jbdiff\" target=\"_blank\" rel=\"external\">jbdiff</a><br></li>\n</ul>\n<p>Tinker的<code>com.tencent.tinker.bsdiff</code>实现基本上和Joe Desbonnet的实现并无两样。</p>\n<h4 id=\"BSDiff基本步骤\"><a href=\"#BSDiff基本步骤\" class=\"headerlink\" title=\"BSDiff基本步骤\"></a>BSDiff基本步骤</h4><ol>\n<li>将old文件中所有子字符串形成一个字典 </li>\n<li>对比old文件和new文件，产生diff string 和 extra string</li>\n<li>将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。</li>\n</ol>\n<p>所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br><br>关于后缀数组概念，需要懂得非比较排序算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">非比较排序之计数排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">非比较排序之桶/箱排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">非比较排序之基数排序</a></li>\n</ul>\n<p>需要懂得生成后缀数组算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/\" target=\"_blank\" rel=\"external\">基于倍增算法实现后缀数组</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/\" target=\"_blank\" rel=\"external\">基于DC3算法实现后缀数组</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>BSDiff，用于服务端比较二进制文件并生成差异补丁；<br><br>BSPatch，将旧文件和补丁文件合并生成新的文件。</p>\n<p>比较差异使用的算法是<code>suffix sort</code>后缀排序算法。其中：<br></p>\n<ul>\n<li>C实现可以参照：<a href=\"https://github.com/cperciva\" target=\"_blank\" rel=\"external\">Colin Percival</a>的<a href=\"https://github.com/cperciva/bsdiff\" target=\"_blank\" rel=\"external\">bsdiff</a></li>\n<li>Java实现可以参照：<a href=\"https://github.com/jdesbonnet\" target=\"_blank\" rel=\"external\">Joe Desbonnet</a>的<a href=\"https://github.com/jdesbonnet/jbdiff\" target=\"_blank\" rel=\"external\">jbdiff</a><br></li>\n</ul>\n<p>Tinker的<code>com.tencent.tinker.bsdiff</code>实现基本上和Joe Desbonnet的实现并无两样。</p>\n<h4 id=\"BSDiff基本步骤\"><a href=\"#BSDiff基本步骤\" class=\"headerlink\" title=\"BSDiff基本步骤\"></a>BSDiff基本步骤</h4><ol>\n<li>将old文件中所有子字符串形成一个字典 </li>\n<li>对比old文件和new文件，产生diff string 和 extra string</li>\n<li>将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。</li>\n</ol>\n<p>所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br><br>关于后缀数组概念，需要懂得非比较排序算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">非比较排序之计数排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">非比较排序之桶/箱排序</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">非比较排序之基数排序</a></li>\n</ul>\n<p>需要懂得生成后缀数组算法：<br></p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/\" target=\"_blank\" rel=\"external\">基于倍增算法实现后缀数组</a></li>\n<li><a href=\"http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/\" target=\"_blank\" rel=\"external\">基于DC3算法实现后缀数组</a></li>\n</ul>\n"},{"layout":"post","title":"Tinker学习(二)标准java虚拟机动态加载代码示例","date":"2017-03-30T00:00:00.000Z","_content":" \n\n虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br/>\n \n自定义classLoader类：\n\n\timport java.io.ByteArrayOutputStream;\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.nio.ByteBuffer;\n\timport java.nio.channels.FileChannel;\n\t\n\tpublic class MyClassLoader extends ClassLoader {\n\t\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\n\t\t\tString classPath = MyClassLoader.class.getResource(\"/\").getPath();\n\t\t\tString fileName = name.replace(\".\", \"/\") + \".class\";\n\t\t\tFile classFile = new File(classPath, fileName);\n\t\n\t\t\tif (!classFile.exists()) {\n\t\t\t\tthrow new ClassNotFoundException(classFile.getPath() + \" 不存在\");\n\t\t\t}\n\t\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tByteBuffer bf = ByteBuffer.allocate(1024);\n\t\t\tFileInputStream fis = null;\n\t\t\tFileChannel fc = null;\n\t\n\t\t\ttry {\n\t\t\t\tfis = new FileInputStream(classFile);\n\t\t\t\tfc = fis.getChannel();\n\t\t\t\twhile (fc.read(bf) > 0) {\n\t\t\t\t\tbf.flip();\n\t\t\t\t\tbos.write(bf.array(), 0, bf.limit());\n\t\t\t\t\tbf.clear();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tfis.close();\n\t\t\t\t\tfc.close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t\t// TODO: handle exception\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n\t\t}\n\t\n\t}\n\n改变的类：\n\t\n\tpublic class Person {\n\t\n\t\tpublic void sayHello() {\n\t\t\tSystem.out.println(\"hello world!\");\n\t\t}\n\t}\n\n\n测试的类：\n\t \n\timport java.lang.reflect.Method;\n\t\n\tpublic class StartUp {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i = 0;\n\t\n\t\t\twhile (true) {\n\t\t\t\tMyClassLoader mcl = new MyClassLoader();\n\t\t\t\tSystem.out.println(mcl.getParent());\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> personClass = mcl.findClass(\"Person\");\n\t\n\t\t\t\t\tObject person = personClass.newInstance();\n\t\t\t\t\tMethod sayHelloMethod = personClass.getMethod(\"sayHello\");\n\t\t\t\t\tsayHelloMethod.invoke(person);\n\t\t\t\t\tSystem.out.println(i++);\n\t\n\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。","source":"_posts/2017-03-30-tinker-source-code-2.md","raw":"---\nlayout: post\ntitle:  Tinker学习(二)标准java虚拟机动态加载代码示例\ndate:   2017-03-30\ncategories: Android \ntag: hotfix\n---\n \n\n虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br/>\n \n自定义classLoader类：\n\n\timport java.io.ByteArrayOutputStream;\n\timport java.io.File;\n\timport java.io.FileInputStream;\n\timport java.nio.ByteBuffer;\n\timport java.nio.channels.FileChannel;\n\t\n\tpublic class MyClassLoader extends ClassLoader {\n\t\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n\t\n\t\t\tString classPath = MyClassLoader.class.getResource(\"/\").getPath();\n\t\t\tString fileName = name.replace(\".\", \"/\") + \".class\";\n\t\t\tFile classFile = new File(classPath, fileName);\n\t\n\t\t\tif (!classFile.exists()) {\n\t\t\t\tthrow new ClassNotFoundException(classFile.getPath() + \" 不存在\");\n\t\t\t}\n\t\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tByteBuffer bf = ByteBuffer.allocate(1024);\n\t\t\tFileInputStream fis = null;\n\t\t\tFileChannel fc = null;\n\t\n\t\t\ttry {\n\t\t\t\tfis = new FileInputStream(classFile);\n\t\t\t\tfc = fis.getChannel();\n\t\t\t\twhile (fc.read(bf) > 0) {\n\t\t\t\t\tbf.flip();\n\t\t\t\t\tbos.write(bf.array(), 0, bf.limit());\n\t\t\t\t\tbf.clear();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tfis.close();\n\t\t\t\t\tfc.close();\n\t\t\t\t} catch (Exception e2) {\n\t\t\t\t\t// TODO: handle exception\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n\t\t}\n\t\n\t}\n\n改变的类：\n\t\n\tpublic class Person {\n\t\n\t\tpublic void sayHello() {\n\t\t\tSystem.out.println(\"hello world!\");\n\t\t}\n\t}\n\n\n测试的类：\n\t \n\timport java.lang.reflect.Method;\n\t\n\tpublic class StartUp {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i = 0;\n\t\n\t\t\twhile (true) {\n\t\t\t\tMyClassLoader mcl = new MyClassLoader();\n\t\t\t\tSystem.out.println(mcl.getParent());\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> personClass = mcl.findClass(\"Person\");\n\t\n\t\t\t\t\tObject person = personClass.newInstance();\n\t\t\t\t\tMethod sayHelloMethod = personClass.getMethod(\"sayHello\");\n\t\t\t\t\tsayHelloMethod.invoke(person);\n\t\t\t\t\tSystem.out.println(i++);\n\t\n\t\t\t\t\tThread.sleep(3000);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。","slug":"tinker-source-code-2","published":1,"updated":"2017-11-16T08:32:28.463Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1dz002w2sivfuvi8tjo","content":"<p>虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br></p>\n<p>自定义classLoader类：</p>\n<pre><code>import java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class MyClassLoader extends ClassLoader {\n\n    @SuppressWarnings(&quot;deprecation&quot;)\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {\n\n        String classPath = MyClassLoader.class.getResource(&quot;/&quot;).getPath();\n        String fileName = name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;\n        File classFile = new File(classPath, fileName);\n\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(classFile.getPath() + &quot; 不存在&quot;);\n        }\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ByteBuffer bf = ByteBuffer.allocate(1024);\n        FileInputStream fis = null;\n        FileChannel fc = null;\n\n        try {\n            fis = new FileInputStream(classFile);\n            fc = fis.getChannel();\n            while (fc.read(bf) &gt; 0) {\n                bf.flip();\n                bos.write(bf.array(), 0, bf.limit());\n                bf.clear();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fis.close();\n                fc.close();\n            } catch (Exception e2) {\n                // TODO: handle exception\n            }\n\n        }\n\n        return defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n    }\n\n}\n</code></pre><p>改变的类：</p>\n<pre><code>public class Person {\n\n    public void sayHello() {\n        System.out.println(&quot;hello world!&quot;);\n    }\n}\n</code></pre><p>测试的类：</p>\n<pre><code>import java.lang.reflect.Method;\n\npublic class StartUp {\n\n    public static void main(String[] args) {\n        int i = 0;\n\n        while (true) {\n            MyClassLoader mcl = new MyClassLoader();\n            System.out.println(mcl.getParent());\n            try {\n                Class&lt;?&gt; personClass = mcl.findClass(&quot;Person&quot;);\n\n                Object person = personClass.newInstance();\n                Method sayHelloMethod = personClass.getMethod(&quot;sayHello&quot;);\n                sayHelloMethod.invoke(person);\n                System.out.println(i++);\n\n                Thread.sleep(3000);\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br></p>\n<p>自定义classLoader类：</p>\n<pre><code>import java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\npublic class MyClassLoader extends ClassLoader {\n\n    @SuppressWarnings(&quot;deprecation&quot;)\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {\n\n        String classPath = MyClassLoader.class.getResource(&quot;/&quot;).getPath();\n        String fileName = name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;\n        File classFile = new File(classPath, fileName);\n\n        if (!classFile.exists()) {\n            throw new ClassNotFoundException(classFile.getPath() + &quot; 不存在&quot;);\n        }\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ByteBuffer bf = ByteBuffer.allocate(1024);\n        FileInputStream fis = null;\n        FileChannel fc = null;\n\n        try {\n            fis = new FileInputStream(classFile);\n            fc = fis.getChannel();\n            while (fc.read(bf) &gt; 0) {\n                bf.flip();\n                bos.write(bf.array(), 0, bf.limit());\n                bf.clear();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                fis.close();\n                fc.close();\n            } catch (Exception e2) {\n                // TODO: handle exception\n            }\n\n        }\n\n        return defineClass(bos.toByteArray(), 0, bos.toByteArray().length);\n    }\n\n}\n</code></pre><p>改变的类：</p>\n<pre><code>public class Person {\n\n    public void sayHello() {\n        System.out.println(&quot;hello world!&quot;);\n    }\n}\n</code></pre><p>测试的类：</p>\n<pre><code>import java.lang.reflect.Method;\n\npublic class StartUp {\n\n    public static void main(String[] args) {\n        int i = 0;\n\n        while (true) {\n            MyClassLoader mcl = new MyClassLoader();\n            System.out.println(mcl.getParent());\n            try {\n                Class&lt;?&gt; personClass = mcl.findClass(&quot;Person&quot;);\n\n                Object person = personClass.newInstance();\n                Method sayHelloMethod = personClass.getMethod(&quot;sayHello&quot;);\n                sayHelloMethod.invoke(person);\n                System.out.println(i++);\n\n                Thread.sleep(3000);\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre><p>修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。</p>\n"},{"layout":"post","title":"FindBugs常见错误提示及解决","date":"2017-04-01T00:00:00.000Z","_content":" \n\n\n#### ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD ####\n>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\n>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。\n\n\n原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。\n<br/>\n\n解决：通过get/set方法提供操作。\n\n#### DM_BOXED_PRIMITIVE_FOR_PARSING ####\n>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.\n>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。\n\n原因：\n\n- static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。\n- static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。\n- static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。\n\n解决：parseXXX方法代替valueOf\n\n#### SS_SHOULD_BE_STATIC ####\n>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.\n>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。\n\n解决方法：final的字段可以定义为static类型\n\n#### DLS_DEAD_LOCAL_STORE ####\n>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br/>\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\n该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br/>\n请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。\n\n解决方法：注释掉。\n\n\n#### SF_SWITCH_NO_DEFAULT ####\n>This method contains a switch statement where default case is missing. Usually you need to provide a default case.\nBecause the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn't contain break statements for other cases.\n此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。\n<br/>\n因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。\n\n解决方法：加上default。\n\n\n#### RV_RETURN_VALUE_IGNORED_BAD_PRACTICE ####\n\n>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the `File.delete()` method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an a typical return value. \n>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，`File.dlete()`方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。\n\n\n#### DC_DOUBLECHECK ####\n\n>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.\n\nsee more:[双重检查锁定与延迟初始化](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#)\n\n#### NM_METHOD_NAMING_CONVENTION ####\n\n>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.\n>方法名开头要小写。","source":"_posts/2017-04-01-findbug-notes.md","raw":"---\nlayout: post\ntitle:  FindBugs常见错误提示及解决\ndate:   2017-04-01\ncategories: JAVA & kotlin\ntag: 杂项\n---\n \n\n\n#### ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD ####\n>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\n>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。\n\n\n原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。\n<br/>\n\n解决：通过get/set方法提供操作。\n\n#### DM_BOXED_PRIMITIVE_FOR_PARSING ####\n>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.\n>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。\n\n原因：\n\n- static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。\n- static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。\n- static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。\n\n解决：parseXXX方法代替valueOf\n\n#### SS_SHOULD_BE_STATIC ####\n>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.\n>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。\n\n解决方法：final的字段可以定义为static类型\n\n#### DLS_DEAD_LOCAL_STORE ####\n>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br/>\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\n该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br/>\n请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。\n\n解决方法：注释掉。\n\n\n#### SF_SWITCH_NO_DEFAULT ####\n>This method contains a switch statement where default case is missing. Usually you need to provide a default case.\nBecause the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn't contain break statements for other cases.\n此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。\n<br/>\n因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。\n\n解决方法：加上default。\n\n\n#### RV_RETURN_VALUE_IGNORED_BAD_PRACTICE ####\n\n>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the `File.delete()` method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an a typical return value. \n>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，`File.dlete()`方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。\n\n\n#### DC_DOUBLECHECK ####\n\n>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.\n\nsee more:[双重检查锁定与延迟初始化](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#)\n\n#### NM_METHOD_NAMING_CONVENTION ####\n\n>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.\n>方法名开头要小写。","slug":"findbug-notes","published":1,"updated":"2017-08-17T02:45:32.031Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1e2002z2sivblexr7fa","content":"<h4 id=\"ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\"><a href=\"#ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\" class=\"headerlink\" title=\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"></a>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><blockquote>\n<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。</p>\n</blockquote>\n<p>原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。<br><br></p>\n<p>解决：通过get/set方法提供操作。</p>\n<h4 id=\"DM-BOXED-PRIMITIVE-FOR-PARSING\"><a href=\"#DM-BOXED-PRIMITIVE-FOR-PARSING\" class=\"headerlink\" title=\"DM_BOXED_PRIMITIVE_FOR_PARSING\"></a>DM_BOXED_PRIMITIVE_FOR_PARSING</h4><blockquote>\n<p>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.<br>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。</p>\n</blockquote>\n<p>原因：</p>\n<ul>\n<li>static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。</li>\n<li>static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。</li>\n<li>static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。</li>\n</ul>\n<p>解决：parseXXX方法代替valueOf</p>\n<h4 id=\"SS-SHOULD-BE-STATIC\"><a href=\"#SS-SHOULD-BE-STATIC\" class=\"headerlink\" title=\"SS_SHOULD_BE_STATIC\"></a>SS_SHOULD_BE_STATIC</h4><blockquote>\n<p>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.<br>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。</p>\n</blockquote>\n<p>解决方法：final的字段可以定义为static类型</p>\n<h4 id=\"DLS-DEAD-LOCAL-STORE\"><a href=\"#DLS-DEAD-LOCAL-STORE\" class=\"headerlink\" title=\"DLS_DEAD_LOCAL_STORE\"></a>DLS_DEAD_LOCAL_STORE</h4><blockquote>\n<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br><br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br><br>请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。</p>\n</blockquote>\n<p>解决方法：注释掉。</p>\n<h4 id=\"SF-SWITCH-NO-DEFAULT\"><a href=\"#SF-SWITCH-NO-DEFAULT\" class=\"headerlink\" title=\"SF_SWITCH_NO_DEFAULT\"></a>SF_SWITCH_NO_DEFAULT</h4><blockquote>\n<p>This method contains a switch statement where default case is missing. Usually you need to provide a default case.<br>Because the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn’t contain break statements for other cases.<br>此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。<br><br><br>因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。</p>\n</blockquote>\n<p>解决方法：加上default。</p>\n<h4 id=\"RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\"><a href=\"#RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\" class=\"headerlink\" title=\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\"></a>RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><blockquote>\n<p>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the <code>File.delete()</code> method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an a typical return value.<br>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，<code>File.dlete()</code>方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。</p>\n</blockquote>\n<h4 id=\"DC-DOUBLECHECK\"><a href=\"#DC-DOUBLECHECK\" class=\"headerlink\" title=\"DC_DOUBLECHECK\"></a>DC_DOUBLECHECK</h4><blockquote>\n<p>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.</p>\n</blockquote>\n<p>see more:<a href=\"http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#\" target=\"_blank\" rel=\"external\">双重检查锁定与延迟初始化</a></p>\n<h4 id=\"NM-METHOD-NAMING-CONVENTION\"><a href=\"#NM-METHOD-NAMING-CONVENTION\" class=\"headerlink\" title=\"NM_METHOD_NAMING_CONVENTION\"></a>NM_METHOD_NAMING_CONVENTION</h4><blockquote>\n<p>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.<br>方法名开头要小写。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\"><a href=\"#ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\" class=\"headerlink\" title=\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"></a>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><blockquote>\n<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。</p>\n</blockquote>\n<p>原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。<br><br></p>\n<p>解决：通过get/set方法提供操作。</p>\n<h4 id=\"DM-BOXED-PRIMITIVE-FOR-PARSING\"><a href=\"#DM-BOXED-PRIMITIVE-FOR-PARSING\" class=\"headerlink\" title=\"DM_BOXED_PRIMITIVE_FOR_PARSING\"></a>DM_BOXED_PRIMITIVE_FOR_PARSING</h4><blockquote>\n<p>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.<br>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。</p>\n</blockquote>\n<p>原因：</p>\n<ul>\n<li>static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。</li>\n<li>static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。</li>\n<li>static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。</li>\n</ul>\n<p>解决：parseXXX方法代替valueOf</p>\n<h4 id=\"SS-SHOULD-BE-STATIC\"><a href=\"#SS-SHOULD-BE-STATIC\" class=\"headerlink\" title=\"SS_SHOULD_BE_STATIC\"></a>SS_SHOULD_BE_STATIC</h4><blockquote>\n<p>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.<br>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。</p>\n</blockquote>\n<p>解决方法：final的字段可以定义为static类型</p>\n<h4 id=\"DLS-DEAD-LOCAL-STORE\"><a href=\"#DLS-DEAD-LOCAL-STORE\" class=\"headerlink\" title=\"DLS_DEAD_LOCAL_STORE\"></a>DLS_DEAD_LOCAL_STORE</h4><blockquote>\n<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br><br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br><br>请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。</p>\n</blockquote>\n<p>解决方法：注释掉。</p>\n<h4 id=\"SF-SWITCH-NO-DEFAULT\"><a href=\"#SF-SWITCH-NO-DEFAULT\" class=\"headerlink\" title=\"SF_SWITCH_NO_DEFAULT\"></a>SF_SWITCH_NO_DEFAULT</h4><blockquote>\n<p>This method contains a switch statement where default case is missing. Usually you need to provide a default case.<br>Because the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn’t contain break statements for other cases.<br>此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。<br><br><br>因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。</p>\n</blockquote>\n<p>解决方法：加上default。</p>\n<h4 id=\"RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\"><a href=\"#RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\" class=\"headerlink\" title=\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\"></a>RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><blockquote>\n<p>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the <code>File.delete()</code> method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an a typical return value.<br>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，<code>File.dlete()</code>方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。</p>\n</blockquote>\n<h4 id=\"DC-DOUBLECHECK\"><a href=\"#DC-DOUBLECHECK\" class=\"headerlink\" title=\"DC_DOUBLECHECK\"></a>DC_DOUBLECHECK</h4><blockquote>\n<p>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.</p>\n</blockquote>\n<p>see more:<a href=\"http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#\" target=\"_blank\" rel=\"external\">双重检查锁定与延迟初始化</a></p>\n<h4 id=\"NM-METHOD-NAMING-CONVENTION\"><a href=\"#NM-METHOD-NAMING-CONVENTION\" class=\"headerlink\" title=\"NM_METHOD_NAMING_CONVENTION\"></a>NM_METHOD_NAMING_CONVENTION</h4><blockquote>\n<p>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.<br>方法名开头要小写。</p>\n</blockquote>\n"},{"layout":"post","title":"Git使用笔记","date":"2017-04-07T00:00:00.000Z","_content":" \n\n#### git管理github ####\n\n1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：`git@github.com:xusx1024/codewars.git`\n\n2，pc端安装git工具，`git --info-path`打印git所在路径；创建本地仓库；\n\n3，在本地文件中，右键点击 Git Bash Here，进入git命令行\n\n4，全局配置 <br>\n\t`git config --global username \"此处定义你的名字\" `<br>\n\t`git config --global useremail xxxxxxx@gmail.com`\n\n5，初始化本地仓库：\n\t`git init `\n\n6，创建readme，并上传：<br>\n\t`git add readme.txt`<br>\n\t`git commint -m \"upload readme\"`<br>\n\n7，生成SSH key，用来和Github连接：\n\t`ssh-keygen -C '这里填你刚才配置的email地址' -t rsa`然后一路点击enter，最后，得到usr/.ssh中的SSH key\n\n8，把SSH key配置到 GitHub中\n\t在用户名上，`setting -  SSH and GPG keys`\n\n9，用到 第一步的那个串了<br>\n\t`git remote add origin git@github.com:xusx1024/codewars.git`<br>\n\t`git push origin master`<br>\n \n\t\n10，以后如果添加的话：<br>\n\t`git add sth`<br>\n\t`git commint -m \"文件说明\"`<br>\n\t`git push origin master`<br>\n\n11.`git add -A .`\n添加所有文件，注意后面有个点。\n\n12.\n`git pull`  抓取远程仓库所有分支更新并合并到本地\n\n13.`git config -l` 查看git的配置信息\n\n\n\n#### git 提交空目录 ####\n\ngit与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。\n\n#### git 克隆分支 ####\n\n多个分支的仓库，使用git clone的方法，只能把HEAD复制下来，如果有多个分支，可以考虑使用：\n\n`git branch -r`来查看各个分支\n\n`git checkout xxx`来clone指定的分支\n\n#### filename too long ####\n\n文件夹的层级过多，导致在clone的时候，出现该提示，可以考虑使用：\n\n`git config --system core.longpaths true`","source":"_posts/2017-04-07-git-command.md","raw":"---\nlayout: post\ntitle:  Git使用笔记\ndate:   2017-04-07\ncategories: Others\ntag: 杂项\n---\n \n\n#### git管理github ####\n\n1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：`git@github.com:xusx1024/codewars.git`\n\n2，pc端安装git工具，`git --info-path`打印git所在路径；创建本地仓库；\n\n3，在本地文件中，右键点击 Git Bash Here，进入git命令行\n\n4，全局配置 <br>\n\t`git config --global username \"此处定义你的名字\" `<br>\n\t`git config --global useremail xxxxxxx@gmail.com`\n\n5，初始化本地仓库：\n\t`git init `\n\n6，创建readme，并上传：<br>\n\t`git add readme.txt`<br>\n\t`git commint -m \"upload readme\"`<br>\n\n7，生成SSH key，用来和Github连接：\n\t`ssh-keygen -C '这里填你刚才配置的email地址' -t rsa`然后一路点击enter，最后，得到usr/.ssh中的SSH key\n\n8，把SSH key配置到 GitHub中\n\t在用户名上，`setting -  SSH and GPG keys`\n\n9，用到 第一步的那个串了<br>\n\t`git remote add origin git@github.com:xusx1024/codewars.git`<br>\n\t`git push origin master`<br>\n \n\t\n10，以后如果添加的话：<br>\n\t`git add sth`<br>\n\t`git commint -m \"文件说明\"`<br>\n\t`git push origin master`<br>\n\n11.`git add -A .`\n添加所有文件，注意后面有个点。\n\n12.\n`git pull`  抓取远程仓库所有分支更新并合并到本地\n\n13.`git config -l` 查看git的配置信息\n\n\n\n#### git 提交空目录 ####\n\ngit与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。\n\n#### git 克隆分支 ####\n\n多个分支的仓库，使用git clone的方法，只能把HEAD复制下来，如果有多个分支，可以考虑使用：\n\n`git branch -r`来查看各个分支\n\n`git checkout xxx`来clone指定的分支\n\n#### filename too long ####\n\n文件夹的层级过多，导致在clone的时候，出现该提示，可以考虑使用：\n\n`git config --system core.longpaths true`","slug":"git-command","published":1,"updated":"2017-08-21T05:37:56.478Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1e400322siv5dec103q","content":"<h4 id=\"git管理github\"><a href=\"#git管理github\" class=\"headerlink\" title=\"git管理github\"></a>git管理github</h4><p>1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：<code>git@github.com:xusx1024/codewars.git</code></p>\n<p>2，pc端安装git工具，<code>git --info-path</code>打印git所在路径；创建本地仓库；</p>\n<p>3，在本地文件中，右键点击 Git Bash Here，进入git命令行</p>\n<p>4，全局配置 <br><br>    <code>git config --global username &quot;此处定义你的名字&quot;</code><br><br>    <code>git config --global useremail xxxxxxx@gmail.com</code></p>\n<p>5，初始化本地仓库：<br>    <code>git init</code></p>\n<p>6，创建readme，并上传：<br><br>    <code>git add readme.txt</code><br><br>    <code>git commint -m &quot;upload readme&quot;</code><br></p>\n<p>7，生成SSH key，用来和Github连接：<br>    <code>ssh-keygen -C &#39;这里填你刚才配置的email地址&#39; -t rsa</code>然后一路点击enter，最后，得到usr/.ssh中的SSH key</p>\n<p>8，把SSH key配置到 GitHub中<br>    在用户名上，<code>setting -  SSH and GPG keys</code></p>\n<p>9，用到 第一步的那个串了<br><br>    <code>git remote add origin git@github.com:xusx1024/codewars.git</code><br><br>    <code>git push origin master</code><br></p>\n<p>10，以后如果添加的话：<br><br>    <code>git add sth</code><br><br>    <code>git commint -m &quot;文件说明&quot;</code><br><br>    <code>git push origin master</code><br></p>\n<p>11.<code>git add -A .</code><br>添加所有文件，注意后面有个点。</p>\n<p>12.<br><code>git pull</code>  抓取远程仓库所有分支更新并合并到本地</p>\n<p>13.<code>git config -l</code> 查看git的配置信息</p>\n<h4 id=\"git-提交空目录\"><a href=\"#git-提交空目录\" class=\"headerlink\" title=\"git 提交空目录\"></a>git 提交空目录</h4><p>git与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。</p>\n<h4 id=\"git-克隆分支\"><a href=\"#git-克隆分支\" class=\"headerlink\" title=\"git 克隆分支\"></a>git 克隆分支</h4><p>多个分支的仓库，使用git clone的方法，只能把HEAD复制下来，如果有多个分支，可以考虑使用：</p>\n<p><code>git branch -r</code>来查看各个分支</p>\n<p><code>git checkout xxx</code>来clone指定的分支</p>\n<h4 id=\"filename-too-long\"><a href=\"#filename-too-long\" class=\"headerlink\" title=\"filename too long\"></a>filename too long</h4><p>文件夹的层级过多，导致在clone的时候，出现该提示，可以考虑使用：</p>\n<p><code>git config --system core.longpaths true</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"git管理github\"><a href=\"#git管理github\" class=\"headerlink\" title=\"git管理github\"></a>git管理github</h4><p>1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：<code>git@github.com:xusx1024/codewars.git</code></p>\n<p>2，pc端安装git工具，<code>git --info-path</code>打印git所在路径；创建本地仓库；</p>\n<p>3，在本地文件中，右键点击 Git Bash Here，进入git命令行</p>\n<p>4，全局配置 <br><br>    <code>git config --global username &quot;此处定义你的名字&quot;</code><br><br>    <code>git config --global useremail xxxxxxx@gmail.com</code></p>\n<p>5，初始化本地仓库：<br>    <code>git init</code></p>\n<p>6，创建readme，并上传：<br><br>    <code>git add readme.txt</code><br><br>    <code>git commint -m &quot;upload readme&quot;</code><br></p>\n<p>7，生成SSH key，用来和Github连接：<br>    <code>ssh-keygen -C &#39;这里填你刚才配置的email地址&#39; -t rsa</code>然后一路点击enter，最后，得到usr/.ssh中的SSH key</p>\n<p>8，把SSH key配置到 GitHub中<br>    在用户名上，<code>setting -  SSH and GPG keys</code></p>\n<p>9，用到 第一步的那个串了<br><br>    <code>git remote add origin git@github.com:xusx1024/codewars.git</code><br><br>    <code>git push origin master</code><br></p>\n<p>10，以后如果添加的话：<br><br>    <code>git add sth</code><br><br>    <code>git commint -m &quot;文件说明&quot;</code><br><br>    <code>git push origin master</code><br></p>\n<p>11.<code>git add -A .</code><br>添加所有文件，注意后面有个点。</p>\n<p>12.<br><code>git pull</code>  抓取远程仓库所有分支更新并合并到本地</p>\n<p>13.<code>git config -l</code> 查看git的配置信息</p>\n<h4 id=\"git-提交空目录\"><a href=\"#git-提交空目录\" class=\"headerlink\" title=\"git 提交空目录\"></a>git 提交空目录</h4><p>git与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。</p>\n<h4 id=\"git-克隆分支\"><a href=\"#git-克隆分支\" class=\"headerlink\" title=\"git 克隆分支\"></a>git 克隆分支</h4><p>多个分支的仓库，使用git clone的方法，只能把HEAD复制下来，如果有多个分支，可以考虑使用：</p>\n<p><code>git branch -r</code>来查看各个分支</p>\n<p><code>git checkout xxx</code>来clone指定的分支</p>\n<h4 id=\"filename-too-long\"><a href=\"#filename-too-long\" class=\"headerlink\" title=\"filename too long\"></a>filename too long</h4><p>文件夹的层级过多，导致在clone的时候，出现该提示，可以考虑使用：</p>\n<p><code>git config --system core.longpaths true</code></p>\n"},{"layout":"post","title":"非比较排序之桶/箱排序","date":"2017-04-10T00:00:00.000Z","_content":" \n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对[基数排序](http://xusx1024.com/2017/04/10/radix-sort/)有一定的理解 T.T，而基数排序是`桶排序`的一种特例。<br>\n\n#### 算法原理 ####\n\n>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：\n>\n>![示例图](/images/buckets_sort.png)\n>\n当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。\n\n<br>\n\n桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br>\n1. 将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。\n2. 分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。\n3. 对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。\n4. 按顺序从每个桶输出数据,排序完成。\n\n[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/BucketSort.html) 提供了一个桶排序的分步动画演示。\n\n#### 实例分析 ####\n设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：\n\n![示例图](/images/bucket-sort-1.png)\n\n然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：\n\n![示例图](/images/bucket-sort-2.png)\n\n\n#### 示例代码 ####\n\t\n\tpackage BuketsSort;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 桶排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class BuketsSort {\n\t\n\t\t/*\n\t\t * 桶排序\n\t\t *\n\t\t * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n\t\t */\n\t\tpublic static void bucketSort(int[] a, int max) {\n\t\t\tint[] buckets;\n\t\n\t\t\tif (a == null || max < 1)\n\t\t\t\treturn;\n\t\n\t\t\t// 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n\t\t\tbuckets = new int[max];\n\t\n\t\t\t// 1. 计数\n\t\t\tfor (int i = 0; i < a.length; i++)\n\t\t\t\tbuckets[a[i]]++;\n\t\n\t\t\t// 2. 排序\n\t\t\tfor (int i = 0, j = 0; i < max; i++) {\n\t\t\t\twhile ((buckets[i]--) > 0) {\n\t\t\t\t\ta[j++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tpublic static void bucketSort(int[] arr) {\n\t\t\t// 分桶，这里采用映射函数f(x)=x/10。\n\t\t\t// 输入数据为0~99之间的数字\n\t\t\tint bucketCount = 10;\n\t\t\tInteger[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tint quotient = arr[i] / 10; // 这里即是使用f(x)\n\t\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\t\tif (bucket[quotient][j] == null) {\n\t\t\t\t\t\tbucket[quotient][j] = arr[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 小桶排序\n\t\t\tfor (int i = 0; i < bucket.length; i++) {\n\t\t\t\t// insertion sort\n\t\t\t\tfor (int j = 1; j < bucket[i].length; ++j) {\n\t\t\t\t\tif (bucket[i][j] == null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint value = bucket[i][j];\n\t\t\t\t\tint position = j;\n\t\t\t\t\twhile (position > 0 && bucket[i][position - 1] > value) {\n\t\t\t\t\t\tbucket[i][position] = bucket[i][position - 1];\n\t\t\t\t\t\tposition--;\n\t\t\t\t\t}\n\t\t\t\t\tbucket[i][position] = value;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t// 输出\n\t\t\tfor (int i = 0, index = 0; i < bucket.length; i++) {\n\t\t\t\tfor (int j = 0; j < bucket[i].length; j++) {\n\t\t\t\t\tif (bucket[i][j] != null) {\n\t\t\t\t\t\tarr[index] = bucket[i][j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t public static void bucketSort2(int [] arr){  \n\t        //寻找数组中min，max，用于建桶  \n\t        int min = 0, max = 0;  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            if(arr[i] < min){  \n\t                min = arr[i];  \n\t            }  \n\t            if(arr[i] > max){  \n\t                max = arr[i];  \n\t            }  \n\t        }  \n\t        //开始建桶，注意桶的数量等于max - min + 1  \n\t        int bucketCount = max - min + 1;  \n\t        int[] bucket = new int[bucketCount];  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            bucket[arr[i] - min]++;  \n\t        }  \n\t        for(int i = 1; i < bucketCount; i++){  \n\t            bucket[i] = bucket[i] + bucket[i - 1];  \n\t        }  \n\t        //开始排序  \n\t        int [] copy = new int[arr.length];  \n\t        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\t          \n\t        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n\t        for(int i = arr.length - 1; i >= 0; i--){  \n\t            arr[--bucket[copy[i] - min]] = copy[i];  \n\t        }  \n\t        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n\t//      for(int i = 0; i <= arr.length - 1; i++){  \n\t//          arr[--bucket[copy[i] - min]] = copy[i];  \n\t//      }  \n\t    }  \n\t\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i;\n\t\t\tint a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\n\t\t\tSystem.out.printf(\"before sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\n\t//\t\tbucketSort(a, 10); // 桶排序\n\t//\t\tbucketSort(a); // 桶排序\n\t\t\tbucketSort2(a); // 桶排序\n\t\n\t\t\tSystem.out.printf(\"after  sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\t}\n\t}\n","source":"_posts/2017-04-10-bucket-sort.md","raw":"---\nlayout: post\ntitle:  非比较排序之桶/箱排序\ndate:   2017-04-10\ncategories: Algorithm\ntag: [算法,hotfix]\n---\n \n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对[基数排序](http://xusx1024.com/2017/04/10/radix-sort/)有一定的理解 T.T，而基数排序是`桶排序`的一种特例。<br>\n\n#### 算法原理 ####\n\n>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：\n>\n>![示例图](/images/buckets_sort.png)\n>\n当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。\n\n<br>\n\n桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br>\n1. 将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。\n2. 分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。\n3. 对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。\n4. 按顺序从每个桶输出数据,排序完成。\n\n[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/BucketSort.html) 提供了一个桶排序的分步动画演示。\n\n#### 实例分析 ####\n设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：\n\n![示例图](/images/bucket-sort-1.png)\n\n然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：\n\n![示例图](/images/bucket-sort-2.png)\n\n\n#### 示例代码 ####\n\t\n\tpackage BuketsSort;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 桶排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class BuketsSort {\n\t\n\t\t/*\n\t\t * 桶排序\n\t\t *\n\t\t * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n\t\t */\n\t\tpublic static void bucketSort(int[] a, int max) {\n\t\t\tint[] buckets;\n\t\n\t\t\tif (a == null || max < 1)\n\t\t\t\treturn;\n\t\n\t\t\t// 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n\t\t\tbuckets = new int[max];\n\t\n\t\t\t// 1. 计数\n\t\t\tfor (int i = 0; i < a.length; i++)\n\t\t\t\tbuckets[a[i]]++;\n\t\n\t\t\t// 2. 排序\n\t\t\tfor (int i = 0, j = 0; i < max; i++) {\n\t\t\t\twhile ((buckets[i]--) > 0) {\n\t\t\t\t\ta[j++] = i;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tpublic static void bucketSort(int[] arr) {\n\t\t\t// 分桶，这里采用映射函数f(x)=x/10。\n\t\t\t// 输入数据为0~99之间的数字\n\t\t\tint bucketCount = 10;\n\t\t\tInteger[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n\t\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\t\tint quotient = arr[i] / 10; // 这里即是使用f(x)\n\t\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\t\tif (bucket[quotient][j] == null) {\n\t\t\t\t\t\tbucket[quotient][j] = arr[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 小桶排序\n\t\t\tfor (int i = 0; i < bucket.length; i++) {\n\t\t\t\t// insertion sort\n\t\t\t\tfor (int j = 1; j < bucket[i].length; ++j) {\n\t\t\t\t\tif (bucket[i][j] == null) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint value = bucket[i][j];\n\t\t\t\t\tint position = j;\n\t\t\t\t\twhile (position > 0 && bucket[i][position - 1] > value) {\n\t\t\t\t\t\tbucket[i][position] = bucket[i][position - 1];\n\t\t\t\t\t\tposition--;\n\t\t\t\t\t}\n\t\t\t\t\tbucket[i][position] = value;\n\t\t\t\t}\n\t\n\t\t\t}\n\t\t\t// 输出\n\t\t\tfor (int i = 0, index = 0; i < bucket.length; i++) {\n\t\t\t\tfor (int j = 0; j < bucket[i].length; j++) {\n\t\t\t\t\tif (bucket[i][j] != null) {\n\t\t\t\t\t\tarr[index] = bucket[i][j];\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t public static void bucketSort2(int [] arr){  \n\t        //寻找数组中min，max，用于建桶  \n\t        int min = 0, max = 0;  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            if(arr[i] < min){  \n\t                min = arr[i];  \n\t            }  \n\t            if(arr[i] > max){  \n\t                max = arr[i];  \n\t            }  \n\t        }  \n\t        //开始建桶，注意桶的数量等于max - min + 1  \n\t        int bucketCount = max - min + 1;  \n\t        int[] bucket = new int[bucketCount];  \n\t        for(int i = 0; i <= arr.length - 1; i++){  \n\t            bucket[arr[i] - min]++;  \n\t        }  \n\t        for(int i = 1; i < bucketCount; i++){  \n\t            bucket[i] = bucket[i] + bucket[i - 1];  \n\t        }  \n\t        //开始排序  \n\t        int [] copy = new int[arr.length];  \n\t        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\t          \n\t        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n\t        for(int i = arr.length - 1; i >= 0; i--){  \n\t            arr[--bucket[copy[i] - min]] = copy[i];  \n\t        }  \n\t        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n\t//      for(int i = 0; i <= arr.length - 1; i++){  \n\t//          arr[--bucket[copy[i] - min]] = copy[i];  \n\t//      }  \n\t    }  \n\t\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint i;\n\t\t\tint a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\n\t\t\tSystem.out.printf(\"before sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\n\t//\t\tbucketSort(a, 10); // 桶排序\n\t//\t\tbucketSort(a); // 桶排序\n\t\t\tbucketSort2(a); // 桶排序\n\t\n\t\t\tSystem.out.printf(\"after  sort:\");\n\t\t\tfor (i = 0; i < a.length; i++)\n\t\t\t\tSystem.out.printf(\"%d \", a[i]);\n\t\t\tSystem.out.printf(\"\\n\");\n\t\t}\n\t}\n","slug":"bucket-sort","published":1,"updated":"2018-01-31T09:54:49.366Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1e600352sivxpq74gdb","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序</a>有一定的理解 T.T，而基数排序是<code>桶排序</code>的一种特例。<br></p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：</p>\n<p><img src=\"/images/buckets_sort.png\" alt=\"示例图\"></p>\n<p>当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。</p>\n</blockquote>\n<p><br></p>\n<p>桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br></p>\n<ol>\n<li>将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。</li>\n<li>分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。</li>\n<li>对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。</li>\n<li>按顺序从每个桶输出数据,排序完成。</li>\n</ol>\n<p><a href=\"http://www.cs.usfca.edu/~galles/visualization/BucketSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p>\n<p><img src=\"/images/bucket-sort-1.png\" alt=\"示例图\"></p>\n<p>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p>\n<p><img src=\"/images/bucket-sort-2.png\" alt=\"示例图\"></p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre><code>package BuketsSort;\n\nimport java.util.Arrays;\n\n/**\n * 桶排序\n * \n * @author sxx.xu\n *\n */\npublic class BuketsSort {\n\n    /*\n     * 桶排序\n     *\n     * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n     */\n    public static void bucketSort(int[] a, int max) {\n        int[] buckets;\n\n        if (a == null || max &lt; 1)\n            return;\n\n        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n        buckets = new int[max];\n\n        // 1. 计数\n        for (int i = 0; i &lt; a.length; i++)\n            buckets[a[i]]++;\n\n        // 2. 排序\n        for (int i = 0, j = 0; i &lt; max; i++) {\n            while ((buckets[i]--) &gt; 0) {\n                a[j++] = i;\n            }\n        }\n\n        buckets = null;\n    }\n\n    public static void bucketSort(int[] arr) {\n        // 分桶，这里采用映射函数f(x)=x/10。\n        // 输入数据为0~99之间的数字\n        int bucketCount = 10;\n        Integer[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n        for (int i = 0; i &lt; arr.length; i++) {\n            int quotient = arr[i] / 10; // 这里即是使用f(x)\n            for (int j = 0; j &lt; arr.length; j++) {\n                if (bucket[quotient][j] == null) {\n                    bucket[quotient][j] = arr[i];\n                    break;\n                }\n            }\n        }\n        // 小桶排序\n        for (int i = 0; i &lt; bucket.length; i++) {\n            // insertion sort\n            for (int j = 1; j &lt; bucket[i].length; ++j) {\n                if (bucket[i][j] == null) {\n                    break;\n                }\n                int value = bucket[i][j];\n                int position = j;\n                while (position &gt; 0 &amp;&amp; bucket[i][position - 1] &gt; value) {\n                    bucket[i][position] = bucket[i][position - 1];\n                    position--;\n                }\n                bucket[i][position] = value;\n            }\n\n        }\n        // 输出\n        for (int i = 0, index = 0; i &lt; bucket.length; i++) {\n            for (int j = 0; j &lt; bucket[i].length; j++) {\n                if (bucket[i][j] != null) {\n                    arr[index] = bucket[i][j];\n                    index++;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n public static void bucketSort2(int [] arr){  \n        //寻找数组中min，max，用于建桶  \n        int min = 0, max = 0;  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            if(arr[i] &lt; min){  \n                min = arr[i];  \n            }  \n            if(arr[i] &gt; max){  \n                max = arr[i];  \n            }  \n        }  \n        //开始建桶，注意桶的数量等于max - min + 1  \n        int bucketCount = max - min + 1;  \n        int[] bucket = new int[bucketCount];  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            bucket[arr[i] - min]++;  \n        }  \n        for(int i = 1; i &lt; bucketCount; i++){  \n            bucket[i] = bucket[i] + bucket[i - 1];  \n        }  \n        //开始排序  \n        int [] copy = new int[arr.length];  \n        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\n        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n        for(int i = arr.length - 1; i &gt;= 0; i--){  \n            arr[--bucket[copy[i] - min]] = copy[i];  \n        }  \n        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n//      for(int i = 0; i &lt;= arr.length - 1; i++){  \n//          arr[--bucket[copy[i] - min]] = copy[i];  \n//      }  \n    }  \n\n\n    public static void main(String[] args) {\n        int i;\n        int a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\n        System.out.printf(&quot;before sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n\n//        bucketSort(a, 10); // 桶排序\n//        bucketSort(a); // 桶排序\n        bucketSort2(a); // 桶排序\n\n        System.out.printf(&quot;after  sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序</a>有一定的理解 T.T，而基数排序是<code>桶排序</code>的一种特例。<br></p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：</p>\n<p><img src=\"/images/buckets_sort.png\" alt=\"示例图\"></p>\n<p>当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。</p>\n</blockquote>\n<p><br></p>\n<p>桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br></p>\n<ol>\n<li>将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。</li>\n<li>分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。</li>\n<li>对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。</li>\n<li>按顺序从每个桶输出数据,排序完成。</li>\n</ol>\n<p><a href=\"http://www.cs.usfca.edu/~galles/visualization/BucketSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p>\n<p><img src=\"/images/bucket-sort-1.png\" alt=\"示例图\"></p>\n<p>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p>\n<p><img src=\"/images/bucket-sort-2.png\" alt=\"示例图\"></p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><pre><code>package BuketsSort;\n\nimport java.util.Arrays;\n\n/**\n * 桶排序\n * \n * @author sxx.xu\n *\n */\npublic class BuketsSort {\n\n    /*\n     * 桶排序\n     *\n     * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围\n     */\n    public static void bucketSort(int[] a, int max) {\n        int[] buckets;\n\n        if (a == null || max &lt; 1)\n            return;\n\n        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。\n        buckets = new int[max];\n\n        // 1. 计数\n        for (int i = 0; i &lt; a.length; i++)\n            buckets[a[i]]++;\n\n        // 2. 排序\n        for (int i = 0, j = 0; i &lt; max; i++) {\n            while ((buckets[i]--) &gt; 0) {\n                a[j++] = i;\n            }\n        }\n\n        buckets = null;\n    }\n\n    public static void bucketSort(int[] arr) {\n        // 分桶，这里采用映射函数f(x)=x/10。\n        // 输入数据为0~99之间的数字\n        int bucketCount = 10;\n        Integer[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。\n        for (int i = 0; i &lt; arr.length; i++) {\n            int quotient = arr[i] / 10; // 这里即是使用f(x)\n            for (int j = 0; j &lt; arr.length; j++) {\n                if (bucket[quotient][j] == null) {\n                    bucket[quotient][j] = arr[i];\n                    break;\n                }\n            }\n        }\n        // 小桶排序\n        for (int i = 0; i &lt; bucket.length; i++) {\n            // insertion sort\n            for (int j = 1; j &lt; bucket[i].length; ++j) {\n                if (bucket[i][j] == null) {\n                    break;\n                }\n                int value = bucket[i][j];\n                int position = j;\n                while (position &gt; 0 &amp;&amp; bucket[i][position - 1] &gt; value) {\n                    bucket[i][position] = bucket[i][position - 1];\n                    position--;\n                }\n                bucket[i][position] = value;\n            }\n\n        }\n        // 输出\n        for (int i = 0, index = 0; i &lt; bucket.length; i++) {\n            for (int j = 0; j &lt; bucket[i].length; j++) {\n                if (bucket[i][j] != null) {\n                    arr[index] = bucket[i][j];\n                    index++;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n public static void bucketSort2(int [] arr){  \n        //寻找数组中min，max，用于建桶  \n        int min = 0, max = 0;  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            if(arr[i] &lt; min){  \n                min = arr[i];  \n            }  \n            if(arr[i] &gt; max){  \n                max = arr[i];  \n            }  \n        }  \n        //开始建桶，注意桶的数量等于max - min + 1  \n        int bucketCount = max - min + 1;  \n        int[] bucket = new int[bucketCount];  \n        for(int i = 0; i &lt;= arr.length - 1; i++){  \n            bucket[arr[i] - min]++;  \n        }  \n        for(int i = 1; i &lt; bucketCount; i++){  \n            bucket[i] = bucket[i] + bucket[i - 1];  \n        }  \n        //开始排序  \n        int [] copy = new int[arr.length];  \n        System.arraycopy(arr, 0, copy, 0, arr.length);  \n\n        //从后往前排序，保持元素相对位置，保证算法稳定性。  \n        for(int i = arr.length - 1; i &gt;= 0; i--){  \n            arr[--bucket[copy[i] - min]] = copy[i];  \n        }  \n        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  \n//      for(int i = 0; i &lt;= arr.length - 1; i++){  \n//          arr[--bucket[copy[i] - min]] = copy[i];  \n//      }  \n    }  \n\n\n    public static void main(String[] args) {\n        int i;\n        int a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\n        System.out.printf(&quot;before sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n\n//        bucketSort(a, 10); // 桶排序\n//        bucketSort(a); // 桶排序\n        bucketSort2(a); // 桶排序\n\n        System.out.printf(&quot;after  sort:&quot;);\n        for (i = 0; i &lt; a.length; i++)\n            System.out.printf(&quot;%d &quot;, a[i]);\n        System.out.printf(&quot;\\n&quot;);\n    }\n}\n</code></pre>"},{"layout":"post","title":"非比较排序之基数排序","date":"2017-04-10T00:00:00.000Z","_content":"\n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对`基数排序`有一定的理解 T.T。<br>\n好，言归正传。基数排序是[桶排序](http://xusx1024.com/2017/04/10/bucket-sort/)的一种特例。 \n\n#### 比较和非比较的区别 ####\n\n常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。\n\n在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。\n\n比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n\n计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。\n\n非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。\n\n非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。\n\n#### 算法原理 ####\n>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。\n<br>\n\n排序过程：<br>\n将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br>\n\n基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/RadixSort.html)。\n\n<br>\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n#### 效率 ####\n\n基数排序的时间复杂度是 **O(k·n)**，其中**n**是排序元素个数， **k**是数字位数。注意这不是说这个时间复杂度一定优于 **O(n·log(n))**， **k**的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； **k**决定了进行多少轮处理，而 **n**是每轮处理的操作数目。\n\n\n#### 实例分析 ####\n\n对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：\n\n![示例图](/images/radix_sort.png)\nJava代码如下：\n\t\n\tpackage RadixSort;\n\t\n\t/**\n\t * 基数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class RadixSort {\n\t\n\t\tprivate static int getMax(int[] array) {\n\t\t\tint max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tmax = i > max ? i : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t\n\t\tpublic static void radixSort(int[] array) {\n\t\t\tint exp = 1;// 个、十、百、千。。。位\n\t\t\tint max = getMax(array);\n\t\n\t\t\tfor (exp = 1; max / exp > 0; exp *= 10)\n\t\t\t\tcountSort(array, exp);\n\t\t}\n\t\n\t\tprivate static void countSort(int[] array, int exp) {\n\t\n\t\t\tint[] outputs = new int[array.length];\n\t\t\tint[] buckets = new int[10];// 0-9\n\t\n\t\t\t//统计array中对应位数的元素的个数\n\t\t\tfor (int i : array) {\n\t\t\t\tbuckets[(i / exp) % 10]++;\n\t\t\t}\n\t\t\t//统计array中，小于该位的元素的个数，相当于排序\n\t\t\tfor (int i = 1; i < buckets.length; i++) {\n\t\t\t\tbuckets[i] += buckets[i - 1];\n\t\t\t}\n\t\t\t//赋值\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\toutputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n\t\t\t\tbuckets[(array[i] / exp) % 10]--;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < outputs.length; i++) {\n\t\t\t\tarray[i] = outputs[i];\n\t\t\t}\n\t\t\toutputs = null;\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tprivate static void radixSort(int[] array, int d) {\n\t\t\tint n = 1;// 个、十、百、千。。。位\n\t\t\tint k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n\t\t\tint length = array.length;\n\t\t\tint[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n\t\t\tint[] order = new int[length];// 用于保存每个桶里有多少个数字\n\t\t\twhile (n < d) {\n\t\t\t\tfor (int num : array) // 将数组array里的每个数字放在相应的桶里\n\t\t\t\t{\n\t\t\t\t\tint digit = (num / n) % 10;\n\t\t\t\t\tbucket[digit][order[digit]] = num;\n\t\t\t\t\torder[digit]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n\t\t\t\t{\n\t\t\t\t\tif (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = 0; j < order[i]; j++) {\n\t\t\t\t\t\t\tarray[k] = bucket[i][j];\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\torder[i] = 0;// 将桶里计数器置0，用于下一次位排序\n\t\t\t\t}\n\t\t\t\tn *= 10;\n\t\t\t\tk = 0;// 将k置0，用于下一轮保存位排序结果\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"before===================================after\");\n\t\t\tradixSort(array);\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tint[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tradixSort(A, 100);\n\t\t\tSystem.out.println(\"\");\n\t\t\tfor (int i : A) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t}\n\t}\n","source":"_posts/2017-04-10-radix-sort.md","raw":"---\nlayout: post\ntitle:  非比较排序之基数排序\ndate:   2017-04-10\ncategories: Algorithm\ntag: [算法,hotfix]\n---\n\n\n#### 简介 ####\n\n探究Tinker的BSDiff算法的过程中，发现用到了`后缀排序`，就去研究后缀排序，然后发现用到`倍增算法`的思想。而倍增是排序的一种策略，这种策略要求必须对`基数排序`有一定的理解 T.T。<br>\n好，言归正传。基数排序是[桶排序](http://xusx1024.com/2017/04/10/bucket-sort/)的一种特例。 \n\n#### 比较和非比较的区别 ####\n\n常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。\n\n在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。\n\n比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n\n计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。\n\n非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。\n\n非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。\n\n#### 算法原理 ####\n>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。\n<br>\n\n排序过程：<br>\n将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br>\n\n基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/RadixSort.html)。\n\n<br>\n基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n\n#### 效率 ####\n\n基数排序的时间复杂度是 **O(k·n)**，其中**n**是排序元素个数， **k**是数字位数。注意这不是说这个时间复杂度一定优于 **O(n·log(n))**， **k**的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； **k**决定了进行多少轮处理，而 **n**是每轮处理的操作数目。\n\n\n#### 实例分析 ####\n\n对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：\n\n![示例图](/images/radix_sort.png)\nJava代码如下：\n\t\n\tpackage RadixSort;\n\t\n\t/**\n\t * 基数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class RadixSort {\n\t\n\t\tprivate static int getMax(int[] array) {\n\t\t\tint max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tmax = i > max ? i : max;\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t\n\t\tpublic static void radixSort(int[] array) {\n\t\t\tint exp = 1;// 个、十、百、千。。。位\n\t\t\tint max = getMax(array);\n\t\n\t\t\tfor (exp = 1; max / exp > 0; exp *= 10)\n\t\t\t\tcountSort(array, exp);\n\t\t}\n\t\n\t\tprivate static void countSort(int[] array, int exp) {\n\t\n\t\t\tint[] outputs = new int[array.length];\n\t\t\tint[] buckets = new int[10];// 0-9\n\t\n\t\t\t//统计array中对应位数的元素的个数\n\t\t\tfor (int i : array) {\n\t\t\t\tbuckets[(i / exp) % 10]++;\n\t\t\t}\n\t\t\t//统计array中，小于该位的元素的个数，相当于排序\n\t\t\tfor (int i = 1; i < buckets.length; i++) {\n\t\t\t\tbuckets[i] += buckets[i - 1];\n\t\t\t}\n\t\t\t//赋值\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\toutputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n\t\t\t\tbuckets[(array[i] / exp) % 10]--;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < outputs.length; i++) {\n\t\t\t\tarray[i] = outputs[i];\n\t\t\t}\n\t\t\toutputs = null;\n\t\t\tbuckets = null;\n\t\t}\n\t\n\t\tprivate static void radixSort(int[] array, int d) {\n\t\t\tint n = 1;// 个、十、百、千。。。位\n\t\t\tint k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n\t\t\tint length = array.length;\n\t\t\tint[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n\t\t\tint[] order = new int[length];// 用于保存每个桶里有多少个数字\n\t\t\twhile (n < d) {\n\t\t\t\tfor (int num : array) // 将数组array里的每个数字放在相应的桶里\n\t\t\t\t{\n\t\t\t\t\tint digit = (num / n) % 10;\n\t\t\t\t\tbucket[digit][order[digit]] = num;\n\t\t\t\t\torder[digit]++;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n\t\t\t\t{\n\t\t\t\t\tif (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = 0; j < order[i]; j++) {\n\t\t\t\t\t\t\tarray[k] = bucket[i][j];\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\torder[i] = 0;// 将桶里计数器置0，用于下一次位排序\n\t\t\t\t}\n\t\t\t\tn *= 10;\n\t\t\t\tk = 0;// 将k置0，用于下一轮保存位排序结果\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t\tSystem.out.println(\"before===================================after\");\n\t\t\tradixSort(array);\n\t\t\tfor (int i : array) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t\tint[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n\t\t\tradixSort(A, 100);\n\t\t\tSystem.out.println(\"\");\n\t\t\tfor (int i : A) {\n\t\t\t\tSystem.out.print(i + \"  \");\n\t\t\t}\n\t\t}\n\t}\n","slug":"radix-sort","published":1,"updated":"2018-01-31T09:54:56.181Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1e800382sivmw97kij0","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<code>基数排序</code>有一定的理解 T.T。<br><br>好，言归正传。基数排序是<a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">桶排序</a>的一种特例。 </p>\n<h4 id=\"比较和非比较的区别\"><a href=\"#比较和非比较的区别\" class=\"headerlink\" title=\"比较和非比较的区别\"></a>比较和非比较的区别</h4><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</p>\n<p>在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。</p>\n<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p>\n<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。</p>\n<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。<br><br></p>\n</blockquote>\n<p>排序过程：<br><br>将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br></p>\n<p>基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/RadixSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a>。</p>\n<p><br><br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<h4 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h4><p>基数排序的时间复杂度是 <strong>O(k·n)</strong>，其中<strong>n</strong>是排序元素个数， <strong>k</strong>是数字位数。注意这不是说这个时间复杂度一定优于 <strong>O(n·log(n))</strong>， <strong>k</strong>的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； <strong>k</strong>决定了进行多少轮处理，而 <strong>n</strong>是每轮处理的操作数目。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>\n<p><img src=\"/images/radix_sort.png\" alt=\"示例图\"><br>Java代码如下：</p>\n<pre><code>package RadixSort;\n\n/**\n * 基数排序\n * \n * @author sxx.xu\n *\n */\npublic class RadixSort {\n\n    private static int getMax(int[] array) {\n        int max = array[0];\n        for (int i : array) {\n            max = i &gt; max ? i : max;\n        }\n        return max;\n    }\n\n    public static void radixSort(int[] array) {\n        int exp = 1;// 个、十、百、千。。。位\n        int max = getMax(array);\n\n        for (exp = 1; max / exp &gt; 0; exp *= 10)\n            countSort(array, exp);\n    }\n\n    private static void countSort(int[] array, int exp) {\n\n        int[] outputs = new int[array.length];\n        int[] buckets = new int[10];// 0-9\n\n        //统计array中对应位数的元素的个数\n        for (int i : array) {\n            buckets[(i / exp) % 10]++;\n        }\n        //统计array中，小于该位的元素的个数，相当于排序\n        for (int i = 1; i &lt; buckets.length; i++) {\n            buckets[i] += buckets[i - 1];\n        }\n        //赋值\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            outputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n            buckets[(array[i] / exp) % 10]--;\n        }\n\n        for (int i = 0; i &lt; outputs.length; i++) {\n            array[i] = outputs[i];\n        }\n        outputs = null;\n        buckets = null;\n    }\n\n    private static void radixSort(int[] array, int d) {\n        int n = 1;// 个、十、百、千。。。位\n        int k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n        int length = array.length;\n        int[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n        int[] order = new int[length];// 用于保存每个桶里有多少个数字\n        while (n &lt; d) {\n            for (int num : array) // 将数组array里的每个数字放在相应的桶里\n            {\n                int digit = (num / n) % 10;\n                bucket[digit][order[digit]] = num;\n                order[digit]++;\n            }\n            for (int i = 0; i &lt; length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            {\n                if (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                {\n                    for (int j = 0; j &lt; order[i]; j++) {\n                        array[k] = bucket[i][j];\n                        k++;\n                    }\n                }\n                order[i] = 0;// 将桶里计数器置0，用于下一次位排序\n            }\n            n *= 10;\n            k = 0;// 将k置0，用于下一轮保存位排序结果\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        System.out.println(&quot;&quot;);\n        System.out.println(&quot;before===================================after&quot;);\n        radixSort(array);\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        int[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        radixSort(A, 100);\n        System.out.println(&quot;&quot;);\n        for (int i : A) {\n            System.out.print(i + &quot;  &quot;);\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<code>基数排序</code>有一定的理解 T.T。<br><br>好，言归正传。基数排序是<a href=\"http://xusx1024.com/2017/04/10/bucket-sort/\" target=\"_blank\" rel=\"external\">桶排序</a>的一种特例。 </p>\n<h4 id=\"比较和非比较的区别\"><a href=\"#比较和非比较的区别\" class=\"headerlink\" title=\"比较和非比较的区别\"></a>比较和非比较的区别</h4><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</p>\n<p>在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。</p>\n<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p>\n<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。</p>\n<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><blockquote>\n<p>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。<br><br></p>\n</blockquote>\n<p>排序过程：<br><br>将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br></p>\n<p>基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/RadixSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a>。</p>\n<p><br><br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>\n<h4 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h4><p>基数排序的时间复杂度是 <strong>O(k·n)</strong>，其中<strong>n</strong>是排序元素个数， <strong>k</strong>是数字位数。注意这不是说这个时间复杂度一定优于 <strong>O(n·log(n))</strong>， <strong>k</strong>的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； <strong>k</strong>决定了进行多少轮处理，而 <strong>n</strong>是每轮处理的操作数目。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>\n<p><img src=\"/images/radix_sort.png\" alt=\"示例图\"><br>Java代码如下：</p>\n<pre><code>package RadixSort;\n\n/**\n * 基数排序\n * \n * @author sxx.xu\n *\n */\npublic class RadixSort {\n\n    private static int getMax(int[] array) {\n        int max = array[0];\n        for (int i : array) {\n            max = i &gt; max ? i : max;\n        }\n        return max;\n    }\n\n    public static void radixSort(int[] array) {\n        int exp = 1;// 个、十、百、千。。。位\n        int max = getMax(array);\n\n        for (exp = 1; max / exp &gt; 0; exp *= 10)\n            countSort(array, exp);\n    }\n\n    private static void countSort(int[] array, int exp) {\n\n        int[] outputs = new int[array.length];\n        int[] buckets = new int[10];// 0-9\n\n        //统计array中对应位数的元素的个数\n        for (int i : array) {\n            buckets[(i / exp) % 10]++;\n        }\n        //统计array中，小于该位的元素的个数，相当于排序\n        for (int i = 1; i &lt; buckets.length; i++) {\n            buckets[i] += buckets[i - 1];\n        }\n        //赋值\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            outputs[buckets[(array[i] / exp) % 10] - 1] = array[i];\n            buckets[(array[i] / exp) % 10]--;\n        }\n\n        for (int i = 0; i &lt; outputs.length; i++) {\n            array[i] = outputs[i];\n        }\n        outputs = null;\n        buckets = null;\n    }\n\n    private static void radixSort(int[] array, int d) {\n        int n = 1;// 个、十、百、千。。。位\n        int k = 0;// 保存每一位排序后的结果用于下一位的排序输入\n        int length = array.length;\n        int[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n        int[] order = new int[length];// 用于保存每个桶里有多少个数字\n        while (n &lt; d) {\n            for (int num : array) // 将数组array里的每个数字放在相应的桶里\n            {\n                int digit = (num / n) % 10;\n                bucket[digit][order[digit]] = num;\n                order[digit]++;\n            }\n            for (int i = 0; i &lt; length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n            {\n                if (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n                {\n                    for (int j = 0; j &lt; order[i]; j++) {\n                        array[k] = bucket[i][j];\n                        k++;\n                    }\n                }\n                order[i] = 0;// 将桶里计数器置0，用于下一次位排序\n            }\n            n *= 10;\n            k = 0;// 将k置0，用于下一轮保存位排序结果\n        }\n\n    }\n\n    public static void main(String[] args) {\n        int array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        System.out.println(&quot;&quot;);\n        System.out.println(&quot;before===================================after&quot;);\n        radixSort(array);\n        for (int i : array) {\n            System.out.print(i + &quot;  &quot;);\n        }\n        int[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };\n        radixSort(A, 100);\n        System.out.println(&quot;&quot;);\n        for (int i : A) {\n            System.out.print(i + &quot;  &quot;);\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"非比较排序之计数排序","date":"2017-04-11T00:00:00.000Z","_content":" \n\n\n#### 简介 ####\n\n[计数排序wiki](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F) <br>\n\n- 计数排序是用来排序0到100之间的数字的最好的算法\n- 计数排序可以用在基数排序中的算法来排序数据范围很大的数组\n- 计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序\n- 计数排序的优势是对已知数量范围的数组进行排序\n- 基于比较的排序算法是不能突破O(NlogN)\n\n\n \n\n#### 算法原理 ####\n \n1. 找出待排序的数组中最大和最小的元素\n1. 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项\n1. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n1. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n\n\n#### 实例分析 ####\n\n具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/CountingSort.html)\n\n<br>\n对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：\n \n![示例图](/images/counting_sort_1.png)<br>\n![示例图](/images/counting_sort_2.png)\n\n\n#### 代码 ####\n\tpackage CountingSort;\n\t\n\t/**\n\t * 计数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class CountingSort {\n\t \n\t\tprivate static void countingSort(int[] array) {\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i];\n\t\t\t\tint index = countArray[elem] - 1;\n\t\t\t\tcountResult[index] = elem;\n\t\t\t\tSystem.out.println(\"当前元素为：\" + elem + \";在排序数组中的位置是：\" + index);\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\n\t\t\t// 桶排序\n\t\t\t// int[][] resultArray = new int[countArray.length][countArray.length];\n\t\t\t// for (int i = 0; i < countArray.length; i++) {\n\t\t\t// for (int j = 0; j < countArray[i]; j++) {\n\t\t\t// resultArray[i][j] = i;\n\t\t\t// }\n\t\t\t// }\n\t\t\t//\n\t\t\t// for (int i = 0; i < resultArray.length; i++) {\n\t\t\t// for (int j = 0; j < resultArray[i].length; j++) {\n\t\t\t// if (resultArray[i][j] != 0)\n\t\t\t// System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\t\n\t\t/**\n\t\t * 优化后的，减少中间数组大小\n\t\t * @param array\n\t\t */\n\t\tprivate static void countingSort2(int[] array) {\n\t\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max - min + 1];\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i - min]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i] - min;\n\t\t\t\tint index = countArray[array[i] - min] - 1;\n\t\t\t\tcountResult[index] = array[i];\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\t\tint[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n\t\t\tcountingSort(array);\n\t\t\tcountingSort2(array);\n\t\t}\n\t}\n","source":"_posts/2017-04-11-counting-sort.md","raw":"---\nlayout: post\ntitle:  非比较排序之计数排序\ndate:   2017-04-11\ncategories: Algorithm\ntag: [算法,hotfix]\n---\n \n\n\n#### 简介 ####\n\n[计数排序wiki](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F) <br>\n\n- 计数排序是用来排序0到100之间的数字的最好的算法\n- 计数排序可以用在基数排序中的算法来排序数据范围很大的数组\n- 计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序\n- 计数排序的优势是对已知数量范围的数组进行排序\n- 基于比较的排序算法是不能突破O(NlogN)\n\n\n \n\n#### 算法原理 ####\n \n1. 找出待排序的数组中最大和最小的元素\n1. 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项\n1. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n1. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n\n\n#### 实例分析 ####\n\n具体的分步动画演示详见：[Data Structure Visualizations](http://www.cs.usfca.edu/~galles/visualization/CountingSort.html)\n\n<br>\n对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：\n \n![示例图](/images/counting_sort_1.png)<br>\n![示例图](/images/counting_sort_2.png)\n\n\n#### 代码 ####\n\tpackage CountingSort;\n\t\n\t/**\n\t * 计数排序\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class CountingSort {\n\t \n\t\tprivate static void countingSort(int[] array) {\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i];\n\t\t\t\tint index = countArray[elem] - 1;\n\t\t\t\tcountResult[index] = elem;\n\t\t\t\tSystem.out.println(\"当前元素为：\" + elem + \";在排序数组中的位置是：\" + index);\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\n\t\t\t// 桶排序\n\t\t\t// int[][] resultArray = new int[countArray.length][countArray.length];\n\t\t\t// for (int i = 0; i < countArray.length; i++) {\n\t\t\t// for (int j = 0; j < countArray[i]; j++) {\n\t\t\t// resultArray[i][j] = i;\n\t\t\t// }\n\t\t\t// }\n\t\t\t//\n\t\t\t// for (int i = 0; i < resultArray.length; i++) {\n\t\t\t// for (int j = 0; j < resultArray[i].length; j++) {\n\t\t\t// if (resultArray[i][j] != 0)\n\t\t\t// System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\t\n\t\t/**\n\t\t * 优化后的，减少中间数组大小\n\t\t * @param array\n\t\t */\n\t\tprivate static void countingSort2(int[] array) {\n\t\n\t\t\tint min = array[0], max = array[0];\n\t\t\tfor (int i : array) {\n\t\t\t\tif (i < min)\n\t\t\t\t\tmin = i;\n\t\t\t\tif (i > max)\n\t\t\t\t\tmax = i;\n\t\t\t}\n\t\n\t\t\tSystem.out.println(\"max value:\" + max + \"\\nmin value:\" + min);\n\t\t\tint[] countArray = new int[max - min + 1];\n\t\t\tint[] countResult = new int[array.length];\n\t\n\t\t\tfor (int i : array) {\n\t\t\t\tcountArray[i - min]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i < countArray.length; i++) {\n\t\t\t\tcountArray[i] += countArray[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\t\tint elem = array[i] - min;\n\t\t\t\tint index = countArray[array[i] - min] - 1;\n\t\t\t\tcountResult[index] = array[i];\n\t\t\t\tcountArray[elem]--;\n\t\t\t}\n\t\n\t\t\tfor (int i : countResult) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tint[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n\t\t\tint[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n\t\t\tcountingSort(array);\n\t\t\tcountingSort2(array);\n\t\t}\n\t}\n","slug":"counting-sort","published":1,"updated":"2018-01-31T09:55:09.436Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1eb003b2siv376vber1","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"external\">计数排序wiki</a> <br></p>\n<ul>\n<li>计数排序是用来排序0到100之间的数字的最好的算法</li>\n<li>计数排序可以用在基数排序中的算法来排序数据范围很大的数组</li>\n<li>计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序</li>\n<li>计数排序的优势是对已知数量范围的数组进行排序</li>\n<li>基于比较的排序算法是不能突破O(NlogN)</li>\n</ul>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>找出待排序的数组中最大和最小的元素</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>\n</ol>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/CountingSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a></p>\n<p><br><br>对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：</p>\n<p><img src=\"/images/counting_sort_1.png\" alt=\"示例图\"><br><br><img src=\"/images/counting_sort_2.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package CountingSort;\n\n/**\n * 计数排序\n * \n * @author sxx.xu\n *\n */\npublic class CountingSort {\n\n    private static void countingSort(int[] array) {\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i];\n            int index = countArray[elem] - 1;\n            countResult[index] = elem;\n            System.out.println(&quot;当前元素为：&quot; + elem + &quot;;在排序数组中的位置是：&quot; + index);\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n\n        // 桶排序\n        // int[][] resultArray = new int[countArray.length][countArray.length];\n        // for (int i = 0; i &lt; countArray.length; i++) {\n        // for (int j = 0; j &lt; countArray[i]; j++) {\n        // resultArray[i][j] = i;\n        // }\n        // }\n        //\n        // for (int i = 0; i &lt; resultArray.length; i++) {\n        // for (int j = 0; j &lt; resultArray[i].length; j++) {\n        // if (resultArray[i][j] != 0)\n        // System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n        // }\n        // }\n    }\n\n    /**\n     * 优化后的，减少中间数组大小\n     * @param array\n     */\n    private static void countingSort2(int[] array) {\n\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max - min + 1];\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i - min]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i] - min;\n            int index = countArray[array[i] - min] - 1;\n            countResult[index] = array[i];\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n        int[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n        countingSort(array);\n        countingSort2(array);\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\" target=\"_blank\" rel=\"external\">计数排序wiki</a> <br></p>\n<ul>\n<li>计数排序是用来排序0到100之间的数字的最好的算法</li>\n<li>计数排序可以用在基数排序中的算法来排序数据范围很大的数组</li>\n<li>计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序</li>\n<li>计数排序的优势是对已知数量范围的数组进行排序</li>\n<li>基于比较的排序算法是不能突破O(NlogN)</li>\n</ul>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>找出待排序的数组中最大和最小的元素</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>\n</ol>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p>具体的分步动画演示详见：<a href=\"http://www.cs.usfca.edu/~galles/visualization/CountingSort.html\" target=\"_blank\" rel=\"external\">Data Structure Visualizations</a></p>\n<p><br><br>对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：</p>\n<p><img src=\"/images/counting_sort_1.png\" alt=\"示例图\"><br><br><img src=\"/images/counting_sort_2.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package CountingSort;\n\n/**\n * 计数排序\n * \n * @author sxx.xu\n *\n */\npublic class CountingSort {\n\n    private static void countingSort(int[] array) {\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i];\n            int index = countArray[elem] - 1;\n            countResult[index] = elem;\n            System.out.println(&quot;当前元素为：&quot; + elem + &quot;;在排序数组中的位置是：&quot; + index);\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n\n        // 桶排序\n        // int[][] resultArray = new int[countArray.length][countArray.length];\n        // for (int i = 0; i &lt; countArray.length; i++) {\n        // for (int j = 0; j &lt; countArray[i]; j++) {\n        // resultArray[i][j] = i;\n        // }\n        // }\n        //\n        // for (int i = 0; i &lt; resultArray.length; i++) {\n        // for (int j = 0; j &lt; resultArray[i].length; j++) {\n        // if (resultArray[i][j] != 0)\n        // System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序\n        // }\n        // }\n    }\n\n    /**\n     * 优化后的，减少中间数组大小\n     * @param array\n     */\n    private static void countingSort2(int[] array) {\n\n        int min = array[0], max = array[0];\n        for (int i : array) {\n            if (i &lt; min)\n                min = i;\n            if (i &gt; max)\n                max = i;\n        }\n\n        System.out.println(&quot;max value:&quot; + max + &quot;\\nmin value:&quot; + min);\n        int[] countArray = new int[max - min + 1];\n        int[] countResult = new int[array.length];\n\n        for (int i : array) {\n            countArray[i - min]++;\n        }\n\n        for (int i = 1; i &lt; countArray.length; i++) {\n            countArray[i] += countArray[i - 1];\n        }\n\n        for (int i = array.length - 1; i &gt;= 0; i--) {\n            int elem = array[i] - min;\n            int index = countArray[array[i] - min] - 1;\n            countResult[index] = array[i];\n            countArray[elem]--;\n        }\n\n        for (int i : countResult) {\n            System.out.println(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };\n        int[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };\n        countingSort(array);\n        countingSort2(array);\n    }\n}\n</code></pre>"},{"layout":"post","title":"基于(前缀)倍增算法实现后缀数组","date":"2017-04-11T00:00:00.000Z","_content":" \n\n#### 简介 ####\n有几个基本概念需要知道。<br>\n\n>\n1. **子串：**字符串S的子串r[i...j],i <= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],...,r[j]形成的字符串;\n2. **后缀：**从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i...len(r)];<br>\n3. **大小比较：**关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]>v[i]则认为u>v，反之则认为u<v，比较结束。如果i>len(u)或者i>len(v)仍比较不出结果，那么若len(u)>len(v)，则认为u>v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。\n4. **后缀数组：**后缀数组SA是一个一维数组，它保存1...n的某个排列SA[1],SA[2],...,SA[n],并且保证suffix(SA[i])<suffix(SA[i+1]), 1 <= i < n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。\n5. **名次数组：**名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。\n6. **height数组：**定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀\n7. **LCP(i,j):**对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。\n\n#### 算法原理 ####\n\n Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用[基数排序(radix sort)](http://xusx1024.com/2017/04/10/radix-sort/)算法，先后对两位数字排序，可以采用[计数排序算法(counting sort)](http://xusx1024.com/2017/04/11/counting-sort/)对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。\n\n#### 实例分析 ####\n\n![示例图](/images/prefix_doubleing_demo_1.png)\n<br> \n \n![示例图](/images/SA&rank.png)\n\n#### 代码 ####\njava语言实现：<br>\n\n\tpackage PrefixDoubling;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 倍增算法实现后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class PrefixDoubling {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\t/**\n\t\t * sa中第i个后缀：SA[rank[i]-1];<br>\n\t\t * i是rank数组的下标;<br>\n\t\t * 串S的第i个后缀是S[i...n],n=S.length-1.\n\t\t * \n\t\t * @author sxx.xu\n\t\t *\n\t\t */\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int suffix, int[] digits) {\n\t\t\t\tthis.iSuffix = suffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i : C)\n\t\t\t\ti = 0;\n\t\n\t\t\tfor (int j = 0; j < tA.length; j++) {\n\t\t\t\tC[tA[j].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++)\n\t\t\t\tC[i] += C[i - 1];\n\t\n\t\t\tfor (int j = tA.length - 1; j >= 0; j--) {\n\t\n\t\t\t\ttB[--C[tA[j].digits[d]]] = tA[j];\n\t\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int d = digitsTotalLen - 1, j = 0; j < digitsLen; d--, j++) {\n\t\t\t\tthis.countingSort(d, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\ttA[i] = tB[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len];\n\t\t\tint r = 1;\n\t\t\trank[tB[0].iSuffix] = r;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix();\n\t\t\tsuffix.rank = rank;\n\t\t\tsuffix.sa = sa;\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic Suffix solve(String text) {\n\t\t\tif (text == null)\n\t\t\t\treturn null;\n\t\t\tint len = text.length();\n\t\t\tif (len == 0)\n\t\t\t\treturn null;\n\t\n\t\t\tint k = 1;\n\t\t\tchar base = text.charAt(len - 1);\n\t\t\tTuple[] tA = new Tuple[len];\n\t\t\tTuple[] tB = new Tuple[len];\n\t\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\ttA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n\t\t\t}\n\t\n\t\t\tSuffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n\t\t\twhile (!suffix.done) {\n\t\t\t\tk <<= 1;\n\t\t\t\tint offset = k >> 1;\n\t\t\t\tfor (int i = 0, j = i + offset; i < len; i++, j++) {\n\t\t\t\t\ttA[i].iSuffix = i;\n\t\t\t\t\ttA[i].digits = new int[] { suffix.rank[i], (j < len) ? suffix.rank[i + offset] : 0 };\n\t\t\t\t}\n\t\t\t\tint max = suffix.rank[suffix.sa[len - 1]];\n\t\t\t\tsuffix = rank(tA, tB, max, 2);\n\t\t\t}\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic void report(Suffix suffix) {\n\t\t\tint[] sa = suffix.sa;\n\t\t\tint[] rank = suffix.rank;\n\t\t\tint len = sa.length;\n\t\t\tSystem.out.println(\"suffix array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", sa[i]);\n\t\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"rank array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", rank[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t/*\n\t\t\t * //plain counting sort test:\n\t\t\t * \n\t\t\t * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n\t\t\t * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n\t\t\t * i=0;i<B.length;i++) System.out.format(\" %d\", B[i]);\n\t\t\t * System.out.println();\n\t\t\t */\n\t\n\t\t\tString text = \"GACCCACCACC#\";\n\t\t\tPrefixDoubling pd = new PrefixDoubling();\n\t\t\tSuffix suffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"mississippi#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"abcdefghijklmmnopqrstuvwxyz#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"yabbadabbado#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t}\n\t\n\t}\n","source":"_posts/2017-04-11-suffix-sort-baseon-prefix-doubleing.md","raw":"---\nlayout: post\ntitle:  基于(前缀)倍增算法实现后缀数组\ndate:   2017-04-11\ncategories: Algorithm\ntag: [算法,hotfix]\n---\n \n\n#### 简介 ####\n有几个基本概念需要知道。<br>\n\n>\n1. **子串：**字符串S的子串r[i...j],i <= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],...,r[j]形成的字符串;\n2. **后缀：**从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i...len(r)];<br>\n3. **大小比较：**关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]>v[i]则认为u>v，反之则认为u<v，比较结束。如果i>len(u)或者i>len(v)仍比较不出结果，那么若len(u)>len(v)，则认为u>v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。\n4. **后缀数组：**后缀数组SA是一个一维数组，它保存1...n的某个排列SA[1],SA[2],...,SA[n],并且保证suffix(SA[i])<suffix(SA[i+1]), 1 <= i < n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。\n5. **名次数组：**名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。\n6. **height数组：**定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀\n7. **LCP(i,j):**对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。\n\n#### 算法原理 ####\n\n Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用[基数排序(radix sort)](http://xusx1024.com/2017/04/10/radix-sort/)算法，先后对两位数字排序，可以采用[计数排序算法(counting sort)](http://xusx1024.com/2017/04/11/counting-sort/)对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。\n\n#### 实例分析 ####\n\n![示例图](/images/prefix_doubleing_demo_1.png)\n<br> \n \n![示例图](/images/SA&rank.png)\n\n#### 代码 ####\njava语言实现：<br>\n\n\tpackage PrefixDoubling;\n\t\n\timport java.util.Arrays;\n\t\n\t/**\n\t * 倍增算法实现后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class PrefixDoubling {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\t/**\n\t\t * sa中第i个后缀：SA[rank[i]-1];<br>\n\t\t * i是rank数组的下标;<br>\n\t\t * 串S的第i个后缀是S[i...n],n=S.length-1.\n\t\t * \n\t\t * @author sxx.xu\n\t\t *\n\t\t */\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int suffix, int[] digits) {\n\t\t\t\tthis.iSuffix = suffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i : C)\n\t\t\t\ti = 0;\n\t\n\t\t\tfor (int j = 0; j < tA.length; j++) {\n\t\t\t\tC[tA[j].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++)\n\t\t\t\tC[i] += C[i - 1];\n\t\n\t\t\tfor (int j = tA.length - 1; j >= 0; j--) {\n\t\n\t\t\t\ttB[--C[tA[j].digits[d]]] = tA[j];\n\t\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int d = digitsTotalLen - 1, j = 0; j < digitsLen; d--, j++) {\n\t\t\t\tthis.countingSort(d, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\ttA[i] = tB[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len];\n\t\t\tint r = 1;\n\t\t\trank[tB[0].iSuffix] = r;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix();\n\t\t\tsuffix.rank = rank;\n\t\t\tsuffix.sa = sa;\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic Suffix solve(String text) {\n\t\t\tif (text == null)\n\t\t\t\treturn null;\n\t\t\tint len = text.length();\n\t\t\tif (len == 0)\n\t\t\t\treturn null;\n\t\n\t\t\tint k = 1;\n\t\t\tchar base = text.charAt(len - 1);\n\t\t\tTuple[] tA = new Tuple[len];\n\t\t\tTuple[] tB = new Tuple[len];\n\t\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\ttA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n\t\t\t}\n\t\n\t\t\tSuffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n\t\t\twhile (!suffix.done) {\n\t\t\t\tk <<= 1;\n\t\t\t\tint offset = k >> 1;\n\t\t\t\tfor (int i = 0, j = i + offset; i < len; i++, j++) {\n\t\t\t\t\ttA[i].iSuffix = i;\n\t\t\t\t\ttA[i].digits = new int[] { suffix.rank[i], (j < len) ? suffix.rank[i + offset] : 0 };\n\t\t\t\t}\n\t\t\t\tint max = suffix.rank[suffix.sa[len - 1]];\n\t\t\t\tsuffix = rank(tA, tB, max, 2);\n\t\t\t}\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tpublic void report(Suffix suffix) {\n\t\t\tint[] sa = suffix.sa;\n\t\t\tint[] rank = suffix.rank;\n\t\t\tint len = sa.length;\n\t\t\tSystem.out.println(\"suffix array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", sa[i]);\n\t\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(\"rank array:\");\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\tSystem.out.format(\" %s\", rank[i]);\n\t\t\tSystem.out.println();\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t/*\n\t\t\t * //plain counting sort test:\n\t\t\t * \n\t\t\t * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n\t\t\t * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n\t\t\t * i=0;i<B.length;i++) System.out.format(\" %d\", B[i]);\n\t\t\t * System.out.println();\n\t\t\t */\n\t\n\t\t\tString text = \"GACCCACCACC#\";\n\t\t\tPrefixDoubling pd = new PrefixDoubling();\n\t\t\tSuffix suffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"mississippi#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"abcdefghijklmmnopqrstuvwxyz#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"yabbadabbado#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t\tSystem.out.println(\"********************************\");\n\t\t\ttext = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";\n\t\t\tpd = new PrefixDoubling();\n\t\t\tsuffix = pd.solve(text);\n\t\t\tSystem.out.format(\"Text: %s%n\", text);\n\t\t\tpd.report(suffix);\n\t\n\t\t}\n\t\n\t}\n","slug":"suffix-sort-baseon-prefix-doubleing","published":1,"updated":"2018-01-31T09:55:28.538Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ed003e2sivt81rgj70","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>有几个基本概念需要知道。<br></p>\n<p>&gt;</p>\n<ol>\n<li><strong>子串：</strong>字符串S的子串r[i…j],i &lt;= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],…,r[j]形成的字符串;</li>\n<li><strong>后缀：</strong>从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i…len(r)];<br></li>\n<li><strong>大小比较：</strong>关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]&gt;v[i]则认为u&gt;v，反之则认为u<v，比较结束。如果i>len(u)或者i&gt;len(v)仍比较不出结果，那么若len(u)&gt;len(v)，则认为u&gt;v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。</v.<br></v，比较结束。如果i></li>\n<li><strong>后缀数组：</strong>后缀数组SA是一个一维数组，它保存1…n的某个排列SA[1],SA[2],…,SA[n],并且保证suffix(SA[i])&lt;suffix(SA[i+1]), 1 &lt;= i &lt; n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。</li>\n<li><strong>名次数组：</strong>名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。</li>\n<li><strong>height数组：</strong>定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀</li>\n<li><strong>LCP(i,j):</strong>对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。</li>\n</ol>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><p> Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序(radix sort)</a>算法，先后对两位数字排序，可以采用<a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">计数排序算法(counting sort)</a>对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p><img src=\"/images/prefix_doubleing_demo_1.png\" alt=\"示例图\"><br><br> </p>\n<p><img src=\"/images/SA&amp;rank.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>java语言实现：<br></p>\n<pre><code>package PrefixDoubling;\n\nimport java.util.Arrays;\n\n/**\n * 倍增算法实现后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class PrefixDoubling {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    /**\n     * sa中第i个后缀：SA[rank[i]-1];&lt;br&gt;\n     * i是rank数组的下标;&lt;br&gt;\n     * 串S的第i个后缀是S[i...n],n=S.length-1.\n     * \n     * @author sxx.xu\n     *\n     */\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int suffix, int[] digits) {\n            this.iSuffix = suffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n        int[] C = new int[max + 1];\n        for (int i : C)\n            i = 0;\n\n        for (int j = 0; j &lt; tA.length; j++) {\n            C[tA[j].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++)\n            C[i] += C[i - 1];\n\n        for (int j = tA.length - 1; j &gt;= 0; j--) {\n\n            tB[--C[tA[j].digits[d]]] = tA[j];\n\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int d = digitsTotalLen - 1, j = 0; j &lt; digitsLen; d--, j++) {\n            this.countingSort(d, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int i = 0; i &lt; len; i++) {\n                    tA[i] = tB[i];\n                }\n            }\n        }\n\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len];\n        int r = 1;\n        rank[tB[0].iSuffix] = r;\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast) {\n                r++;\n            }\n            rank[tB[i].iSuffix] = r;\n        }\n\n        Suffix suffix = new Suffix();\n        suffix.rank = rank;\n        suffix.sa = sa;\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    public Suffix solve(String text) {\n        if (text == null)\n            return null;\n        int len = text.length();\n        if (len == 0)\n            return null;\n\n        int k = 1;\n        char base = text.charAt(len - 1);\n        Tuple[] tA = new Tuple[len];\n        Tuple[] tB = new Tuple[len];\n\n        for (int i = 0; i &lt; len; i++) {\n            tA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n        }\n\n        Suffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n        while (!suffix.done) {\n            k &lt;&lt;= 1;\n            int offset = k &gt;&gt; 1;\n            for (int i = 0, j = i + offset; i &lt; len; i++, j++) {\n                tA[i].iSuffix = i;\n                tA[i].digits = new int[] { suffix.rank[i], (j &lt; len) ? suffix.rank[i + offset] : 0 };\n            }\n            int max = suffix.rank[suffix.sa[len - 1]];\n            suffix = rank(tA, tB, max, 2);\n        }\n        return suffix;\n    }\n\n    public void report(Suffix suffix) {\n        int[] sa = suffix.sa;\n        int[] rank = suffix.rank;\n        int len = sa.length;\n        System.out.println(&quot;suffix array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, sa[i]);\n\n        System.out.println();\n        System.out.println(&quot;rank array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, rank[i]);\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        /*\n         * //plain counting sort test:\n         * \n         * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n         * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n         * i=0;i&lt;B.length;i++) System.out.format(&quot; %d&quot;, B[i]);\n         * System.out.println();\n         */\n\n        String text = &quot;GACCCACCACC#&quot;;\n        PrefixDoubling pd = new PrefixDoubling();\n        Suffix suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;mississippi#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;yabbadabbado#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>有几个基本概念需要知道。<br></p>\n<p>&gt;</p>\n<ol>\n<li><strong>子串：</strong>字符串S的子串r[i…j],i &lt;= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],…,r[j]形成的字符串;</li>\n<li><strong>后缀：</strong>从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i…len(r)];<br></li>\n<li><strong>大小比较：</strong>关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]&gt;v[i]则认为u&gt;v，反之则认为u<v，比较结束。如果i>len(u)或者i&gt;len(v)仍比较不出结果，那么若len(u)&gt;len(v)，则认为u&gt;v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。</v.<br></v，比较结束。如果i></li>\n<li><strong>后缀数组：</strong>后缀数组SA是一个一维数组，它保存1…n的某个排列SA[1],SA[2],…,SA[n],并且保证suffix(SA[i])&lt;suffix(SA[i+1]), 1 &lt;= i &lt; n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。</li>\n<li><strong>名次数组：</strong>名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。</li>\n<li><strong>height数组：</strong>定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀</li>\n<li><strong>LCP(i,j):</strong>对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。</li>\n</ol>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><p> Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用<a href=\"http://xusx1024.com/2017/04/10/radix-sort/\" target=\"_blank\" rel=\"external\">基数排序(radix sort)</a>算法，先后对两位数字排序，可以采用<a href=\"http://xusx1024.com/2017/04/11/counting-sort/\" target=\"_blank\" rel=\"external\">计数排序算法(counting sort)</a>对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。</p>\n<h4 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h4><p><img src=\"/images/prefix_doubleing_demo_1.png\" alt=\"示例图\"><br><br> </p>\n<p><img src=\"/images/SA&amp;rank.png\" alt=\"示例图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>java语言实现：<br></p>\n<pre><code>package PrefixDoubling;\n\nimport java.util.Arrays;\n\n/**\n * 倍增算法实现后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class PrefixDoubling {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    /**\n     * sa中第i个后缀：SA[rank[i]-1];&lt;br&gt;\n     * i是rank数组的下标;&lt;br&gt;\n     * 串S的第i个后缀是S[i...n],n=S.length-1.\n     * \n     * @author sxx.xu\n     *\n     */\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int suffix, int[] digits) {\n            this.iSuffix = suffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n        int[] C = new int[max + 1];\n        for (int i : C)\n            i = 0;\n\n        for (int j = 0; j &lt; tA.length; j++) {\n            C[tA[j].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++)\n            C[i] += C[i - 1];\n\n        for (int j = tA.length - 1; j &gt;= 0; j--) {\n\n            tB[--C[tA[j].digits[d]]] = tA[j];\n\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int d = digitsTotalLen - 1, j = 0; j &lt; digitsLen; d--, j++) {\n            this.countingSort(d, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int i = 0; i &lt; len; i++) {\n                    tA[i] = tB[i];\n                }\n            }\n        }\n\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len];\n        int r = 1;\n        rank[tB[0].iSuffix] = r;\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast) {\n                r++;\n            }\n            rank[tB[i].iSuffix] = r;\n        }\n\n        Suffix suffix = new Suffix();\n        suffix.rank = rank;\n        suffix.sa = sa;\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    public Suffix solve(String text) {\n        if (text == null)\n            return null;\n        int len = text.length();\n        if (len == 0)\n            return null;\n\n        int k = 1;\n        char base = text.charAt(len - 1);\n        Tuple[] tA = new Tuple[len];\n        Tuple[] tB = new Tuple[len];\n\n        for (int i = 0; i &lt; len; i++) {\n            tA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });\n        }\n\n        Suffix suffix = rank(tA, tB, MAX_CHAR - base, 1);\n        while (!suffix.done) {\n            k &lt;&lt;= 1;\n            int offset = k &gt;&gt; 1;\n            for (int i = 0, j = i + offset; i &lt; len; i++, j++) {\n                tA[i].iSuffix = i;\n                tA[i].digits = new int[] { suffix.rank[i], (j &lt; len) ? suffix.rank[i + offset] : 0 };\n            }\n            int max = suffix.rank[suffix.sa[len - 1]];\n            suffix = rank(tA, tB, max, 2);\n        }\n        return suffix;\n    }\n\n    public void report(Suffix suffix) {\n        int[] sa = suffix.sa;\n        int[] rank = suffix.rank;\n        int len = sa.length;\n        System.out.println(&quot;suffix array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, sa[i]);\n\n        System.out.println();\n        System.out.println(&quot;rank array:&quot;);\n        for (int i = 0; i &lt; len; i++)\n            System.out.format(&quot; %s&quot;, rank[i]);\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        /*\n         * //plain counting sort test:\n         * \n         * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();\n         * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int\n         * i=0;i&lt;B.length;i++) System.out.format(&quot; %d&quot;, B[i]);\n         * System.out.println();\n         */\n\n        String text = &quot;GACCCACCACC#&quot;;\n        PrefixDoubling pd = new PrefixDoubling();\n        Suffix suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;mississippi#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;yabbadabbado#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n        System.out.println(&quot;********************************&quot;);\n        text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;\n        pd = new PrefixDoubling();\n        suffix = pd.solve(text);\n        System.out.format(&quot;Text: %s%n&quot;, text);\n        pd.report(suffix);\n\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"Android系统服务：AccessibilityManager","date":"2017-04-20T00:00:00.000Z","_content":" \n\n#### 能做什么 ####\n \n- 抢红包\n- 自动安装apk(偷装流氓软件)\n- UI自动化测试\n- 监听短信内容\n- 帮助有障碍人士(...)\n\n#### 重要的类 ####\n\n`android.accessibilityservice.AccessibilityService`\n##### 重要的方法 #####\n\n`onAccessibilityEvent`<br/>\n`onInterrupt`\n\n#### 清单文件固定配置 ####\n\n        <service\n            android:name=\".SnatchRedEnvelopeService\"\n            android:enabled=\"true\"\n            android:exported=\"true\"\n            android:label=\"@string/service_name\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.accessibilityservice\"\n                android:resource=\"@xml/snatch_red_envelope_service_config\"/>\n        </service>\n\n##### 4.0之后配置服务参数 meta-data #####\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/accessibility_description\"\n    android:accessibilityEventTypes=\"typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged\"\n    android:packageNames=\"com.tencent.mm,com.tencent.mobileqq\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:notificationTimeout=\"100\"\n    android:accessibilityFlags=\"flagDefault\"\n    android:canRetrieveWindowContent=\"true\"/>\n\n此处相当于配置一个`AccessibilityServiceInfo`,代码如下：<br/>\n\n\t@Override\n    protected void onServiceConnected() {\n        AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n        serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n        serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n        serviceInfo.packageNames = new String[]{\"com.tencent.mm\",\"com.tencent.mobileqq\"}; \n        serviceInfo.notificationTimeout=100;\n        setServiceInfo(serviceInfo);\n    }\n\n\n#### 示例 ####\n\n[Github:SnatchRedEnvelope](https://github.com/xusx1024/SnatchRedEnvelope)\n","source":"_posts/2017-04-20-android-system-service-AccessibilityManager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：AccessibilityManager\ndate:   2017-04-20\ncategories: Android System Framework\ntag: android\n---\n \n\n#### 能做什么 ####\n \n- 抢红包\n- 自动安装apk(偷装流氓软件)\n- UI自动化测试\n- 监听短信内容\n- 帮助有障碍人士(...)\n\n#### 重要的类 ####\n\n`android.accessibilityservice.AccessibilityService`\n##### 重要的方法 #####\n\n`onAccessibilityEvent`<br/>\n`onInterrupt`\n\n#### 清单文件固定配置 ####\n\n        <service\n            android:name=\".SnatchRedEnvelopeService\"\n            android:enabled=\"true\"\n            android:exported=\"true\"\n            android:label=\"@string/service_name\"\n            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">\n            <intent-filter>\n                <action android:name=\"android.accessibilityservice.AccessibilityService\"/>\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.accessibilityservice\"\n                android:resource=\"@xml/snatch_red_envelope_service_config\"/>\n        </service>\n\n##### 4.0之后配置服务参数 meta-data #####\n\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<accessibility-service\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:description=\"@string/accessibility_description\"\n    android:accessibilityEventTypes=\"typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged\"\n    android:packageNames=\"com.tencent.mm,com.tencent.mobileqq\"\n    android:accessibilityFeedbackType=\"feedbackGeneric\"\n    android:notificationTimeout=\"100\"\n    android:accessibilityFlags=\"flagDefault\"\n    android:canRetrieveWindowContent=\"true\"/>\n\n此处相当于配置一个`AccessibilityServiceInfo`,代码如下：<br/>\n\n\t@Override\n    protected void onServiceConnected() {\n        AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n        serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n        serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n        serviceInfo.packageNames = new String[]{\"com.tencent.mm\",\"com.tencent.mobileqq\"}; \n        serviceInfo.notificationTimeout=100;\n        setServiceInfo(serviceInfo);\n    }\n\n\n#### 示例 ####\n\n[Github:SnatchRedEnvelope](https://github.com/xusx1024/SnatchRedEnvelope)\n","slug":"android-system-service-AccessibilityManager","published":1,"updated":"2017-08-17T02:46:35.806Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ef003h2siv7yp6f44p","content":"<h4 id=\"能做什么\"><a href=\"#能做什么\" class=\"headerlink\" title=\"能做什么\"></a>能做什么</h4><ul>\n<li>抢红包</li>\n<li>自动安装apk(偷装流氓软件)</li>\n<li>UI自动化测试</li>\n<li>监听短信内容</li>\n<li>帮助有障碍人士(…)</li>\n</ul>\n<h4 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h4><p><code>android.accessibilityservice.AccessibilityService</code></p>\n<h5 id=\"重要的方法\"><a href=\"#重要的方法\" class=\"headerlink\" title=\"重要的方法\"></a>重要的方法</h5><p><code>onAccessibilityEvent</code><br><br><code>onInterrupt</code></p>\n<h4 id=\"清单文件固定配置\"><a href=\"#清单文件固定配置\" class=\"headerlink\" title=\"清单文件固定配置\"></a>清单文件固定配置</h4><pre><code>&lt;service\n    android:name=&quot;.SnatchRedEnvelopeService&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;\n    android:label=&quot;@string/service_name&quot;\n    android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;\n    &lt;/intent-filter&gt;\n\n    &lt;meta-data\n        android:name=&quot;android.accessibilityservice&quot;\n        android:resource=&quot;@xml/snatch_red_envelope_service_config&quot;/&gt;\n&lt;/service&gt;\n</code></pre><h5 id=\"4-0之后配置服务参数-meta-data\"><a href=\"#4-0之后配置服务参数-meta-data\" class=\"headerlink\" title=\"4.0之后配置服务参数 meta-data\"></a>4.0之后配置服务参数 meta-data</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;accessibility-service\nxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\nandroid:description=&quot;@string/accessibility_description&quot;\nandroid:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged&quot;\nandroid:packageNames=&quot;com.tencent.mm,com.tencent.mobileqq&quot;\nandroid:accessibilityFeedbackType=&quot;feedbackGeneric&quot;\nandroid:notificationTimeout=&quot;100&quot;\nandroid:accessibilityFlags=&quot;flagDefault&quot;\nandroid:canRetrieveWindowContent=&quot;true&quot;/&gt;\n</code></pre><p>此处相当于配置一个<code>AccessibilityServiceInfo</code>,代码如下：<br></p>\n<pre><code>@Override\nprotected void onServiceConnected() {\n    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n    serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n    serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n    serviceInfo.packageNames = new String[]{&quot;com.tencent.mm&quot;,&quot;com.tencent.mobileqq&quot;}; \n    serviceInfo.notificationTimeout=100;\n    setServiceInfo(serviceInfo);\n}\n</code></pre><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><a href=\"https://github.com/xusx1024/SnatchRedEnvelope\" target=\"_blank\" rel=\"external\">Github:SnatchRedEnvelope</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"能做什么\"><a href=\"#能做什么\" class=\"headerlink\" title=\"能做什么\"></a>能做什么</h4><ul>\n<li>抢红包</li>\n<li>自动安装apk(偷装流氓软件)</li>\n<li>UI自动化测试</li>\n<li>监听短信内容</li>\n<li>帮助有障碍人士(…)</li>\n</ul>\n<h4 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h4><p><code>android.accessibilityservice.AccessibilityService</code></p>\n<h5 id=\"重要的方法\"><a href=\"#重要的方法\" class=\"headerlink\" title=\"重要的方法\"></a>重要的方法</h5><p><code>onAccessibilityEvent</code><br><br><code>onInterrupt</code></p>\n<h4 id=\"清单文件固定配置\"><a href=\"#清单文件固定配置\" class=\"headerlink\" title=\"清单文件固定配置\"></a>清单文件固定配置</h4><pre><code>&lt;service\n    android:name=&quot;.SnatchRedEnvelopeService&quot;\n    android:enabled=&quot;true&quot;\n    android:exported=&quot;true&quot;\n    android:label=&quot;@string/service_name&quot;\n    android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;\n    &lt;/intent-filter&gt;\n\n    &lt;meta-data\n        android:name=&quot;android.accessibilityservice&quot;\n        android:resource=&quot;@xml/snatch_red_envelope_service_config&quot;/&gt;\n&lt;/service&gt;\n</code></pre><h5 id=\"4-0之后配置服务参数-meta-data\"><a href=\"#4-0之后配置服务参数-meta-data\" class=\"headerlink\" title=\"4.0之后配置服务参数 meta-data\"></a>4.0之后配置服务参数 meta-data</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;accessibility-service\nxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\nandroid:description=&quot;@string/accessibility_description&quot;\nandroid:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged|typeWindowContentChanged|typeWindowsChanged&quot;\nandroid:packageNames=&quot;com.tencent.mm,com.tencent.mobileqq&quot;\nandroid:accessibilityFeedbackType=&quot;feedbackGeneric&quot;\nandroid:notificationTimeout=&quot;100&quot;\nandroid:accessibilityFlags=&quot;flagDefault&quot;\nandroid:canRetrieveWindowContent=&quot;true&quot;/&gt;\n</code></pre><p>此处相当于配置一个<code>AccessibilityServiceInfo</code>,代码如下：<br></p>\n<pre><code>@Override\nprotected void onServiceConnected() {\n    AccessibilityServiceInfo serviceInfo = new AccessibilityServiceInfo();\n    serviceInfo.eventTypes = AccessibilityEvent.TYPES_ALL_MASK;\n    serviceInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;\n    serviceInfo.packageNames = new String[]{&quot;com.tencent.mm&quot;,&quot;com.tencent.mobileqq&quot;}; \n    serviceInfo.notificationTimeout=100;\n    setServiceInfo(serviceInfo);\n}\n</code></pre><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p><a href=\"https://github.com/xusx1024/SnatchRedEnvelope\" target=\"_blank\" rel=\"external\">Github:SnatchRedEnvelope</a></p>\n"},{"layout":"post","title":"基于DC3算法实现后缀数组","date":"2017-04-13T00:00:00.000Z","_content":" \n\n\n#### 简介 ####\n\n DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 \"Simple Linear Work Suffix Array Construction\"中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法\n\n#### 算法原理 ####\n \n1. 先将后缀分成两部分，然后对第一部分的后缀排序;\n2. 利用1的结果，对第二部分的后缀排序;\n3. 将1和2的结果合并，即完成对所有后缀排序;\n\n \n#### 代码 ####\n\t \n\tpackage DC3;\n\t\n\t/**\n\t * DC3算法构建后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class DC3 {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\n\t\t\tpublic Suffix(int[] sa, int[] rank) {\n\t\t\t\tthis.sa = sa;\n\t\t\t\tthis.rank = rank;\n\t\t\t}\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int iSuffix, int[] digits) {\n\t\t\t\tthis.iSuffix = iSuffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i = 0; i <= max; i++) {\n\t\t\t\tC[i] = 0;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < tA.length; i++) {\n\t\t\t\tC[tA[i].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tC[i] += C[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = tA.length - 1; i >= 0; i--) {\n\t\t\t\ttB[--C[tA[i].digits[d]]] = tA[i];\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int i = digitsTotalLen - 1, j = 0; j < digitsLen; i--, j++) {\n\t\t\t\tthis.countingSort(i, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\t\ttA[k] = tB[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len + 2];\n\t\t\trank[len] = 1;\n\t\t\trank[len + 1] = 1;\n\t\n\t\t\tint r = 1;\n\t\n\t\t\trank[tB[0].iSuffix] = r;\n\t\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast)\n\t\t\t\t\tr++;\n\t\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix(sa, rank);\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tprivate int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\t\tint[] sa = new int[len];\n\t\t\tfor (int i = 0; i < sa.length; i++)\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\tpublic Suffix reduce(int[] rank, int max) {\n\t\n\t\t\tint len = rank.length - 2;\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tint n2 = len / 3;\n\t\n\t\t\tTuple[] tA = new Tuple[n1 + n2];\n\t\t\tTuple[] tB = new Tuple[n1 + n2];\n\t\n\t\t\tfor (int i = 0, j = 1; i < n1; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\tfor (int i = n1, j = 2; i < n1 + n2; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\treturn rank(tA, tB, max, 3);\n\t\t}\n\t\n\t\tpublic int[] skew(int[] rank, int max) {\n\t\t\tint len = rank.length - 2;\n\t\n\t\t\tSuffix suffixT12 = reduce(rank, max);\n\t\n\t\t\tint[] sa12 = null;\n\t\n\t\t\t// 1.caculate sa12\n\t\t\tif (!suffixT12.done) {\n\t\t\t\tint[] rankT12 = suffixT12.rank;\n\t\t\t\tint maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n\t\t\t\tsa12 = skew(rankT12, maxT12);\n\t\t\t} else {\n\t\t\t\tsa12 = suffixT12.sa;\n\t\t\t}\n\t\n\t\t\t// index conversion for sa12\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\tif (sa12[i] < n1) {\n\t\t\t\t\tsa12[i] = 1 + 3 * sa12[i];\n\t\t\t\t} else {\n\t\t\t\t\tsa12[i] = 2 + 3 * (sa12[i]-n1);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// recaculate rank for sa12\n\t\t\tint[] rank12 = new int[len + 2];\n\t\n\t\t\trank12[len] = 1;\n\t\t\trank12[len + 1] = 1;\n\t\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\trank12[sa12[i]] = i + 1;\n\t\t\t}\n\t\n\t\t\t// 2.caculate sa0\n\t\n\t\t\tint n0 = (len + 2) / 3;\n\t\t\tTuple[] tA = new Tuple[n0];\n\t\t\tTuple[] tB = new Tuple[n0];\n\t\n\t\t\tfor (int i = 0, j = 0; i < n0; i++, j += 3) {\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank12[j + 1];\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2 });\n\t\t\t}\n\t\n\t\t\tint max12 = rank12[sa12[sa12.length - 1]];\n\t\t\tint[] sa0 = orderSuffix(tA, tB, max < max12 ? max12 : max, 2);\n\t\n\t\t\tfor (int i = 0; i < n0; i++) {\n\t\t\t\tsa0[i] = 3 * sa0[i];\n\t\t\t}\n\t\n\t\t\t// 3.merge sa12 and sa0\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tint i = 0, j = 0, k = 0;\n\t\n\t\t\twhile (i < sa12.length && j < sa0.length) {\n\t\t\t\tint p = sa12[i];\n\t\t\t\tint q = sa0[j];\n\t\n\t\t\t\tif (p % 3 == 1) {\n\t\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank12[p + 1] < rank12[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank[p + 1] < rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else if (rank[p + 1] > rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rank12[p + 2] < rank12[q + 2]) {\n\t\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = i; m < sa12.length; m++) {\n\t\t\t\tsa[k++] = sa12[m];\n\t\t\t}\n\t\t\tfor (int m = j; m < sa0.length; m++) {\n\t\t\t\tsa[k++] = sa0[m];\n\t\t\t}\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\t public Suffix solve(String text){  \n\t\t        if(text == null)return null;  \n\t\t        int len = text.length();  \n\t\t        if(len == 0) return null;  \n\t\t          \n\t\t        char base = text.charAt(len-1); //the smallest char  \n\t\t        Tuple[] tA = new Tuple[len];  \n\t\t        Tuple[] tB = new Tuple[len]; //placeholder  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n\t\t        }  \n\t\t        Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\t\t           \n\t\t        int max = suffix.rank[suffix.sa[len-1]];  \n\t\t        int[] sa  = skew(suffix.rank,max);  \n\t\t          \n\t\t        //caculate rank for result suffix array  \n\t\t        int[] r = new int[len];       \n\t\t        for(int k=0;k<sa.length;k++){  \n\t\t            r[sa[k]] = k+1;  \n\t\t        }  \n\t\t        return new Suffix(sa,r);  \n\t\t          \n\t\t    }  \n\t\t    public void report(Suffix suffix){  \n\t\t        int[] sa = suffix.sa;  \n\t\t        int[] rank = suffix.rank;  \n\t\t        int len = sa.length;  \n\t\t          \n\t\t        System.out.println(\"suffix array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", sa[i]);              \n\t\t        }  \n\t\t        System.out.println();  \n\t\t        System.out.println(\"rank array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", rank[i]);            \n\t\t        }         \n\t\t        System.out.println();  \n\t\t    }  \n\t\t    public static void main(String[] args) {  \n\t\t        String text = \"GACCCACCACC#\";  \n\t\t        DC3 dc3 = new DC3();  \n\t\t        Suffix suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"mississippi#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"abcdefghijklmmnopqrstuvwxyz#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"yabbadabbado#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t    }  \n\t}\n","source":"_posts/2017-04-13-suffix-sort-baseon-dc3.md","raw":"---\nlayout: post\ntitle:  基于DC3算法实现后缀数组\ndate:   2017-04-13\ncategories: Algorithm\ntag: [算法,hotfix]\n---\n \n\n\n#### 简介 ####\n\n DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 \"Simple Linear Work Suffix Array Construction\"中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法\n\n#### 算法原理 ####\n \n1. 先将后缀分成两部分，然后对第一部分的后缀排序;\n2. 利用1的结果，对第二部分的后缀排序;\n3. 将1和2的结果合并，即完成对所有后缀排序;\n\n \n#### 代码 ####\n\t \n\tpackage DC3;\n\t\n\t/**\n\t * DC3算法构建后缀数组\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class DC3 {\n\t\n\t\tpublic static final char MAX_CHAR = '\\u00FF';\n\t\n\t\tclass Suffix {\n\t\t\tint[] sa;\n\t\t\tint[] rank;\n\t\t\tboolean done;\n\t\n\t\t\tpublic Suffix(int[] sa, int[] rank) {\n\t\t\t\tthis.sa = sa;\n\t\t\t\tthis.rank = rank;\n\t\t\t}\n\t\t}\n\t\n\t\tclass Tuple {\n\t\t\tint iSuffix;\n\t\t\tint[] digits;\n\t\n\t\t\tpublic Tuple(int iSuffix, int[] digits) {\n\t\t\t\tthis.iSuffix = iSuffix;\n\t\t\t\tthis.digits = digits;\n\t\t\t}\n\t\n\t\t\tpublic String toString() {\n\t\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\tsb.append(iSuffix);\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tfor (int i = 0; i < digits.length; i++) {\n\t\t\t\t\tsb.append(digits[i]);\n\t\t\t\t\tif (i < digits.length - 1)\n\t\t\t\t\t\tsb.append(\"-\");\n\t\t\t\t}\n\t\t\t\tsb.append(\")\");\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\t\n\t\t\tint[] C = new int[max + 1];\n\t\t\tfor (int i = 0; i <= max; i++) {\n\t\t\t\tC[i] = 0;\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < tA.length; i++) {\n\t\t\t\tC[tA[i].digits[d]]++;\n\t\t\t}\n\t\n\t\t\tfor (int i = 1; i <= max; i++) {\n\t\t\t\tC[i] += C[i - 1];\n\t\t\t}\n\t\n\t\t\tfor (int i = tA.length - 1; i >= 0; i--) {\n\t\t\t\ttB[--C[tA[i].digits[d]]] = tA[i];\n\t\t\t}\n\t\t}\n\t\n\t\tprivate void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tfor (int i = digitsTotalLen - 1, j = 0; j < digitsLen; i--, j++) {\n\t\t\t\tthis.countingSort(i, tA, tB, max);\n\t\t\t\tif (j < digitsLen - 1) {\n\t\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\t\ttA[k] = tB[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tprivate Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\n\t\t\tint digitsTotalLen = tA[0].digits.length;\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tsa[0] = tB[0].iSuffix;\n\t\n\t\t\tint[] rank = new int[len + 2];\n\t\t\trank[len] = 1;\n\t\t\trank[len + 1] = 1;\n\t\n\t\t\tint r = 1;\n\t\n\t\t\trank[tB[0].iSuffix] = r;\n\t\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\t\tboolean equalLast = true;\n\t\n\t\t\t\tfor (int j = digitsTotalLen - digitsLen; j < digitsTotalLen; j++) {\n\t\t\t\t\tif (tB[i].digits[j] != tB[i - 1].digits[j]) {\n\t\t\t\t\t\tequalLast = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!equalLast)\n\t\t\t\t\tr++;\n\t\n\t\t\t\trank[tB[i].iSuffix] = r;\n\t\n\t\t\t}\n\t\n\t\t\tSuffix suffix = new Suffix(sa, rank);\n\t\t\tif (r == len) {\n\t\t\t\tsuffix.done = true;\n\t\t\t} else {\n\t\t\t\tsuffix.done = false;\n\t\t\t}\n\t\n\t\t\treturn suffix;\n\t\t}\n\t\n\t\tprivate int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\t\n\t\t\tint len = tA.length;\n\t\t\tradixSort(tA, tB, max, digitsLen);\n\t\t\tint[] sa = new int[len];\n\t\t\tfor (int i = 0; i < sa.length; i++)\n\t\t\t\tsa[i] = tB[i].iSuffix;\n\t\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\tpublic Suffix reduce(int[] rank, int max) {\n\t\n\t\t\tint len = rank.length - 2;\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tint n2 = len / 3;\n\t\n\t\t\tTuple[] tA = new Tuple[n1 + n2];\n\t\t\tTuple[] tB = new Tuple[n1 + n2];\n\t\n\t\t\tfor (int i = 0, j = 1; i < n1; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\tfor (int i = n1, j = 2; i < n1 + n2; i++, j += 3) {\n\t\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank[j + 1];\n\t\t\t\tint r3 = rank[j + 2];\n\t\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n\t\t\t}\n\t\n\t\t\treturn rank(tA, tB, max, 3);\n\t\t}\n\t\n\t\tpublic int[] skew(int[] rank, int max) {\n\t\t\tint len = rank.length - 2;\n\t\n\t\t\tSuffix suffixT12 = reduce(rank, max);\n\t\n\t\t\tint[] sa12 = null;\n\t\n\t\t\t// 1.caculate sa12\n\t\t\tif (!suffixT12.done) {\n\t\t\t\tint[] rankT12 = suffixT12.rank;\n\t\t\t\tint maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n\t\t\t\tsa12 = skew(rankT12, maxT12);\n\t\t\t} else {\n\t\t\t\tsa12 = suffixT12.sa;\n\t\t\t}\n\t\n\t\t\t// index conversion for sa12\n\t\t\tint n1 = (len + 1) / 3;\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\tif (sa12[i] < n1) {\n\t\t\t\t\tsa12[i] = 1 + 3 * sa12[i];\n\t\t\t\t} else {\n\t\t\t\t\tsa12[i] = 2 + 3 * (sa12[i]-n1);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// recaculate rank for sa12\n\t\t\tint[] rank12 = new int[len + 2];\n\t\n\t\t\trank12[len] = 1;\n\t\t\trank12[len + 1] = 1;\n\t\n\t\t\tfor (int i = 0; i < sa12.length; i++) {\n\t\t\t\trank12[sa12[i]] = i + 1;\n\t\t\t}\n\t\n\t\t\t// 2.caculate sa0\n\t\n\t\t\tint n0 = (len + 2) / 3;\n\t\t\tTuple[] tA = new Tuple[n0];\n\t\t\tTuple[] tB = new Tuple[n0];\n\t\n\t\t\tfor (int i = 0, j = 0; i < n0; i++, j += 3) {\n\t\t\t\tint r1 = rank[j];\n\t\t\t\tint r2 = rank12[j + 1];\n\t\t\t\ttA[i] = new Tuple(i, new int[] { r1, r2 });\n\t\t\t}\n\t\n\t\t\tint max12 = rank12[sa12[sa12.length - 1]];\n\t\t\tint[] sa0 = orderSuffix(tA, tB, max < max12 ? max12 : max, 2);\n\t\n\t\t\tfor (int i = 0; i < n0; i++) {\n\t\t\t\tsa0[i] = 3 * sa0[i];\n\t\t\t}\n\t\n\t\t\t// 3.merge sa12 and sa0\n\t\n\t\t\tint[] sa = new int[len];\n\t\t\tint i = 0, j = 0, k = 0;\n\t\n\t\t\twhile (i < sa12.length && j < sa0.length) {\n\t\t\t\tint p = sa12[i];\n\t\t\t\tint q = sa0[j];\n\t\n\t\t\t\tif (p % 3 == 1) {\n\t\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank12[p + 1] < rank12[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (rank[p] < rank[q]) {\n\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else if (rank[p] > rank[q]) {\n\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (rank[p + 1] < rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else if (rank[p + 1] > rank[q + 1]) {\n\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (rank12[p + 2] < rank12[q + 2]) {\n\t\t\t\t\t\t\t\tsa[k++] = p;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsa[k++] = q;\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int m = i; m < sa12.length; m++) {\n\t\t\t\tsa[k++] = sa12[m];\n\t\t\t}\n\t\t\tfor (int m = j; m < sa0.length; m++) {\n\t\t\t\tsa[k++] = sa0[m];\n\t\t\t}\n\t\t\treturn sa;\n\t\n\t\t}\n\t\n\t\t public Suffix solve(String text){  \n\t\t        if(text == null)return null;  \n\t\t        int len = text.length();  \n\t\t        if(len == 0) return null;  \n\t\t          \n\t\t        char base = text.charAt(len-1); //the smallest char  \n\t\t        Tuple[] tA = new Tuple[len];  \n\t\t        Tuple[] tB = new Tuple[len]; //placeholder  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n\t\t        }  \n\t\t        Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\t\t           \n\t\t        int max = suffix.rank[suffix.sa[len-1]];  \n\t\t        int[] sa  = skew(suffix.rank,max);  \n\t\t          \n\t\t        //caculate rank for result suffix array  \n\t\t        int[] r = new int[len];       \n\t\t        for(int k=0;k<sa.length;k++){  \n\t\t            r[sa[k]] = k+1;  \n\t\t        }  \n\t\t        return new Suffix(sa,r);  \n\t\t          \n\t\t    }  \n\t\t    public void report(Suffix suffix){  \n\t\t        int[] sa = suffix.sa;  \n\t\t        int[] rank = suffix.rank;  \n\t\t        int len = sa.length;  \n\t\t          \n\t\t        System.out.println(\"suffix array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", sa[i]);              \n\t\t        }  \n\t\t        System.out.println();  \n\t\t        System.out.println(\"rank array:\");  \n\t\t        for(int i=0;i<len;i++){  \n\t\t            System.out.format(\" %s\", rank[i]);            \n\t\t        }         \n\t\t        System.out.println();  \n\t\t    }  \n\t\t    public static void main(String[] args) {  \n\t\t        String text = \"GACCCACCACC#\";  \n\t\t        DC3 dc3 = new DC3();  \n\t\t        Suffix suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"mississippi#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"abcdefghijklmmnopqrstuvwxyz#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"yabbadabbado#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t          \n\t\t        text = \"DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#\";  \n\t\t        dc3 = new DC3();  \n\t\t        suffix = dc3.solve(text);  \n\t\t        System.out.format(\"Text: %s%n\",text);  \n\t\t        dc3.report(suffix);  \n\t\t    }  \n\t}\n","slug":"suffix-sort-baseon-dc3","published":1,"updated":"2018-01-31T09:57:07.181Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ek003k2siv6gnrscks","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p> DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 “Simple Linear Work Suffix Array Construction”中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>先将后缀分成两部分，然后对第一部分的后缀排序;</li>\n<li>利用1的结果，对第二部分的后缀排序;</li>\n<li>将1和2的结果合并，即完成对所有后缀排序;</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package DC3;\n\n/**\n * DC3算法构建后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class DC3 {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n\n        public Suffix(int[] sa, int[] rank) {\n            this.sa = sa;\n            this.rank = rank;\n        }\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int iSuffix, int[] digits) {\n            this.iSuffix = iSuffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\n        int[] C = new int[max + 1];\n        for (int i = 0; i &lt;= max; i++) {\n            C[i] = 0;\n        }\n\n        for (int i = 0; i &lt; tA.length; i++) {\n            C[tA[i].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++) {\n            C[i] += C[i - 1];\n        }\n\n        for (int i = tA.length - 1; i &gt;= 0; i--) {\n            tB[--C[tA[i].digits[d]]] = tA[i];\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int i = digitsTotalLen - 1, j = 0; j &lt; digitsLen; i--, j++) {\n            this.countingSort(i, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int k = 0; k &lt; len; k++) {\n                    tA[k] = tB[k];\n                }\n            }\n        }\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len + 2];\n        rank[len] = 1;\n        rank[len + 1] = 1;\n\n        int r = 1;\n\n        rank[tB[0].iSuffix] = r;\n\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast)\n                r++;\n\n            rank[tB[i].iSuffix] = r;\n\n        }\n\n        Suffix suffix = new Suffix(sa, rank);\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    private int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n        int[] sa = new int[len];\n        for (int i = 0; i &lt; sa.length; i++)\n            sa[i] = tB[i].iSuffix;\n\n        return sa;\n\n    }\n\n    public Suffix reduce(int[] rank, int max) {\n\n        int len = rank.length - 2;\n        int n1 = (len + 1) / 3;\n        int n2 = len / 3;\n\n        Tuple[] tA = new Tuple[n1 + n2];\n        Tuple[] tB = new Tuple[n1 + n2];\n\n        for (int i = 0, j = 1; i &lt; n1; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        for (int i = n1, j = 2; i &lt; n1 + n2; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        return rank(tA, tB, max, 3);\n    }\n\n    public int[] skew(int[] rank, int max) {\n        int len = rank.length - 2;\n\n        Suffix suffixT12 = reduce(rank, max);\n\n        int[] sa12 = null;\n\n        // 1.caculate sa12\n        if (!suffixT12.done) {\n            int[] rankT12 = suffixT12.rank;\n            int maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n            sa12 = skew(rankT12, maxT12);\n        } else {\n            sa12 = suffixT12.sa;\n        }\n\n        // index conversion for sa12\n        int n1 = (len + 1) / 3;\n        for (int i = 0; i &lt; sa12.length; i++) {\n            if (sa12[i] &lt; n1) {\n                sa12[i] = 1 + 3 * sa12[i];\n            } else {\n                sa12[i] = 2 + 3 * (sa12[i]-n1);\n            }\n        }\n\n        // recaculate rank for sa12\n        int[] rank12 = new int[len + 2];\n\n        rank12[len] = 1;\n        rank12[len + 1] = 1;\n\n        for (int i = 0; i &lt; sa12.length; i++) {\n            rank12[sa12[i]] = i + 1;\n        }\n\n        // 2.caculate sa0\n\n        int n0 = (len + 2) / 3;\n        Tuple[] tA = new Tuple[n0];\n        Tuple[] tB = new Tuple[n0];\n\n        for (int i = 0, j = 0; i &lt; n0; i++, j += 3) {\n            int r1 = rank[j];\n            int r2 = rank12[j + 1];\n            tA[i] = new Tuple(i, new int[] { r1, r2 });\n        }\n\n        int max12 = rank12[sa12[sa12.length - 1]];\n        int[] sa0 = orderSuffix(tA, tB, max &lt; max12 ? max12 : max, 2);\n\n        for (int i = 0; i &lt; n0; i++) {\n            sa0[i] = 3 * sa0[i];\n        }\n\n        // 3.merge sa12 and sa0\n\n        int[] sa = new int[len];\n        int i = 0, j = 0, k = 0;\n\n        while (i &lt; sa12.length &amp;&amp; j &lt; sa0.length) {\n            int p = sa12[i];\n            int q = sa0[j];\n\n            if (p % 3 == 1) {\n\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank12[p + 1] &lt; rank12[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else {\n                        sa[k++] = q;\n                        j++;\n                    }\n                }\n            } else {\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank[p + 1] &lt; rank[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else if (rank[p + 1] &gt; rank[q + 1]) {\n                        sa[k++] = q;\n                        j++;\n                    } else {\n                        if (rank12[p + 2] &lt; rank12[q + 2]) {\n                            sa[k++] = p;\n                            i++;\n                        } else {\n                            sa[k++] = q;\n                            j++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int m = i; m &lt; sa12.length; m++) {\n            sa[k++] = sa12[m];\n        }\n        for (int m = j; m &lt; sa0.length; m++) {\n            sa[k++] = sa0[m];\n        }\n        return sa;\n\n    }\n\n     public Suffix solve(String text){  \n            if(text == null)return null;  \n            int len = text.length();  \n            if(len == 0) return null;  \n\n            char base = text.charAt(len-1); //the smallest char  \n            Tuple[] tA = new Tuple[len];  \n            Tuple[] tB = new Tuple[len]; //placeholder  \n            for(int i=0;i&lt;len;i++){  \n                tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n            }  \n            Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\n            int max = suffix.rank[suffix.sa[len-1]];  \n            int[] sa  = skew(suffix.rank,max);  \n\n            //caculate rank for result suffix array  \n            int[] r = new int[len];       \n            for(int k=0;k&lt;sa.length;k++){  \n                r[sa[k]] = k+1;  \n            }  \n            return new Suffix(sa,r);  \n\n        }  \n        public void report(Suffix suffix){  \n            int[] sa = suffix.sa;  \n            int[] rank = suffix.rank;  \n            int len = sa.length;  \n\n            System.out.println(&quot;suffix array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, sa[i]);              \n            }  \n            System.out.println();  \n            System.out.println(&quot;rank array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, rank[i]);            \n            }         \n            System.out.println();  \n        }  \n        public static void main(String[] args) {  \n            String text = &quot;GACCCACCACC#&quot;;  \n            DC3 dc3 = new DC3();  \n            Suffix suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;mississippi#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;yabbadabbado#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n        }  \n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p> DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 “Simple Linear Work Suffix Array Construction”中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法</p>\n<h4 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h4><ol>\n<li>先将后缀分成两部分，然后对第一部分的后缀排序;</li>\n<li>利用1的结果，对第二部分的后缀排序;</li>\n<li>将1和2的结果合并，即完成对所有后缀排序;</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package DC3;\n\n/**\n * DC3算法构建后缀数组\n * \n * @author sxx.xu\n *\n */\npublic class DC3 {\n\n    public static final char MAX_CHAR = &apos;\\u00FF&apos;;\n\n    class Suffix {\n        int[] sa;\n        int[] rank;\n        boolean done;\n\n        public Suffix(int[] sa, int[] rank) {\n            this.sa = sa;\n            this.rank = rank;\n        }\n    }\n\n    class Tuple {\n        int iSuffix;\n        int[] digits;\n\n        public Tuple(int iSuffix, int[] digits) {\n            this.iSuffix = iSuffix;\n            this.digits = digits;\n        }\n\n        public String toString() {\n            StringBuffer sb = new StringBuffer();\n            sb.append(iSuffix);\n            sb.append(&quot;(&quot;);\n            for (int i = 0; i &lt; digits.length; i++) {\n                sb.append(digits[i]);\n                if (i &lt; digits.length - 1)\n                    sb.append(&quot;-&quot;);\n            }\n            sb.append(&quot;)&quot;);\n            return sb.toString();\n        }\n    }\n\n    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {\n\n        int[] C = new int[max + 1];\n        for (int i = 0; i &lt;= max; i++) {\n            C[i] = 0;\n        }\n\n        for (int i = 0; i &lt; tA.length; i++) {\n            C[tA[i].digits[d]]++;\n        }\n\n        for (int i = 1; i &lt;= max; i++) {\n            C[i] += C[i - 1];\n        }\n\n        for (int i = tA.length - 1; i &gt;= 0; i--) {\n            tB[--C[tA[i].digits[d]]] = tA[i];\n        }\n    }\n\n    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        int digitsTotalLen = tA[0].digits.length;\n\n        for (int i = digitsTotalLen - 1, j = 0; j &lt; digitsLen; i--, j++) {\n            this.countingSort(i, tA, tB, max);\n            if (j &lt; digitsLen - 1) {\n                for (int k = 0; k &lt; len; k++) {\n                    tA[k] = tB[k];\n                }\n            }\n        }\n    }\n\n    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n\n        int digitsTotalLen = tA[0].digits.length;\n\n        int[] sa = new int[len];\n        sa[0] = tB[0].iSuffix;\n\n        int[] rank = new int[len + 2];\n        rank[len] = 1;\n        rank[len + 1] = 1;\n\n        int r = 1;\n\n        rank[tB[0].iSuffix] = r;\n\n        for (int i = 1; i &lt; len; i++) {\n            sa[i] = tB[i].iSuffix;\n\n            boolean equalLast = true;\n\n            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {\n                if (tB[i].digits[j] != tB[i - 1].digits[j]) {\n                    equalLast = false;\n                    break;\n                }\n            }\n\n            if (!equalLast)\n                r++;\n\n            rank[tB[i].iSuffix] = r;\n\n        }\n\n        Suffix suffix = new Suffix(sa, rank);\n        if (r == len) {\n            suffix.done = true;\n        } else {\n            suffix.done = false;\n        }\n\n        return suffix;\n    }\n\n    private int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {\n\n        int len = tA.length;\n        radixSort(tA, tB, max, digitsLen);\n        int[] sa = new int[len];\n        for (int i = 0; i &lt; sa.length; i++)\n            sa[i] = tB[i].iSuffix;\n\n        return sa;\n\n    }\n\n    public Suffix reduce(int[] rank, int max) {\n\n        int len = rank.length - 2;\n        int n1 = (len + 1) / 3;\n        int n2 = len / 3;\n\n        Tuple[] tA = new Tuple[n1 + n2];\n        Tuple[] tB = new Tuple[n1 + n2];\n\n        for (int i = 0, j = 1; i &lt; n1; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        for (int i = n1, j = 2; i &lt; n1 + n2; i++, j += 3) {\n\n            int r1 = rank[j];\n            int r2 = rank[j + 1];\n            int r3 = rank[j + 2];\n\n            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });\n        }\n\n        return rank(tA, tB, max, 3);\n    }\n\n    public int[] skew(int[] rank, int max) {\n        int len = rank.length - 2;\n\n        Suffix suffixT12 = reduce(rank, max);\n\n        int[] sa12 = null;\n\n        // 1.caculate sa12\n        if (!suffixT12.done) {\n            int[] rankT12 = suffixT12.rank;\n            int maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];\n            sa12 = skew(rankT12, maxT12);\n        } else {\n            sa12 = suffixT12.sa;\n        }\n\n        // index conversion for sa12\n        int n1 = (len + 1) / 3;\n        for (int i = 0; i &lt; sa12.length; i++) {\n            if (sa12[i] &lt; n1) {\n                sa12[i] = 1 + 3 * sa12[i];\n            } else {\n                sa12[i] = 2 + 3 * (sa12[i]-n1);\n            }\n        }\n\n        // recaculate rank for sa12\n        int[] rank12 = new int[len + 2];\n\n        rank12[len] = 1;\n        rank12[len + 1] = 1;\n\n        for (int i = 0; i &lt; sa12.length; i++) {\n            rank12[sa12[i]] = i + 1;\n        }\n\n        // 2.caculate sa0\n\n        int n0 = (len + 2) / 3;\n        Tuple[] tA = new Tuple[n0];\n        Tuple[] tB = new Tuple[n0];\n\n        for (int i = 0, j = 0; i &lt; n0; i++, j += 3) {\n            int r1 = rank[j];\n            int r2 = rank12[j + 1];\n            tA[i] = new Tuple(i, new int[] { r1, r2 });\n        }\n\n        int max12 = rank12[sa12[sa12.length - 1]];\n        int[] sa0 = orderSuffix(tA, tB, max &lt; max12 ? max12 : max, 2);\n\n        for (int i = 0; i &lt; n0; i++) {\n            sa0[i] = 3 * sa0[i];\n        }\n\n        // 3.merge sa12 and sa0\n\n        int[] sa = new int[len];\n        int i = 0, j = 0, k = 0;\n\n        while (i &lt; sa12.length &amp;&amp; j &lt; sa0.length) {\n            int p = sa12[i];\n            int q = sa0[j];\n\n            if (p % 3 == 1) {\n\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank12[p + 1] &lt; rank12[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else {\n                        sa[k++] = q;\n                        j++;\n                    }\n                }\n            } else {\n                if (rank[p] &lt; rank[q]) {\n                    sa[k++] = p;\n                    i++;\n                } else if (rank[p] &gt; rank[q]) {\n                    sa[k++] = q;\n                    j++;\n                } else {\n                    if (rank[p + 1] &lt; rank[q + 1]) {\n                        sa[k++] = p;\n                        i++;\n                    } else if (rank[p + 1] &gt; rank[q + 1]) {\n                        sa[k++] = q;\n                        j++;\n                    } else {\n                        if (rank12[p + 2] &lt; rank12[q + 2]) {\n                            sa[k++] = p;\n                            i++;\n                        } else {\n                            sa[k++] = q;\n                            j++;\n                        }\n                    }\n                }\n            }\n        }\n        for (int m = i; m &lt; sa12.length; m++) {\n            sa[k++] = sa12[m];\n        }\n        for (int m = j; m &lt; sa0.length; m++) {\n            sa[k++] = sa0[m];\n        }\n        return sa;\n\n    }\n\n     public Suffix solve(String text){  \n            if(text == null)return null;  \n            int len = text.length();  \n            if(len == 0) return null;  \n\n            char base = text.charAt(len-1); //the smallest char  \n            Tuple[] tA = new Tuple[len];  \n            Tuple[] tB = new Tuple[len]; //placeholder  \n            for(int i=0;i&lt;len;i++){  \n                tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  \n            }  \n            Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  \n\n            int max = suffix.rank[suffix.sa[len-1]];  \n            int[] sa  = skew(suffix.rank,max);  \n\n            //caculate rank for result suffix array  \n            int[] r = new int[len];       \n            for(int k=0;k&lt;sa.length;k++){  \n                r[sa[k]] = k+1;  \n            }  \n            return new Suffix(sa,r);  \n\n        }  \n        public void report(Suffix suffix){  \n            int[] sa = suffix.sa;  \n            int[] rank = suffix.rank;  \n            int len = sa.length;  \n\n            System.out.println(&quot;suffix array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, sa[i]);              \n            }  \n            System.out.println();  \n            System.out.println(&quot;rank array:&quot;);  \n            for(int i=0;i&lt;len;i++){  \n                System.out.format(&quot; %s&quot;, rank[i]);            \n            }         \n            System.out.println();  \n        }  \n        public static void main(String[] args) {  \n            String text = &quot;GACCCACCACC#&quot;;  \n            DC3 dc3 = new DC3();  \n            Suffix suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;mississippi#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;yabbadabbado#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n\n            text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;  \n            dc3 = new DC3();  \n            suffix = dc3.solve(text);  \n            System.out.format(&quot;Text: %s%n&quot;,text);  \n            dc3.report(suffix);  \n        }  \n}\n</code></pre>"},{"layout":"post","title":"Android开发中特别的api","date":"2017-04-21T00:00:00.000Z","_content":" \n#### 前言 ####\n android库很大，开发中会遇到一些不常用的api，记录在此。\n \n\n#### ActionBar相关 ####\n\n- setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击\n- actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP\n- actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME\n- actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM\n- actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示\n\n\n#### 判断Activity是否仍在运行 ####\n\n\tif (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n        return;\n    }\n\n#### 开关使用ToggleButton或者Switch ####\n\n\n \n\n \n ","source":"_posts/2017-04-21-android-special-api.md","raw":"---\nlayout: post\ntitle:  Android开发中特别的api\ndate:   2017-04-21\ncategories: Android \ntag: android\n---\n \n#### 前言 ####\n android库很大，开发中会遇到一些不常用的api，记录在此。\n \n\n#### ActionBar相关 ####\n\n- setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击\n- actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP\n- actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME\n- actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM\n- actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示\n\n\n#### 判断Activity是否仍在运行 ####\n\n\tif (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n        return;\n    }\n\n#### 开关使用ToggleButton或者Switch ####\n\n\n \n\n \n ","slug":"android-special-api","published":1,"updated":"2017-11-16T08:29:15.604Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ep003n2sivb2aaknqm","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p> android库很大，开发中会遇到一些不常用的api，记录在此。</p>\n<h4 id=\"ActionBar相关\"><a href=\"#ActionBar相关\" class=\"headerlink\" title=\"ActionBar相关\"></a>ActionBar相关</h4><ul>\n<li>setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击</li>\n<li>actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP</li>\n<li>actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME</li>\n<li>actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM</li>\n<li>actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示</li>\n</ul>\n<h4 id=\"判断Activity是否仍在运行\"><a href=\"#判断Activity是否仍在运行\" class=\"headerlink\" title=\"判断Activity是否仍在运行\"></a>判断Activity是否仍在运行</h4><pre><code>if (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n    return;\n}\n</code></pre><h4 id=\"开关使用ToggleButton或者Switch\"><a href=\"#开关使用ToggleButton或者Switch\" class=\"headerlink\" title=\"开关使用ToggleButton或者Switch\"></a>开关使用ToggleButton或者Switch</h4>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p> android库很大，开发中会遇到一些不常用的api，记录在此。</p>\n<h4 id=\"ActionBar相关\"><a href=\"#ActionBar相关\" class=\"headerlink\" title=\"ActionBar相关\"></a>ActionBar相关</h4><ul>\n<li>setHomeButtonEnabled这个小于4.0版本的默认值为true的。但是在4.0及其以上是false，该方法的作用：决定左上角的图标是否可以点击。没有向左的小图标。 true 图标可以点击  false 不可以点击</li>\n<li>actionBar.setDisplayHomeAsUpEnabled(true)    // 给左上角图标的左边加上一个返回的图标 。对应ActionBar.DISPLAY_HOME_AS_UP</li>\n<li>actionBar.setDisplayShowHomeEnabled(true)   //使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题，否则，显示应用程序图标，对应id为Android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME</li>\n<li>actionBar.setDisplayShowCustomEnabled(true)  // 使自定义的普通View能在title栏显示，即actionBar.setCustomView能起作用，对应ActionBar.DISPLAY_SHOW_CUSTOM</li>\n<li>actionBar.setDisplayShowTitleEnabled(true)   //对应去掉ActionBar是否显示</li>\n</ul>\n<h4 id=\"判断Activity是否仍在运行\"><a href=\"#判断Activity是否仍在运行\" class=\"headerlink\" title=\"判断Activity是否仍在运行\"></a>判断Activity是否仍在运行</h4><pre><code>if (activity == null || activity.isDestroyed() || activity.isFinishing()) {\n    return;\n}\n</code></pre><h4 id=\"开关使用ToggleButton或者Switch\"><a href=\"#开关使用ToggleButton或者Switch\" class=\"headerlink\" title=\"开关使用ToggleButton或者Switch\"></a>开关使用ToggleButton或者Switch</h4>"},{"layout":"post","title":"JavaEE学习路线图","date":"2017-05-17T00:00:00.000Z","_content":" \n \n![来自传智播客](/images/java_web_study_path.png)\n","source":"_posts/2017-05-15-javaee-tips.md","raw":"---\nlayout: post\ntitle:  JavaEE学习路线图\ndate:   2017-05-17\ncategories: JAVA & kotlin\ntag: 杂项\n---\n \n \n![来自传智播客](/images/java_web_study_path.png)\n","slug":"javaee-tips","published":1,"updated":"2017-08-17T02:47:35.552Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1eu003q2sivko4r8ur9","content":"<p><img src=\"/images/java_web_study_path.png\" alt=\"来自传智播客\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/java_web_study_path.png\" alt=\"来自传智播客\"></p>\n"},{"layout":"post","title":"Android学习路线图","date":"2017-04-01T00:00:00.000Z","_content":"\n\n\n#### 程序设计 ####\n\n\n|  知识点  ||链接或书籍|进阶|\n| :------ | :------ | :------ | :------ |\n|__java__|基本语法(如继承、异常、引用、泛型等)|[Java核心技术 卷I](https://book.douban.com/subject/25762168/)（适合入门）|[Effective Java中文版](https://book.douban.com/subject/3360807/)（如何写好的Java代码）<br>[Java解惑](https://book.douban.com/subject/5362860/)（介绍烂Java代码是什么样的）\n|  | 多线程、并发 |[Java并发编程实战](https://book.douban.com/subject/10484692/)<br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）|  |\n||Java 7|[Java程序员修炼之道](https://book.douban.com/subject/24841235/) （详细的介绍Java 7 的新特性）||\n||Java 8|[写给大忙人看的Java SE 8](https://book.douban.com/subject/26274206/)<br>[函数式编程思维](https://book.douban.com/subject/26587213/)||\n||Java虚拟机|[深入理解Java虚拟机](https://book.douban.com/subject/24722612/) （并不是那么难，Java程序员都该看看）||\n||性能优化|[Java性能优化权威指南](https://book.douban.com/subject/25828043/) （后面的章节好像用处不大，前面有些部分还是值得看）||\n|__算法与数据结构__|算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br>|[数据结构与算法分析](https://book.douban.com/subject/1139426/) （涵盖面比较全、示例是Java语言）<br>[算法设计与分析基础](https://book.douban.com/subject/26337727/)（实用主义的典型、偏算法设计<br>[编程珠玑](https://book.douban.com/subject/3227098/)（实践型算法数据||\n|__操作系统__|对Linux/OS的基本认知<br>Linux的常用命令|[鸟哥的Linux私房菜](https://book.douban.com/subject/4889838/)<br>[Linux内核设计与实现(原书第3版)](https://book.douban.com/subject/6097773/)（很精炼的语言描述清楚了内核算法）||\n|__网络__|Http/Https<br>TCP/IP|[图解HTTP](https://book.douban.com/subject/25863515/)<br>[图解TCP/IP](https://book.douban.com/subject/24737674/)|[TCP/IP详解](https://book.douban.com/subject/1088054/)|\n|__Android__|四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）|[UniversalMusicePlayer](https://github.com/googlesamples/android-UniversalMusicPlayer)(通过学习一个音乐播放器的代码能很快了解四大组件)<br>[Android Training官方课程](http://hukai.me/android-training-course-in-chinese/index.html)<br>[Android一些重要知识点解析整理](https://github.com/FX-Max/Point-of-Android)<br>[Android UI/UX库](https://github.com/wasabeef/awesome-android-ui)<br>（各类常用组件及扩展组件的集合）[Picasso](http://square.github.io/picasso/)、[Glide](https://github.com/bumptech/glide)（两个图片加载库）<br>[The Google I/O 2016 Android App](https://github.com/google/iosched)(Google大会官方的App，适合学习各类实现)<br>[Android开发技术前线](http://www.devtf.cn/)（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）|[第三方库集合](https://github.com/wasabeef/awesome-android-libraries)|\n\n#### 软件工程 ####\n\n\n|  知识点  ||链接或书籍|进阶|\n| :------ | :------ | :------ | :------ |\n|__基础工具__|IDE、Git、Maven|[AndroidStudio](https://developer.android.com/studio/index.html)<br>[Git权威指南中文手册](http://iissnan.com/progit/html/zh/ch1_0.html)||\n|__软件质量__|代码整洁<br>代码质量<br>代码重构|[编写可读代码的艺术](https://book.douban.com/subject/10797189/)（来自Google工程师，专注于代码可读性）<br>[代码整洁之道](https://book.douban.com/subject/4199741/)（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br>[重构-改善既有代码的设计](https://book.douban.com/subject/4262627/)（学习改善已有代码）<br>[重构手册](https://book.douban.com/subject/1173730/)（改善代码的实际操作）||\n|__设计模式__|23种常见设计模式|[大话设计模式](https://book.douban.com/subject/2334288/)<br>[Head First设计模式](https://book.douban.com/subject/2243615/)(两本入门级的设计模式书籍)|[设计模式-可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)（设计模式在实际中的应用）|\n|__敏捷开发__||[解析极限编程](https://book.douban.com/subject/1790225/)<br>[敏捷开发的艺术](https://book.douban.com/subject/4037534/)|[敏捷软件开发-原则、模式与实践](https://book.douban.com/subject/5348122/)|\n|__专业开发__|序员职业素养<br>更高效、更实效|[程序员的是职业素养](https://book.douban.com/subject/11614538/)<br>[程序员修炼之道-从小工到专家](https://book.douban.com/subject/5387402/)||\n|__思考人生__||[黑客与画家](https://book.douban.com/subject/6021440/)(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)||\n\n\n#### 鸣谢 ####\n\n[一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本](https://www.diycode.cc/topics/122)\n <br>\n[另一份 Android 开发学习路线图](https://www.diycode.cc/topics/117)\n","source":"_posts/2017-04-01-android-study-path.md","raw":"---\nlayout: post\ntitle:  Android学习路线图\ndate:   2017-04-01\ncategories: Android\ntag: android\n---\n\n\n\n#### 程序设计 ####\n\n\n|  知识点  ||链接或书籍|进阶|\n| :------ | :------ | :------ | :------ |\n|__java__|基本语法(如继承、异常、引用、泛型等)|[Java核心技术 卷I](https://book.douban.com/subject/25762168/)（适合入门）|[Effective Java中文版](https://book.douban.com/subject/3360807/)（如何写好的Java代码）<br>[Java解惑](https://book.douban.com/subject/5362860/)（介绍烂Java代码是什么样的）\n|  | 多线程、并发 |[Java并发编程实战](https://book.douban.com/subject/10484692/)<br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）|  |\n||Java 7|[Java程序员修炼之道](https://book.douban.com/subject/24841235/) （详细的介绍Java 7 的新特性）||\n||Java 8|[写给大忙人看的Java SE 8](https://book.douban.com/subject/26274206/)<br>[函数式编程思维](https://book.douban.com/subject/26587213/)||\n||Java虚拟机|[深入理解Java虚拟机](https://book.douban.com/subject/24722612/) （并不是那么难，Java程序员都该看看）||\n||性能优化|[Java性能优化权威指南](https://book.douban.com/subject/25828043/) （后面的章节好像用处不大，前面有些部分还是值得看）||\n|__算法与数据结构__|算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br>|[数据结构与算法分析](https://book.douban.com/subject/1139426/) （涵盖面比较全、示例是Java语言）<br>[算法设计与分析基础](https://book.douban.com/subject/26337727/)（实用主义的典型、偏算法设计<br>[编程珠玑](https://book.douban.com/subject/3227098/)（实践型算法数据||\n|__操作系统__|对Linux/OS的基本认知<br>Linux的常用命令|[鸟哥的Linux私房菜](https://book.douban.com/subject/4889838/)<br>[Linux内核设计与实现(原书第3版)](https://book.douban.com/subject/6097773/)（很精炼的语言描述清楚了内核算法）||\n|__网络__|Http/Https<br>TCP/IP|[图解HTTP](https://book.douban.com/subject/25863515/)<br>[图解TCP/IP](https://book.douban.com/subject/24737674/)|[TCP/IP详解](https://book.douban.com/subject/1088054/)|\n|__Android__|四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）|[UniversalMusicePlayer](https://github.com/googlesamples/android-UniversalMusicPlayer)(通过学习一个音乐播放器的代码能很快了解四大组件)<br>[Android Training官方课程](http://hukai.me/android-training-course-in-chinese/index.html)<br>[Android一些重要知识点解析整理](https://github.com/FX-Max/Point-of-Android)<br>[Android UI/UX库](https://github.com/wasabeef/awesome-android-ui)<br>（各类常用组件及扩展组件的集合）[Picasso](http://square.github.io/picasso/)、[Glide](https://github.com/bumptech/glide)（两个图片加载库）<br>[The Google I/O 2016 Android App](https://github.com/google/iosched)(Google大会官方的App，适合学习各类实现)<br>[Android开发技术前线](http://www.devtf.cn/)（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）|[第三方库集合](https://github.com/wasabeef/awesome-android-libraries)|\n\n#### 软件工程 ####\n\n\n|  知识点  ||链接或书籍|进阶|\n| :------ | :------ | :------ | :------ |\n|__基础工具__|IDE、Git、Maven|[AndroidStudio](https://developer.android.com/studio/index.html)<br>[Git权威指南中文手册](http://iissnan.com/progit/html/zh/ch1_0.html)||\n|__软件质量__|代码整洁<br>代码质量<br>代码重构|[编写可读代码的艺术](https://book.douban.com/subject/10797189/)（来自Google工程师，专注于代码可读性）<br>[代码整洁之道](https://book.douban.com/subject/4199741/)（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br>[重构-改善既有代码的设计](https://book.douban.com/subject/4262627/)（学习改善已有代码）<br>[重构手册](https://book.douban.com/subject/1173730/)（改善代码的实际操作）||\n|__设计模式__|23种常见设计模式|[大话设计模式](https://book.douban.com/subject/2334288/)<br>[Head First设计模式](https://book.douban.com/subject/2243615/)(两本入门级的设计模式书籍)|[设计模式-可复用面向对象软件的基础](https://book.douban.com/subject/1052241/)（设计模式在实际中的应用）|\n|__敏捷开发__||[解析极限编程](https://book.douban.com/subject/1790225/)<br>[敏捷开发的艺术](https://book.douban.com/subject/4037534/)|[敏捷软件开发-原则、模式与实践](https://book.douban.com/subject/5348122/)|\n|__专业开发__|序员职业素养<br>更高效、更实效|[程序员的是职业素养](https://book.douban.com/subject/11614538/)<br>[程序员修炼之道-从小工到专家](https://book.douban.com/subject/5387402/)||\n|__思考人生__||[黑客与画家](https://book.douban.com/subject/6021440/)(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)||\n\n\n#### 鸣谢 ####\n\n[一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本](https://www.diycode.cc/topics/122)\n <br>\n[另一份 Android 开发学习路线图](https://www.diycode.cc/topics/117)\n","slug":"android-study-path","published":1,"updated":"2018-02-05T02:30:28.607Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ey003t2sivnnulznb9","content":"<h4 id=\"程序设计\"><a href=\"#程序设计\" class=\"headerlink\" title=\"程序设计\"></a>程序设计</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>java</strong></td>\n<td style=\"text-align:left\">基本语法(如继承、异常、引用、泛型等)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25762168/\" target=\"_blank\" rel=\"external\">Java核心技术 卷I</a>（适合入门）</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/3360807/\" target=\"_blank\" rel=\"external\">Effective Java中文版</a>（如何写好的Java代码）<br><a href=\"https://book.douban.com/subject/5362860/\" target=\"_blank\" rel=\"external\">Java解惑</a>（介绍烂Java代码是什么样的）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">多线程、并发</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"external\">Java并发编程实战</a><br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 7</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24841235/\" target=\"_blank\" rel=\"external\">Java程序员修炼之道</a> （详细的介绍Java 7 的新特性）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 8</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/26274206/\" target=\"_blank\" rel=\"external\">写给大忙人看的Java SE 8</a><br><a href=\"https://book.douban.com/subject/26587213/\" target=\"_blank\" rel=\"external\">函数式编程思维</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java虚拟机</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24722612/\" target=\"_blank\" rel=\"external\">深入理解Java虚拟机</a> （并不是那么难，Java程序员都该看看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">性能优化</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25828043/\" target=\"_blank\" rel=\"external\">Java性能优化权威指南</a> （后面的章节好像用处不大，前面有些部分还是值得看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>算法与数据结构</strong></td>\n<td style=\"text-align:left\">算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"external\">数据结构与算法分析</a> （涵盖面比较全、示例是Java语言）<br><a href=\"https://book.douban.com/subject/26337727/\" target=\"_blank\" rel=\"external\">算法设计与分析基础</a>（实用主义的典型、偏算法设计<br><a href=\"https://book.douban.com/subject/3227098/\" target=\"_blank\" rel=\"external\">编程珠玑</a>（实践型算法数据</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>操作系统</strong></td>\n<td style=\"text-align:left\">对Linux/OS的基本认知<br>Linux的常用命令</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/4889838/\" target=\"_blank\" rel=\"external\">鸟哥的Linux私房菜</a><br><a href=\"https://book.douban.com/subject/6097773/\" target=\"_blank\" rel=\"external\">Linux内核设计与实现(原书第3版)</a>（很精炼的语言描述清楚了内核算法）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>网络</strong></td>\n<td style=\"text-align:left\">Http/Https<br>TCP/IP</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25863515/\" target=\"_blank\" rel=\"external\">图解HTTP</a><br><a href=\"https://book.douban.com/subject/24737674/\" target=\"_blank\" rel=\"external\">图解TCP/IP</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"external\">TCP/IP详解</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Android</strong></td>\n<td style=\"text-align:left\">四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/googlesamples/android-UniversalMusicPlayer\" target=\"_blank\" rel=\"external\">UniversalMusicePlayer</a>(通过学习一个音乐播放器的代码能很快了解四大组件)<br><a href=\"http://hukai.me/android-training-course-in-chinese/index.html\" target=\"_blank\" rel=\"external\">Android Training官方课程</a><br><a href=\"https://github.com/FX-Max/Point-of-Android\" target=\"_blank\" rel=\"external\">Android一些重要知识点解析整理</a><br><a href=\"https://github.com/wasabeef/awesome-android-ui\" target=\"_blank\" rel=\"external\">Android UI/UX库</a><br>（各类常用组件及扩展组件的集合）<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"external\">Picasso</a>、<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">Glide</a>（两个图片加载库）<br><a href=\"https://github.com/google/iosched\" target=\"_blank\" rel=\"external\">The Google I/O 2016 Android App</a>(Google大会官方的App，适合学习各类实现)<br><a href=\"http://www.devtf.cn/\" target=\"_blank\" rel=\"external\">Android开发技术前线</a>（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/wasabeef/awesome-android-libraries\" target=\"_blank\" rel=\"external\">第三方库集合</a></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"软件工程\"><a href=\"#软件工程\" class=\"headerlink\" title=\"软件工程\"></a>软件工程</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础工具</strong></td>\n<td style=\"text-align:left\">IDE、Git、Maven</td>\n<td style=\"text-align:left\"><a href=\"https://developer.android.com/studio/index.html\" target=\"_blank\" rel=\"external\">AndroidStudio</a><br><a href=\"http://iissnan.com/progit/html/zh/ch1_0.html\" target=\"_blank\" rel=\"external\">Git权威指南中文手册</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>软件质量</strong></td>\n<td style=\"text-align:left\">代码整洁<br>代码质量<br>代码重构</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10797189/\" target=\"_blank\" rel=\"external\">编写可读代码的艺术</a>（来自Google工程师，专注于代码可读性）<br><a href=\"https://book.douban.com/subject/4199741/\" target=\"_blank\" rel=\"external\">代码整洁之道</a>（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br><a href=\"https://book.douban.com/subject/4262627/\" target=\"_blank\" rel=\"external\">重构-改善既有代码的设计</a>（学习改善已有代码）<br><a href=\"https://book.douban.com/subject/1173730/\" target=\"_blank\" rel=\"external\">重构手册</a>（改善代码的实际操作）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>设计模式</strong></td>\n<td style=\"text-align:left\">23种常见设计模式</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/2334288/\" target=\"_blank\" rel=\"external\">大话设计模式</a><br><a href=\"https://book.douban.com/subject/2243615/\" target=\"_blank\" rel=\"external\">Head First设计模式</a>(两本入门级的设计模式书籍)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1052241/\" target=\"_blank\" rel=\"external\">设计模式-可复用面向对象软件的基础</a>（设计模式在实际中的应用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>敏捷开发</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1790225/\" target=\"_blank\" rel=\"external\">解析极限编程</a><br><a href=\"https://book.douban.com/subject/4037534/\" target=\"_blank\" rel=\"external\">敏捷开发的艺术</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/5348122/\" target=\"_blank\" rel=\"external\">敏捷软件开发-原则、模式与实践</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>专业开发</strong></td>\n<td style=\"text-align:left\">序员职业素养<br>更高效、更实效</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/11614538/\" target=\"_blank\" rel=\"external\">程序员的是职业素养</a><br><a href=\"https://book.douban.com/subject/5387402/\" target=\"_blank\" rel=\"external\">程序员修炼之道-从小工到专家</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>思考人生</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/6021440/\" target=\"_blank\" rel=\"external\">黑客与画家</a>(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://www.diycode.cc/topics/122\" target=\"_blank\" rel=\"external\">一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本</a><br> <br><br><a href=\"https://www.diycode.cc/topics/117\" target=\"_blank\" rel=\"external\">另一份 Android 开发学习路线图</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"程序设计\"><a href=\"#程序设计\" class=\"headerlink\" title=\"程序设计\"></a>程序设计</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>java</strong></td>\n<td style=\"text-align:left\">基本语法(如继承、异常、引用、泛型等)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25762168/\" target=\"_blank\" rel=\"external\">Java核心技术 卷I</a>（适合入门）</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/3360807/\" target=\"_blank\" rel=\"external\">Effective Java中文版</a>（如何写好的Java代码）<br><a href=\"https://book.douban.com/subject/5362860/\" target=\"_blank\" rel=\"external\">Java解惑</a>（介绍烂Java代码是什么样的）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">多线程、并发</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"external\">Java并发编程实战</a><br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 7</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24841235/\" target=\"_blank\" rel=\"external\">Java程序员修炼之道</a> （详细的介绍Java 7 的新特性）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java 8</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/26274206/\" target=\"_blank\" rel=\"external\">写给大忙人看的Java SE 8</a><br><a href=\"https://book.douban.com/subject/26587213/\" target=\"_blank\" rel=\"external\">函数式编程思维</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Java虚拟机</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/24722612/\" target=\"_blank\" rel=\"external\">深入理解Java虚拟机</a> （并不是那么难，Java程序员都该看看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">性能优化</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25828043/\" target=\"_blank\" rel=\"external\">Java性能优化权威指南</a> （后面的章节好像用处不大，前面有些部分还是值得看）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>算法与数据结构</strong></td>\n<td style=\"text-align:left\">算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1139426/\" target=\"_blank\" rel=\"external\">数据结构与算法分析</a> （涵盖面比较全、示例是Java语言）<br><a href=\"https://book.douban.com/subject/26337727/\" target=\"_blank\" rel=\"external\">算法设计与分析基础</a>（实用主义的典型、偏算法设计<br><a href=\"https://book.douban.com/subject/3227098/\" target=\"_blank\" rel=\"external\">编程珠玑</a>（实践型算法数据</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>操作系统</strong></td>\n<td style=\"text-align:left\">对Linux/OS的基本认知<br>Linux的常用命令</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/4889838/\" target=\"_blank\" rel=\"external\">鸟哥的Linux私房菜</a><br><a href=\"https://book.douban.com/subject/6097773/\" target=\"_blank\" rel=\"external\">Linux内核设计与实现(原书第3版)</a>（很精炼的语言描述清楚了内核算法）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>网络</strong></td>\n<td style=\"text-align:left\">Http/Https<br>TCP/IP</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/25863515/\" target=\"_blank\" rel=\"external\">图解HTTP</a><br><a href=\"https://book.douban.com/subject/24737674/\" target=\"_blank\" rel=\"external\">图解TCP/IP</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1088054/\" target=\"_blank\" rel=\"external\">TCP/IP详解</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Android</strong></td>\n<td style=\"text-align:left\">四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/googlesamples/android-UniversalMusicPlayer\" target=\"_blank\" rel=\"external\">UniversalMusicePlayer</a>(通过学习一个音乐播放器的代码能很快了解四大组件)<br><a href=\"http://hukai.me/android-training-course-in-chinese/index.html\" target=\"_blank\" rel=\"external\">Android Training官方课程</a><br><a href=\"https://github.com/FX-Max/Point-of-Android\" target=\"_blank\" rel=\"external\">Android一些重要知识点解析整理</a><br><a href=\"https://github.com/wasabeef/awesome-android-ui\" target=\"_blank\" rel=\"external\">Android UI/UX库</a><br>（各类常用组件及扩展组件的集合）<a href=\"http://square.github.io/picasso/\" target=\"_blank\" rel=\"external\">Picasso</a>、<a href=\"https://github.com/bumptech/glide\" target=\"_blank\" rel=\"external\">Glide</a>（两个图片加载库）<br><a href=\"https://github.com/google/iosched\" target=\"_blank\" rel=\"external\">The Google I/O 2016 Android App</a>(Google大会官方的App，适合学习各类实现)<br><a href=\"http://www.devtf.cn/\" target=\"_blank\" rel=\"external\">Android开发技术前线</a>（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）</td>\n<td style=\"text-align:left\"><a href=\"https://github.com/wasabeef/awesome-android-libraries\" target=\"_blank\" rel=\"external\">第三方库集合</a></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"软件工程\"><a href=\"#软件工程\" class=\"headerlink\" title=\"软件工程\"></a>软件工程</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">知识点</th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">链接或书籍</th>\n<th style=\"text-align:left\">进阶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>基础工具</strong></td>\n<td style=\"text-align:left\">IDE、Git、Maven</td>\n<td style=\"text-align:left\"><a href=\"https://developer.android.com/studio/index.html\" target=\"_blank\" rel=\"external\">AndroidStudio</a><br><a href=\"http://iissnan.com/progit/html/zh/ch1_0.html\" target=\"_blank\" rel=\"external\">Git权威指南中文手册</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>软件质量</strong></td>\n<td style=\"text-align:left\">代码整洁<br>代码质量<br>代码重构</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/10797189/\" target=\"_blank\" rel=\"external\">编写可读代码的艺术</a>（来自Google工程师，专注于代码可读性）<br><a href=\"https://book.douban.com/subject/4199741/\" target=\"_blank\" rel=\"external\">代码整洁之道</a>（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br><a href=\"https://book.douban.com/subject/4262627/\" target=\"_blank\" rel=\"external\">重构-改善既有代码的设计</a>（学习改善已有代码）<br><a href=\"https://book.douban.com/subject/1173730/\" target=\"_blank\" rel=\"external\">重构手册</a>（改善代码的实际操作）</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>设计模式</strong></td>\n<td style=\"text-align:left\">23种常见设计模式</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/2334288/\" target=\"_blank\" rel=\"external\">大话设计模式</a><br><a href=\"https://book.douban.com/subject/2243615/\" target=\"_blank\" rel=\"external\">Head First设计模式</a>(两本入门级的设计模式书籍)</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1052241/\" target=\"_blank\" rel=\"external\">设计模式-可复用面向对象软件的基础</a>（设计模式在实际中的应用）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>敏捷开发</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/1790225/\" target=\"_blank\" rel=\"external\">解析极限编程</a><br><a href=\"https://book.douban.com/subject/4037534/\" target=\"_blank\" rel=\"external\">敏捷开发的艺术</a></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/5348122/\" target=\"_blank\" rel=\"external\">敏捷软件开发-原则、模式与实践</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>专业开发</strong></td>\n<td style=\"text-align:left\">序员职业素养<br>更高效、更实效</td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/11614538/\" target=\"_blank\" rel=\"external\">程序员的是职业素养</a><br><a href=\"https://book.douban.com/subject/5387402/\" target=\"_blank\" rel=\"external\">程序员修炼之道-从小工到专家</a></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>思考人生</strong></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><a href=\"https://book.douban.com/subject/6021440/\" target=\"_blank\" rel=\"external\">黑客与画家</a>(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h4><p><a href=\"https://www.diycode.cc/topics/122\" target=\"_blank\" rel=\"external\">一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本</a><br> <br><br><a href=\"https://www.diycode.cc/topics/117\" target=\"_blank\" rel=\"external\">另一份 Android 开发学习路线图</a></p>\n"},{"layout":"post","title":"AndroidSDK开发注意事项","date":"2017-05-09T00:00:00.000Z","_content":"\n \n\n#### SDK的实现目标  ####\n \n- 简洁易用\n- 稳定\n- 高效\n\n不应该对宿主应用有过多的代码侵入<br>\n不应该有复杂频繁的接入工作[一行代码接入]<br>\n</br>\n在不影响宿主稳定的前提下，足够高效；<br>\n更少的内存占用；<br>\n更少的电量消耗；<br>\n更少的流量消耗；<br>\n \n\n#### 架构设计 ####\n\n- 模块化开发\n\t>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合\n- 组件化开发\n\t>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK\n- 插件化开发\n\t>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。\n- SDK初始化\n- 云更新控制\n\t>可以通过服务端的云控服务，关闭某些SDK功能。\n- 安全\n\t- appId + appSecret\n\t- 核心逻辑采用C/C++\n\t- 通讯加密\n\t\t- https\n\t\t- 对称加密\n\t\t- 非对称加密\n\t- 设备安全[一些开发者会用虚拟机来刷广告]\n- 减少传输数据的大小\n\t- 如果对传输的数据大小有要求，建议对数据压缩\n\t- 可采用json/xml/protobuf等协议，也可自定义二进制协议\n- 选择支持最低系统版本\n- 权限管理\n\t- 最小权限原则\n\t- 动态权限申请\n- 日志服务\n\t- 日志要在关键位置上打点，记录有效信息\n\t- 上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生\n\t- 要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响\n\n#### API的设计 ####\n\t1.  方法名能够表明其用途\n\t2.  参数的合法性检验\n\t\t- 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n\t\t- 对于私有方法，通过断言的方式来检查参数的合法\n\t\t- 检查构造参数的合法性，以使对象处在统一状态\n\t\t- 如果检查的代价太大，需要综合考量\n\t3. 方法要明确其单一的功能-单一职责原则\n\t4. 方法异常问题\n\t\t>对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n\t5. 方法权限控制\n\t\t>需从安全和业务的角度考虑，方法是公开、非公开、静态\n\t6. 避免过长参数\n\t\t- Builder模式\n\t\t- 通过静态内部类\n\t\t- 将参数封装成对象\n\t\t- 将参数拆解为多个方法\n\t7. 谨慎使用方法重载\n\t8. 谨慎使用变长参数\n\t9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n\t10. 必要时进行保护性拷贝\n\n#### SDK版本管理策略 ####\n\n- 版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号\n\t> V1_0_0_108_170515_alpha\n\t\n\t希腊字母版本号说明：\n\t- alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放\n\t- beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug\n\t- rc：该版本已相当成熟，与正式版相差无几\n\t- release：最终交付或公开发布版本，该版本发布时，以符号R来代替release\n\n\n- 版本号修改规则\n\t- 主版本号：功能模块有较大变化或整体架构发生变化\n\t- 子版本号：功能有一定变化\n\t- 阶段版本号：bug修复或较小变动\n\t- 日期版本号：用于记录修改项目的当前日期\n\t- 希腊字母版本号：标注软件所处的开发阶段\n- API 版本管理\n\t1. 原则上SDK API一旦发布不可变\n\t2. 特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭\n\t3. 优先选择添加新方法并尽量兼容原始方法\n\t4. 需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)\n\n- API 文档\n\t- 分为内部版和公开版\n\t- 与SDK的改变要同步更新\n\n\n\n \n \n ","source":"_posts/2017-05-09-android-develop-sdk-tips.md","raw":"---\nlayout: post\ntitle:  AndroidSDK开发注意事项\ndate:   2017-05-09\ncategories: Android\ntag: android\n---\n\n \n\n#### SDK的实现目标  ####\n \n- 简洁易用\n- 稳定\n- 高效\n\n不应该对宿主应用有过多的代码侵入<br>\n不应该有复杂频繁的接入工作[一行代码接入]<br>\n</br>\n在不影响宿主稳定的前提下，足够高效；<br>\n更少的内存占用；<br>\n更少的电量消耗；<br>\n更少的流量消耗；<br>\n \n\n#### 架构设计 ####\n\n- 模块化开发\n\t>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合\n- 组件化开发\n\t>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK\n- 插件化开发\n\t>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。\n- SDK初始化\n- 云更新控制\n\t>可以通过服务端的云控服务，关闭某些SDK功能。\n- 安全\n\t- appId + appSecret\n\t- 核心逻辑采用C/C++\n\t- 通讯加密\n\t\t- https\n\t\t- 对称加密\n\t\t- 非对称加密\n\t- 设备安全[一些开发者会用虚拟机来刷广告]\n- 减少传输数据的大小\n\t- 如果对传输的数据大小有要求，建议对数据压缩\n\t- 可采用json/xml/protobuf等协议，也可自定义二进制协议\n- 选择支持最低系统版本\n- 权限管理\n\t- 最小权限原则\n\t- 动态权限申请\n- 日志服务\n\t- 日志要在关键位置上打点，记录有效信息\n\t- 上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生\n\t- 要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响\n\n#### API的设计 ####\n\t1.  方法名能够表明其用途\n\t2.  参数的合法性检验\n\t\t- 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n\t\t- 对于私有方法，通过断言的方式来检查参数的合法\n\t\t- 检查构造参数的合法性，以使对象处在统一状态\n\t\t- 如果检查的代价太大，需要综合考量\n\t3. 方法要明确其单一的功能-单一职责原则\n\t4. 方法异常问题\n\t\t>对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n\t5. 方法权限控制\n\t\t>需从安全和业务的角度考虑，方法是公开、非公开、静态\n\t6. 避免过长参数\n\t\t- Builder模式\n\t\t- 通过静态内部类\n\t\t- 将参数封装成对象\n\t\t- 将参数拆解为多个方法\n\t7. 谨慎使用方法重载\n\t8. 谨慎使用变长参数\n\t9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n\t10. 必要时进行保护性拷贝\n\n#### SDK版本管理策略 ####\n\n- 版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号\n\t> V1_0_0_108_170515_alpha\n\t\n\t希腊字母版本号说明：\n\t- alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放\n\t- beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug\n\t- rc：该版本已相当成熟，与正式版相差无几\n\t- release：最终交付或公开发布版本，该版本发布时，以符号R来代替release\n\n\n- 版本号修改规则\n\t- 主版本号：功能模块有较大变化或整体架构发生变化\n\t- 子版本号：功能有一定变化\n\t- 阶段版本号：bug修复或较小变动\n\t- 日期版本号：用于记录修改项目的当前日期\n\t- 希腊字母版本号：标注软件所处的开发阶段\n- API 版本管理\n\t1. 原则上SDK API一旦发布不可变\n\t2. 特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭\n\t3. 优先选择添加新方法并尽量兼容原始方法\n\t4. 需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)\n\n- API 文档\n\t- 分为内部版和公开版\n\t- 与SDK的改变要同步更新\n\n\n\n \n \n ","slug":"android-develop-sdk-tips","published":1,"updated":"2017-11-16T08:34:26.322Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1f2003w2siv2vrjuvsm","content":"<h4 id=\"SDK的实现目标\"><a href=\"#SDK的实现目标\" class=\"headerlink\" title=\"SDK的实现目标\"></a>SDK的实现目标</h4><ul>\n<li>简洁易用</li>\n<li>稳定</li>\n<li>高效</li>\n</ul>\n<p>不应该对宿主应用有过多的代码侵入<br><br>不应该有复杂频繁的接入工作[一行代码接入]<br><br><br><br>在不影响宿主稳定的前提下，足够高效；<br><br>更少的内存占用；<br><br>更少的电量消耗；<br><br>更少的流量消耗；<br></p>\n<h4 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h4><ul>\n<li>模块化开发<blockquote>\n<p>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合</p>\n</blockquote>\n</li>\n<li>组件化开发<blockquote>\n<p>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK</p>\n</blockquote>\n</li>\n<li>插件化开发<blockquote>\n<p>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。</p>\n</blockquote>\n</li>\n<li>SDK初始化</li>\n<li>云更新控制<blockquote>\n<p>可以通过服务端的云控服务，关闭某些SDK功能。</p>\n</blockquote>\n</li>\n<li>安全<ul>\n<li>appId + appSecret</li>\n<li>核心逻辑采用C/C++</li>\n<li>通讯加密<ul>\n<li>https</li>\n<li>对称加密</li>\n<li>非对称加密</li>\n</ul>\n</li>\n<li>设备安全[一些开发者会用虚拟机来刷广告]</li>\n</ul>\n</li>\n<li>减少传输数据的大小<ul>\n<li>如果对传输的数据大小有要求，建议对数据压缩</li>\n<li>可采用json/xml/protobuf等协议，也可自定义二进制协议</li>\n</ul>\n</li>\n<li>选择支持最低系统版本</li>\n<li>权限管理<ul>\n<li>最小权限原则</li>\n<li>动态权限申请</li>\n</ul>\n</li>\n<li>日志服务<ul>\n<li>日志要在关键位置上打点，记录有效信息</li>\n<li>上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生</li>\n<li>要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"API的设计\"><a href=\"#API的设计\" class=\"headerlink\" title=\"API的设计\"></a>API的设计</h4><pre><code>1.  方法名能够表明其用途\n2.  参数的合法性检验\n    - 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n    - 对于私有方法，通过断言的方式来检查参数的合法\n    - 检查构造参数的合法性，以使对象处在统一状态\n    - 如果检查的代价太大，需要综合考量\n3. 方法要明确其单一的功能-单一职责原则\n4. 方法异常问题\n    &gt;对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n5. 方法权限控制\n    &gt;需从安全和业务的角度考虑，方法是公开、非公开、静态\n6. 避免过长参数\n    - Builder模式\n    - 通过静态内部类\n    - 将参数封装成对象\n    - 将参数拆解为多个方法\n7. 谨慎使用方法重载\n8. 谨慎使用变长参数\n9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n10. 必要时进行保护性拷贝\n</code></pre><h4 id=\"SDK版本管理策略\"><a href=\"#SDK版本管理策略\" class=\"headerlink\" title=\"SDK版本管理策略\"></a>SDK版本管理策略</h4><ul>\n<li><p>版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号</p>\n<blockquote>\n<p>V1_0_0_108_170515_alpha</p>\n</blockquote>\n<p>  希腊字母版本号说明：</p>\n<ul>\n<li>alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放</li>\n<li>beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug</li>\n<li>rc：该版本已相当成熟，与正式版相差无几</li>\n<li>release：最终交付或公开发布版本，该版本发布时，以符号R来代替release</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>版本号修改规则<ul>\n<li>主版本号：功能模块有较大变化或整体架构发生变化</li>\n<li>子版本号：功能有一定变化</li>\n<li>阶段版本号：bug修复或较小变动</li>\n<li>日期版本号：用于记录修改项目的当前日期</li>\n<li>希腊字母版本号：标注软件所处的开发阶段</li>\n</ul>\n</li>\n<li><p>API 版本管理</p>\n<ol>\n<li>原则上SDK API一旦发布不可变</li>\n<li>特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭</li>\n<li>优先选择添加新方法并尽量兼容原始方法</li>\n<li>需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)</li>\n</ol>\n</li>\n<li><p>API 文档</p>\n<ul>\n<li>分为内部版和公开版</li>\n<li>与SDK的改变要同步更新</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"SDK的实现目标\"><a href=\"#SDK的实现目标\" class=\"headerlink\" title=\"SDK的实现目标\"></a>SDK的实现目标</h4><ul>\n<li>简洁易用</li>\n<li>稳定</li>\n<li>高效</li>\n</ul>\n<p>不应该对宿主应用有过多的代码侵入<br><br>不应该有复杂频繁的接入工作[一行代码接入]<br><br><br><br>在不影响宿主稳定的前提下，足够高效；<br><br>更少的内存占用；<br><br>更少的电量消耗；<br><br>更少的流量消耗；<br></p>\n<h4 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h4><ul>\n<li>模块化开发<blockquote>\n<p>根据单一职责将系统拆分为不同的小模块<br>模块间通过协议或接口进行通信，以减少耦合</p>\n</blockquote>\n</li>\n<li>组件化开发<blockquote>\n<p>将整个项目划分为多个模块，几个模块或单个模块作为一个组件，开发过程中可分别开发，发布时通过依赖，将组件合并成完整的SDK</p>\n</blockquote>\n</li>\n<li>插件化开发<blockquote>\n<p>SDK 分为宿主和插件。宿主向开发者提供必要的服务接口，并提供自定义的插件加载器，可以热更新，解决方法数64k问题。</p>\n</blockquote>\n</li>\n<li>SDK初始化</li>\n<li>云更新控制<blockquote>\n<p>可以通过服务端的云控服务，关闭某些SDK功能。</p>\n</blockquote>\n</li>\n<li>安全<ul>\n<li>appId + appSecret</li>\n<li>核心逻辑采用C/C++</li>\n<li>通讯加密<ul>\n<li>https</li>\n<li>对称加密</li>\n<li>非对称加密</li>\n</ul>\n</li>\n<li>设备安全[一些开发者会用虚拟机来刷广告]</li>\n</ul>\n</li>\n<li>减少传输数据的大小<ul>\n<li>如果对传输的数据大小有要求，建议对数据压缩</li>\n<li>可采用json/xml/protobuf等协议，也可自定义二进制协议</li>\n</ul>\n</li>\n<li>选择支持最低系统版本</li>\n<li>权限管理<ul>\n<li>最小权限原则</li>\n<li>动态权限申请</li>\n</ul>\n</li>\n<li>日志服务<ul>\n<li>日志要在关键位置上打点，记录有效信息</li>\n<li>上传信息要保证最大的可靠性，不能发生上传失败，抛弃日志的情况发生</li>\n<li>要考虑日志IO带来的开销，不能对正常的流程有过多的性能的影响</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"API的设计\"><a href=\"#API的设计\" class=\"headerlink\" title=\"API的设计\"></a>API的设计</h4><pre><code>1.  方法名能够表明其用途\n2.  参数的合法性检验\n    - 对于公开方法，通过显式检查，抛出异常的方式，并且使用javadoc的@throw来说明抛出异常的原因\n    - 对于私有方法，通过断言的方式来检查参数的合法\n    - 检查构造参数的合法性，以使对象处在统一状态\n    - 如果检查的代价太大，需要综合考量\n3. 方法要明确其单一的功能-单一职责原则\n4. 方法异常问题\n    &gt;对于需要暴露给开发者的方法，要及时地抛出可查异常，来帮助开发者在编译阶段发现的问题，对于运行时异常，必须保证不能导致宿主程序出问题\n5. 方法权限控制\n    &gt;需从安全和业务的角度考虑，方法是公开、非公开、静态\n6. 避免过长参数\n    - Builder模式\n    - 通过静态内部类\n    - 将参数封装成对象\n    - 将参数拆解为多个方法\n7. 谨慎使用方法重载\n8. 谨慎使用变长参数\n9. 避免方法直接返回null，对于返回集合或list，不要返回null，返回长度为0的容器。\n10. 必要时进行保护性拷贝\n</code></pre><h4 id=\"SDK版本管理策略\"><a href=\"#SDK版本管理策略\" class=\"headerlink\" title=\"SDK版本管理策略\"></a>SDK版本管理策略</h4><ul>\n<li><p>版本号命名：V + 主版本号 + 子版本号 + 阶段版本号 + 日期版本号 + 希腊字母版本号</p>\n<blockquote>\n<p>V1_0_0_108_170515_alpha</p>\n</blockquote>\n<p>  希腊字母版本号说明：</p>\n<ul>\n<li>alpha：内部测试版，表示该阶段主要是以实现功能为主，通常只在内部流通而不对外开放</li>\n<li>beat：外部测试版，相对alpha版已有很大改进，需要进一步测试和检查以消除bug</li>\n<li>rc：该版本已相当成熟，与正式版相差无几</li>\n<li>release：最终交付或公开发布版本，该版本发布时，以符号R来代替release</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>版本号修改规则<ul>\n<li>主版本号：功能模块有较大变化或整体架构发生变化</li>\n<li>子版本号：功能有一定变化</li>\n<li>阶段版本号：bug修复或较小变动</li>\n<li>日期版本号：用于记录修改项目的当前日期</li>\n<li>希腊字母版本号：标注软件所处的开发阶段</li>\n</ul>\n</li>\n<li><p>API 版本管理</p>\n<ol>\n<li>原则上SDK API一旦发布不可变</li>\n<li>特殊情况下变更，要遵守开闭原则即对扩展开放对修改关闭</li>\n<li>优先选择添加新方法并尽量兼容原始方法</li>\n<li>需要废弃某些方法是，使用@deprecated标识，并给出替代方案和废弃时间(通常是版本号)</li>\n</ol>\n</li>\n<li><p>API 文档</p>\n<ul>\n<li>分为内部版和公开版</li>\n<li>与SDK的改变要同步更新</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"Android系统服务：CaptioningManager","date":"2017-05-18T00:00:00.000Z","_content":" \n#### CaptioningManager是什么 ####\n \n- 看名字：字幕管理\n- [Android开发无障碍指南](http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm):\n\t>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。\n\n#### 设备如何设置 ####\n\n[google 官方说明](https://support.google.com/accessibility/android/answer/6006554)\n\n **字幕** \n\n您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。\n\n开启字幕功能<br>\n打开设备的“设置”应用<br>\n点按`无障碍`，然后点按`字幕`<br>\n点按顶部的`开启/关闭`开关<br> \n<br> \n**更改字幕设置**<br>\n开启字幕功能后，您可以在`设置` > `无障碍` > `字幕`中调整以下设置。<br>\n \n- 语言：选择您想要以何种语言显示字幕 \n- 文字大小：选择字幕文字大小 \n- 字幕样式：为字幕文字和背景选择样式和颜色 \n <br>\n\n您的字幕设置可能不适用于某些应用。<br>\n \n#### 官方文档 ####\n\n[简介](https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn)\n\n官方文档称之为：隐藏式字幕。4.4版本释出。<br>\n\n现在播放HTTP Live Steam(HLS)视频时，`VideoView`支持`WebVTT`字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br>\n您也可以使用`addSubtitleSource()`方法为`VideoView`提供`WebVTT`字幕跟踪。此方法接受一个`InputStream`,其携带字幕数据和指定该字幕数据格式的`MediaFormat`对象，您可以使用`createSubtitleFormat()`指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br>\n如果您不使用`VideoView`显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的`CaptioningManager API`允许您查询用户的隐藏式字幕首选项，包括`CaptioningManager.CaptionStyle`定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个`CaptioningManager.CaptioningChangeListener`实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br>\n\n[WebVTT 及 HTML5 <track> 元素简介](https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/)<br>\n[WebVTT与srt格式转换](https://www.zhihu.com/question/29789259)\n\n\n#### 题外话：视频弹幕 ####\n\n\n[基础原理](http://blog.csdn.net/zhangphil/article/details/52021055)<br>\n\n[简单封装](https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java)<br>\n\n[成熟的B站](https://github.com/Bilibili/DanmakuFlameMaster)<br>","source":"_posts/2017-05-18-android-system-service-CaptioningManager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：CaptioningManager\ndate:   2017-05-18\ncategories: Android System Framework\ntags: android\n---\n \n#### CaptioningManager是什么 ####\n \n- 看名字：字幕管理\n- [Android开发无障碍指南](http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm):\n\t>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。\n\n#### 设备如何设置 ####\n\n[google 官方说明](https://support.google.com/accessibility/android/answer/6006554)\n\n **字幕** \n\n您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。\n\n开启字幕功能<br>\n打开设备的“设置”应用<br>\n点按`无障碍`，然后点按`字幕`<br>\n点按顶部的`开启/关闭`开关<br> \n<br> \n**更改字幕设置**<br>\n开启字幕功能后，您可以在`设置` > `无障碍` > `字幕`中调整以下设置。<br>\n \n- 语言：选择您想要以何种语言显示字幕 \n- 文字大小：选择字幕文字大小 \n- 字幕样式：为字幕文字和背景选择样式和颜色 \n <br>\n\n您的字幕设置可能不适用于某些应用。<br>\n \n#### 官方文档 ####\n\n[简介](https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn)\n\n官方文档称之为：隐藏式字幕。4.4版本释出。<br>\n\n现在播放HTTP Live Steam(HLS)视频时，`VideoView`支持`WebVTT`字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br>\n您也可以使用`addSubtitleSource()`方法为`VideoView`提供`WebVTT`字幕跟踪。此方法接受一个`InputStream`,其携带字幕数据和指定该字幕数据格式的`MediaFormat`对象，您可以使用`createSubtitleFormat()`指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br>\n如果您不使用`VideoView`显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的`CaptioningManager API`允许您查询用户的隐藏式字幕首选项，包括`CaptioningManager.CaptionStyle`定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个`CaptioningManager.CaptioningChangeListener`实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br>\n\n[WebVTT 及 HTML5 <track> 元素简介](https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/)<br>\n[WebVTT与srt格式转换](https://www.zhihu.com/question/29789259)\n\n\n#### 题外话：视频弹幕 ####\n\n\n[基础原理](http://blog.csdn.net/zhangphil/article/details/52021055)<br>\n\n[简单封装](https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java)<br>\n\n[成熟的B站](https://github.com/Bilibili/DanmakuFlameMaster)<br>","slug":"android-system-service-CaptioningManager","published":1,"updated":"2017-08-17T02:47:45.951Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1f5003z2sivnwwywf8g","content":"<h4 id=\"CaptioningManager是什么\"><a href=\"#CaptioningManager是什么\" class=\"headerlink\" title=\"CaptioningManager是什么\"></a>CaptioningManager是什么</h4><ul>\n<li>看名字：字幕管理</li>\n<li><a href=\"http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm\" target=\"_blank\" rel=\"external\">Android开发无障碍指南</a>:<blockquote>\n<p>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"设备如何设置\"><a href=\"#设备如何设置\" class=\"headerlink\" title=\"设备如何设置\"></a>设备如何设置</h4><p><a href=\"https://support.google.com/accessibility/android/answer/6006554\" target=\"_blank\" rel=\"external\">google 官方说明</a></p>\n<p> <strong>字幕</strong> </p>\n<p>您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。</p>\n<p>开启字幕功能<br><br>打开设备的“设置”应用<br><br>点按<code>无障碍</code>，然后点按<code>字幕</code><br><br>点按顶部的<code>开启/关闭</code>开关<br><br><br><br><strong>更改字幕设置</strong><br><br>开启字幕功能后，您可以在<code>设置</code> &gt; <code>无障碍</code> &gt; <code>字幕</code>中调整以下设置。<br></p>\n<ul>\n<li>语言：选择您想要以何种语言显示字幕 </li>\n<li>文字大小：选择字幕文字大小 </li>\n<li>字幕样式：为字幕文字和背景选择样式和颜色<br><br></li>\n</ul>\n<p>您的字幕设置可能不适用于某些应用。<br></p>\n<h4 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h4><p><a href=\"https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn\" target=\"_blank\" rel=\"external\">简介</a></p>\n<p>官方文档称之为：隐藏式字幕。4.4版本释出。<br></p>\n<p>现在播放HTTP Live Steam(HLS)视频时，<code>VideoView</code>支持<code>WebVTT</code>字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br><br>您也可以使用<code>addSubtitleSource()</code>方法为<code>VideoView</code>提供<code>WebVTT</code>字幕跟踪。此方法接受一个<code>InputStream</code>,其携带字幕数据和指定该字幕数据格式的<code>MediaFormat</code>对象，您可以使用<code>createSubtitleFormat()</code>指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br><br>如果您不使用<code>VideoView</code>显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的<code>CaptioningManager API</code>允许您查询用户的隐藏式字幕首选项，包括<code>CaptioningManager.CaptionStyle</code>定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个<code>CaptioningManager.CaptioningChangeListener</code>实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br></p>\n<p><a href=\"https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/\" target=\"_blank\" rel=\"external\">WebVTT 及 HTML5 <track> 元素简介</a><br><br><a href=\"https://www.zhihu.com/question/29789259\" target=\"_blank\" rel=\"external\">WebVTT与srt格式转换</a></p>\n<h4 id=\"题外话：视频弹幕\"><a href=\"#题外话：视频弹幕\" class=\"headerlink\" title=\"题外话：视频弹幕\"></a>题外话：视频弹幕</h4><p><a href=\"http://blog.csdn.net/zhangphil/article/details/52021055\" target=\"_blank\" rel=\"external\">基础原理</a><br></p>\n<p><a href=\"https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java\" target=\"_blank\" rel=\"external\">简单封装</a><br></p>\n<p><a href=\"https://github.com/Bilibili/DanmakuFlameMaster\" target=\"_blank\" rel=\"external\">成熟的B站</a><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"CaptioningManager是什么\"><a href=\"#CaptioningManager是什么\" class=\"headerlink\" title=\"CaptioningManager是什么\"></a>CaptioningManager是什么</h4><ul>\n<li>看名字：字幕管理</li>\n<li><a href=\"http://informationaccessibilityassociation.github.io/androidAccessibility/checklist.htm\" target=\"_blank\" rel=\"external\">Android开发无障碍指南</a>:<blockquote>\n<p>如果应用程序提供视频播放，必须为聋人和重听用户提供字幕和注释来帮助他们理解。视频播放控件必须明确说明字幕是否可用，并提供简单的方式启用字幕。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"设备如何设置\"><a href=\"#设备如何设置\" class=\"headerlink\" title=\"设备如何设置\"></a>设备如何设置</h4><p><a href=\"https://support.google.com/accessibility/android/answer/6006554\" target=\"_blank\" rel=\"external\">google 官方说明</a></p>\n<p> <strong>字幕</strong> </p>\n<p>您可以为设备开启字幕功能以及为字幕选择所需选项（语言、文字和样式）。</p>\n<p>开启字幕功能<br><br>打开设备的“设置”应用<br><br>点按<code>无障碍</code>，然后点按<code>字幕</code><br><br>点按顶部的<code>开启/关闭</code>开关<br><br><br><br><strong>更改字幕设置</strong><br><br>开启字幕功能后，您可以在<code>设置</code> &gt; <code>无障碍</code> &gt; <code>字幕</code>中调整以下设置。<br></p>\n<ul>\n<li>语言：选择您想要以何种语言显示字幕 </li>\n<li>文字大小：选择字幕文字大小 </li>\n<li>字幕样式：为字幕文字和背景选择样式和颜色<br><br></li>\n</ul>\n<p>您的字幕设置可能不适用于某些应用。<br></p>\n<h4 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h4><p><a href=\"https://developer.android.google.cn/about/versions/android-4.4.html?hl=zh-cn\" target=\"_blank\" rel=\"external\">简介</a></p>\n<p>官方文档称之为：隐藏式字幕。4.4版本释出。<br></p>\n<p>现在播放HTTP Live Steam(HLS)视频时，<code>VideoView</code>支持<code>WebVTT</code>字幕跟踪，根据用户在系统设置中定义的隐藏式字幕首选项显示字幕跟踪。<br><br>您也可以使用<code>addSubtitleSource()</code>方法为<code>VideoView</code>提供<code>WebVTT</code>字幕跟踪。此方法接受一个<code>InputStream</code>,其携带字幕数据和指定该字幕数据格式的<code>MediaFormat</code>对象，您可以使用<code>createSubtitleFormat()</code>指定该对象。这些字幕也会按照用户的首选项显示在视频上。<br><br>如果您不使用<code>VideoView</code>显示您的视频内容，则应尽可能使您的字幕叠加层与用户的隐藏式字幕首选项匹配。新的<code>CaptioningManager API</code>允许您查询用户的隐藏式字幕首选项，包括<code>CaptioningManager.CaptionStyle</code>定义的样式，如字体和颜色。如果用户在视频已开始后调整部分首选项，您应侦听首选项的变化，方法是注册一个<code>CaptioningManager.CaptioningChangeListener</code>实例以在任意首选项发生变化时接收回调，然后根据需要更新您的字幕。<br></p>\n<p><a href=\"https://dev.opera.com/articles/zh-cn/an-introduction-to-webvtt-and-track/\" target=\"_blank\" rel=\"external\">WebVTT 及 HTML5 <track> 元素简介</a><br><br><a href=\"https://www.zhihu.com/question/29789259\" target=\"_blank\" rel=\"external\">WebVTT与srt格式转换</a></p>\n<h4 id=\"题外话：视频弹幕\"><a href=\"#题外话：视频弹幕\" class=\"headerlink\" title=\"题外话：视频弹幕\"></a>题外话：视频弹幕</h4><p><a href=\"http://blog.csdn.net/zhangphil/article/details/52021055\" target=\"_blank\" rel=\"external\">基础原理</a><br></p>\n<p><a href=\"https://github.com/linsea/OpenDanmaku/blob/master/opendanmaku/src/main/java/com/opendanmaku/DanmakuItem.java\" target=\"_blank\" rel=\"external\">简单封装</a><br></p>\n<p><a href=\"https://github.com/Bilibili/DanmakuFlameMaster\" target=\"_blank\" rel=\"external\">成熟的B站</a><br></p>\n"},{"layout":"post","title":"简单工厂模式","date":"2017-05-23T00:00:00.000Z","_content":" \n\n#### what ####\n\n 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。\n\n\n#### 模式结构 ####\n\n- **Factory：工厂角色**<br>\n\t工厂角色负责实现创建所有实例\n\n- **Product:抽象产品角色**<br>\n\t抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n\n- **ConcreteProduct:具体的产品角色**<br>\n\t具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\t\n \n![类图](/images/simple_factory_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/simple_factory_sequence_diagram.png)\n \n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory)\n<br>\n抽象产品角色：\n\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n\n具体的产品角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductA implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product A!\");\n\t\t}\n\t}\n\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductB implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product B!\");\n\t\t}\n\t}\n\n工厂角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n测试：\n\t\n\tpackage SimpleFactory;\n\t\n\timport static org.junit.Assert.*;\n\t\n\tpublic class Test {\n\t\t@org.junit.Test\n\t\tpublic void test() throws Exception {\n\t\t\ttesting(Product.TYPEA);\n\t\t\ttesting(Product.TYPEB);\n\t\t\t// testing(3);\n\t\t}\n\t\n\t\tpublic static void testing(int type) {\n\t\t\tProduct p = ProductFactory.getTypeAConcreteProduct(type);\n\t\t\tassertNotEquals(p, null);\n\t\t\tp.use();\n\t\t}\n\t}\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 简单工厂为静态方法，调用起来方便\n- 工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护\n\n#### 使用场景 #### \n\n- 工厂类负责创建的对象比较少\n","source":"_posts/2017-05-23-design-patterns-simple-factory.md","raw":"---\nlayout: post\ntitle:  简单工厂模式\ndate:   2017-05-23\ncategories: Design Pattern\ntags: 设计模式\n---\n \n\n#### what ####\n\n 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。\n\n\n#### 模式结构 ####\n\n- **Factory：工厂角色**<br>\n\t工厂角色负责实现创建所有实例\n\n- **Product:抽象产品角色**<br>\n\t抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n\n- **ConcreteProduct:具体的产品角色**<br>\n\t具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\t\n \n![类图](/images/simple_factory_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/simple_factory_sequence_diagram.png)\n \n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory)\n<br>\n抽象产品角色：\n\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n\n具体的产品角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductA implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product A!\");\n\t\t}\n\t}\n\n\tpackage SimpleFactory;\n\t\n\tpublic class ConcreteProductB implements Product {\n\t\t@Override\n\t\tpublic void use() {\n\t\t\tSystem.out.println(\"useing concrete product B!\");\n\t\t}\n\t}\n\n工厂角色：\n\t\n\tpackage SimpleFactory;\n\t\n\tpublic interface Product {\n\t\tint TYPEA = 1;\n\t\tint TYPEB = 2;\n\t\n\t\tvoid use();\n\t}\n\n测试：\n\t\n\tpackage SimpleFactory;\n\t\n\timport static org.junit.Assert.*;\n\t\n\tpublic class Test {\n\t\t@org.junit.Test\n\t\tpublic void test() throws Exception {\n\t\t\ttesting(Product.TYPEA);\n\t\t\ttesting(Product.TYPEB);\n\t\t\t// testing(3);\n\t\t}\n\t\n\t\tpublic static void testing(int type) {\n\t\t\tProduct p = ProductFactory.getTypeAConcreteProduct(type);\n\t\t\tassertNotEquals(p, null);\n\t\t\tp.use();\n\t\t}\n\t}\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 简单工厂为静态方法，调用起来方便\n- 工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护\n\n#### 使用场景 #### \n\n- 工厂类负责创建的对象比较少\n","slug":"design-patterns-simple-factory","published":1,"updated":"2017-08-17T02:47:54.700Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1f800422sivei0kafs0","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li><p><strong>Factory：工厂角色</strong><br><br>  工厂角色负责实现创建所有实例</p>\n</li>\n<li><p><strong>Product:抽象产品角色</strong><br><br>  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>\n</li>\n<li><p><strong>ConcreteProduct:具体的产品角色</strong><br><br>  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>\n</li>\n</ul>\n<p><img src=\"/images/simple_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/simple_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory\" target=\"_blank\" rel=\"external\">GitHub</a><br><br><br>抽象产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>具体的产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic class ConcreteProductA implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product A!&quot;);\n    }\n}\n\npackage SimpleFactory;\n\npublic class ConcreteProductB implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product B!&quot;);\n    }\n}\n</code></pre><p>工厂角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>测试：</p>\n<pre><code>package SimpleFactory;\n\nimport static org.junit.Assert.*;\n\npublic class Test {\n    @org.junit.Test\n    public void test() throws Exception {\n        testing(Product.TYPEA);\n        testing(Product.TYPEB);\n        // testing(3);\n    }\n\n    public static void testing(int type) {\n        Product p = ProductFactory.getTypeAConcreteProduct(type);\n        assertNotEquals(p, null);\n        p.use();\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>简单工厂为静态方法，调用起来方便</li>\n<li>工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>工厂类负责创建的对象比较少</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 简单工厂模式又称为静态工厂模式。根据不同的参数返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li><p><strong>Factory：工厂角色</strong><br><br>  工厂角色负责实现创建所有实例</p>\n</li>\n<li><p><strong>Product:抽象产品角色</strong><br><br>  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>\n</li>\n<li><p><strong>ConcreteProduct:具体的产品角色</strong><br><br>  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p>\n</li>\n</ul>\n<p><img src=\"/images/simple_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/simple_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/SimpleFactory\" target=\"_blank\" rel=\"external\">GitHub</a><br><br><br>抽象产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>具体的产品角色：</p>\n<pre><code>package SimpleFactory;\n\npublic class ConcreteProductA implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product A!&quot;);\n    }\n}\n\npackage SimpleFactory;\n\npublic class ConcreteProductB implements Product {\n    @Override\n    public void use() {\n        System.out.println(&quot;useing concrete product B!&quot;);\n    }\n}\n</code></pre><p>工厂角色：</p>\n<pre><code>package SimpleFactory;\n\npublic interface Product {\n    int TYPEA = 1;\n    int TYPEB = 2;\n\n    void use();\n}\n</code></pre><p>测试：</p>\n<pre><code>package SimpleFactory;\n\nimport static org.junit.Assert.*;\n\npublic class Test {\n    @org.junit.Test\n    public void test() throws Exception {\n        testing(Product.TYPEA);\n        testing(Product.TYPEB);\n        // testing(3);\n    }\n\n    public static void testing(int type) {\n        Product p = ProductFactory.getTypeAConcreteProduct(type);\n        assertNotEquals(p, null);\n        p.use();\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>简单工厂为静态方法，调用起来方便</li>\n<li>工厂的职责过重，增加新的产品需要改变工厂的判断逻辑，违反了开闭原则，不利于扩展和维护</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>工厂类负责创建的对象比较少</li>\n</ul>\n"},{"layout":"post","title":"工厂方法模式","date":"2017-05-24T00:00:00.000Z","_content":" \n#### what ####\n\n 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t \n![类图](/images/factory_method_class_diagram.png)\n#### 时序图 ####\n \n![时序图](/images/factory_method_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod)\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式\n- 增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”\n- 增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销\n- 考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。\n\n#### 使用场景 #### \n\n- 调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类\n- 一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展\n\n#### 扩展 ####\n\n- 使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求\n- 产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的\n- 多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。\n","source":"_posts/2017-05-24-design-patterns-factory-method.md","raw":"---\nlayout: post\ntitle:  工厂方法模式\ndate:   2017-05-24\ncategories: Design Pattern\ntags: 设计模式\n---\n \n#### what ####\n\n 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t \n![类图](/images/factory_method_class_diagram.png)\n#### 时序图 ####\n \n![时序图](/images/factory_method_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod)\n\n#### 分析 ####\n\n- 创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割\n- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式\n- 增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”\n- 增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销\n- 考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。\n\n#### 使用场景 #### \n\n- 调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类\n- 一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展\n\n#### 扩展 ####\n\n- 使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求\n- 产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的\n- 多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。\n","slug":"design-patterns-factory-method","published":1,"updated":"2017-08-17T02:48:05.477Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fb00452siv7ia1trp9","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/factory_method_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/factory_method_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式</li>\n<li>增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”</li>\n<li>增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销</li>\n<li>考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类</li>\n<li>一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求</li>\n<li>产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的</li>\n<li>多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫作虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/factory_method_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/factory_method_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FactoryMethod\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>创建对象和对象本身业务剥离，屏蔽创建对象的细节，降低耦合度，实现了责任的分割</li>\n<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。所有的具体工厂类都具有同一抽象父类，因此又被称为多态工厂模式</li>\n<li>增加新产品时，无须修改其他，只要添加一个具体工厂和具体产品就可以了，系统的扩展性很好，符合“开闭原则”</li>\n<li>增加新产品时，系统中类的个数成对增加，一定程度上增加了系统的复杂度，带来额外开销</li>\n<li>考虑到系统的可扩展性，需要引入抽象层，增加了系统的抽象性和理解难度。</li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>调用者不知道它所需要的对象的类，但要知道创建具体产品的工厂类</li>\n<li>一个类通过其子类来指定创建哪个对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象覆盖父类对象，从而使系统更容易扩展</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求</li>\n<li>产品对象的重复使用：工厂将已创建的产品保存到一个集合，然后根据客户对产品的请求，对集合进行查询，返回已有或创建新的</li>\n<li>多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法是，工厂方法模式就退化成简单工厂模式。</li>\n</ul>\n"},{"layout":"post","title":"策略模式","date":"2017-05-25T00:00:00.000Z","_content":" \n\n#### what ####\n \n策略模式是对象行为型模式<br>\n\n策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  Strategy：抽象策略类\n-  ConcreteStrategy：具体策略类\n\t\n \n![类图](/images/strategy_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/strategy_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern)\n\n#### 分析 ####\n\n- 在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if...else...等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难\n- 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。\n\n\n#### 优劣 ####\n\n- 对开闭原则完美支持，用户自由切换算法，易于扩展\n- 可以避免使用多重条件转移语句\n\n- 必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则\n- 需要维护许多策略类","source":"_posts/2017-05-25-design-patterns-strategy-pattern.md","raw":"---\nlayout: post\ntitle:  策略模式\ndate:   2017-05-25\ncategories: Design Pattern\ntags: 设计模式\n---\n \n\n#### what ####\n \n策略模式是对象行为型模式<br>\n\n策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  Strategy：抽象策略类\n-  ConcreteStrategy：具体策略类\n\t\n \n![类图](/images/strategy_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/strategy_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern)\n\n#### 分析 ####\n\n- 在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if...else...等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难\n- 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。\n\n\n#### 优劣 ####\n\n- 对开闭原则完美支持，用户自由切换算法，易于扩展\n- 可以避免使用多重条件转移语句\n\n- 必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则\n- 需要维护许多策略类","slug":"design-patterns-strategy-pattern","published":1,"updated":"2017-08-17T02:48:15.664Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fd00482sivso4dhge7","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>策略模式是对象行为型模式<br></p>\n<p>策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>Strategy：抽象策略类</li>\n<li>ConcreteStrategy：具体策略类</li>\n</ul>\n<p><img src=\"/images/strategy_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/strategy_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难</li>\n<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。</li>\n</ul>\n<h4 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h4><ul>\n<li>对开闭原则完美支持，用户自由切换算法，易于扩展</li>\n<li><p>可以避免使用多重条件转移语句</p>\n</li>\n<li><p>必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则</p>\n</li>\n<li>需要维护许多策略类</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>策略模式是对象行为型模式<br></p>\n<p>策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>Strategy：抽象策略类</li>\n<li>ConcreteStrategy：具体策略类</li>\n</ul>\n<p><img src=\"/images/strategy_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/strategy_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难</li>\n<li>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。</li>\n</ul>\n<h4 id=\"优劣\"><a href=\"#优劣\" class=\"headerlink\" title=\"优劣\"></a>优劣</h4><ul>\n<li>对开闭原则完美支持，用户自由切换算法，易于扩展</li>\n<li><p>可以避免使用多重条件转移语句</p>\n</li>\n<li><p>必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则</p>\n</li>\n<li>需要维护许多策略类</li>\n</ul>\n"},{"layout":"post","title":"抽象工厂模式","date":"2017-05-25T00:00:00.000Z","_content":"\n#### 引入概念 ####\n\n- **产品等级结构：**产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n- **产品族：** 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。\n\n \n![示例图](/images/abstract_factory_product_level.png)\n\n#### what ####\n\n 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t\n![类图](/images/abstract_factory_class_diagram.png)\n\n\n#### 时序图 ####\n\n![时序图](/images/abstract_factory_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory)\n\n#### 分析 ####\n\n- 抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)\n- 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式\n- \n\n#### 使用场景 #### \n\n- 适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定\n- 比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。\n\n#### 扩展 ####\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n","source":"_posts/2017-05-25-design-patterns-abstract-factory.md","raw":"---\nlayout: post\ntitle:  抽象工厂模式\ndate:   2017-05-25\ncategories: Design Pattern\ntags: 设计模式\n---\n\n#### 引入概念 ####\n\n- **产品等级结构：**产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。\n- **产品族：** 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。\n\n \n![示例图](/images/abstract_factory_product_level.png)\n\n#### what ####\n\n 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。\n\n#### 模式结构 ####\n\n-  Factory：抽象工厂\n-  ConcreteFactory：具体工厂\n-  Product：抽象产品\n-  ConcreteProduct：具体产品\n\t\n![类图](/images/abstract_factory_class_diagram.png)\n\n\n#### 时序图 ####\n\n![时序图](/images/abstract_factory_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory)\n\n#### 分析 ####\n\n- 抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)\n- 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式\n- \n\n#### 使用场景 #### \n\n- 适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定\n- 比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。\n\n#### 扩展 ####\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n","slug":"design-patterns-abstract-factory","published":1,"updated":"2017-08-17T02:48:11.066Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fg004b2sivqfh5yk75","content":"<h4 id=\"引入概念\"><a href=\"#引入概念\" class=\"headerlink\" title=\"引入概念\"></a>引入概念</h4><ul>\n<li><strong>产品等级结构：</strong>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>\n<li><strong>产品族：</strong> 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。</li>\n</ul>\n<p><img src=\"/images/abstract_factory_product_level.png\" alt=\"示例图\"></p>\n<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/abstract_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/abstract_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)</li>\n<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式</li>\n<li></li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定</li>\n<li>比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引入概念\"><a href=\"#引入概念\" class=\"headerlink\" title=\"引入概念\"></a>引入概念</h4><ul>\n<li><strong>产品等级结构：</strong>产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>\n<li><strong>产品族：</strong> 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱、海尔电视机。</li>\n</ul>\n<p><img src=\"/images/abstract_factory_product_level.png\" alt=\"示例图\"></p>\n<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为kit模式，属于对象创建型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n</ul>\n<p><img src=\"/images/abstract_factory_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/abstract_factory_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/AbstractFactory\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>抽象工厂定义了产品的所有行为，因此增加产品族很方便，增加产品等级类别需要改动抽象工厂(开闭原则的倾斜性)</li>\n<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式</li>\n<li></li>\n</ul>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>适用于产品确定，但是产品线不确定的场景，比如要生产汽车，但是汽车的配置不确定</li>\n<li>比如app换肤，整体的颜色，字体，背景，按钮，文本框。。。</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p>\n"},{"layout":"post","title":"状态模式","date":"2017-05-26T00:00:00.000Z","_content":" \n\n#### what ####\n \n状态模式是对象行为型模式<br>\n\n看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br>\n\n状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  State：抽象状态类\n-  ConcreteState：具体状态类\n \n![类图](/images/state_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/state_pattern_sequence_diagram.png)\n \n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern)\n\n#### 适用场景 ####\n\n- 对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为\n- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。\n\n\n#### 分析 ####\n\n- 在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象\n- 简单状态模式和可切换状态的状态模式\n","source":"_posts/2017-05-26-design-patterns-state-pattern.md","raw":"---\nlayout: post\ntitle:  状态模式\ndate:   2017-05-26\ncategories: Design Pattern\ntags: 设计模式\n---\n \n\n#### what ####\n \n状态模式是对象行为型模式<br>\n\n看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br>\n\n状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).\n\n#### 模式结构 ####\n\n-  Context:环境类\n-  State：抽象状态类\n-  ConcreteState：具体状态类\n \n![类图](/images/state_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/state_pattern_sequence_diagram.png)\n \n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern)\n\n#### 适用场景 ####\n\n- 对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为\n- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。\n\n\n#### 分析 ####\n\n- 在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象\n- 简单状态模式和可切换状态的状态模式\n","slug":"design-patterns-state-pattern","published":1,"updated":"2017-08-17T02:48:20.082Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fj004e2sivdkynh16k","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>状态模式是对象行为型模式<br></p>\n<p>看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br></p>\n<p>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>State：抽象状态类</li>\n<li>ConcreteState：具体状态类</li>\n</ul>\n<p><img src=\"/images/state_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/state_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为</li>\n<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</li>\n<li>简单状态模式和可切换状态的状态模式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>状态模式是对象行为型模式<br></p>\n<p>看完状态模式的模式的类图和时序图，真的，和策略模式一毛一样。但是他们的思想是不同的。策略模式的具体实现类是可以根据选择的策略不同来相互替换的，状态模式是根据当前对象的不同而执行对应的状态实现。策略模式的选择权在于调用者，而状态模式的选择权更多在于用户使用软件操作后的结果。这是我自己的理解。<br></p>\n<p>状态模式(State Pattern)：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Object for State).</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Context:环境类</li>\n<li>State：抽象状态类</li>\n<li>ConcreteState：具体状态类</li>\n</ul>\n<p><img src=\"/images/state_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/state_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StatePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>对象的行为依赖于它的状态(属性)并且可以根据它的状态改变而改变它的相关行为</li>\n<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，是客户类与类库之间的耦合性增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象</li>\n<li>简单状态模式和可切换状态的状态模式</li>\n</ul>\n"},{"layout":"post","title":"接口常量反模式","date":"2017-05-31T00:00:00.000Z","_content":" \n#### what ####\n\n在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br>\n\n下面是两个例子：\n\n\tpublic interface IConstant {\n\tString NAME = \"\";\n\tint VALUE = 2;\n\tboolean IS_TEACHER = false;\n\t}\t\n\n<br>\n\t\n\tpublic class CConstant {\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t}\n\n#### 接口的优点 ####\n\n- 接口会自动将成员变量设置为static、final的\n- 使得代码更加简单清晰\n- 字节码文件相对于类来说更少，jvm加载和维护的成本变低\n- jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快\n\n#### 反模式之处 ####\n\n由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。\n\n#### 反反模式的做法 ####\n\nfinal类 + 私有构造，如下：<br>\n\t\n\tpublic final class Constants {\n\t\tprivate Constants() {\n\t\t}\n\t\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t\n\t}\n","source":"_posts/2017-05-31-anti-patterns-constant-interface.md","raw":"---\nlayout: post\ntitle:  接口常量反模式\ndate:   2017-05-31\ncategories: Design Pattern\ntags: 设计模式\n---\n \n#### what ####\n\n在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br>\n\n下面是两个例子：\n\n\tpublic interface IConstant {\n\tString NAME = \"\";\n\tint VALUE = 2;\n\tboolean IS_TEACHER = false;\n\t}\t\n\n<br>\n\t\n\tpublic class CConstant {\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t}\n\n#### 接口的优点 ####\n\n- 接口会自动将成员变量设置为static、final的\n- 使得代码更加简单清晰\n- 字节码文件相对于类来说更少，jvm加载和维护的成本变低\n- jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快\n\n#### 反模式之处 ####\n\n由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。\n\n#### 反反模式的做法 ####\n\nfinal类 + 私有构造，如下：<br>\n\t\n\tpublic final class Constants {\n\t\tprivate Constants() {\n\t\t}\n\t\n\t\tpublic static final String NAME = \"\";\n\t\tpublic static final int VALUE = 2;\n\t\tpublic static final boolean IS_TEACHER = false;\n\t\n\t}\n","slug":"anti-patterns-constant-interface","published":1,"updated":"2017-08-17T02:48:28.898Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fl004h2sivw51ich70","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br></p>\n<p>下面是两个例子：</p>\n<pre><code>public interface IConstant {\nString NAME = &quot;&quot;;\nint VALUE = 2;\nboolean IS_TEACHER = false;\n}    \n</code></pre><p><br></p>\n<pre><code>public class CConstant {\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n}\n</code></pre><h4 id=\"接口的优点\"><a href=\"#接口的优点\" class=\"headerlink\" title=\"接口的优点\"></a>接口的优点</h4><ul>\n<li>接口会自动将成员变量设置为static、final的</li>\n<li>使得代码更加简单清晰</li>\n<li>字节码文件相对于类来说更少，jvm加载和维护的成本变低</li>\n<li>jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快</li>\n</ul>\n<h4 id=\"反模式之处\"><a href=\"#反模式之处\" class=\"headerlink\" title=\"反模式之处\"></a>反模式之处</h4><p>由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。</p>\n<h4 id=\"反反模式的做法\"><a href=\"#反反模式的做法\" class=\"headerlink\" title=\"反反模式的做法\"></a>反反模式的做法</h4><p>final类 + 私有构造，如下：<br></p>\n<pre><code>public final class Constants {\n    private Constants() {\n    }\n\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>在应用中，我们往往需要一个常量文件，用于存储被多个地方引用的共享常量。一般我们都将其设计为静态的公共常量，有时放在接口中，有时放在类中。<br></p>\n<p>下面是两个例子：</p>\n<pre><code>public interface IConstant {\nString NAME = &quot;&quot;;\nint VALUE = 2;\nboolean IS_TEACHER = false;\n}    \n</code></pre><p><br></p>\n<pre><code>public class CConstant {\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n}\n</code></pre><h4 id=\"接口的优点\"><a href=\"#接口的优点\" class=\"headerlink\" title=\"接口的优点\"></a>接口的优点</h4><ul>\n<li>接口会自动将成员变量设置为static、final的</li>\n<li>使得代码更加简单清晰</li>\n<li>字节码文件相对于类来说更少，jvm加载和维护的成本变低</li>\n<li>jvm加载接口时，不必担心类提供的额外特征(如重载、方法的动态绑定等)，因此加载更快</li>\n</ul>\n<h4 id=\"反模式之处\"><a href=\"#反模式之处\" class=\"headerlink\" title=\"反模式之处\"></a>反模式之处</h4><p>由于Java中没有一种方式可以阻止类实现接口。合作开发中，一旦某个类实现了我们的常量接口，这就导致增加不必要的常量。这会动摇整个基础，并引起混乱。</p>\n<h4 id=\"反反模式的做法\"><a href=\"#反反模式的做法\" class=\"headerlink\" title=\"反反模式的做法\"></a>反反模式的做法</h4><p>final类 + 私有构造，如下：<br></p>\n<pre><code>public final class Constants {\n    private Constants() {\n    }\n\n    public static final String NAME = &quot;&quot;;\n    public static final int VALUE = 2;\n    public static final boolean IS_TEACHER = false;\n\n}\n</code></pre>"},{"layout":"post","title":"软件开发反模式","date":"2017-05-31T00:00:00.000Z","_content":" \n\n#### **过早优化** ####\n\n##### what #####\n\t在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n\n##### why #####\n\t想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \n\tDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n\n##### how #####\n\t把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n\t当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\t\n\t不假思索就动手，还不如不做。——Tim Peter\n\n##### 总结 ##### \n\n\t优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n\n\n\n#### 单车车库 ####\n\n##### what #####\n\t花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n\n##### why #####\n\t浪费时间。\n\n##### how #####\n\t如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n\t当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n\n##### 总结 #####\n\t单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n\t避免花费太多时间在琐碎的事情上。\n\n#### 分析瘫痪 ####\n \n##### what #####\n\t对问题的过度分析，阻碍了行动和进展。\n\n##### why #####\n\t过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n\t或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。\t\n\n##### how #####\n\t意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n\t每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n\n##### 总结 #####\n\t宁愿迭代，也不用过度分析和猜测。\n\n#### 上帝类 ####\n\t\n##### what #####\n\t上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n\n##### why #####\n\t违反了单一责任原则，难以单元测试、调试和记录文档。\n\n##### how #####\n\t通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n\n##### 总结 #####\n\t避免有着太多责任和依赖的庞大的类。\n\n#### 新增类恐惧症 ####\n##### what #####\n\t认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n\n##### why #####\n\t新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n##### how #####\n\t简化设计新增类，解耦代码中不必要的耦合部分。\n\n##### 总结 #####\n\t类的数量多，并不能说明设计很糟糕。\n\n#### 内部平台效应 ####\n\n##### what #####\n\t复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n\n##### why #####\n\t重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n\n##### how #####\n\t学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n\n##### 总结 #####\n\t避免重新发明你的操作系统或开发平台已经做得很多的功能。\t\n\n#### 魔法数和字符串 ####\n\n##### what #####\n\t使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n\n##### why #####\n\t增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n\n##### how #####\n\t使用命名的常量、资源检索方法或者注释。\n\n##### 总结 #####\n\t避免在代码中出现未注释、未命名的数字和字符串字面量。\n\n#### 数字管理 ####\n>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates\n\n\n##### what #####\n\t严格地依靠数字来做决定。\n\n##### why #####\n\t在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n\t例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n\n##### how #####\n\t理智地使用测量和数字，而非盲目。\n\n##### 总结 #####\n\t用数字来得出你的决策，但不是用数字来做决定。\n\n#### 幽灵类 ####\n>要想达到完美，不是没有东西可加，而是没有东西可减。\n\n\n##### what #####\n\t无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n\n##### why #####\n\t增加了测试和维护的复杂度，降低了代码的可读性。\n\n##### how #####\n\t不要写无用的类，或者通过重构来消除。\n\n##### 总结 #####\n\t避免没有真正责任的类。","source":"_posts/2017-05-31-anti-patterns.md","raw":"---\nlayout:  \ntitle:  软件开发反模式\ndate:   2017-05-31\ncategories: Design Pattern\ntags: 设计模式\n---\n \n\n#### **过早优化** ####\n\n##### what #####\n\t在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n\n##### why #####\n\t想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \n\tDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n\n##### how #####\n\t把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n\t当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\t\n\t不假思索就动手，还不如不做。——Tim Peter\n\n##### 总结 ##### \n\n\t优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n\n\n\n#### 单车车库 ####\n\n##### what #####\n\t花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n\n##### why #####\n\t浪费时间。\n\n##### how #####\n\t如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n\t当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n\n##### 总结 #####\n\t单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n\t避免花费太多时间在琐碎的事情上。\n\n#### 分析瘫痪 ####\n \n##### what #####\n\t对问题的过度分析，阻碍了行动和进展。\n\n##### why #####\n\t过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n\t或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。\t\n\n##### how #####\n\t意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n\t每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n\n##### 总结 #####\n\t宁愿迭代，也不用过度分析和猜测。\n\n#### 上帝类 ####\n\t\n##### what #####\n\t上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n\n##### why #####\n\t违反了单一责任原则，难以单元测试、调试和记录文档。\n\n##### how #####\n\t通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n\n##### 总结 #####\n\t避免有着太多责任和依赖的庞大的类。\n\n#### 新增类恐惧症 ####\n##### what #####\n\t认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n\n##### why #####\n\t新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n##### how #####\n\t简化设计新增类，解耦代码中不必要的耦合部分。\n\n##### 总结 #####\n\t类的数量多，并不能说明设计很糟糕。\n\n#### 内部平台效应 ####\n\n##### what #####\n\t复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n\n##### why #####\n\t重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n\n##### how #####\n\t学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n\n##### 总结 #####\n\t避免重新发明你的操作系统或开发平台已经做得很多的功能。\t\n\n#### 魔法数和字符串 ####\n\n##### what #####\n\t使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n\n##### why #####\n\t增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n\n##### how #####\n\t使用命名的常量、资源检索方法或者注释。\n\n##### 总结 #####\n\t避免在代码中出现未注释、未命名的数字和字符串字面量。\n\n#### 数字管理 ####\n>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates\n\n\n##### what #####\n\t严格地依靠数字来做决定。\n\n##### why #####\n\t在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n\t例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n\n##### how #####\n\t理智地使用测量和数字，而非盲目。\n\n##### 总结 #####\n\t用数字来得出你的决策，但不是用数字来做决定。\n\n#### 幽灵类 ####\n>要想达到完美，不是没有东西可加，而是没有东西可减。\n\n\n##### what #####\n\t无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n\n##### why #####\n\t增加了测试和维护的复杂度，降低了代码的可读性。\n\n##### how #####\n\t不要写无用的类，或者通过重构来消除。\n\n##### 总结 #####\n\t避免没有真正责任的类。","slug":"anti-patterns","published":1,"updated":"2017-08-17T02:48:25.503Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fn004k2sivx69z1lqb","content":"<h4 id=\"过早优化\"><a href=\"#过早优化\" class=\"headerlink\" title=\"过早优化\"></a><strong>过早优化</strong></h4><h5 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n</code></pre><h5 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \nDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n</code></pre><h5 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\n不假思索就动手，还不如不做。——Tim Peter\n</code></pre><h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n</code></pre><h4 id=\"单车车库\"><a href=\"#单车车库\" class=\"headerlink\" title=\"单车车库\"></a>单车车库</h4><h5 id=\"what-1\"><a href=\"#what-1\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n</code></pre><h5 id=\"why-1\"><a href=\"#why-1\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>浪费时间。\n</code></pre><h5 id=\"how-1\"><a href=\"#how-1\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n</code></pre><h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n避免花费太多时间在琐碎的事情上。\n</code></pre><h4 id=\"分析瘫痪\"><a href=\"#分析瘫痪\" class=\"headerlink\" title=\"分析瘫痪\"></a>分析瘫痪</h4><h5 id=\"what-2\"><a href=\"#what-2\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>对问题的过度分析，阻碍了行动和进展。\n</code></pre><h5 id=\"why-2\"><a href=\"#why-2\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。    \n</code></pre><h5 id=\"how-2\"><a href=\"#how-2\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n</code></pre><h5 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>宁愿迭代，也不用过度分析和猜测。\n</code></pre><h4 id=\"上帝类\"><a href=\"#上帝类\" class=\"headerlink\" title=\"上帝类\"></a>上帝类</h4><h5 id=\"what-3\"><a href=\"#what-3\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n</code></pre><h5 id=\"why-3\"><a href=\"#why-3\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>违反了单一责任原则，难以单元测试、调试和记录文档。\n</code></pre><h5 id=\"how-3\"><a href=\"#how-3\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n</code></pre><h5 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免有着太多责任和依赖的庞大的类。\n</code></pre><h4 id=\"新增类恐惧症\"><a href=\"#新增类恐惧症\" class=\"headerlink\" title=\"新增类恐惧症\"></a>新增类恐惧症</h4><h5 id=\"what-4\"><a href=\"#what-4\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n</code></pre><h5 id=\"why-4\"><a href=\"#why-4\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n</code></pre><h5 id=\"how-4\"><a href=\"#how-4\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>简化设计新增类，解耦代码中不必要的耦合部分。\n</code></pre><h5 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>类的数量多，并不能说明设计很糟糕。\n</code></pre><h4 id=\"内部平台效应\"><a href=\"#内部平台效应\" class=\"headerlink\" title=\"内部平台效应\"></a>内部平台效应</h4><h5 id=\"what-5\"><a href=\"#what-5\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n</code></pre><h5 id=\"why-5\"><a href=\"#why-5\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n</code></pre><h5 id=\"how-5\"><a href=\"#how-5\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n</code></pre><h5 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免重新发明你的操作系统或开发平台已经做得很多的功能。    \n</code></pre><h4 id=\"魔法数和字符串\"><a href=\"#魔法数和字符串\" class=\"headerlink\" title=\"魔法数和字符串\"></a>魔法数和字符串</h4><h5 id=\"what-6\"><a href=\"#what-6\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n</code></pre><h5 id=\"why-6\"><a href=\"#why-6\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n</code></pre><h5 id=\"how-6\"><a href=\"#how-6\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>使用命名的常量、资源检索方法或者注释。\n</code></pre><h5 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免在代码中出现未注释、未命名的数字和字符串字面量。\n</code></pre><h4 id=\"数字管理\"><a href=\"#数字管理\" class=\"headerlink\" title=\"数字管理\"></a>数字管理</h4><blockquote>\n<p>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates</p>\n</blockquote>\n<h5 id=\"what-7\"><a href=\"#what-7\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>严格地依靠数字来做决定。\n</code></pre><h5 id=\"why-7\"><a href=\"#why-7\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n</code></pre><h5 id=\"how-7\"><a href=\"#how-7\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>理智地使用测量和数字，而非盲目。\n</code></pre><h5 id=\"总结-7\"><a href=\"#总结-7\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>用数字来得出你的决策，但不是用数字来做决定。\n</code></pre><h4 id=\"幽灵类\"><a href=\"#幽灵类\" class=\"headerlink\" title=\"幽灵类\"></a>幽灵类</h4><blockquote>\n<p>要想达到完美，不是没有东西可加，而是没有东西可减。</p>\n</blockquote>\n<h5 id=\"what-8\"><a href=\"#what-8\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n</code></pre><h5 id=\"why-8\"><a href=\"#why-8\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了测试和维护的复杂度，降低了代码的可读性。\n</code></pre><h5 id=\"how-8\"><a href=\"#how-8\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>不要写无用的类，或者通过重构来消除。\n</code></pre><h5 id=\"总结-8\"><a href=\"#总结-8\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免没有真正责任的类。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"过早优化\"><a href=\"#过早优化\" class=\"headerlink\" title=\"过早优化\"></a><strong>过早优化</strong></h4><h5 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>在你有足够的信息能确定在哪优化、如何优化之前就展开优化。\n</code></pre><h5 id=\"why\"><a href=\"#why\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>想要知道实践中的确切瓶颈很困难。试图在得到实验数据之前就实行优化，可能会提高代码复杂度，并引发难以察举的bug。 \nDonald Knuth有云：97%的时间里，我们应该忘掉微不足道的效率：过早的优化是万恶之源。然后，在3%的决定性时刻，我们不该错过优化。\n</code></pre><h5 id=\"how\"><a href=\"#how\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>把整洁的、可读性强的、能运行的代码放在首位，使用已知的和测试过的算法和工具。\n当需要找到瓶颈和决定优化优先级时，使用分析工具。依赖于测量而不是臆想和推断。 \n\n不假思索就动手，还不如不做。——Tim Peter\n</code></pre><h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>优化之前分析。避免为了效率而牺牲简洁性，除非效率被验证了的确是有必要的。\n</code></pre><h4 id=\"单车车库\"><a href=\"#单车车库\" class=\"headerlink\" title=\"单车车库\"></a>单车车库</h4><h5 id=\"what-1\"><a href=\"#what-1\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>花大量时间来辩论和决定琐碎、太主观的问题的趋势。\n</code></pre><h5 id=\"why-1\"><a href=\"#why-1\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>浪费时间。\n</code></pre><h5 id=\"how-1\"><a href=\"#how-1\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>如果你注意到了，那鼓励团队成员意识到这种趋势，并且优先达成决定(投票、抛硬币等，如果你不得不这样做的话)。\n当这个决定有意义时，考虑随后A/B的来回顾这个决定，而不是进一步的内部讨论。\n</code></pre><h5 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>单车车库相对于提前优化更容易被发现和制止。只要注意你用在做决定和合约上的琐碎问题的时间，如果有必要，就加以干涉。\n避免花费太多时间在琐碎的事情上。\n</code></pre><h4 id=\"分析瘫痪\"><a href=\"#分析瘫痪\" class=\"headerlink\" title=\"分析瘫痪\"></a>分析瘫痪</h4><h5 id=\"what-2\"><a href=\"#what-2\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>对问题的过度分析，阻碍了行动和进展。\n</code></pre><h5 id=\"why-2\"><a href=\"#why-2\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>过度分析会延缓进展，甚至彻底终止进展。在极端情况下，分析的结果到了要做的时候已经过时了，\n或者更糟的是，项目或许从来走不出分析阶段。当决定难以做出时，很容易想到，更多的信息将会有助于做出决定。    \n</code></pre><h5 id=\"how-2\"><a href=\"#how-2\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>意识是有帮助的。重点在于迭代和改进。伴随着更多有帮助的、有意义的分析得到的数据，\n每次迭代都会提供更多的反馈。如果没有新的数据点，更多的分析将变得越来越让人猜疑。\n</code></pre><h5 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>宁愿迭代，也不用过度分析和猜测。\n</code></pre><h4 id=\"上帝类\"><a href=\"#上帝类\" class=\"headerlink\" title=\"上帝类\"></a>上帝类</h4><h5 id=\"what-3\"><a href=\"#what-3\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>上帝类控制很值很多其他类，以及有很多依赖类，也就有更大的责任。\n</code></pre><h5 id=\"why-3\"><a href=\"#why-3\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>违反了单一责任原则，难以单元测试、调试和记录文档。\n</code></pre><h5 id=\"how-3\"><a href=\"#how-3\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>通过把责任打散成单一的、清晰的、经过单元测试的、文档易编写的类，可以避免类变成上帝类。\n</code></pre><h5 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免有着太多责任和依赖的庞大的类。\n</code></pre><h4 id=\"新增类恐惧症\"><a href=\"#新增类恐惧症\" class=\"headerlink\" title=\"新增类恐惧症\"></a>新增类恐惧症</h4><h5 id=\"what-4\"><a href=\"#what-4\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>认为更多的类必然使得设计更加复杂，导致对新增类或把大类分解为一些小类感到恐惧。\n</code></pre><h5 id=\"why-4\"><a href=\"#why-4\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>新增类可以明显降低复杂度。一些简单的、易于维护、易于记录文档的类，要远远好过于有着太多责任的、单一庞大的、复杂类。\n</code></pre><h5 id=\"how-4\"><a href=\"#how-4\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>简化设计新增类，解耦代码中不必要的耦合部分。\n</code></pre><h5 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>类的数量多，并不能说明设计很糟糕。\n</code></pre><h4 id=\"内部平台效应\"><a href=\"#内部平台效应\" class=\"headerlink\" title=\"内部平台效应\"></a>内部平台效应</h4><h5 id=\"what-5\"><a href=\"#what-5\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>复杂的软件系统趋势在于重实现它所运行的平台特点或平台所使用的语言，通常实现的比较烂。\n</code></pre><h5 id=\"why-5\"><a href=\"#why-5\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>重新发明语言，导致代码阅读困难，有更陡峭的学习曲线，限制了重构和代码分析工具的效用。\n</code></pre><h5 id=\"how-5\"><a href=\"#how-5\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>学习使用你的操作系统或平台提供的平台和功能，抵制住创建已有语言结构的诱惑。\n</code></pre><h5 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免重新发明你的操作系统或开发平台已经做得很多的功能。    \n</code></pre><h4 id=\"魔法数和字符串\"><a href=\"#魔法数和字符串\" class=\"headerlink\" title=\"魔法数和字符串\"></a>魔法数和字符串</h4><h5 id=\"what-6\"><a href=\"#what-6\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>使用未命名的数字或字符串字面量，而不是在代码里命名为常量。\n</code></pre><h5 id=\"why-6\"><a href=\"#why-6\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了代码理解难度，如果必须要修改这些常量，寻找和替换会导致一些微妙的bug。\n</code></pre><h5 id=\"how-6\"><a href=\"#how-6\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>使用命名的常量、资源检索方法或者注释。\n</code></pre><h5 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免在代码中出现未注释、未命名的数字和字符串字面量。\n</code></pre><h4 id=\"数字管理\"><a href=\"#数字管理\" class=\"headerlink\" title=\"数字管理\"></a>数字管理</h4><blockquote>\n<p>用代码行数来衡量开发进度，无异于用重量来衡量制造飞机的进度。——BillGates</p>\n</blockquote>\n<h5 id=\"what-7\"><a href=\"#what-7\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>严格地依靠数字来做决定。\n</code></pre><h5 id=\"why-7\"><a href=\"#why-7\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>在单车车库中，我们要求根据数据来优化或做决策，而不是光靠凭空想。但是，盲目的信任数字也很危险。\n例如，模型无效了但是数据还在，或者模型过期了，不再能精准的代表现实。这就会导致一些错误的决定，尤其是如果他们完全自动化时。\n</code></pre><h5 id=\"how-7\"><a href=\"#how-7\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>理智地使用测量和数字，而非盲目。\n</code></pre><h5 id=\"总结-7\"><a href=\"#总结-7\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>用数字来得出你的决策，但不是用数字来做决定。\n</code></pre><h4 id=\"幽灵类\"><a href=\"#幽灵类\" class=\"headerlink\" title=\"幽灵类\"></a>幽灵类</h4><blockquote>\n<p>要想达到完美，不是没有东西可加，而是没有东西可减。</p>\n</blockquote>\n<h5 id=\"what-8\"><a href=\"#what-8\" class=\"headerlink\" title=\"what\"></a>what</h5><pre><code>无用类本身没有真正的责任，经常用来指示调用另一个类的方法或者增加一层不必要的抽象。\n</code></pre><h5 id=\"why-8\"><a href=\"#why-8\" class=\"headerlink\" title=\"why\"></a>why</h5><pre><code>增加了测试和维护的复杂度，降低了代码的可读性。\n</code></pre><h5 id=\"how-8\"><a href=\"#how-8\" class=\"headerlink\" title=\"how\"></a>how</h5><pre><code>不要写无用的类，或者通过重构来消除。\n</code></pre><h5 id=\"总结-8\"><a href=\"#总结-8\" class=\"headerlink\" title=\"总结\"></a>总结</h5><pre><code>避免没有真正责任的类。\n</code></pre>"},{"title":"解释器模式","date":"2017-06-02T09:39:35.000Z","_content":"\n#### 定义 ####\n\n解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。\n解释器模式是一种行为型模式。\n#### 类图 ####\n- Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。\n- AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。\n- TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。\n- NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。\n\n![类图](/images/interpreter_class_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern)\n\n#### 分析 ####\n\n- 为自定义语言的设计和实现提供了一种解决方案\n- 使用频率不高，在正则表达式、xml文档解析等领域广泛应用\n- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护\n- 使用了大量的循环和递归，导致执行效率很低\n- 尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足\n- 一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具\n- 如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现","source":"_posts/2017-06-02-design-patterns-interpreter.md","raw":"---\ntitle: 解释器模式\ndate: 2017-06-02 09:39:35\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。\n解释器模式是一种行为型模式。\n#### 类图 ####\n- Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。\n- AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。\n- TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。\n- NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。\n\n![类图](/images/interpreter_class_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern)\n\n#### 分析 ####\n\n- 为自定义语言的设计和实现提供了一种解决方案\n- 使用频率不高，在正则表达式、xml文档解析等领域广泛应用\n- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护\n- 使用了大量的循环和递归，导致执行效率很低\n- 尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足\n- 一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具\n- 如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现","slug":"design-patterns-interpreter","published":1,"updated":"2017-08-17T02:48:39.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1fr004n2sivpgvgpldi","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。<br>解释器模式是一种行为型模式。</p>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><ul>\n<li>Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li>\n<li>AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li>\n<li>TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li>\n<li>NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li>\n</ul>\n<p><img src=\"/images/interpreter_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>为自定义语言的设计和实现提供了一种解决方案</li>\n<li>使用频率不高，在正则表达式、xml文档解析等领域广泛应用</li>\n<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护</li>\n<li>使用了大量的循环和递归，导致执行效率很低</li>\n<li>尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足</li>\n<li>一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具</li>\n<li>如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。<br>解释器模式是一种行为型模式。</p>\n<h4 id=\"类图\"><a href=\"#类图\" class=\"headerlink\" title=\"类图\"></a>类图</h4><ul>\n<li>Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li>\n<li>AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li>\n<li>TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li>\n<li>NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li>\n</ul>\n<p><img src=\"/images/interpreter_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>为自定义语言的设计和实现提供了一种解决方案</li>\n<li>使用频率不高，在正则表达式、xml文档解析等领域广泛应用</li>\n<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护</li>\n<li>使用了大量的循环和递归，导致执行效率很低</li>\n<li>尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足</li>\n<li>一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具</li>\n<li>如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现</li>\n</ul>\n"},{"layout":"post","title":"责任链模式","date":"2017-05-31T00:00:00.000Z","_content":"\n#### what ####\n \n责任链模式是对象行为型模式<br>\n\n责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>\n\n客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。\n\n \n#### 模式结构 ####\n\n- Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链\n- ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。\n\n![类图](/images/chain_of_responsibility_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/chain_of_responsibility_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility)\n\n#### 适用场景 ####\n\n - 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的\n - 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n - 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 \n\n\n#### 分析 ####\n\n- 责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型\n- 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。\n- 责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。\n- 纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况\n- 不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。\n","source":"_posts/2017-05-31-design-patterns-chain-of-responsibility.md","raw":"---\nlayout: post\ntitle:  责任链模式\ndate:   2017-05-31\ncategories: Design Pattern\ntag: 设计模式\n---\n\n#### what ####\n \n责任链模式是对象行为型模式<br>\n\n责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>\n\n客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。\n\n \n#### 模式结构 ####\n\n- Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链\n- ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。\n\n![类图](/images/chain_of_responsibility_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/chain_of_responsibility_sequence_diagram.png)\n\n#### 代码 ####\n\n [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility)\n\n#### 适用场景 ####\n\n - 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的\n - 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求\n - 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 \n\n\n#### 分析 ####\n\n- 责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型\n- 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。\n- 责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。\n- 纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况\n- 不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。\n","slug":"design-patterns-chain-of-responsibility","published":1,"updated":"2017-08-17T02:48:33.599Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1fu004q2sivo87hz8j5","content":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>责任链模式是对象行为型模式<br></p>\n<p>责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br></p>\n<p>客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链</li>\n<li>ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。</li>\n</ul>\n<p><img src=\"/images/chain_of_responsibility_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/chain_of_responsibility_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>\n<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>\n<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型</li>\n<li>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li>\n<li>责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。</li>\n<li>纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况</li>\n<li>不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"what\"><a href=\"#what\" class=\"headerlink\" title=\"what\"></a>what</h4><p>责任链模式是对象行为型模式<br></p>\n<p>责任链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br></p>\n<p>客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现发送者和接收者耦合解耦。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Handler(抽象处理者)：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在此定义了抽象方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链</li>\n<li>ConcreteHandler(具体处理者)：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理，否则转发给后继者。</li>\n</ul>\n<p><img src=\"/images/chain_of_responsibility_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/chain_of_responsibility_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p> <a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ChainOfResponsibility\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>\n<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>\n<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>责任链可以是一条直线、一个环、或者一个树形结构，最常见的的直线型</li>\n<li>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li>\n<li>责任链模式并不创建责任链，责任链的创建工作一般在使用该责任链的客户端完成。</li>\n<li>纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，并且要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被处理的情况</li>\n<li>不纯的责任链模式，关于请求，允许部分处理后向下传递，也允许处理完后继续向下传递，也允许最终不被任何处理者接收。</li>\n</ul>\n"},{"title":"使用Messenger进行进程间通信注意事项","date":"2017-06-08T15:49:35.000Z","_content":"\n#### 需求 ####\n\n![需求示意图](/images/auth_sequence_diagram.png)\n\n看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来\n本来懒得费事，一个`startActivityForResult`即可结束战斗\n后来发现，我的SDK里没有UI，也就没有处理`onActivityResult`的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。\n\n#### Messenger的使用 ####\n此处不是我想略，网上教程很多，看个比较完善简单的：[Android 基于Message的进程间通信 Messenger完全解析](http://blog.csdn.net/lmj623565791/article/details/47017485)\n代码有些地方不适合新的Android版本，但是也够用了。\n\n#### 注意事项 ####\n\n##### 需求问题解决 ####\nSDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。\n其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。\nkotlin代码如下：\n\n    var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\n    private val mMessenger = Messenger(object : Handler() {\n        override fun handleMessage(msgfromClient: Message) {\n            val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n            try {\n                when (msgfromClient.what) {\n                    REMOTE_CLIENT -> {//远程访问-SDK\n                        remoteMsg = msgfromClient.replyTo\n                        var intent: Intent = Intent()\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        val appID: String = bundle.get(\"APPID\") as String\n\n                        //开启授权页Activity\n                        intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                        intent.putExtra(\"appID\", appID)\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                        startActivity(intent)\n                    }\n                    LOCAL_CLIENT -> {//本地访问-授权页\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        msgToClient.obj = bundle//拿到授权页信使带来的code\n                        remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                    }\n                }\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            } catch (e: RemoteException) {\n                e.printStackTrace()\n            }\n\n            super.handleMessage(msgfromClient)\n        }\n    })\n\n\n根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。\n\n##### 单向双向 #####\n\tmsgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。\n\n##### 多向通信 ####\n在这个里[Remote Messenger Service Sample](https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample)可以看到多个客户端互相通信的官方示例。\n官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。\n\n##### 隐式启动service #####\n\n 5.0之后需要：\n\n\t\tIntent intent = new Intent();\n\t\tintent.setAction(action);\n\t\tintent.setPackage(pkgName);\n\t\tcontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n\n##### 魅族手机无法启动 #####\n设置app权限，允许后台运行即可。话说这手机牌子坑爹。\n\n\n##### Can't marshal non-Parcelable objects across processes #####\nmsg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。\n \n \n##### MainActivity has leaked ServiceConnection #####\n页面关闭时，记得unbind","source":"_posts/2017-06-08-android-ipc-messenger-tips.md","raw":"---\ntitle: 使用Messenger进行进程间通信注意事项\ndate: 2017-06-08 15:49:35\ntags: android\ncategories: Android \n---\n\n#### 需求 ####\n\n![需求示意图](/images/auth_sequence_diagram.png)\n\n看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来\n本来懒得费事，一个`startActivityForResult`即可结束战斗\n后来发现，我的SDK里没有UI，也就没有处理`onActivityResult`的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。\n\n#### Messenger的使用 ####\n此处不是我想略，网上教程很多，看个比较完善简单的：[Android 基于Message的进程间通信 Messenger完全解析](http://blog.csdn.net/lmj623565791/article/details/47017485)\n代码有些地方不适合新的Android版本，但是也够用了。\n\n#### 注意事项 ####\n\n##### 需求问题解决 ####\nSDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。\n其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。\nkotlin代码如下：\n\n    var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\n    private val mMessenger = Messenger(object : Handler() {\n        override fun handleMessage(msgfromClient: Message) {\n            val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n            try {\n                when (msgfromClient.what) {\n                    REMOTE_CLIENT -> {//远程访问-SDK\n                        remoteMsg = msgfromClient.replyTo\n                        var intent: Intent = Intent()\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        val appID: String = bundle.get(\"APPID\") as String\n\n                        //开启授权页Activity\n                        intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                        intent.putExtra(\"appID\", appID)\n                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                        startActivity(intent)\n                    }\n                    LOCAL_CLIENT -> {//本地访问-授权页\n                        val bundle: Bundle = msgfromClient.obj as Bundle\n                        msgToClient.obj = bundle//拿到授权页信使带来的code\n                        remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                    }\n                }\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            } catch (e: RemoteException) {\n                e.printStackTrace()\n            }\n\n            super.handleMessage(msgfromClient)\n        }\n    })\n\n\n根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。\n\n##### 单向双向 #####\n\tmsgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。\n\n##### 多向通信 ####\n在这个里[Remote Messenger Service Sample](https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample)可以看到多个客户端互相通信的官方示例。\n官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。\n\n##### 隐式启动service #####\n\n 5.0之后需要：\n\n\t\tIntent intent = new Intent();\n\t\tintent.setAction(action);\n\t\tintent.setPackage(pkgName);\n\t\tcontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n\n##### 魅族手机无法启动 #####\n设置app权限，允许后台运行即可。话说这手机牌子坑爹。\n\n\n##### Can't marshal non-Parcelable objects across processes #####\nmsg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。\n \n \n##### MainActivity has leaked ServiceConnection #####\n页面关闭时，记得unbind","slug":"android-ipc-messenger-tips","published":1,"updated":"2017-11-16T08:29:03.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1fx004t2sivnbus8we0","content":"<h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p><img src=\"/images/auth_sequence_diagram.png\" alt=\"需求示意图\"></p>\n<p>看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来<br>本来懒得费事，一个<code>startActivityForResult</code>即可结束战斗<br>后来发现，我的SDK里没有UI，也就没有处理<code>onActivityResult</code>的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。</p>\n<h4 id=\"Messenger的使用\"><a href=\"#Messenger的使用\" class=\"headerlink\" title=\"Messenger的使用\"></a>Messenger的使用</h4><p>此处不是我想略，网上教程很多，看个比较完善简单的：<a href=\"http://blog.csdn.net/lmj623565791/article/details/47017485\" target=\"_blank\" rel=\"external\">Android 基于Message的进程间通信 Messenger完全解析</a><br>代码有些地方不适合新的Android版本，但是也够用了。</p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><h5 id=\"需求问题解决\"><a href=\"#需求问题解决\" class=\"headerlink\" title=\"需求问题解决\"></a>需求问题解决</h5><p>SDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。<br>其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。<br>kotlin代码如下：</p>\n<pre><code>var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\nprivate val mMessenger = Messenger(object : Handler() {\n    override fun handleMessage(msgfromClient: Message) {\n        val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n        try {\n            when (msgfromClient.what) {\n                REMOTE_CLIENT -&gt; {//远程访问-SDK\n                    remoteMsg = msgfromClient.replyTo\n                    var intent: Intent = Intent()\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    val appID: String = bundle.get(&quot;APPID&quot;) as String\n\n                    //开启授权页Activity\n                    intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                    intent.putExtra(&quot;appID&quot;, appID)\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                    startActivity(intent)\n                }\n                LOCAL_CLIENT -&gt; {//本地访问-授权页\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    msgToClient.obj = bundle//拿到授权页信使带来的code\n                    remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                }\n            }\n        } catch (e: InterruptedException) {\n            e.printStackTrace()\n        } catch (e: RemoteException) {\n            e.printStackTrace()\n        }\n\n        super.handleMessage(msgfromClient)\n    }\n})\n</code></pre><p>根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。</p>\n<h5 id=\"单向双向\"><a href=\"#单向双向\" class=\"headerlink\" title=\"单向双向\"></a>单向双向</h5><pre><code>msgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n</code></pre><p>这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。</p>\n<h5 id=\"多向通信\"><a href=\"#多向通信\" class=\"headerlink\" title=\"多向通信\"></a>多向通信</h5><p>在这个里<a href=\"https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample\" target=\"_blank\" rel=\"external\">Remote Messenger Service Sample</a>可以看到多个客户端互相通信的官方示例。<br>官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。</p>\n<h5 id=\"隐式启动service\"><a href=\"#隐式启动service\" class=\"headerlink\" title=\"隐式启动service\"></a>隐式启动service</h5><p> 5.0之后需要：</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(action);\nintent.setPackage(pkgName);\ncontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n</code></pre><h5 id=\"魅族手机无法启动\"><a href=\"#魅族手机无法启动\" class=\"headerlink\" title=\"魅族手机无法启动\"></a>魅族手机无法启动</h5><p>设置app权限，允许后台运行即可。话说这手机牌子坑爹。</p>\n<h5 id=\"Can’t-marshal-non-Parcelable-objects-across-processes\"><a href=\"#Can’t-marshal-non-Parcelable-objects-across-processes\" class=\"headerlink\" title=\"Can’t marshal non-Parcelable objects across processes\"></a>Can’t marshal non-Parcelable objects across processes</h5><p>msg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。</p>\n<h5 id=\"MainActivity-has-leaked-ServiceConnection\"><a href=\"#MainActivity-has-leaked-ServiceConnection\" class=\"headerlink\" title=\"MainActivity has leaked ServiceConnection\"></a>MainActivity has leaked ServiceConnection</h5><p>页面关闭时，记得unbind</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h4><p><img src=\"/images/auth_sequence_diagram.png\" alt=\"需求示意图\"></p>\n<p>看时序图比较简单，进程间通信，把APPID传过去，把授权码带回来<br>本来懒得费事，一个<code>startActivityForResult</code>即可结束战斗<br>后来发现，我的SDK里没有UI，也就没有处理<code>onActivityResult</code>的地方了，我想过开启一个no ui的Activity，后来还是不要这么简单粗暴了。</p>\n<h4 id=\"Messenger的使用\"><a href=\"#Messenger的使用\" class=\"headerlink\" title=\"Messenger的使用\"></a>Messenger的使用</h4><p>此处不是我想略，网上教程很多，看个比较完善简单的：<a href=\"http://blog.csdn.net/lmj623565791/article/details/47017485\" target=\"_blank\" rel=\"external\">Android 基于Message的进程间通信 Messenger完全解析</a><br>代码有些地方不适合新的Android版本，但是也够用了。</p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><h5 id=\"需求问题解决\"><a href=\"#需求问题解决\" class=\"headerlink\" title=\"需求问题解决\"></a>需求问题解决</h5><p>SDK发送至目标app的一个远程服务，该服务启动授权activity，获取code后，也绑定式启动该服务，找到SDK的信使，把code回传。<br>其中，通信双方其实是SDK和授权页，远程服务在授权app中，起到一个中间桥梁的作用。<br>kotlin代码如下：</p>\n<pre><code>var remoteMsg: Messenger? = null//全局变量，用于保存SDK端的信使，等待授权页的结果回来后，使用其发送msg\nprivate val mMessenger = Messenger(object : Handler() {\n    override fun handleMessage(msgfromClient: Message) {\n        val msgToClient = Message.obtain(msgfromClient)//返回给客户端的消息\n        try {\n            when (msgfromClient.what) {\n                REMOTE_CLIENT -&gt; {//远程访问-SDK\n                    remoteMsg = msgfromClient.replyTo\n                    var intent: Intent = Intent()\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    val appID: String = bundle.get(&quot;APPID&quot;) as String\n\n                    //开启授权页Activity\n                    intent.setClass(this@AuthMessengerService, AuthActivity::class.java)\n                    intent.putExtra(&quot;appID&quot;, appID)\n                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                    startActivity(intent)\n                }\n                LOCAL_CLIENT -&gt; {//本地访问-授权页\n                    val bundle: Bundle = msgfromClient.obj as Bundle\n                    msgToClient.obj = bundle//拿到授权页信使带来的code\n                    remoteMsg!!.send(msgToClient)//使用SDK端的信使发送，即发送给SDK端\n                }\n            }\n        } catch (e: InterruptedException) {\n            e.printStackTrace()\n        } catch (e: RemoteException) {\n            e.printStackTrace()\n        }\n\n        super.handleMessage(msgfromClient)\n    }\n})\n</code></pre><p>根据代码，可以看到SDK和service是双向通信，授权页和service是单向通信。因此授权页通信完成后立刻unbind即可。</p>\n<h5 id=\"单向双向\"><a href=\"#单向双向\" class=\"headerlink\" title=\"单向双向\"></a>单向双向</h5><pre><code>msgFromLocalClient.replyTo = mMessenger//单向通信,不需要回传信使\n</code></pre><p>这句话决定了是否需要信使带回结果，如果需要，在mMessenger 里处理。在示例blog中类似代码可以参考。</p>\n<h5 id=\"多向通信\"><a href=\"#多向通信\" class=\"headerlink\" title=\"多向通信\"></a>多向通信</h5><p>在这个里<a href=\"https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample\" target=\"_blank\" rel=\"external\">Remote Messenger Service Sample</a>可以看到多个客户端互相通信的官方示例。<br>官方示例应该只适应于多对一，如果多对多的话，自个儿实现AIDL比较靠谱。</p>\n<h5 id=\"隐式启动service\"><a href=\"#隐式启动service\" class=\"headerlink\" title=\"隐式启动service\"></a>隐式启动service</h5><p> 5.0之后需要：</p>\n<pre><code>Intent intent = new Intent();\nintent.setAction(action);\nintent.setPackage(pkgName);\ncontext.bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n</code></pre><h5 id=\"魅族手机无法启动\"><a href=\"#魅族手机无法启动\" class=\"headerlink\" title=\"魅族手机无法启动\"></a>魅族手机无法启动</h5><p>设置app权限，允许后台运行即可。话说这手机牌子坑爹。</p>\n<h5 id=\"Can’t-marshal-non-Parcelable-objects-across-processes\"><a href=\"#Can’t-marshal-non-Parcelable-objects-across-processes\" class=\"headerlink\" title=\"Can’t marshal non-Parcelable objects across processes\"></a>Can’t marshal non-Parcelable objects across processes</h5><p>msg里没几个参数，如果要传的东西多，就放入Bundle里面，然后赋值给msg.obj。或者你的自定义对象是Parcelable的也可以直接放入msg.obj。</p>\n<h5 id=\"MainActivity-has-leaked-ServiceConnection\"><a href=\"#MainActivity-has-leaked-ServiceConnection\" class=\"headerlink\" title=\"MainActivity has leaked ServiceConnection\"></a>MainActivity has leaked ServiceConnection</h5><p>页面关闭时，记得unbind</p>\n"},{"title":"HttpRequest学习笔记","date":"2017-06-12T20:13:51.000Z","_content":"\n#### cvc-complex-type.2.4.a: Invalid content was found starting with element 'display-name' ####\n\n`web.xml`在自动生成servlet的时候出现的提示。\n\n通常是由于标签位置，标签DTD的校验规则所影响的。\n\n删除 `http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd` 即不采用该校验规则 \n \n\n#### request 重要方法 ####\n- 获取IP\n- 获取请求方法\n- 获取请求参数\n- 获取浏览器类型\n- 获取协议\n- 获取服务器名\n- 获取服务器端口\n- 获取项目名\n- 获取servlet路径\n- 获取GET参数\n- 获取URI\n- 获取URL\n \n#### 使用referer完成防盗链 ####\n- 在浏览器地址栏直接输入ip，referer为空\n- 从百度输入ip，referer为百度\n\n#### 获取request参数 ####\n- 获取get参数\n- 获取post参数\n- 获取单值\n- 获取多值\n- 获取map\n\n#### 请求转发和请求包含 ####\n\n- 转发：下一个servlet设置响应体，当前servlet只能设置响应头\n- 包含：共同完成响应体\n- 无论转发或者包含，都是使用同一个request/response\n- 使用set/getAttribute来，在两个servlet之间传递参数【request域、session域、application域中都有这个属性的操作，但是其生命周期不同】\n\n##### 和重定向的区别 ####\n- 重定向是两个请求，地址栏地址会改变\n- 转发/包含是一个请求\n- 转发/包含只能转发到本项目的servl\n- 重定向既可以到本项目也可以到别的项目\n- 重定向需要给出requestURI，即全路径\n- 转发/包含是服务端行为\n- 转发/包含效率较高\n\n\n","source":"_posts/2017-06-12-httprequest-study-tips.md","raw":"---\ntitle: HttpRequest学习笔记\ndate: 2017-06-12 20:13:51 \ntags: javaEE\ncategories: NetWork\n---\n\n#### cvc-complex-type.2.4.a: Invalid content was found starting with element 'display-name' ####\n\n`web.xml`在自动生成servlet的时候出现的提示。\n\n通常是由于标签位置，标签DTD的校验规则所影响的。\n\n删除 `http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd` 即不采用该校验规则 \n \n\n#### request 重要方法 ####\n- 获取IP\n- 获取请求方法\n- 获取请求参数\n- 获取浏览器类型\n- 获取协议\n- 获取服务器名\n- 获取服务器端口\n- 获取项目名\n- 获取servlet路径\n- 获取GET参数\n- 获取URI\n- 获取URL\n \n#### 使用referer完成防盗链 ####\n- 在浏览器地址栏直接输入ip，referer为空\n- 从百度输入ip，referer为百度\n\n#### 获取request参数 ####\n- 获取get参数\n- 获取post参数\n- 获取单值\n- 获取多值\n- 获取map\n\n#### 请求转发和请求包含 ####\n\n- 转发：下一个servlet设置响应体，当前servlet只能设置响应头\n- 包含：共同完成响应体\n- 无论转发或者包含，都是使用同一个request/response\n- 使用set/getAttribute来，在两个servlet之间传递参数【request域、session域、application域中都有这个属性的操作，但是其生命周期不同】\n\n##### 和重定向的区别 ####\n- 重定向是两个请求，地址栏地址会改变\n- 转发/包含是一个请求\n- 转发/包含只能转发到本项目的servl\n- 重定向既可以到本项目也可以到别的项目\n- 重定向需要给出requestURI，即全路径\n- 转发/包含是服务端行为\n- 转发/包含效率较高\n\n\n","slug":"httprequest-study-tips","published":1,"updated":"2017-08-17T02:49:23.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1fz004w2sivtux62i4f","content":"<h4 id=\"cvc-complex-type-2-4-a-Invalid-content-was-found-starting-with-element-‘display-name’\"><a href=\"#cvc-complex-type-2-4-a-Invalid-content-was-found-starting-with-element-‘display-name’\" class=\"headerlink\" title=\"cvc-complex-type.2.4.a: Invalid content was found starting with element ‘display-name’\"></a>cvc-complex-type.2.4.a: Invalid content was found starting with element ‘display-name’</h4><p><code>web.xml</code>在自动生成servlet的时候出现的提示。</p>\n<p>通常是由于标签位置，标签DTD的校验规则所影响的。</p>\n<p>删除 <code>http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd</code> 即不采用该校验规则 </p>\n<h4 id=\"request-重要方法\"><a href=\"#request-重要方法\" class=\"headerlink\" title=\"request 重要方法\"></a>request 重要方法</h4><ul>\n<li>获取IP</li>\n<li>获取请求方法</li>\n<li>获取请求参数</li>\n<li>获取浏览器类型</li>\n<li>获取协议</li>\n<li>获取服务器名</li>\n<li>获取服务器端口</li>\n<li>获取项目名</li>\n<li>获取servlet路径</li>\n<li>获取GET参数</li>\n<li>获取URI</li>\n<li>获取URL</li>\n</ul>\n<h4 id=\"使用referer完成防盗链\"><a href=\"#使用referer完成防盗链\" class=\"headerlink\" title=\"使用referer完成防盗链\"></a>使用referer完成防盗链</h4><ul>\n<li>在浏览器地址栏直接输入ip，referer为空</li>\n<li>从百度输入ip，referer为百度</li>\n</ul>\n<h4 id=\"获取request参数\"><a href=\"#获取request参数\" class=\"headerlink\" title=\"获取request参数\"></a>获取request参数</h4><ul>\n<li>获取get参数</li>\n<li>获取post参数</li>\n<li>获取单值</li>\n<li>获取多值</li>\n<li>获取map</li>\n</ul>\n<h4 id=\"请求转发和请求包含\"><a href=\"#请求转发和请求包含\" class=\"headerlink\" title=\"请求转发和请求包含\"></a>请求转发和请求包含</h4><ul>\n<li>转发：下一个servlet设置响应体，当前servlet只能设置响应头</li>\n<li>包含：共同完成响应体</li>\n<li>无论转发或者包含，都是使用同一个request/response</li>\n<li>使用set/getAttribute来，在两个servlet之间传递参数【request域、session域、application域中都有这个属性的操作，但是其生命周期不同】</li>\n</ul>\n<h5 id=\"和重定向的区别\"><a href=\"#和重定向的区别\" class=\"headerlink\" title=\"和重定向的区别\"></a>和重定向的区别</h5><ul>\n<li>重定向是两个请求，地址栏地址会改变</li>\n<li>转发/包含是一个请求</li>\n<li>转发/包含只能转发到本项目的servl</li>\n<li>重定向既可以到本项目也可以到别的项目</li>\n<li>重定向需要给出requestURI，即全路径</li>\n<li>转发/包含是服务端行为</li>\n<li>转发/包含效率较高</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"cvc-complex-type-2-4-a-Invalid-content-was-found-starting-with-element-‘display-name’\"><a href=\"#cvc-complex-type-2-4-a-Invalid-content-was-found-starting-with-element-‘display-name’\" class=\"headerlink\" title=\"cvc-complex-type.2.4.a: Invalid content was found starting with element ‘display-name’\"></a>cvc-complex-type.2.4.a: Invalid content was found starting with element ‘display-name’</h4><p><code>web.xml</code>在自动生成servlet的时候出现的提示。</p>\n<p>通常是由于标签位置，标签DTD的校验规则所影响的。</p>\n<p>删除 <code>http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd</code> 即不采用该校验规则 </p>\n<h4 id=\"request-重要方法\"><a href=\"#request-重要方法\" class=\"headerlink\" title=\"request 重要方法\"></a>request 重要方法</h4><ul>\n<li>获取IP</li>\n<li>获取请求方法</li>\n<li>获取请求参数</li>\n<li>获取浏览器类型</li>\n<li>获取协议</li>\n<li>获取服务器名</li>\n<li>获取服务器端口</li>\n<li>获取项目名</li>\n<li>获取servlet路径</li>\n<li>获取GET参数</li>\n<li>获取URI</li>\n<li>获取URL</li>\n</ul>\n<h4 id=\"使用referer完成防盗链\"><a href=\"#使用referer完成防盗链\" class=\"headerlink\" title=\"使用referer完成防盗链\"></a>使用referer完成防盗链</h4><ul>\n<li>在浏览器地址栏直接输入ip，referer为空</li>\n<li>从百度输入ip，referer为百度</li>\n</ul>\n<h4 id=\"获取request参数\"><a href=\"#获取request参数\" class=\"headerlink\" title=\"获取request参数\"></a>获取request参数</h4><ul>\n<li>获取get参数</li>\n<li>获取post参数</li>\n<li>获取单值</li>\n<li>获取多值</li>\n<li>获取map</li>\n</ul>\n<h4 id=\"请求转发和请求包含\"><a href=\"#请求转发和请求包含\" class=\"headerlink\" title=\"请求转发和请求包含\"></a>请求转发和请求包含</h4><ul>\n<li>转发：下一个servlet设置响应体，当前servlet只能设置响应头</li>\n<li>包含：共同完成响应体</li>\n<li>无论转发或者包含，都是使用同一个request/response</li>\n<li>使用set/getAttribute来，在两个servlet之间传递参数【request域、session域、application域中都有这个属性的操作，但是其生命周期不同】</li>\n</ul>\n<h5 id=\"和重定向的区别\"><a href=\"#和重定向的区别\" class=\"headerlink\" title=\"和重定向的区别\"></a>和重定向的区别</h5><ul>\n<li>重定向是两个请求，地址栏地址会改变</li>\n<li>转发/包含是一个请求</li>\n<li>转发/包含只能转发到本项目的servl</li>\n<li>重定向既可以到本项目也可以到别的项目</li>\n<li>重定向需要给出requestURI，即全路径</li>\n<li>转发/包含是服务端行为</li>\n<li>转发/包含效率较高</li>\n</ul>\n"},{"title":"观察者设计模式","date":"2017-06-09T15:10:47.000Z","_content":"\n#### 定义 ####\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。\n\n观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。\n\n#### 模式结构 ####\n- Subject：目标\n- ConcreteSubject：具体目标\n- Observer：观察者\n- ConcreteObserver：具体观察者\n\n![类图](/images/observer_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/observer_pattern_sequence_diagram.png)\n\n#### 代码 ####\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ObserverPattern)\n#### 分析 ####\n##### 优点 #####\n- 可以实现表示层和数据逻辑层分离，并定义了稳定的消息更新传递机制\n- 观察者和目标之间是一个抽象的耦合\n- 支持广播通信\n- 符合开闭原则\n\n##### 缺点 #####\n- 如果目标有许多观察者，通知所有观察者会花费许多时间\n- 如果观察者和目标之间有循环依赖的话，目标会触发他们之间的循环调用\n- 观察者无法知道目标是如何发生变化的，只是知道目标发生了变化\n\n#### 扩展 ####\nMVC模式可以用观察者模式来实现，其中观察目标就是Model，观察者就是View，中介者就是Controller。当Model数据发生改变，View将自动改变其显示内容。\n","source":"_posts/2017-06-09-design-patterns-observer.md","raw":"---\ntitle: 观察者设计模式\ndate: 2017-06-09 15:10:47\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。\n\n观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。\n\n#### 模式结构 ####\n- Subject：目标\n- ConcreteSubject：具体目标\n- Observer：观察者\n- ConcreteObserver：具体观察者\n\n![类图](/images/observer_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/observer_pattern_sequence_diagram.png)\n\n#### 代码 ####\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ObserverPattern)\n#### 分析 ####\n##### 优点 #####\n- 可以实现表示层和数据逻辑层分离，并定义了稳定的消息更新传递机制\n- 观察者和目标之间是一个抽象的耦合\n- 支持广播通信\n- 符合开闭原则\n\n##### 缺点 #####\n- 如果目标有许多观察者，通知所有观察者会花费许多时间\n- 如果观察者和目标之间有循环依赖的话，目标会触发他们之间的循环调用\n- 观察者无法知道目标是如何发生变化的，只是知道目标发生了变化\n\n#### 扩展 ####\nMVC模式可以用观察者模式来实现，其中观察目标就是Model，观察者就是View，中介者就是Controller。当Model数据发生改变，View将自动改变其显示内容。\n","slug":"design-patterns-observer","published":1,"updated":"2017-08-17T02:49:03.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1g1004z2sivef9n7ub3","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>\n<p>观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Subject：目标</li>\n<li>ConcreteSubject：具体目标</li>\n<li>Observer：观察者</li>\n<li>ConcreteObserver：具体观察者</li>\n</ul>\n<p><img src=\"/images/observer_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/observer_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ObserverPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>可以实现表示层和数据逻辑层分离，并定义了稳定的消息更新传递机制</li>\n<li>观察者和目标之间是一个抽象的耦合</li>\n<li>支持广播通信</li>\n<li>符合开闭原则</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>如果目标有许多观察者，通知所有观察者会花费许多时间</li>\n<li>如果观察者和目标之间有循环依赖的话，目标会触发他们之间的循环调用</li>\n<li>观察者无法知道目标是如何发生变化的，只是知道目标发生了变化</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>MVC模式可以用观察者模式来实现，其中观察目标就是Model，观察者就是View，中介者就是Controller。当Model数据发生改变，View将自动改变其显示内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>\n<p>观察者模式(Observer Pattern)：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(publish/subscribe)模式、模型-视图(model/view)模式、源-监听器(source/listener)模式或从属者(dependents)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Subject：目标</li>\n<li>ConcreteSubject：具体目标</li>\n<li>Observer：观察者</li>\n<li>ConcreteObserver：具体观察者</li>\n</ul>\n<p><img src=\"/images/observer_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/observer_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ObserverPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>可以实现表示层和数据逻辑层分离，并定义了稳定的消息更新传递机制</li>\n<li>观察者和目标之间是一个抽象的耦合</li>\n<li>支持广播通信</li>\n<li>符合开闭原则</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>如果目标有许多观察者，通知所有观察者会花费许多时间</li>\n<li>如果观察者和目标之间有循环依赖的话，目标会触发他们之间的循环调用</li>\n<li>观察者无法知道目标是如何发生变化的，只是知道目标发生了变化</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>MVC模式可以用观察者模式来实现，其中观察目标就是Model，观察者就是View，中介者就是Controller。当Model数据发生改变，View将自动改变其显示内容。</p>\n"},{"title":"认知偏差之决策、信念与行为偏误","date":"2017-06-13T00:00:00.000Z","_content":"\n#### 不明确性效应 ####\n\n人的决策会因为信息的缺乏或“模糊”而受到影响，决策时倾向避开资讯不足的选项。\n\n该效应意味着，人们倾向于选择具有已知可能性的有利结果，而不是未知可能性的有利结果。\n\n人们有一个经验法则来避开信息缺失的选项。这通常会引导他们去寻找缺失的信息。然而，在许多情况下，信息是无法获得的。\n\n[Ambiguity effect](https://en.wikipedia.org/wiki/Ambiguity_effect)\n\n[译文](http://www.jianshu.com/p/7c2a1a9ee31d)\n \n#### 锚定效应 ####\n\n为不熟悉的事物估值时，会把熟悉的类似事物或不久前接触到的无关数值当做“锚”，估出来的数值会大大倾向“锚”。\n\n[WIKI](https://zh.wikipedia.org/wiki/%E9%8C%A8%E5%AE%9A%E6%95%88%E6%87%89)\n\n人类在进行决策时会过度偏重最早取得的第一笔资讯(这称为锚点)，即使这个资讯与这项决定明显无关。在进行决策时，人类倾向于利用最早取得的片段资讯，以快速做出决定，在接下来的决定中，再用第一个决定为基准点，逐步修正。但是人类容易过度利用第一个锚点，来对其他资讯与决定做出诠释，当第一个参考用的锚点与实际上的事实之间的有很大出入，就会造成偏误。\n\n##### 应用 #####\n\n- 我们在公众场合亮相时，谁和我们在一起。因为所以这一切都会影响到别人对我们的评价，我们身边的“锚定”成为评定我们个人价值的基准\n- 一个新产品在货架紧挨着可口可乐、百事可乐，那么他的定价也是这么高，容易被消费者接受\n- 一个店铺，不断在高端百货商店扩展专卖店，常常和名牌店比邻，有利于建立其高端产品的形象","source":"_posts/2017-06-13-ambiguity-effect.md","raw":"---\ntitle: 认知偏差之决策、信念与行为偏误\ndate: 2017-06-13 \ntags: cognition\ncategories: Others\n---\n\n#### 不明确性效应 ####\n\n人的决策会因为信息的缺乏或“模糊”而受到影响，决策时倾向避开资讯不足的选项。\n\n该效应意味着，人们倾向于选择具有已知可能性的有利结果，而不是未知可能性的有利结果。\n\n人们有一个经验法则来避开信息缺失的选项。这通常会引导他们去寻找缺失的信息。然而，在许多情况下，信息是无法获得的。\n\n[Ambiguity effect](https://en.wikipedia.org/wiki/Ambiguity_effect)\n\n[译文](http://www.jianshu.com/p/7c2a1a9ee31d)\n \n#### 锚定效应 ####\n\n为不熟悉的事物估值时，会把熟悉的类似事物或不久前接触到的无关数值当做“锚”，估出来的数值会大大倾向“锚”。\n\n[WIKI](https://zh.wikipedia.org/wiki/%E9%8C%A8%E5%AE%9A%E6%95%88%E6%87%89)\n\n人类在进行决策时会过度偏重最早取得的第一笔资讯(这称为锚点)，即使这个资讯与这项决定明显无关。在进行决策时，人类倾向于利用最早取得的片段资讯，以快速做出决定，在接下来的决定中，再用第一个决定为基准点，逐步修正。但是人类容易过度利用第一个锚点，来对其他资讯与决定做出诠释，当第一个参考用的锚点与实际上的事实之间的有很大出入，就会造成偏误。\n\n##### 应用 #####\n\n- 我们在公众场合亮相时，谁和我们在一起。因为所以这一切都会影响到别人对我们的评价，我们身边的“锚定”成为评定我们个人价值的基准\n- 一个新产品在货架紧挨着可口可乐、百事可乐，那么他的定价也是这么高，容易被消费者接受\n- 一个店铺，不断在高端百货商店扩展专卖店，常常和名牌店比邻，有利于建立其高端产品的形象","slug":"ambiguity-effect","published":1,"updated":"2017-11-16T08:33:51.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1g500542sivu4k379lq","content":"<h4 id=\"不明确性效应\"><a href=\"#不明确性效应\" class=\"headerlink\" title=\"不明确性效应\"></a>不明确性效应</h4><p>人的决策会因为信息的缺乏或“模糊”而受到影响，决策时倾向避开资讯不足的选项。</p>\n<p>该效应意味着，人们倾向于选择具有已知可能性的有利结果，而不是未知可能性的有利结果。</p>\n<p>人们有一个经验法则来避开信息缺失的选项。这通常会引导他们去寻找缺失的信息。然而，在许多情况下，信息是无法获得的。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Ambiguity_effect\" target=\"_blank\" rel=\"external\">Ambiguity effect</a></p>\n<p><a href=\"http://www.jianshu.com/p/7c2a1a9ee31d\" target=\"_blank\" rel=\"external\">译文</a></p>\n<h4 id=\"锚定效应\"><a href=\"#锚定效应\" class=\"headerlink\" title=\"锚定效应\"></a>锚定效应</h4><p>为不熟悉的事物估值时，会把熟悉的类似事物或不久前接触到的无关数值当做“锚”，估出来的数值会大大倾向“锚”。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E9%8C%A8%E5%AE%9A%E6%95%88%E6%87%89\" target=\"_blank\" rel=\"external\">WIKI</a></p>\n<p>人类在进行决策时会过度偏重最早取得的第一笔资讯(这称为锚点)，即使这个资讯与这项决定明显无关。在进行决策时，人类倾向于利用最早取得的片段资讯，以快速做出决定，在接下来的决定中，再用第一个决定为基准点，逐步修正。但是人类容易过度利用第一个锚点，来对其他资讯与决定做出诠释，当第一个参考用的锚点与实际上的事实之间的有很大出入，就会造成偏误。</p>\n<h5 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h5><ul>\n<li>我们在公众场合亮相时，谁和我们在一起。因为所以这一切都会影响到别人对我们的评价，我们身边的“锚定”成为评定我们个人价值的基准</li>\n<li>一个新产品在货架紧挨着可口可乐、百事可乐，那么他的定价也是这么高，容易被消费者接受</li>\n<li>一个店铺，不断在高端百货商店扩展专卖店，常常和名牌店比邻，有利于建立其高端产品的形象</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"不明确性效应\"><a href=\"#不明确性效应\" class=\"headerlink\" title=\"不明确性效应\"></a>不明确性效应</h4><p>人的决策会因为信息的缺乏或“模糊”而受到影响，决策时倾向避开资讯不足的选项。</p>\n<p>该效应意味着，人们倾向于选择具有已知可能性的有利结果，而不是未知可能性的有利结果。</p>\n<p>人们有一个经验法则来避开信息缺失的选项。这通常会引导他们去寻找缺失的信息。然而，在许多情况下，信息是无法获得的。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Ambiguity_effect\" target=\"_blank\" rel=\"external\">Ambiguity effect</a></p>\n<p><a href=\"http://www.jianshu.com/p/7c2a1a9ee31d\" target=\"_blank\" rel=\"external\">译文</a></p>\n<h4 id=\"锚定效应\"><a href=\"#锚定效应\" class=\"headerlink\" title=\"锚定效应\"></a>锚定效应</h4><p>为不熟悉的事物估值时，会把熟悉的类似事物或不久前接触到的无关数值当做“锚”，估出来的数值会大大倾向“锚”。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E9%8C%A8%E5%AE%9A%E6%95%88%E6%87%89\" target=\"_blank\" rel=\"external\">WIKI</a></p>\n<p>人类在进行决策时会过度偏重最早取得的第一笔资讯(这称为锚点)，即使这个资讯与这项决定明显无关。在进行决策时，人类倾向于利用最早取得的片段资讯，以快速做出决定，在接下来的决定中，再用第一个决定为基准点，逐步修正。但是人类容易过度利用第一个锚点，来对其他资讯与决定做出诠释，当第一个参考用的锚点与实际上的事实之间的有很大出入，就会造成偏误。</p>\n<h5 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h5><ul>\n<li>我们在公众场合亮相时，谁和我们在一起。因为所以这一切都会影响到别人对我们的评价，我们身边的“锚定”成为评定我们个人价值的基准</li>\n<li>一个新产品在货架紧挨着可口可乐、百事可乐，那么他的定价也是这么高，容易被消费者接受</li>\n<li>一个店铺，不断在高端百货商店扩展专卖店，常常和名牌店比邻，有利于建立其高端产品的形象</li>\n</ul>\n"},{"title":"字符编码学习笔记","date":"2017-06-13T00:00:00.000Z","_content":"\n#### 常见字符编码 ####\n- ISO-8859-1 不支持中文\n- gbk、gb2312 国标 \n- utf-8 万国码\n\n#### 响应编码 ####\n- 当使用response.getWriter()来向客户端发送字符数据时，如果之前没有设置编码，默认使用ISO，不支持中文\n- 一般浏览器会把数据当做gbk\n- 服务器设置Content-Type响应头，告诉浏览器编码格式 `text/html;charset=utf-8`，同时也设置了响应编码，一句顶两句\n- 使用writer之前，先setContentType\n\n#### 请求编码 ####\n\n- 上次请求返回的Content-Type类型决定表单的编码类型\n- servlet默认使用ISO\n\t- POST：在获取参数之前调用request的setCharacterEncoding\n    - GET： `apache-tomcat-9.0.0.M21/conf/server.xml` 的Connector标签下，设置URIEncoding=\"UTF-8\" 但是`禁止使用`，这是Tomcat的全局设置\n    - GET：先获取GET参数，得到ISO的编码，用ISO反编回来，然后用UTF-8编码\n- Tomcat8 之后默认UTF-8了\n\n#### URL编码 ####\n\n- 不是字符编码，是用来在客户端与服务端之间传递参数用的一种方式\n- 服务器可自动识别URL编码\n- URLEncoder.encode\n\n\n\n","source":"_posts/2017-06-13-coding-study-tips.md","raw":"---\ntitle: 字符编码学习笔记\ndate: 2017-06-13\ntags: javaEE\ncategories: JAVA & kotlin\n---\n\n#### 常见字符编码 ####\n- ISO-8859-1 不支持中文\n- gbk、gb2312 国标 \n- utf-8 万国码\n\n#### 响应编码 ####\n- 当使用response.getWriter()来向客户端发送字符数据时，如果之前没有设置编码，默认使用ISO，不支持中文\n- 一般浏览器会把数据当做gbk\n- 服务器设置Content-Type响应头，告诉浏览器编码格式 `text/html;charset=utf-8`，同时也设置了响应编码，一句顶两句\n- 使用writer之前，先setContentType\n\n#### 请求编码 ####\n\n- 上次请求返回的Content-Type类型决定表单的编码类型\n- servlet默认使用ISO\n\t- POST：在获取参数之前调用request的setCharacterEncoding\n    - GET： `apache-tomcat-9.0.0.M21/conf/server.xml` 的Connector标签下，设置URIEncoding=\"UTF-8\" 但是`禁止使用`，这是Tomcat的全局设置\n    - GET：先获取GET参数，得到ISO的编码，用ISO反编回来，然后用UTF-8编码\n- Tomcat8 之后默认UTF-8了\n\n#### URL编码 ####\n\n- 不是字符编码，是用来在客户端与服务端之间传递参数用的一种方式\n- 服务器可自动识别URL编码\n- URLEncoder.encode\n\n\n\n","slug":"coding-study-tips","published":1,"updated":"2017-08-17T02:49:53.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1ga00572siv444gdlx5","content":"<h4 id=\"常见字符编码\"><a href=\"#常见字符编码\" class=\"headerlink\" title=\"常见字符编码\"></a>常见字符编码</h4><ul>\n<li>ISO-8859-1 不支持中文</li>\n<li>gbk、gb2312 国标 </li>\n<li>utf-8 万国码</li>\n</ul>\n<h4 id=\"响应编码\"><a href=\"#响应编码\" class=\"headerlink\" title=\"响应编码\"></a>响应编码</h4><ul>\n<li>当使用response.getWriter()来向客户端发送字符数据时，如果之前没有设置编码，默认使用ISO，不支持中文</li>\n<li>一般浏览器会把数据当做gbk</li>\n<li>服务器设置Content-Type响应头，告诉浏览器编码格式 <code>text/html;charset=utf-8</code>，同时也设置了响应编码，一句顶两句</li>\n<li>使用writer之前，先setContentType</li>\n</ul>\n<h4 id=\"请求编码\"><a href=\"#请求编码\" class=\"headerlink\" title=\"请求编码\"></a>请求编码</h4><ul>\n<li>上次请求返回的Content-Type类型决定表单的编码类型</li>\n<li>servlet默认使用ISO<ul>\n<li>POST：在获取参数之前调用request的setCharacterEncoding</li>\n<li>GET： <code>apache-tomcat-9.0.0.M21/conf/server.xml</code> 的Connector标签下，设置URIEncoding=”UTF-8” 但是<code>禁止使用</code>，这是Tomcat的全局设置</li>\n<li>GET：先获取GET参数，得到ISO的编码，用ISO反编回来，然后用UTF-8编码</li>\n</ul>\n</li>\n<li>Tomcat8 之后默认UTF-8了</li>\n</ul>\n<h4 id=\"URL编码\"><a href=\"#URL编码\" class=\"headerlink\" title=\"URL编码\"></a>URL编码</h4><ul>\n<li>不是字符编码，是用来在客户端与服务端之间传递参数用的一种方式</li>\n<li>服务器可自动识别URL编码</li>\n<li>URLEncoder.encode</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"常见字符编码\"><a href=\"#常见字符编码\" class=\"headerlink\" title=\"常见字符编码\"></a>常见字符编码</h4><ul>\n<li>ISO-8859-1 不支持中文</li>\n<li>gbk、gb2312 国标 </li>\n<li>utf-8 万国码</li>\n</ul>\n<h4 id=\"响应编码\"><a href=\"#响应编码\" class=\"headerlink\" title=\"响应编码\"></a>响应编码</h4><ul>\n<li>当使用response.getWriter()来向客户端发送字符数据时，如果之前没有设置编码，默认使用ISO，不支持中文</li>\n<li>一般浏览器会把数据当做gbk</li>\n<li>服务器设置Content-Type响应头，告诉浏览器编码格式 <code>text/html;charset=utf-8</code>，同时也设置了响应编码，一句顶两句</li>\n<li>使用writer之前，先setContentType</li>\n</ul>\n<h4 id=\"请求编码\"><a href=\"#请求编码\" class=\"headerlink\" title=\"请求编码\"></a>请求编码</h4><ul>\n<li>上次请求返回的Content-Type类型决定表单的编码类型</li>\n<li>servlet默认使用ISO<ul>\n<li>POST：在获取参数之前调用request的setCharacterEncoding</li>\n<li>GET： <code>apache-tomcat-9.0.0.M21/conf/server.xml</code> 的Connector标签下，设置URIEncoding=”UTF-8” 但是<code>禁止使用</code>，这是Tomcat的全局设置</li>\n<li>GET：先获取GET参数，得到ISO的编码，用ISO反编回来，然后用UTF-8编码</li>\n</ul>\n</li>\n<li>Tomcat8 之后默认UTF-8了</li>\n</ul>\n<h4 id=\"URL编码\"><a href=\"#URL编码\" class=\"headerlink\" title=\"URL编码\"></a>URL编码</h4><ul>\n<li>不是字符编码，是用来在客户端与服务端之间传递参数用的一种方式</li>\n<li>服务器可自动识别URL编码</li>\n<li>URLEncoder.encode</li>\n</ul>\n"},{"title":"中介者设计模式","date":"2017-06-13T00:00:00.000Z","_content":"\n#### 定义 ####\n\n中介者模式(Mediator Pattern):用一中介对象封装一系列对象交互，中介者使对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。中介者模式又称为调停者模式，是一种对象行为型模式。\n \n#### 模式结构 ####\n\n- Mediator：抽象中介者\n- ConcreteMediator：具体中介者\n- Colleague：抽象同事类\n- ConcreteColleague：具体同事类\n \n![类图](/images/mediator_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/mediator_pattern_sequence_diagram.png)\n\n#### 代码 ####\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MediatorPattern)\n#### 分析 ####\n##### 优点 #####\n- 可以使对象的关系数量急剧减少，简化了对象之间的交互\n- 将各同事解耦\n- 减少子类生成\n- 可以简化各同事类的设计和实现\n\n##### 缺点 #####\n- 中介者类中包含了同事之间的交互细节，可能会导致中介者类非常复杂，使得系统难以维护\n\n##### 中介者的职责 #####\n- 结构上的中转作用：通过中介者提供的中转作用，各个同事对象就不再需要显示引用其他同事，当需要和其他同事进行通信时，通过中介者即可。\n- 行为上的协调作用：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。\n \n#### 扩展 ####\n- 当系统中出现了“多对多”交互复杂的关系群时，千万别着急使用中介者模式，你首先需要做的就是反思你的系统在设计上是否合理\n- 虚拟聊天室可用该模式\n- MVC架构中的控制器可以该模式。Controller作为一种中介者，负责控制视图对象View和模型对象Model之间的交互\n- 可方便地应用于图形界面开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系\n\n#### 相较于观察者 ####\n- 中介者涉及到中介和客户，解决的是客户之间消息传递的问题\n- 观察者设计到观察者和目标，解决的是观察者和众多目标之间通信的问题，并非目标之间的通信\n","source":"_posts/2017-06-13-design-patterns-mediator.md","raw":"---\ntitle: 中介者设计模式\ndate: 2017-06-13 \ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n中介者模式(Mediator Pattern):用一中介对象封装一系列对象交互，中介者使对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。中介者模式又称为调停者模式，是一种对象行为型模式。\n \n#### 模式结构 ####\n\n- Mediator：抽象中介者\n- ConcreteMediator：具体中介者\n- Colleague：抽象同事类\n- ConcreteColleague：具体同事类\n \n![类图](/images/mediator_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/mediator_pattern_sequence_diagram.png)\n\n#### 代码 ####\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MediatorPattern)\n#### 分析 ####\n##### 优点 #####\n- 可以使对象的关系数量急剧减少，简化了对象之间的交互\n- 将各同事解耦\n- 减少子类生成\n- 可以简化各同事类的设计和实现\n\n##### 缺点 #####\n- 中介者类中包含了同事之间的交互细节，可能会导致中介者类非常复杂，使得系统难以维护\n\n##### 中介者的职责 #####\n- 结构上的中转作用：通过中介者提供的中转作用，各个同事对象就不再需要显示引用其他同事，当需要和其他同事进行通信时，通过中介者即可。\n- 行为上的协调作用：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。\n \n#### 扩展 ####\n- 当系统中出现了“多对多”交互复杂的关系群时，千万别着急使用中介者模式，你首先需要做的就是反思你的系统在设计上是否合理\n- 虚拟聊天室可用该模式\n- MVC架构中的控制器可以该模式。Controller作为一种中介者，负责控制视图对象View和模型对象Model之间的交互\n- 可方便地应用于图形界面开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系\n\n#### 相较于观察者 ####\n- 中介者涉及到中介和客户，解决的是客户之间消息传递的问题\n- 观察者设计到观察者和目标，解决的是观察者和众多目标之间通信的问题，并非目标之间的通信\n","slug":"design-patterns-mediator","published":1,"updated":"2017-08-17T02:50:04.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gd005a2siv39jut5c5","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>中介者模式(Mediator Pattern):用一中介对象封装一系列对象交互，中介者使对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。中介者模式又称为调停者模式，是一种对象行为型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Mediator：抽象中介者</li>\n<li>ConcreteMediator：具体中介者</li>\n<li>Colleague：抽象同事类</li>\n<li>ConcreteColleague：具体同事类</li>\n</ul>\n<p><img src=\"/images/mediator_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/mediator_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MediatorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>可以使对象的关系数量急剧减少，简化了对象之间的交互</li>\n<li>将各同事解耦</li>\n<li>减少子类生成</li>\n<li>可以简化各同事类的设计和实现</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>中介者类中包含了同事之间的交互细节，可能会导致中介者类非常复杂，使得系统难以维护</li>\n</ul>\n<h5 id=\"中介者的职责\"><a href=\"#中介者的职责\" class=\"headerlink\" title=\"中介者的职责\"></a>中介者的职责</h5><ul>\n<li>结构上的中转作用：通过中介者提供的中转作用，各个同事对象就不再需要显示引用其他同事，当需要和其他同事进行通信时，通过中介者即可。</li>\n<li>行为上的协调作用：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>当系统中出现了“多对多”交互复杂的关系群时，千万别着急使用中介者模式，你首先需要做的就是反思你的系统在设计上是否合理</li>\n<li>虚拟聊天室可用该模式</li>\n<li>MVC架构中的控制器可以该模式。Controller作为一种中介者，负责控制视图对象View和模型对象Model之间的交互</li>\n<li>可方便地应用于图形界面开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系</li>\n</ul>\n<h4 id=\"相较于观察者\"><a href=\"#相较于观察者\" class=\"headerlink\" title=\"相较于观察者\"></a>相较于观察者</h4><ul>\n<li>中介者涉及到中介和客户，解决的是客户之间消息传递的问题</li>\n<li>观察者设计到观察者和目标，解决的是观察者和众多目标之间通信的问题，并非目标之间的通信</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>中介者模式(Mediator Pattern):用一中介对象封装一系列对象交互，中介者使对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。中介者模式又称为调停者模式，是一种对象行为型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Mediator：抽象中介者</li>\n<li>ConcreteMediator：具体中介者</li>\n<li>Colleague：抽象同事类</li>\n<li>ConcreteColleague：具体同事类</li>\n</ul>\n<p><img src=\"/images/mediator_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/mediator_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MediatorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>可以使对象的关系数量急剧减少，简化了对象之间的交互</li>\n<li>将各同事解耦</li>\n<li>减少子类生成</li>\n<li>可以简化各同事类的设计和实现</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>中介者类中包含了同事之间的交互细节，可能会导致中介者类非常复杂，使得系统难以维护</li>\n</ul>\n<h5 id=\"中介者的职责\"><a href=\"#中介者的职责\" class=\"headerlink\" title=\"中介者的职责\"></a>中介者的职责</h5><ul>\n<li>结构上的中转作用：通过中介者提供的中转作用，各个同事对象就不再需要显示引用其他同事，当需要和其他同事进行通信时，通过中介者即可。</li>\n<li>行为上的协调作用：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>当系统中出现了“多对多”交互复杂的关系群时，千万别着急使用中介者模式，你首先需要做的就是反思你的系统在设计上是否合理</li>\n<li>虚拟聊天室可用该模式</li>\n<li>MVC架构中的控制器可以该模式。Controller作为一种中介者，负责控制视图对象View和模型对象Model之间的交互</li>\n<li>可方便地应用于图形界面开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系</li>\n</ul>\n<h4 id=\"相较于观察者\"><a href=\"#相较于观察者\" class=\"headerlink\" title=\"相较于观察者\"></a>相较于观察者</h4><ul>\n<li>中介者涉及到中介和客户，解决的是客户之间消息传递的问题</li>\n<li>观察者设计到观察者和目标，解决的是观察者和众多目标之间通信的问题，并非目标之间的通信</li>\n</ul>\n"},{"title":"JSP、Cookie、Session学习","date":"2017-06-14T00:00:00.000Z","_content":"\n#### JSP定义 ####\nJava server page\n##### jsp和servlet #####\n\n- servlet不适合设置HTML响应体，需要大量的response.getWriter().pring(\"\");\n- servlet 动态资源，可以编程\n- HTML是静态页面，不能包含动态信息\n- HTML不用为输出HTML标签而发愁\n- jsp在原有HTML的基础上添加Java脚本，构成jsp页面\n- jsp作为请求发起/结束页面\n- servlet作为请求中处理数据的环节\n\n##### jsp组成 #####\n\n- jsp = html + java脚本 + jsp标签\n- jsp中无需创建即可使用的对象共9个，被称之为9大内置对象。例如：request对象、out对象\n- 3中Java脚本\n\t- <%...%>放置Java代码\n\t- <%=...%>Java表达式，用于输出一条表达式或变量的结果\n\t- <%!...%>声明，用来创建类的成员变量和成员方法\n\t- <%-- ... ---%> jsp注释\n\n##### jsp原理 #####\n\n- jsp其实是一个特殊的servlet。\n- 当jsp第一次被访问，服务器会把jsp编译成Java文件，这个Java文件其实实现了servlet接口\n- 把该Java编译成.class文件\n- 然后创建该类对象\n- 最好调用其service方法\n- 第二次请求时，直接调用其service方法\n\n#### 会话跟踪技术 ####\n\n- Cookie\n\n#### Cookie ####\n\n- 由服务器创建保存到客户端的浏览器的一个键值对，服务器保存Cookie的响应头：Set-Cookie:aaa=AAA\n- Cookie由HTTP协议制定的\n- 当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头\n- 1个Cookie最大4kb\n- 1个服务器最多向一个浏览器保存20个Cookie\n- 1个浏览器最多保存300个Cookie，由于浏览器竞争，肯定都超4kb,20,300了。\n\n##### 作用 #####\n\n- 服务端使用Cookie来跟踪客户端状态\n- 保存商品浏览记录\n- 显示上次登录名\n\n##### 使用 #####\n\n- response.addCookie()\n- request.getCookies()\n\n##### 详解 #####\n\n- maxAge:最大生命时长以秒为单位\n- path：并非Cookie在客户端的路径，而是浏览器访问服务器的路径，如果包含某个Cookie的路径，那么就会归还这个Cookie\n- domain：指定Cookie的域名，当多个二级域中共享Cookie时才有用\n\t- 例如：www.baidu.com,zhidao.baidu.com,news.baidu.com,tieba.baidu.com共用Cookie时使用domain,设置domain为:cookie.setDomain(\".baidu.com\");\n\t- 必须设置path为：cookie.setPath(\"/\");\n\n#### HttpSession ####\n\n- JavaWeb提供的类，用来会话跟踪的类。session是服务端对象，保存在服务器\n- HttpSession是Servlet三大域对象之一\n- HttpSession底层依赖Cookie，或是URL重写\n- 会话范围\n- session是JSP内置对象\n\n##### session原理 #####\n\n- UUID生成session，32位长，不重复的\n- getSession\n- getMaxInactiveInterval(),获取最大不活动时间，秒单位\n- invalidate() 让session立刻失效，用于用户登出\n- isNew() session是否为最新\n- web.xml中可以配置session的最大不活动时间\n\t- <session-config><session-timeout>4</session-timeout></session-config>\n\n\n##### URL重写 #####\n\n- 浏览器禁用cookie时，URL重写添加JSession字段\n- response.encodeURL(\"/xxxxservlet\");会查看cookie是否存在，如果存在就只encode这个url，否则在url添加JSessionId。这就是智能URL重写\n\n#### JSP三大指令 ####\n\n##### page #####\n\n- <%@page language=\"java\" info=\"xxx\" ...%>一个jsp页面中可以0-N个指令定义\n- 习惯性放在jsp文件的首行\n- pageEncoding：指定当前jsp页面的编码\n- contentType\n- errorPage 出错时转发到指定页面\n- isErrorPage 指定当前页面是否为处理错误的页面，该页面会设置状态为500！只有该页面可以使用9大内置对象exception\n- web.xml配置errorpage，<error-page><error-code>404</error-code><location></location></error-page>\n- autoFlush：指定jsp的输出流，缓冲区满时是否自动刷新，默认为true，如果为false，那么缓冲区满时会抛出异常。\n- buffer：指定缓冲区的大小，默认8kb，通常不需要修改。\n- isELIgnored：是否忽略el表达式，默认是false，不忽略，即支持el表达式\n- language：指定当前jsp编译后的语言类型，默认值java。也只能是java\n- info：信息\n- isThreadSafe：当前的jsp是否支持并发访问。默认为false，支持。\n- session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象。\n- extends：让jsp生成的servlet去继承该属性指定的类\n\n##### include #####\n\n- <%@include%> 在jsp编译成java文件时完成，他们共同生成一个java文件，然后再生成一个class\n- RequestDispatcher的include是一个方法，包含和被包含是两个文件\n\n\n##### taglib #####\n\n- <%@ taglib prefix=\"fn\" uri=\"\"%> //引入EL函数库\n\n#### JSP九大内置对象 ####\n\n- out:jsp输出流，用了向客户端享元\n- config：servletConfig对象\n- exception：Throwable\n- session：httpSession\n- response：httpServletResponse\n- request：HttpServletRequest\n- page：当前jsp对象，他的引用类型为Object。Object page = this；\n- application：servletContext\n- *pageContext：最重要。\n\t- Servlet中有三大对象，jsp中有四大域\n\t\t- servletContext\n\t\t- session\n\t\t- request\n\t\t- pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据\n\t\t\t- 域对象\n\t\t\t- 代理其他域\n\t\t\t- 获取其他8个内置对象\n\n#### JSP动作标签 ####\n\n- 与html标签有本质的区别，动作标签是由tomcat解释执行，html由浏览器来执行\n- 20个，用处不大\n- <jsp:forward>:转发！\n- <jsp:include>:包含\n- <jsp:param>:forward和include的子标签，用来传递参数\n\n#### JavaBean概念 ####\n\n- 必须为成员提供get/set方法，只提供一个也行\n- 必须要有默认构造\n- 此时称成员为属性\n\n\n#### EL表达式 ####\n\n- EL是JSP内置的表达式语言\n- ${}\n- EL替代的是<%= %>，只能做输出\n- \n- EL表达式读取四大域\n\t- ${xxx}\n\t- ${pageScope.xxx},${requestScope.xxx},${sessionScope.xxx},${applicationScope.xxx}，指定域获取信息\n- javaBean导航\n-  11个内置对象\n\t-  param\n\t-  initParam\n\t-  paramValues\n\t-  header\n\t-  headerValues\n\t-  Cookie:Map<String ,Cookie>\n\t-  pageContext\n\n\n`update @ 2017年7月14日18:51:25`\n \n#### EL函数库 ####\n\n- <%@ taglib prefix=\"fn\" uri=\"\"%> //引入标签库\n\n\n##### 自定义函数库 #####\n\n- 写一个java类，类中可以定义0-N个方法，但必须是static，并且有返回值的\n- 写一个.tld文件\n- 在jsp页面中导入标签库\n- 在jsp中使用\n- ","source":"_posts/2017-06-14-jsp-study-tips.md","raw":"---\ntitle: JSP、Cookie、Session学习\ndate: 2017-06-14 \ntags: javaEE\ncategories: JAVA & kotlin\n---\n\n#### JSP定义 ####\nJava server page\n##### jsp和servlet #####\n\n- servlet不适合设置HTML响应体，需要大量的response.getWriter().pring(\"\");\n- servlet 动态资源，可以编程\n- HTML是静态页面，不能包含动态信息\n- HTML不用为输出HTML标签而发愁\n- jsp在原有HTML的基础上添加Java脚本，构成jsp页面\n- jsp作为请求发起/结束页面\n- servlet作为请求中处理数据的环节\n\n##### jsp组成 #####\n\n- jsp = html + java脚本 + jsp标签\n- jsp中无需创建即可使用的对象共9个，被称之为9大内置对象。例如：request对象、out对象\n- 3中Java脚本\n\t- <%...%>放置Java代码\n\t- <%=...%>Java表达式，用于输出一条表达式或变量的结果\n\t- <%!...%>声明，用来创建类的成员变量和成员方法\n\t- <%-- ... ---%> jsp注释\n\n##### jsp原理 #####\n\n- jsp其实是一个特殊的servlet。\n- 当jsp第一次被访问，服务器会把jsp编译成Java文件，这个Java文件其实实现了servlet接口\n- 把该Java编译成.class文件\n- 然后创建该类对象\n- 最好调用其service方法\n- 第二次请求时，直接调用其service方法\n\n#### 会话跟踪技术 ####\n\n- Cookie\n\n#### Cookie ####\n\n- 由服务器创建保存到客户端的浏览器的一个键值对，服务器保存Cookie的响应头：Set-Cookie:aaa=AAA\n- Cookie由HTTP协议制定的\n- 当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头\n- 1个Cookie最大4kb\n- 1个服务器最多向一个浏览器保存20个Cookie\n- 1个浏览器最多保存300个Cookie，由于浏览器竞争，肯定都超4kb,20,300了。\n\n##### 作用 #####\n\n- 服务端使用Cookie来跟踪客户端状态\n- 保存商品浏览记录\n- 显示上次登录名\n\n##### 使用 #####\n\n- response.addCookie()\n- request.getCookies()\n\n##### 详解 #####\n\n- maxAge:最大生命时长以秒为单位\n- path：并非Cookie在客户端的路径，而是浏览器访问服务器的路径，如果包含某个Cookie的路径，那么就会归还这个Cookie\n- domain：指定Cookie的域名，当多个二级域中共享Cookie时才有用\n\t- 例如：www.baidu.com,zhidao.baidu.com,news.baidu.com,tieba.baidu.com共用Cookie时使用domain,设置domain为:cookie.setDomain(\".baidu.com\");\n\t- 必须设置path为：cookie.setPath(\"/\");\n\n#### HttpSession ####\n\n- JavaWeb提供的类，用来会话跟踪的类。session是服务端对象，保存在服务器\n- HttpSession是Servlet三大域对象之一\n- HttpSession底层依赖Cookie，或是URL重写\n- 会话范围\n- session是JSP内置对象\n\n##### session原理 #####\n\n- UUID生成session，32位长，不重复的\n- getSession\n- getMaxInactiveInterval(),获取最大不活动时间，秒单位\n- invalidate() 让session立刻失效，用于用户登出\n- isNew() session是否为最新\n- web.xml中可以配置session的最大不活动时间\n\t- <session-config><session-timeout>4</session-timeout></session-config>\n\n\n##### URL重写 #####\n\n- 浏览器禁用cookie时，URL重写添加JSession字段\n- response.encodeURL(\"/xxxxservlet\");会查看cookie是否存在，如果存在就只encode这个url，否则在url添加JSessionId。这就是智能URL重写\n\n#### JSP三大指令 ####\n\n##### page #####\n\n- <%@page language=\"java\" info=\"xxx\" ...%>一个jsp页面中可以0-N个指令定义\n- 习惯性放在jsp文件的首行\n- pageEncoding：指定当前jsp页面的编码\n- contentType\n- errorPage 出错时转发到指定页面\n- isErrorPage 指定当前页面是否为处理错误的页面，该页面会设置状态为500！只有该页面可以使用9大内置对象exception\n- web.xml配置errorpage，<error-page><error-code>404</error-code><location></location></error-page>\n- autoFlush：指定jsp的输出流，缓冲区满时是否自动刷新，默认为true，如果为false，那么缓冲区满时会抛出异常。\n- buffer：指定缓冲区的大小，默认8kb，通常不需要修改。\n- isELIgnored：是否忽略el表达式，默认是false，不忽略，即支持el表达式\n- language：指定当前jsp编译后的语言类型，默认值java。也只能是java\n- info：信息\n- isThreadSafe：当前的jsp是否支持并发访问。默认为false，支持。\n- session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象。\n- extends：让jsp生成的servlet去继承该属性指定的类\n\n##### include #####\n\n- <%@include%> 在jsp编译成java文件时完成，他们共同生成一个java文件，然后再生成一个class\n- RequestDispatcher的include是一个方法，包含和被包含是两个文件\n\n\n##### taglib #####\n\n- <%@ taglib prefix=\"fn\" uri=\"\"%> //引入EL函数库\n\n#### JSP九大内置对象 ####\n\n- out:jsp输出流，用了向客户端享元\n- config：servletConfig对象\n- exception：Throwable\n- session：httpSession\n- response：httpServletResponse\n- request：HttpServletRequest\n- page：当前jsp对象，他的引用类型为Object。Object page = this；\n- application：servletContext\n- *pageContext：最重要。\n\t- Servlet中有三大对象，jsp中有四大域\n\t\t- servletContext\n\t\t- session\n\t\t- request\n\t\t- pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据\n\t\t\t- 域对象\n\t\t\t- 代理其他域\n\t\t\t- 获取其他8个内置对象\n\n#### JSP动作标签 ####\n\n- 与html标签有本质的区别，动作标签是由tomcat解释执行，html由浏览器来执行\n- 20个，用处不大\n- <jsp:forward>:转发！\n- <jsp:include>:包含\n- <jsp:param>:forward和include的子标签，用来传递参数\n\n#### JavaBean概念 ####\n\n- 必须为成员提供get/set方法，只提供一个也行\n- 必须要有默认构造\n- 此时称成员为属性\n\n\n#### EL表达式 ####\n\n- EL是JSP内置的表达式语言\n- ${}\n- EL替代的是<%= %>，只能做输出\n- \n- EL表达式读取四大域\n\t- ${xxx}\n\t- ${pageScope.xxx},${requestScope.xxx},${sessionScope.xxx},${applicationScope.xxx}，指定域获取信息\n- javaBean导航\n-  11个内置对象\n\t-  param\n\t-  initParam\n\t-  paramValues\n\t-  header\n\t-  headerValues\n\t-  Cookie:Map<String ,Cookie>\n\t-  pageContext\n\n\n`update @ 2017年7月14日18:51:25`\n \n#### EL函数库 ####\n\n- <%@ taglib prefix=\"fn\" uri=\"\"%> //引入标签库\n\n\n##### 自定义函数库 #####\n\n- 写一个java类，类中可以定义0-N个方法，但必须是static，并且有返回值的\n- 写一个.tld文件\n- 在jsp页面中导入标签库\n- 在jsp中使用\n- ","slug":"jsp-study-tips","published":1,"updated":"2017-09-13T11:41:22.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gg005e2sivk1tx9w6f","content":"<h4 id=\"JSP定义\"><a href=\"#JSP定义\" class=\"headerlink\" title=\"JSP定义\"></a>JSP定义</h4><p>Java server page</p>\n<h5 id=\"jsp和servlet\"><a href=\"#jsp和servlet\" class=\"headerlink\" title=\"jsp和servlet\"></a>jsp和servlet</h5><ul>\n<li>servlet不适合设置HTML响应体，需要大量的response.getWriter().pring(“”);</li>\n<li>servlet 动态资源，可以编程</li>\n<li>HTML是静态页面，不能包含动态信息</li>\n<li>HTML不用为输出HTML标签而发愁</li>\n<li>jsp在原有HTML的基础上添加Java脚本，构成jsp页面</li>\n<li>jsp作为请求发起/结束页面</li>\n<li>servlet作为请求中处理数据的环节</li>\n</ul>\n<h5 id=\"jsp组成\"><a href=\"#jsp组成\" class=\"headerlink\" title=\"jsp组成\"></a>jsp组成</h5><ul>\n<li>jsp = html + java脚本 + jsp标签</li>\n<li>jsp中无需创建即可使用的对象共9个，被称之为9大内置对象。例如：request对象、out对象</li>\n<li>3中Java脚本<ul>\n<li>&lt;%…%&gt;放置Java代码</li>\n<li>&lt;%=…%&gt;Java表达式，用于输出一条表达式或变量的结果</li>\n<li>&lt;%!…%&gt;声明，用来创建类的成员变量和成员方法</li>\n<li>&lt;%– … —%&gt; jsp注释</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"jsp原理\"><a href=\"#jsp原理\" class=\"headerlink\" title=\"jsp原理\"></a>jsp原理</h5><ul>\n<li>jsp其实是一个特殊的servlet。</li>\n<li>当jsp第一次被访问，服务器会把jsp编译成Java文件，这个Java文件其实实现了servlet接口</li>\n<li>把该Java编译成.class文件</li>\n<li>然后创建该类对象</li>\n<li>最好调用其service方法</li>\n<li>第二次请求时，直接调用其service方法</li>\n</ul>\n<h4 id=\"会话跟踪技术\"><a href=\"#会话跟踪技术\" class=\"headerlink\" title=\"会话跟踪技术\"></a>会话跟踪技术</h4><ul>\n<li>Cookie</li>\n</ul>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><ul>\n<li>由服务器创建保存到客户端的浏览器的一个键值对，服务器保存Cookie的响应头：Set-Cookie:aaa=AAA</li>\n<li>Cookie由HTTP协议制定的</li>\n<li>当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头</li>\n<li>1个Cookie最大4kb</li>\n<li>1个服务器最多向一个浏览器保存20个Cookie</li>\n<li>1个浏览器最多保存300个Cookie，由于浏览器竞争，肯定都超4kb,20,300了。</li>\n</ul>\n<h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><ul>\n<li>服务端使用Cookie来跟踪客户端状态</li>\n<li>保存商品浏览记录</li>\n<li>显示上次登录名</li>\n</ul>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><ul>\n<li>response.addCookie()</li>\n<li>request.getCookies()</li>\n</ul>\n<h5 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h5><ul>\n<li>maxAge:最大生命时长以秒为单位</li>\n<li>path：并非Cookie在客户端的路径，而是浏览器访问服务器的路径，如果包含某个Cookie的路径，那么就会归还这个Cookie</li>\n<li>domain：指定Cookie的域名，当多个二级域中共享Cookie时才有用<ul>\n<li>例如：www.baidu.com,zhidao.baidu.com,news.baidu.com,tieba.baidu.com共用Cookie时使用domain,设置domain为:cookie.setDomain(“.baidu.com”);</li>\n<li>必须设置path为：cookie.setPath(“/“);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"HttpSession\"><a href=\"#HttpSession\" class=\"headerlink\" title=\"HttpSession\"></a>HttpSession</h4><ul>\n<li>JavaWeb提供的类，用来会话跟踪的类。session是服务端对象，保存在服务器</li>\n<li>HttpSession是Servlet三大域对象之一</li>\n<li>HttpSession底层依赖Cookie，或是URL重写</li>\n<li>会话范围</li>\n<li>session是JSP内置对象</li>\n</ul>\n<h5 id=\"session原理\"><a href=\"#session原理\" class=\"headerlink\" title=\"session原理\"></a>session原理</h5><ul>\n<li>UUID生成session，32位长，不重复的</li>\n<li>getSession</li>\n<li>getMaxInactiveInterval(),获取最大不活动时间，秒单位</li>\n<li>invalidate() 让session立刻失效，用于用户登出</li>\n<li>isNew() session是否为最新</li>\n<li>web.xml中可以配置session的最大不活动时间<ul>\n<li><session-config><session-timeout>4</session-timeout></session-config></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"URL重写\"><a href=\"#URL重写\" class=\"headerlink\" title=\"URL重写\"></a>URL重写</h5><ul>\n<li>浏览器禁用cookie时，URL重写添加JSession字段</li>\n<li>response.encodeURL(“/xxxxservlet”);会查看cookie是否存在，如果存在就只encode这个url，否则在url添加JSessionId。这就是智能URL重写</li>\n</ul>\n<h4 id=\"JSP三大指令\"><a href=\"#JSP三大指令\" class=\"headerlink\" title=\"JSP三大指令\"></a>JSP三大指令</h4><h5 id=\"page\"><a href=\"#page\" class=\"headerlink\" title=\"page\"></a>page</h5><ul>\n<li>&lt;%@page language=”java” info=”xxx” …%&gt;一个jsp页面中可以0-N个指令定义</li>\n<li>习惯性放在jsp文件的首行</li>\n<li>pageEncoding：指定当前jsp页面的编码</li>\n<li>contentType</li>\n<li>errorPage 出错时转发到指定页面</li>\n<li>isErrorPage 指定当前页面是否为处理错误的页面，该页面会设置状态为500！只有该页面可以使用9大内置对象exception</li>\n<li>web.xml配置errorpage，<error-page><error-code>404</error-code><location></location></error-page></li>\n<li>autoFlush：指定jsp的输出流，缓冲区满时是否自动刷新，默认为true，如果为false，那么缓冲区满时会抛出异常。</li>\n<li>buffer：指定缓冲区的大小，默认8kb，通常不需要修改。</li>\n<li>isELIgnored：是否忽略el表达式，默认是false，不忽略，即支持el表达式</li>\n<li>language：指定当前jsp编译后的语言类型，默认值java。也只能是java</li>\n<li>info：信息</li>\n<li>isThreadSafe：当前的jsp是否支持并发访问。默认为false，支持。</li>\n<li>session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象。</li>\n<li>extends：让jsp生成的servlet去继承该属性指定的类</li>\n</ul>\n<h5 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h5><ul>\n<li><a href=\"&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x25;&#64;&#105;&#x6e;&#99;&#108;&#x75;&#x64;&#101;&#x25;\">&#x25;&#64;&#105;&#x6e;&#99;&#108;&#x75;&#x64;&#101;&#x25;</a> 在jsp编译成java文件时完成，他们共同生成一个java文件，然后再生成一个class</li>\n<li>RequestDispatcher的include是一个方法，包含和被包含是两个文件</li>\n</ul>\n<h5 id=\"taglib\"><a href=\"#taglib\" class=\"headerlink\" title=\"taglib\"></a>taglib</h5><ul>\n<li>&lt;%@ taglib prefix=”fn” uri=””%&gt; //引入EL函数库</li>\n</ul>\n<h4 id=\"JSP九大内置对象\"><a href=\"#JSP九大内置对象\" class=\"headerlink\" title=\"JSP九大内置对象\"></a>JSP九大内置对象</h4><ul>\n<li>out:jsp输出流，用了向客户端享元</li>\n<li>config：servletConfig对象</li>\n<li>exception：Throwable</li>\n<li>session：httpSession</li>\n<li>response：httpServletResponse</li>\n<li>request：HttpServletRequest</li>\n<li>page：当前jsp对象，他的引用类型为Object。Object page = this；</li>\n<li>application：servletContext</li>\n<li>*pageContext：最重要。<ul>\n<li>Servlet中有三大对象，jsp中有四大域<ul>\n<li>servletContext</li>\n<li>session</li>\n<li>request</li>\n<li>pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据<ul>\n<li>域对象</li>\n<li>代理其他域</li>\n<li>获取其他8个内置对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JSP动作标签\"><a href=\"#JSP动作标签\" class=\"headerlink\" title=\"JSP动作标签\"></a>JSP动作标签</h4><ul>\n<li>与html标签有本质的区别，动作标签是由tomcat解释执行，html由浏览器来执行</li>\n<li>20个，用处不大</li>\n<li><jsp:forward>:转发！</jsp:forward></li>\n<li><jsp:include>:包含</jsp:include></li>\n<li><jsp:param>:forward和include的子标签，用来传递参数</jsp:param></li>\n</ul>\n<h4 id=\"JavaBean概念\"><a href=\"#JavaBean概念\" class=\"headerlink\" title=\"JavaBean概念\"></a>JavaBean概念</h4><ul>\n<li>必须为成员提供get/set方法，只提供一个也行</li>\n<li>必须要有默认构造</li>\n<li>此时称成员为属性</li>\n</ul>\n<h4 id=\"EL表达式\"><a href=\"#EL表达式\" class=\"headerlink\" title=\"EL表达式\"></a>EL表达式</h4><ul>\n<li>EL是JSP内置的表达式语言</li>\n<li>${}</li>\n<li>EL替代的是&lt;%= %&gt;，只能做输出</li>\n<li></li>\n<li>EL表达式读取四大域<ul>\n<li>${xxx}</li>\n<li>${pageScope.xxx},${requestScope.xxx},${sessionScope.xxx},${applicationScope.xxx}，指定域获取信息</li>\n</ul>\n</li>\n<li>javaBean导航</li>\n<li>11个内置对象<ul>\n<li>param</li>\n<li>initParam</li>\n<li>paramValues</li>\n<li>header</li>\n<li>headerValues</li>\n<li>Cookie:Map<string ,cookie=\"\"></string></li>\n<li>pageContext</li>\n</ul>\n</li>\n</ul>\n<p><code>update @ 2017年7月14日18:51:25</code></p>\n<h4 id=\"EL函数库\"><a href=\"#EL函数库\" class=\"headerlink\" title=\"EL函数库\"></a>EL函数库</h4><ul>\n<li>&lt;%@ taglib prefix=”fn” uri=””%&gt; //引入标签库</li>\n</ul>\n<h5 id=\"自定义函数库\"><a href=\"#自定义函数库\" class=\"headerlink\" title=\"自定义函数库\"></a>自定义函数库</h5><ul>\n<li>写一个java类，类中可以定义0-N个方法，但必须是static，并且有返回值的</li>\n<li>写一个.tld文件</li>\n<li>在jsp页面中导入标签库</li>\n<li>在jsp中使用</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JSP定义\"><a href=\"#JSP定义\" class=\"headerlink\" title=\"JSP定义\"></a>JSP定义</h4><p>Java server page</p>\n<h5 id=\"jsp和servlet\"><a href=\"#jsp和servlet\" class=\"headerlink\" title=\"jsp和servlet\"></a>jsp和servlet</h5><ul>\n<li>servlet不适合设置HTML响应体，需要大量的response.getWriter().pring(“”);</li>\n<li>servlet 动态资源，可以编程</li>\n<li>HTML是静态页面，不能包含动态信息</li>\n<li>HTML不用为输出HTML标签而发愁</li>\n<li>jsp在原有HTML的基础上添加Java脚本，构成jsp页面</li>\n<li>jsp作为请求发起/结束页面</li>\n<li>servlet作为请求中处理数据的环节</li>\n</ul>\n<h5 id=\"jsp组成\"><a href=\"#jsp组成\" class=\"headerlink\" title=\"jsp组成\"></a>jsp组成</h5><ul>\n<li>jsp = html + java脚本 + jsp标签</li>\n<li>jsp中无需创建即可使用的对象共9个，被称之为9大内置对象。例如：request对象、out对象</li>\n<li>3中Java脚本<ul>\n<li>&lt;%…%&gt;放置Java代码</li>\n<li>&lt;%=…%&gt;Java表达式，用于输出一条表达式或变量的结果</li>\n<li>&lt;%!…%&gt;声明，用来创建类的成员变量和成员方法</li>\n<li>&lt;%– … —%&gt; jsp注释</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"jsp原理\"><a href=\"#jsp原理\" class=\"headerlink\" title=\"jsp原理\"></a>jsp原理</h5><ul>\n<li>jsp其实是一个特殊的servlet。</li>\n<li>当jsp第一次被访问，服务器会把jsp编译成Java文件，这个Java文件其实实现了servlet接口</li>\n<li>把该Java编译成.class文件</li>\n<li>然后创建该类对象</li>\n<li>最好调用其service方法</li>\n<li>第二次请求时，直接调用其service方法</li>\n</ul>\n<h4 id=\"会话跟踪技术\"><a href=\"#会话跟踪技术\" class=\"headerlink\" title=\"会话跟踪技术\"></a>会话跟踪技术</h4><ul>\n<li>Cookie</li>\n</ul>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><ul>\n<li>由服务器创建保存到客户端的浏览器的一个键值对，服务器保存Cookie的响应头：Set-Cookie:aaa=AAA</li>\n<li>Cookie由HTTP协议制定的</li>\n<li>当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头</li>\n<li>1个Cookie最大4kb</li>\n<li>1个服务器最多向一个浏览器保存20个Cookie</li>\n<li>1个浏览器最多保存300个Cookie，由于浏览器竞争，肯定都超4kb,20,300了。</li>\n</ul>\n<h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><ul>\n<li>服务端使用Cookie来跟踪客户端状态</li>\n<li>保存商品浏览记录</li>\n<li>显示上次登录名</li>\n</ul>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><ul>\n<li>response.addCookie()</li>\n<li>request.getCookies()</li>\n</ul>\n<h5 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h5><ul>\n<li>maxAge:最大生命时长以秒为单位</li>\n<li>path：并非Cookie在客户端的路径，而是浏览器访问服务器的路径，如果包含某个Cookie的路径，那么就会归还这个Cookie</li>\n<li>domain：指定Cookie的域名，当多个二级域中共享Cookie时才有用<ul>\n<li>例如：www.baidu.com,zhidao.baidu.com,news.baidu.com,tieba.baidu.com共用Cookie时使用domain,设置domain为:cookie.setDomain(“.baidu.com”);</li>\n<li>必须设置path为：cookie.setPath(“/“);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"HttpSession\"><a href=\"#HttpSession\" class=\"headerlink\" title=\"HttpSession\"></a>HttpSession</h4><ul>\n<li>JavaWeb提供的类，用来会话跟踪的类。session是服务端对象，保存在服务器</li>\n<li>HttpSession是Servlet三大域对象之一</li>\n<li>HttpSession底层依赖Cookie，或是URL重写</li>\n<li>会话范围</li>\n<li>session是JSP内置对象</li>\n</ul>\n<h5 id=\"session原理\"><a href=\"#session原理\" class=\"headerlink\" title=\"session原理\"></a>session原理</h5><ul>\n<li>UUID生成session，32位长，不重复的</li>\n<li>getSession</li>\n<li>getMaxInactiveInterval(),获取最大不活动时间，秒单位</li>\n<li>invalidate() 让session立刻失效，用于用户登出</li>\n<li>isNew() session是否为最新</li>\n<li>web.xml中可以配置session的最大不活动时间<ul>\n<li><session-config><session-timeout>4</session-timeout></session-config></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"URL重写\"><a href=\"#URL重写\" class=\"headerlink\" title=\"URL重写\"></a>URL重写</h5><ul>\n<li>浏览器禁用cookie时，URL重写添加JSession字段</li>\n<li>response.encodeURL(“/xxxxservlet”);会查看cookie是否存在，如果存在就只encode这个url，否则在url添加JSessionId。这就是智能URL重写</li>\n</ul>\n<h4 id=\"JSP三大指令\"><a href=\"#JSP三大指令\" class=\"headerlink\" title=\"JSP三大指令\"></a>JSP三大指令</h4><h5 id=\"page\"><a href=\"#page\" class=\"headerlink\" title=\"page\"></a>page</h5><ul>\n<li>&lt;%@page language=”java” info=”xxx” …%&gt;一个jsp页面中可以0-N个指令定义</li>\n<li>习惯性放在jsp文件的首行</li>\n<li>pageEncoding：指定当前jsp页面的编码</li>\n<li>contentType</li>\n<li>errorPage 出错时转发到指定页面</li>\n<li>isErrorPage 指定当前页面是否为处理错误的页面，该页面会设置状态为500！只有该页面可以使用9大内置对象exception</li>\n<li>web.xml配置errorpage，<error-page><error-code>404</error-code><location></location></error-page></li>\n<li>autoFlush：指定jsp的输出流，缓冲区满时是否自动刷新，默认为true，如果为false，那么缓冲区满时会抛出异常。</li>\n<li>buffer：指定缓冲区的大小，默认8kb，通常不需要修改。</li>\n<li>isELIgnored：是否忽略el表达式，默认是false，不忽略，即支持el表达式</li>\n<li>language：指定当前jsp编译后的语言类型，默认值java。也只能是java</li>\n<li>info：信息</li>\n<li>isThreadSafe：当前的jsp是否支持并发访问。默认为false，支持。</li>\n<li>session：当前页面是否支持session，如果为false，那么当前页面就没有session这个内置对象。</li>\n<li>extends：让jsp生成的servlet去继承该属性指定的类</li>\n</ul>\n<h5 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include\"></a>include</h5><ul>\n<li><a href=\"&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x25;&#64;&#105;&#x6e;&#99;&#108;&#x75;&#x64;&#101;&#x25;\">&#x25;&#64;&#105;&#x6e;&#99;&#108;&#x75;&#x64;&#101;&#x25;</a> 在jsp编译成java文件时完成，他们共同生成一个java文件，然后再生成一个class</li>\n<li>RequestDispatcher的include是一个方法，包含和被包含是两个文件</li>\n</ul>\n<h5 id=\"taglib\"><a href=\"#taglib\" class=\"headerlink\" title=\"taglib\"></a>taglib</h5><ul>\n<li>&lt;%@ taglib prefix=”fn” uri=””%&gt; //引入EL函数库</li>\n</ul>\n<h4 id=\"JSP九大内置对象\"><a href=\"#JSP九大内置对象\" class=\"headerlink\" title=\"JSP九大内置对象\"></a>JSP九大内置对象</h4><ul>\n<li>out:jsp输出流，用了向客户端享元</li>\n<li>config：servletConfig对象</li>\n<li>exception：Throwable</li>\n<li>session：httpSession</li>\n<li>response：httpServletResponse</li>\n<li>request：HttpServletRequest</li>\n<li>page：当前jsp对象，他的引用类型为Object。Object page = this；</li>\n<li>application：servletContext</li>\n<li>*pageContext：最重要。<ul>\n<li>Servlet中有三大对象，jsp中有四大域<ul>\n<li>servletContext</li>\n<li>session</li>\n<li>request</li>\n<li>pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据<ul>\n<li>域对象</li>\n<li>代理其他域</li>\n<li>获取其他8个内置对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JSP动作标签\"><a href=\"#JSP动作标签\" class=\"headerlink\" title=\"JSP动作标签\"></a>JSP动作标签</h4><ul>\n<li>与html标签有本质的区别，动作标签是由tomcat解释执行，html由浏览器来执行</li>\n<li>20个，用处不大</li>\n<li><jsp:forward>:转发！</jsp:forward></li>\n<li><jsp:include>:包含</jsp:include></li>\n<li><jsp:param>:forward和include的子标签，用来传递参数</jsp:param></li>\n</ul>\n<h4 id=\"JavaBean概念\"><a href=\"#JavaBean概念\" class=\"headerlink\" title=\"JavaBean概念\"></a>JavaBean概念</h4><ul>\n<li>必须为成员提供get/set方法，只提供一个也行</li>\n<li>必须要有默认构造</li>\n<li>此时称成员为属性</li>\n</ul>\n<h4 id=\"EL表达式\"><a href=\"#EL表达式\" class=\"headerlink\" title=\"EL表达式\"></a>EL表达式</h4><ul>\n<li>EL是JSP内置的表达式语言</li>\n<li>${}</li>\n<li>EL替代的是&lt;%= %&gt;，只能做输出</li>\n<li></li>\n<li>EL表达式读取四大域<ul>\n<li>${xxx}</li>\n<li>${pageScope.xxx},${requestScope.xxx},${sessionScope.xxx},${applicationScope.xxx}，指定域获取信息</li>\n</ul>\n</li>\n<li>javaBean导航</li>\n<li>11个内置对象<ul>\n<li>param</li>\n<li>initParam</li>\n<li>paramValues</li>\n<li>header</li>\n<li>headerValues</li>\n<li>Cookie:Map<string ,cookie=\"\"></string></li>\n<li>pageContext</li>\n</ul>\n</li>\n</ul>\n<p><code>update @ 2017年7月14日18:51:25</code></p>\n<h4 id=\"EL函数库\"><a href=\"#EL函数库\" class=\"headerlink\" title=\"EL函数库\"></a>EL函数库</h4><ul>\n<li>&lt;%@ taglib prefix=”fn” uri=””%&gt; //引入标签库</li>\n</ul>\n<h5 id=\"自定义函数库\"><a href=\"#自定义函数库\" class=\"headerlink\" title=\"自定义函数库\"></a>自定义函数库</h5><ul>\n<li>写一个java类，类中可以定义0-N个方法，但必须是static，并且有返回值的</li>\n<li>写一个.tld文件</li>\n<li>在jsp页面中导入标签库</li>\n<li>在jsp中使用</li>\n<li></li>\n</ul>\n"},{"title":"命令模式","date":"2017-06-14T00:00:00.000Z","_content":"\n#### 定义 ####\n\n命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，又叫做动作(Action)模式或事务(Transaction)模式。\n \n#### 模式结构 ####\n\n- client：创建具体的命令和接收者\n- command：命令的抽象类\n- ConcreteCommand：具体的命令，定义接收者和行为之间的弱耦合\n- Invoker：负责调用命令对象，执行请求\n- receiver：处理请求，任何一个类都可以成为接收者\n \n![类图](/images/command_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/command_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CommandPattern)\n\n#### 分析 ####\n\n使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更换的灵活性和可扩展性。\n\n##### 优点 #####\n- 新的命令可以很容易地添加\n- 比较容易地设计一个命令队列或宏命令\n- 为请求的撤销和恢复操作提供了一种设计和实现方案\n\n##### 缺点 #####\n- 可能会导致某些系统有过多的具体命令类。\n\n#### 适用场景 ####\n\n- 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。\n- 系统需要支持命令的撤销和恢复操作\n- 系统需要将一组操作组合在一起形成宏命令\n\n##### 实例 #####\n\n- 电视遥控器\n- 宏命令\n- 收音机\n\n#### 扩展 ####\n- 基于敏捷开发的原则，我们在设计程序的时候，如果按照目前的需求，不使用某种模式也能很好地解决，那么我们就不要引入它，因为要引入一种设计模式并不困难，我们大可以在真正需要用到的时候再对系统进行一下，引入这个设计模式。\n- 在实际操作中，可省略接收者角色，让命令对象直接实现请求而不是将工作委托给接收者。\n","source":"_posts/2017-06-14-design-patterns-command.md","raw":"---\ntitle: 命令模式\ndate: 2017-06-14 \ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，又叫做动作(Action)模式或事务(Transaction)模式。\n \n#### 模式结构 ####\n\n- client：创建具体的命令和接收者\n- command：命令的抽象类\n- ConcreteCommand：具体的命令，定义接收者和行为之间的弱耦合\n- Invoker：负责调用命令对象，执行请求\n- receiver：处理请求，任何一个类都可以成为接收者\n \n![类图](/images/command_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/command_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CommandPattern)\n\n#### 分析 ####\n\n使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更换的灵活性和可扩展性。\n\n##### 优点 #####\n- 新的命令可以很容易地添加\n- 比较容易地设计一个命令队列或宏命令\n- 为请求的撤销和恢复操作提供了一种设计和实现方案\n\n##### 缺点 #####\n- 可能会导致某些系统有过多的具体命令类。\n\n#### 适用场景 ####\n\n- 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。\n- 系统需要支持命令的撤销和恢复操作\n- 系统需要将一组操作组合在一起形成宏命令\n\n##### 实例 #####\n\n- 电视遥控器\n- 宏命令\n- 收音机\n\n#### 扩展 ####\n- 基于敏捷开发的原则，我们在设计程序的时候，如果按照目前的需求，不使用某种模式也能很好地解决，那么我们就不要引入它，因为要引入一种设计模式并不困难，我们大可以在真正需要用到的时候再对系统进行一下，引入这个设计模式。\n- 在实际操作中，可省略接收者角色，让命令对象直接实现请求而不是将工作委托给接收者。\n","slug":"design-patterns-command","published":1,"updated":"2017-08-17T02:50:10.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gm005h2sivmsoe92bm","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，又叫做动作(Action)模式或事务(Transaction)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>client：创建具体的命令和接收者</li>\n<li>command：命令的抽象类</li>\n<li>ConcreteCommand：具体的命令，定义接收者和行为之间的弱耦合</li>\n<li>Invoker：负责调用命令对象，执行请求</li>\n<li>receiver：处理请求，任何一个类都可以成为接收者</li>\n</ul>\n<p><img src=\"/images/command_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/command_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CommandPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更换的灵活性和可扩展性。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>新的命令可以很容易地添加</li>\n<li>比较容易地设计一个命令队列或宏命令</li>\n<li>为请求的撤销和恢复操作提供了一种设计和实现方案</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>可能会导致某些系统有过多的具体命令类。</li>\n</ul>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</li>\n<li>系统需要支持命令的撤销和恢复操作</li>\n<li>系统需要将一组操作组合在一起形成宏命令</li>\n</ul>\n<h5 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h5><ul>\n<li>电视遥控器</li>\n<li>宏命令</li>\n<li>收音机</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>基于敏捷开发的原则，我们在设计程序的时候，如果按照目前的需求，不使用某种模式也能很好地解决，那么我们就不要引入它，因为要引入一种设计模式并不困难，我们大可以在真正需要用到的时候再对系统进行一下，引入这个设计模式。</li>\n<li>在实际操作中，可省略接收者角色，让命令对象直接实现请求而不是将工作委托给接收者。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，又叫做动作(Action)模式或事务(Transaction)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>client：创建具体的命令和接收者</li>\n<li>command：命令的抽象类</li>\n<li>ConcreteCommand：具体的命令，定义接收者和行为之间的弱耦合</li>\n<li>Invoker：负责调用命令对象，执行请求</li>\n<li>receiver：处理请求，任何一个类都可以成为接收者</li>\n</ul>\n<p><img src=\"/images/command_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/command_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CommandPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更换的灵活性和可扩展性。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>新的命令可以很容易地添加</li>\n<li>比较容易地设计一个命令队列或宏命令</li>\n<li>为请求的撤销和恢复操作提供了一种设计和实现方案</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>可能会导致某些系统有过多的具体命令类。</li>\n</ul>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><ul>\n<li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</li>\n<li>系统需要支持命令的撤销和恢复操作</li>\n<li>系统需要将一组操作组合在一起形成宏命令</li>\n</ul>\n<h5 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h5><ul>\n<li>电视遥控器</li>\n<li>宏命令</li>\n<li>收音机</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>基于敏捷开发的原则，我们在设计程序的时候，如果按照目前的需求，不使用某种模式也能很好地解决，那么我们就不要引入它，因为要引入一种设计模式并不困难，我们大可以在真正需要用到的时候再对系统进行一下，引入这个设计模式。</li>\n<li>在实际操作中，可省略接收者角色，让命令对象直接实现请求而不是将工作委托给接收者。</li>\n</ul>\n"},{"title":"迭代器模式","date":"2017-06-15T00:00:00.000Z","_content":"\n#### 定义 ####\n\n迭代器模式(Iterator Pattern)：提供一种方法顺序访问一个聚合对象中的各个元素，而不用暴露其内部的表示，别名为游标(Cursort)。这是一种行为型类型模式。\n\n在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象用于两个职责：一是存数据；二是取数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责”的要求。\n \n#### 模式结构 ####\n\n- Iterator(抽象迭代器):它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。\n- ConcreteIterator(具体迭代器):迭代器的具体实现类。通过游标来记录在聚合对象中所处的位置。\n- Aggregate(抽象聚合类):存储和管理元素对象，createIterator()方法充当了抽象迭代器工厂角色。\n- ConcreteAggregate(具体聚合类):具体实现类。\n \n![类图](/images/iterator_pattern_class_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/IteratorPattern)\n\n#### 分析 ####\n\n迭代器和聚合类是密不可分的，所以大多数语言在实现容器的同时都提供了迭代器，所以我想说的是：这些语言提供的容器和迭代器大多数情况下可以满足需要的。同样的，如果我们需要自定义容器，那么我们一定要提供迭代器。\n\n##### 优点 #####\n\n- 更换聚合类非常方便\n- 支持以不同方式遍历一个聚合类，更换迭代器即可\n\n##### 缺点 #####\n\n- 迭代器的设计难度较大，尤其是扩展\n- 对于比较简单的遍历，迭代器有些繁琐，比如我们平时用for代替Iterator遍历一个数组\n\n","source":"_posts/2017-06-15-design-patterns-iterator.md","raw":"---\ntitle: 迭代器模式\ndate: 2017-06-15\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n迭代器模式(Iterator Pattern)：提供一种方法顺序访问一个聚合对象中的各个元素，而不用暴露其内部的表示，别名为游标(Cursort)。这是一种行为型类型模式。\n\n在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象用于两个职责：一是存数据；二是取数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责”的要求。\n \n#### 模式结构 ####\n\n- Iterator(抽象迭代器):它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。\n- ConcreteIterator(具体迭代器):迭代器的具体实现类。通过游标来记录在聚合对象中所处的位置。\n- Aggregate(抽象聚合类):存储和管理元素对象，createIterator()方法充当了抽象迭代器工厂角色。\n- ConcreteAggregate(具体聚合类):具体实现类。\n \n![类图](/images/iterator_pattern_class_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/IteratorPattern)\n\n#### 分析 ####\n\n迭代器和聚合类是密不可分的，所以大多数语言在实现容器的同时都提供了迭代器，所以我想说的是：这些语言提供的容器和迭代器大多数情况下可以满足需要的。同样的，如果我们需要自定义容器，那么我们一定要提供迭代器。\n\n##### 优点 #####\n\n- 更换聚合类非常方便\n- 支持以不同方式遍历一个聚合类，更换迭代器即可\n\n##### 缺点 #####\n\n- 迭代器的设计难度较大，尤其是扩展\n- 对于比较简单的遍历，迭代器有些繁琐，比如我们平时用for代替Iterator遍历一个数组\n\n","slug":"design-patterns-iterator","published":1,"updated":"2017-08-17T02:50:33.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gp005k2sivcudea5ts","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>迭代器模式(Iterator Pattern)：提供一种方法顺序访问一个聚合对象中的各个元素，而不用暴露其内部的表示，别名为游标(Cursort)。这是一种行为型类型模式。</p>\n<p>在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象用于两个职责：一是存数据；二是取数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责”的要求。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Iterator(抽象迭代器):它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。</li>\n<li>ConcreteIterator(具体迭代器):迭代器的具体实现类。通过游标来记录在聚合对象中所处的位置。</li>\n<li>Aggregate(抽象聚合类):存储和管理元素对象，createIterator()方法充当了抽象迭代器工厂角色。</li>\n<li>ConcreteAggregate(具体聚合类):具体实现类。</li>\n</ul>\n<p><img src=\"/images/iterator_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/IteratorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>迭代器和聚合类是密不可分的，所以大多数语言在实现容器的同时都提供了迭代器，所以我想说的是：这些语言提供的容器和迭代器大多数情况下可以满足需要的。同样的，如果我们需要自定义容器，那么我们一定要提供迭代器。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>更换聚合类非常方便</li>\n<li>支持以不同方式遍历一个聚合类，更换迭代器即可</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>迭代器的设计难度较大，尤其是扩展</li>\n<li>对于比较简单的遍历，迭代器有些繁琐，比如我们平时用for代替Iterator遍历一个数组</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>迭代器模式(Iterator Pattern)：提供一种方法顺序访问一个聚合对象中的各个元素，而不用暴露其内部的表示，别名为游标(Cursort)。这是一种行为型类型模式。</p>\n<p>在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象用于两个职责：一是存数据；二是取数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责”的要求。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Iterator(抽象迭代器):它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。</li>\n<li>ConcreteIterator(具体迭代器):迭代器的具体实现类。通过游标来记录在聚合对象中所处的位置。</li>\n<li>Aggregate(抽象聚合类):存储和管理元素对象，createIterator()方法充当了抽象迭代器工厂角色。</li>\n<li>ConcreteAggregate(具体聚合类):具体实现类。</li>\n</ul>\n<p><img src=\"/images/iterator_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/IteratorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>迭代器和聚合类是密不可分的，所以大多数语言在实现容器的同时都提供了迭代器，所以我想说的是：这些语言提供的容器和迭代器大多数情况下可以满足需要的。同样的，如果我们需要自定义容器，那么我们一定要提供迭代器。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>更换聚合类非常方便</li>\n<li>支持以不同方式遍历一个聚合类，更换迭代器即可</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>迭代器的设计难度较大，尤其是扩展</li>\n<li>对于比较简单的遍历，迭代器有些繁琐，比如我们平时用for代替Iterator遍历一个数组</li>\n</ul>\n"},{"title":"备忘录模式","date":"2017-06-16T00:00:00.000Z","_content":"\n#### 定义 ####\n\n备忘录模式(Memento Pattern):在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。这是一种对象行为型模式，别名为Token，又称作Snapshot。\n  \n#### 模式结构 ####\n\n-  Originator(原发器):它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态(比如象棋的某一步)，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器\n-  Memento(备忘录):存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用\n-  Caretaker(负责人):负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。\n \n![类图](/images/memento_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![类图](/images/memento_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MementoPattern)\n\n#### 分析 ####\n\n应用领域包括：文字处理 、图像编辑、数据库管理系统等软件中。\n\n##### 优点 #####\n\n- 提供了一种状态恢复的实现机制\n- 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码改动\n\n##### 缺点 #####\n\n-  如果原发器的类成员变量过多，会占用大量空间\n\n#### 扩展 ####\n\n- 备忘录做成原发器的内部类\n- 备忘录的生成使用[原型设计模式](http://xusx1024.com/2017/03/18/design-patterns-prototype-1/)\n- 备忘录模式通常与命令模式和迭代子模式一同使用\n- 保证负责人不能对备忘录修改的方法，使用标识接口\n\t\tpackage MementoPattern;\n\t\t\n\t\t/**\n\t\t *  备忘录模式中，管理者只负责管理，是不可以修改备忘录的<br/>\n\t\t *  \n\t\t *  所以，使用标识接口{@link MementoIF}}，管理者便不能修改备忘录的内容\n\t\t * \n\t\t * @author sxx.xu\n\t\t *\n\t\t */\n\t\tpublic class MementoCaretaker3 {\n\t\t\tprivate MementoIF memento;\n\t\t\n\t\t\tpublic MementoIF getMemento() {\n\t\t\t\treturn memento;\n\t\t\t}\n\t\t\n\t\t\tpublic void setMemento(MementoIF memento) {\n\t\t\t\tthis.memento = memento;\n\t\t\t}\n\t\t\n\t\t}  \n\n- “自述历史”模式（History-On-Self Pattern），备忘录模式的特殊实现形式。Demo:[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/HistoryOnSelfPattern)\n\n","source":"_posts/2017-06-16-design-patterns-memento.md","raw":"---\ntitle: 备忘录模式\ndate: 2017-06-16\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n备忘录模式(Memento Pattern):在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。这是一种对象行为型模式，别名为Token，又称作Snapshot。\n  \n#### 模式结构 ####\n\n-  Originator(原发器):它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态(比如象棋的某一步)，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器\n-  Memento(备忘录):存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用\n-  Caretaker(负责人):负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。\n \n![类图](/images/memento_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![类图](/images/memento_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MementoPattern)\n\n#### 分析 ####\n\n应用领域包括：文字处理 、图像编辑、数据库管理系统等软件中。\n\n##### 优点 #####\n\n- 提供了一种状态恢复的实现机制\n- 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码改动\n\n##### 缺点 #####\n\n-  如果原发器的类成员变量过多，会占用大量空间\n\n#### 扩展 ####\n\n- 备忘录做成原发器的内部类\n- 备忘录的生成使用[原型设计模式](http://xusx1024.com/2017/03/18/design-patterns-prototype-1/)\n- 备忘录模式通常与命令模式和迭代子模式一同使用\n- 保证负责人不能对备忘录修改的方法，使用标识接口\n\t\tpackage MementoPattern;\n\t\t\n\t\t/**\n\t\t *  备忘录模式中，管理者只负责管理，是不可以修改备忘录的<br/>\n\t\t *  \n\t\t *  所以，使用标识接口{@link MementoIF}}，管理者便不能修改备忘录的内容\n\t\t * \n\t\t * @author sxx.xu\n\t\t *\n\t\t */\n\t\tpublic class MementoCaretaker3 {\n\t\t\tprivate MementoIF memento;\n\t\t\n\t\t\tpublic MementoIF getMemento() {\n\t\t\t\treturn memento;\n\t\t\t}\n\t\t\n\t\t\tpublic void setMemento(MementoIF memento) {\n\t\t\t\tthis.memento = memento;\n\t\t\t}\n\t\t\n\t\t}  \n\n- “自述历史”模式（History-On-Self Pattern），备忘录模式的特殊实现形式。Demo:[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/HistoryOnSelfPattern)\n\n","slug":"design-patterns-memento","published":1,"updated":"2017-08-17T02:50:37.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gs005n2sivt6qoagzh","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>备忘录模式(Memento Pattern):在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。这是一种对象行为型模式，别名为Token，又称作Snapshot。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Originator(原发器):它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态(比如象棋的某一步)，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器</li>\n<li>Memento(备忘录):存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用</li>\n<li>Caretaker(负责人):负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</li>\n</ul>\n<p><img src=\"/images/memento_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/memento_pattern_sequence_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MementoPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>应用领域包括：文字处理 、图像编辑、数据库管理系统等软件中。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>提供了一种状态恢复的实现机制</li>\n<li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码改动</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>如果原发器的类成员变量过多，会占用大量空间</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>备忘录做成原发器的内部类</li>\n<li>备忘录的生成使用<a href=\"http://xusx1024.com/2017/03/18/design-patterns-prototype-1/\" target=\"_blank\" rel=\"external\">原型设计模式</a></li>\n<li>备忘录模式通常与命令模式和迭代子模式一同使用</li>\n<li><p>保证负责人不能对备忘录修改的方法，使用标识接口</p>\n<pre><code>package MementoPattern;\n\n/**\n *  备忘录模式中，管理者只负责管理，是不可以修改备忘录的&lt;br/&gt;\n *  \n *  所以，使用标识接口{@link MementoIF}}，管理者便不能修改备忘录的内容\n * \n * @author sxx.xu\n *\n */\npublic class MementoCaretaker3 {\n    private MementoIF memento;\n\n    public MementoIF getMemento() {\n        return memento;\n    }\n\n    public void setMemento(MementoIF memento) {\n        this.memento = memento;\n    }\n\n}  \n</code></pre></li>\n<li><p>“自述历史”模式（History-On-Self Pattern），备忘录模式的特殊实现形式。Demo:<a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/HistoryOnSelfPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>备忘录模式(Memento Pattern):在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。这是一种对象行为型模式，别名为Token，又称作Snapshot。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Originator(原发器):它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态(比如象棋的某一步)，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器</li>\n<li>Memento(备忘录):存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用</li>\n<li>Caretaker(负责人):负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</li>\n</ul>\n<p><img src=\"/images/memento_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/memento_pattern_sequence_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/MementoPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>应用领域包括：文字处理 、图像编辑、数据库管理系统等软件中。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>提供了一种状态恢复的实现机制</li>\n<li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码改动</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>如果原发器的类成员变量过多，会占用大量空间</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><ul>\n<li>备忘录做成原发器的内部类</li>\n<li>备忘录的生成使用<a href=\"http://xusx1024.com/2017/03/18/design-patterns-prototype-1/\" target=\"_blank\" rel=\"external\">原型设计模式</a></li>\n<li>备忘录模式通常与命令模式和迭代子模式一同使用</li>\n<li><p>保证负责人不能对备忘录修改的方法，使用标识接口</p>\n<pre><code>package MementoPattern;\n\n/**\n *  备忘录模式中，管理者只负责管理，是不可以修改备忘录的&lt;br/&gt;\n *  \n *  所以，使用标识接口{@link MementoIF}}，管理者便不能修改备忘录的内容\n * \n * @author sxx.xu\n *\n */\npublic class MementoCaretaker3 {\n    private MementoIF memento;\n\n    public MementoIF getMemento() {\n        return memento;\n    }\n\n    public void setMemento(MementoIF memento) {\n        this.memento = memento;\n    }\n\n}  \n</code></pre></li>\n<li><p>“自述历史”模式（History-On-Self Pattern），备忘录模式的特殊实现形式。Demo:<a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/HistoryOnSelfPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n</li>\n</ul>\n"},{"title":"模版方法模式","date":"2017-06-19T00:00:00.000Z","_content":"\n#### 定义 ####\n\n模版方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模版方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n  \n#### 模式结构 ####\n\n-  Abstract Template(抽象模版)：定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，这是一个顶级逻辑的组成步骤。定义并实现一个模版方法，这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。\n-  Concrete Template(具体模版)：实现父类定义的一个或多个抽象方法，可以有多个具体模版，同事可以有不同的实现，从而使顶级逻辑的实现各不相同。\n \n![类图](/images/template_method_pattern_class_diagram.png)\n\n#### 代码 ####\n\t\n\tpackage TemplateMethodPattern;\n\t\n\t/**\n\t * 抽象模版\n\t * @author sxx.xu\n\t *\n\t */\n\tpublic abstract class AbstractTemplate {\n\n\t\t/**\n\t\t * 模版方法\n\t\t */\n\t\tpublic void templateMethod(){\n\t\t\tabstractMethod();\n\t\t\thookMethod();\n\t\t\tconcreteMethod();\n\t\t}\n\t\t\n\t\t/**\n\t\t * 子类必须实现\n\t\t */\n\t\tprotected abstract void abstractMethod();\n\t\t/**\n\t\t * 钩子方法，子类可以实现\n\t\t */\n\t\tprotected void hookMethod(){}\n\t\t/**\n\t\t * 子类不必关心\n\t\t */\n\t\tprivate final void concreteMethod(){\n\t\t\t\n\t\t}\n\t}\n\n \n********************\n\n\tpackage TemplateMethodPattern;\n\t/**\n\t * 具体模版\n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class ConcreteTemplate extends AbstractTemplate {\n\t\n\t\t@Override\n\t\tprotected void abstractMethod() {\n\t\t\t \n\t\n\t\t}\n\t\n\t\t/**\n\t\t * 具体模版可选择实现\n\t\t */\n\t\t@Override\n\t\tprotected void hookMethod() {\n\t\t\tsuper.hookMethod();\n\t\t}\n\t}\n\n#### 分析 ####\n\n该模式的方法可以分为两大类：模版方法和基本方法。\n\n##### 模版方法 #####\n\n- 定义在抽象类中，把基本操作方法组合在一起形成一个总算放或一个总行为的方法\n- 可以有多个模版方法，每个模版方法都可以调用任意多个基本方法\n\n\n##### 基本方法 #####\n\n- 抽象方法：由抽象类声明，具体子类实现\n- 具体方法：抽象类声明并实现，子类并不实现或置换\n- 钩子方法：由抽象类声明并实现，子类可以扩展:\n\t- 通常该方法在抽象类中为空实现作为默认实现，叫做“Do Nothing Hook”\n\t- 命名应当以do开始，Java中。例如在HttpServlet类中，doGet(),doPost()\n\n\n##### 优点 #####\n\n- 父类形式化定义一个算法，而由它的子类来实现细节，子类在实现详细的处理算法时并不会改变算法中步骤的执行次序\n- 一种代码复用技术，鼓励我们恰当使用继承来实现代码复用\n- 可以实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行\n\n##### 缺点 #####\n\n-  如果父类中可变的基本方法过多，系统庞大，设计抽象，此时，可以配合桥接模式来进行设计。\n\n \n\n","source":"_posts/2017-06-19-design-patterns-template-method.md","raw":"---\ntitle: 模版方法模式\ndate: 2017-06-19\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n模版方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模版方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n  \n#### 模式结构 ####\n\n-  Abstract Template(抽象模版)：定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，这是一个顶级逻辑的组成步骤。定义并实现一个模版方法，这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。\n-  Concrete Template(具体模版)：实现父类定义的一个或多个抽象方法，可以有多个具体模版，同事可以有不同的实现，从而使顶级逻辑的实现各不相同。\n \n![类图](/images/template_method_pattern_class_diagram.png)\n\n#### 代码 ####\n\t\n\tpackage TemplateMethodPattern;\n\t\n\t/**\n\t * 抽象模版\n\t * @author sxx.xu\n\t *\n\t */\n\tpublic abstract class AbstractTemplate {\n\n\t\t/**\n\t\t * 模版方法\n\t\t */\n\t\tpublic void templateMethod(){\n\t\t\tabstractMethod();\n\t\t\thookMethod();\n\t\t\tconcreteMethod();\n\t\t}\n\t\t\n\t\t/**\n\t\t * 子类必须实现\n\t\t */\n\t\tprotected abstract void abstractMethod();\n\t\t/**\n\t\t * 钩子方法，子类可以实现\n\t\t */\n\t\tprotected void hookMethod(){}\n\t\t/**\n\t\t * 子类不必关心\n\t\t */\n\t\tprivate final void concreteMethod(){\n\t\t\t\n\t\t}\n\t}\n\n \n********************\n\n\tpackage TemplateMethodPattern;\n\t/**\n\t * 具体模版\n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class ConcreteTemplate extends AbstractTemplate {\n\t\n\t\t@Override\n\t\tprotected void abstractMethod() {\n\t\t\t \n\t\n\t\t}\n\t\n\t\t/**\n\t\t * 具体模版可选择实现\n\t\t */\n\t\t@Override\n\t\tprotected void hookMethod() {\n\t\t\tsuper.hookMethod();\n\t\t}\n\t}\n\n#### 分析 ####\n\n该模式的方法可以分为两大类：模版方法和基本方法。\n\n##### 模版方法 #####\n\n- 定义在抽象类中，把基本操作方法组合在一起形成一个总算放或一个总行为的方法\n- 可以有多个模版方法，每个模版方法都可以调用任意多个基本方法\n\n\n##### 基本方法 #####\n\n- 抽象方法：由抽象类声明，具体子类实现\n- 具体方法：抽象类声明并实现，子类并不实现或置换\n- 钩子方法：由抽象类声明并实现，子类可以扩展:\n\t- 通常该方法在抽象类中为空实现作为默认实现，叫做“Do Nothing Hook”\n\t- 命名应当以do开始，Java中。例如在HttpServlet类中，doGet(),doPost()\n\n\n##### 优点 #####\n\n- 父类形式化定义一个算法，而由它的子类来实现细节，子类在实现详细的处理算法时并不会改变算法中步骤的执行次序\n- 一种代码复用技术，鼓励我们恰当使用继承来实现代码复用\n- 可以实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行\n\n##### 缺点 #####\n\n-  如果父类中可变的基本方法过多，系统庞大，设计抽象，此时，可以配合桥接模式来进行设计。\n\n \n\n","slug":"design-patterns-template-method","published":1,"updated":"2017-08-17T02:50:41.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gv005q2sivduzyuefn","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>模版方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模版方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Abstract Template(抽象模版)：定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，这是一个顶级逻辑的组成步骤。定义并实现一个模版方法，这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>\n<li>Concrete Template(具体模版)：实现父类定义的一个或多个抽象方法，可以有多个具体模版，同事可以有不同的实现，从而使顶级逻辑的实现各不相同。</li>\n</ul>\n<p><img src=\"/images/template_method_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package TemplateMethodPattern;\n\n/**\n * 抽象模版\n * @author sxx.xu\n *\n */\npublic abstract class AbstractTemplate {\n\n    /**\n     * 模版方法\n     */\n    public void templateMethod(){\n        abstractMethod();\n        hookMethod();\n        concreteMethod();\n    }\n\n    /**\n     * 子类必须实现\n     */\n    protected abstract void abstractMethod();\n    /**\n     * 钩子方法，子类可以实现\n     */\n    protected void hookMethod(){}\n    /**\n     * 子类不必关心\n     */\n    private final void concreteMethod(){\n\n    }\n}\n</code></pre><hr>\n<pre><code>package TemplateMethodPattern;\n/**\n * 具体模版\n * @author sxx.xu\n *\n */\npublic class ConcreteTemplate extends AbstractTemplate {\n\n    @Override\n    protected void abstractMethod() {\n\n\n    }\n\n    /**\n     * 具体模版可选择实现\n     */\n    @Override\n    protected void hookMethod() {\n        super.hookMethod();\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>该模式的方法可以分为两大类：模版方法和基本方法。</p>\n<h5 id=\"模版方法\"><a href=\"#模版方法\" class=\"headerlink\" title=\"模版方法\"></a>模版方法</h5><ul>\n<li>定义在抽象类中，把基本操作方法组合在一起形成一个总算放或一个总行为的方法</li>\n<li>可以有多个模版方法，每个模版方法都可以调用任意多个基本方法</li>\n</ul>\n<h5 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h5><ul>\n<li>抽象方法：由抽象类声明，具体子类实现</li>\n<li>具体方法：抽象类声明并实现，子类并不实现或置换</li>\n<li>钩子方法：由抽象类声明并实现，子类可以扩展:<ul>\n<li>通常该方法在抽象类中为空实现作为默认实现，叫做“Do Nothing Hook”</li>\n<li>命名应当以do开始，Java中。例如在HttpServlet类中，doGet(),doPost()</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>父类形式化定义一个算法，而由它的子类来实现细节，子类在实现详细的处理算法时并不会改变算法中步骤的执行次序</li>\n<li>一种代码复用技术，鼓励我们恰当使用继承来实现代码复用</li>\n<li>可以实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>如果父类中可变的基本方法过多，系统庞大，设计抽象，此时，可以配合桥接模式来进行设计。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>模版方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模版方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Abstract Template(抽象模版)：定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，这是一个顶级逻辑的组成步骤。定义并实现一个模版方法，这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>\n<li>Concrete Template(具体模版)：实现父类定义的一个或多个抽象方法，可以有多个具体模版，同事可以有不同的实现，从而使顶级逻辑的实现各不相同。</li>\n</ul>\n<p><img src=\"/images/template_method_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><pre><code>package TemplateMethodPattern;\n\n/**\n * 抽象模版\n * @author sxx.xu\n *\n */\npublic abstract class AbstractTemplate {\n\n    /**\n     * 模版方法\n     */\n    public void templateMethod(){\n        abstractMethod();\n        hookMethod();\n        concreteMethod();\n    }\n\n    /**\n     * 子类必须实现\n     */\n    protected abstract void abstractMethod();\n    /**\n     * 钩子方法，子类可以实现\n     */\n    protected void hookMethod(){}\n    /**\n     * 子类不必关心\n     */\n    private final void concreteMethod(){\n\n    }\n}\n</code></pre><hr>\n<pre><code>package TemplateMethodPattern;\n/**\n * 具体模版\n * @author sxx.xu\n *\n */\npublic class ConcreteTemplate extends AbstractTemplate {\n\n    @Override\n    protected void abstractMethod() {\n\n\n    }\n\n    /**\n     * 具体模版可选择实现\n     */\n    @Override\n    protected void hookMethod() {\n        super.hookMethod();\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>该模式的方法可以分为两大类：模版方法和基本方法。</p>\n<h5 id=\"模版方法\"><a href=\"#模版方法\" class=\"headerlink\" title=\"模版方法\"></a>模版方法</h5><ul>\n<li>定义在抽象类中，把基本操作方法组合在一起形成一个总算放或一个总行为的方法</li>\n<li>可以有多个模版方法，每个模版方法都可以调用任意多个基本方法</li>\n</ul>\n<h5 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h5><ul>\n<li>抽象方法：由抽象类声明，具体子类实现</li>\n<li>具体方法：抽象类声明并实现，子类并不实现或置换</li>\n<li>钩子方法：由抽象类声明并实现，子类可以扩展:<ul>\n<li>通常该方法在抽象类中为空实现作为默认实现，叫做“Do Nothing Hook”</li>\n<li>命名应当以do开始，Java中。例如在HttpServlet类中，doGet(),doPost()</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>父类形式化定义一个算法，而由它的子类来实现细节，子类在实现详细的处理算法时并不会改变算法中步骤的执行次序</li>\n<li>一种代码复用技术，鼓励我们恰当使用继承来实现代码复用</li>\n<li>可以实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>如果父类中可变的基本方法过多，系统庞大，设计抽象，此时，可以配合桥接模式来进行设计。</li>\n</ul>\n"},{"title":"访问者模式","date":"2017-06-20T00:00:00.000Z","_content":"\n#### 定义 ####\n\n访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问模式是一种对象行为型模式。\n  \n#### 模式结构 ####\n\n- Visitor：抽象访问者，声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口\n- ConcreteVisitor：具体访问者，实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作\n- Node：抽象节点，声明一个接受操作，接受一个访问者对象作为一个参数\n- ConcreteNode：具体节点，实现了抽象节点所规定的接受操作\n- ObjectStructure：结构对象，可以遍历结构中的所有元素，如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set\n \n![类图](/images/visitor_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/visitor_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\t\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/VisitorPattern)\n\n#### 分析 ####\n\n个人理解，这是个多对多的关系。每个访问者可以封装固定的操作去访问所有的节点。每个节点都有被访问时相应调用的方法。\n对象构造管理访问者和节点\n客户端传给对象构造不同的访问者，然后得到数据。\n客户端只需要关心自己提供对应的访问者，可以使用工厂生产，不必关心具体细节。\n\n##### 优点 #####\n\n- 增加新的访问操作很方便\n- 将访问行为集中到访问者中，而不是分散在一个个元素类，职责明确\n- 让用户在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作\n\n##### 缺点 #####\n\n-  增加新的元素节点很困难。每一次增加，都要在抽象访问者中增加新的抽象操作。\n-  访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象需要暴露自己的内部操作和内部状态，否则访问者无法访问\n \n#### 分派 ####\n\n变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。\n\n\tList list = new ArrayList();\n \n根据对象的类型而对方法进行的选择，就是分派，分派又分为两种：静态分派、动态分派。\n\n##### 静态分派 #####\n\n发生在编译时期，分派根据静态类型信息发生，`方法重载`就是静态分派。\n\t\n\tpackage VisitorPattern;\n\t\n\tpublic class People {\n\t\n\t\tvoid ride(Horse h) {\n\t\t\tSystem.out.println(\"ride horse\");\n\t\t}\n\t\n\t\tvoid ride(WhiteHorse h) {\n\t\t\tSystem.out.println(\"ride White Horse\");\n\t\t}\n\t\n\t\tvoid ride(BlackHorse h) {\n\t\t\tSystem.out.println(\"ride Black Horse\");\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tHorse wh = new WhiteHorse();\n\t\t\tHorse bh = new BlackHorse();\n\t\n\t\t\tPeople p = new People();\n\t\t\tp.ride(wh);\n\t\t\tp.ride(bh);\n\t\t}\n\t\n\t}\n\t\n\tclass Horse {\n\t}\n\t\n\tclass WhiteHorse extends Horse {\n\t}\n\t\n\tclass BlackHorse extends Horse {\n\t}\n\n>打印结果：\n>ride horse\nride horse\n\n两次对ride()方法传入对是不同对参数，虽然具有不同的真实类型，但是它们的静态类型都是一样的，重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。\n\n##### 动态分派 #####\n\n发生在运行时期，动态分派动态地置换掉某个方法。java通过重写支持动态分派。\n\t\n\tpackage VisitorPattern;\n\t\n\tpublic class Demo {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tHorse1 h = new WhiteHorse1();\n\t\t\th.eat();\n\t\t}\n\t\n\t}\n\t\n\tclass Horse1 {\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"horse eatting\");\n\t\t}\n\t}\n\t\n\tclass WhiteHorse1 extends Horse1 {\n\t\t@Override\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"WhiteHorse1 horse eatting\");\n\t\t}\n\t}\n\t\n\tclass BlackHorse1 extends Horse1 {\n\t\t@Override\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"BlackHorse1 horse eatting\");\n\t\t}\n\t}\n\n>打印结果：\n>WhiteHorse1 horse eatting\n\nJava编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。\n\n#### 宗量 ####\n\n一个方法所属的对象叫做方法的接收者；\n方法的接收者与方法的参数统称为方法的宗量。\n\n根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言和多分派语言。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。\n\nJava是动态的单分派语言，因为动态分派仅仅会考虑到方法的接收者类型。\nJava又是静态的多分派语言，因为他对重载方法的分派会考虑到方法的接收者类型以及方法的所有参数的类型。\n\n在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在Java语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态的单分派的特征。\n\n","source":"_posts/2017-06-20-design-patterns-visitor.md","raw":"---\ntitle: 访问者模式\ndate: 2017-06-20\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问模式是一种对象行为型模式。\n  \n#### 模式结构 ####\n\n- Visitor：抽象访问者，声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口\n- ConcreteVisitor：具体访问者，实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作\n- Node：抽象节点，声明一个接受操作，接受一个访问者对象作为一个参数\n- ConcreteNode：具体节点，实现了抽象节点所规定的接受操作\n- ObjectStructure：结构对象，可以遍历结构中的所有元素，如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set\n \n![类图](/images/visitor_pattern_class_diagram.png)\n\n#### 时序图 ####\n\n![时序图](/images/visitor_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\t\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/VisitorPattern)\n\n#### 分析 ####\n\n个人理解，这是个多对多的关系。每个访问者可以封装固定的操作去访问所有的节点。每个节点都有被访问时相应调用的方法。\n对象构造管理访问者和节点\n客户端传给对象构造不同的访问者，然后得到数据。\n客户端只需要关心自己提供对应的访问者，可以使用工厂生产，不必关心具体细节。\n\n##### 优点 #####\n\n- 增加新的访问操作很方便\n- 将访问行为集中到访问者中，而不是分散在一个个元素类，职责明确\n- 让用户在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作\n\n##### 缺点 #####\n\n-  增加新的元素节点很困难。每一次增加，都要在抽象访问者中增加新的抽象操作。\n-  访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象需要暴露自己的内部操作和内部状态，否则访问者无法访问\n \n#### 分派 ####\n\n变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。\n\n\tList list = new ArrayList();\n \n根据对象的类型而对方法进行的选择，就是分派，分派又分为两种：静态分派、动态分派。\n\n##### 静态分派 #####\n\n发生在编译时期，分派根据静态类型信息发生，`方法重载`就是静态分派。\n\t\n\tpackage VisitorPattern;\n\t\n\tpublic class People {\n\t\n\t\tvoid ride(Horse h) {\n\t\t\tSystem.out.println(\"ride horse\");\n\t\t}\n\t\n\t\tvoid ride(WhiteHorse h) {\n\t\t\tSystem.out.println(\"ride White Horse\");\n\t\t}\n\t\n\t\tvoid ride(BlackHorse h) {\n\t\t\tSystem.out.println(\"ride Black Horse\");\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tHorse wh = new WhiteHorse();\n\t\t\tHorse bh = new BlackHorse();\n\t\n\t\t\tPeople p = new People();\n\t\t\tp.ride(wh);\n\t\t\tp.ride(bh);\n\t\t}\n\t\n\t}\n\t\n\tclass Horse {\n\t}\n\t\n\tclass WhiteHorse extends Horse {\n\t}\n\t\n\tclass BlackHorse extends Horse {\n\t}\n\n>打印结果：\n>ride horse\nride horse\n\n两次对ride()方法传入对是不同对参数，虽然具有不同的真实类型，但是它们的静态类型都是一样的，重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。\n\n##### 动态分派 #####\n\n发生在运行时期，动态分派动态地置换掉某个方法。java通过重写支持动态分派。\n\t\n\tpackage VisitorPattern;\n\t\n\tpublic class Demo {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tHorse1 h = new WhiteHorse1();\n\t\t\th.eat();\n\t\t}\n\t\n\t}\n\t\n\tclass Horse1 {\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"horse eatting\");\n\t\t}\n\t}\n\t\n\tclass WhiteHorse1 extends Horse1 {\n\t\t@Override\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"WhiteHorse1 horse eatting\");\n\t\t}\n\t}\n\t\n\tclass BlackHorse1 extends Horse1 {\n\t\t@Override\n\t\tpublic void eat() {\n\t\t\tSystem.out.println(\"BlackHorse1 horse eatting\");\n\t\t}\n\t}\n\n>打印结果：\n>WhiteHorse1 horse eatting\n\nJava编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。\n\n#### 宗量 ####\n\n一个方法所属的对象叫做方法的接收者；\n方法的接收者与方法的参数统称为方法的宗量。\n\n根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言和多分派语言。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。\n\nJava是动态的单分派语言，因为动态分派仅仅会考虑到方法的接收者类型。\nJava又是静态的多分派语言，因为他对重载方法的分派会考虑到方法的接收者类型以及方法的所有参数的类型。\n\n在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在Java语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态的单分派的特征。\n\n","slug":"design-patterns-visitor","published":1,"updated":"2017-08-17T02:50:46.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1gx005t2sivy3ui0rea","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问模式是一种对象行为型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Visitor：抽象访问者，声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口</li>\n<li>ConcreteVisitor：具体访问者，实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作</li>\n<li>Node：抽象节点，声明一个接受操作，接受一个访问者对象作为一个参数</li>\n<li>ConcreteNode：具体节点，实现了抽象节点所规定的接受操作</li>\n<li>ObjectStructure：结构对象，可以遍历结构中的所有元素，如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set</li>\n</ul>\n<p><img src=\"/images/visitor_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/visitor_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/VisitorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>个人理解，这是个多对多的关系。每个访问者可以封装固定的操作去访问所有的节点。每个节点都有被访问时相应调用的方法。<br>对象构造管理访问者和节点<br>客户端传给对象构造不同的访问者，然后得到数据。<br>客户端只需要关心自己提供对应的访问者，可以使用工厂生产，不必关心具体细节。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>增加新的访问操作很方便</li>\n<li>将访问行为集中到访问者中，而不是分散在一个个元素类，职责明确</li>\n<li>让用户在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>增加新的元素节点很困难。每一次增加，都要在抽象访问者中增加新的抽象操作。</li>\n<li>访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象需要暴露自己的内部操作和内部状态，否则访问者无法访问</li>\n</ul>\n<h4 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h4><p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。</p>\n<pre><code>List list = new ArrayList();\n</code></pre><p>根据对象的类型而对方法进行的选择，就是分派，分派又分为两种：静态分派、动态分派。</p>\n<h5 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h5><p>发生在编译时期，分派根据静态类型信息发生，<code>方法重载</code>就是静态分派。</p>\n<pre><code>package VisitorPattern;\n\npublic class People {\n\n    void ride(Horse h) {\n        System.out.println(&quot;ride horse&quot;);\n    }\n\n    void ride(WhiteHorse h) {\n        System.out.println(&quot;ride White Horse&quot;);\n    }\n\n    void ride(BlackHorse h) {\n        System.out.println(&quot;ride Black Horse&quot;);\n    }\n\n    public static void main(String[] args) {\n        Horse wh = new WhiteHorse();\n        Horse bh = new BlackHorse();\n\n        People p = new People();\n        p.ride(wh);\n        p.ride(bh);\n    }\n\n}\n\nclass Horse {\n}\n\nclass WhiteHorse extends Horse {\n}\n\nclass BlackHorse extends Horse {\n}\n</code></pre><blockquote>\n<p>打印结果：<br>ride horse<br>ride horse</p>\n</blockquote>\n<p>两次对ride()方法传入对是不同对参数，虽然具有不同的真实类型，但是它们的静态类型都是一样的，重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</p>\n<h5 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h5><p>发生在运行时期，动态分派动态地置换掉某个方法。java通过重写支持动态分派。</p>\n<pre><code>package VisitorPattern;\n\npublic class Demo {\n\n    public static void main(String[] args) {\n        Horse1 h = new WhiteHorse1();\n        h.eat();\n    }\n\n}\n\nclass Horse1 {\n    public void eat() {\n        System.out.println(&quot;horse eatting&quot;);\n    }\n}\n\nclass WhiteHorse1 extends Horse1 {\n    @Override\n    public void eat() {\n        System.out.println(&quot;WhiteHorse1 horse eatting&quot;);\n    }\n}\n\nclass BlackHorse1 extends Horse1 {\n    @Override\n    public void eat() {\n        System.out.println(&quot;BlackHorse1 horse eatting&quot;);\n    }\n}\n</code></pre><blockquote>\n<p>打印结果：<br>WhiteHorse1 horse eatting</p>\n</blockquote>\n<p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>\n<h4 id=\"宗量\"><a href=\"#宗量\" class=\"headerlink\" title=\"宗量\"></a>宗量</h4><p>一个方法所属的对象叫做方法的接收者；<br>方法的接收者与方法的参数统称为方法的宗量。</p>\n<p>根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言和多分派语言。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。</p>\n<p>Java是动态的单分派语言，因为动态分派仅仅会考虑到方法的接收者类型。<br>Java又是静态的多分派语言，因为他对重载方法的分派会考虑到方法的接收者类型以及方法的所有参数的类型。</p>\n<p>在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在Java语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态的单分派的特征。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>访问者模式(Visitor Pattern):提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问模式是一种对象行为型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Visitor：抽象访问者，声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口</li>\n<li>ConcreteVisitor：具体访问者，实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作</li>\n<li>Node：抽象节点，声明一个接受操作，接受一个访问者对象作为一个参数</li>\n<li>ConcreteNode：具体节点，实现了抽象节点所规定的接受操作</li>\n<li>ObjectStructure：结构对象，可以遍历结构中的所有元素，如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set</li>\n</ul>\n<p><img src=\"/images/visitor_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/visitor_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/VisitorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>个人理解，这是个多对多的关系。每个访问者可以封装固定的操作去访问所有的节点。每个节点都有被访问时相应调用的方法。<br>对象构造管理访问者和节点<br>客户端传给对象构造不同的访问者，然后得到数据。<br>客户端只需要关心自己提供对应的访问者，可以使用工厂生产，不必关心具体细节。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>增加新的访问操作很方便</li>\n<li>将访问行为集中到访问者中，而不是分散在一个个元素类，职责明确</li>\n<li>让用户在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>增加新的元素节点很困难。每一次增加，都要在抽象访问者中增加新的抽象操作。</li>\n<li>访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象需要暴露自己的内部操作和内部状态，否则访问者无法访问</li>\n</ul>\n<h4 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h4><p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。</p>\n<pre><code>List list = new ArrayList();\n</code></pre><p>根据对象的类型而对方法进行的选择，就是分派，分派又分为两种：静态分派、动态分派。</p>\n<h5 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h5><p>发生在编译时期，分派根据静态类型信息发生，<code>方法重载</code>就是静态分派。</p>\n<pre><code>package VisitorPattern;\n\npublic class People {\n\n    void ride(Horse h) {\n        System.out.println(&quot;ride horse&quot;);\n    }\n\n    void ride(WhiteHorse h) {\n        System.out.println(&quot;ride White Horse&quot;);\n    }\n\n    void ride(BlackHorse h) {\n        System.out.println(&quot;ride Black Horse&quot;);\n    }\n\n    public static void main(String[] args) {\n        Horse wh = new WhiteHorse();\n        Horse bh = new BlackHorse();\n\n        People p = new People();\n        p.ride(wh);\n        p.ride(bh);\n    }\n\n}\n\nclass Horse {\n}\n\nclass WhiteHorse extends Horse {\n}\n\nclass BlackHorse extends Horse {\n}\n</code></pre><blockquote>\n<p>打印结果：<br>ride horse<br>ride horse</p>\n</blockquote>\n<p>两次对ride()方法传入对是不同对参数，虽然具有不同的真实类型，但是它们的静态类型都是一样的，重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</p>\n<h5 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h5><p>发生在运行时期，动态分派动态地置换掉某个方法。java通过重写支持动态分派。</p>\n<pre><code>package VisitorPattern;\n\npublic class Demo {\n\n    public static void main(String[] args) {\n        Horse1 h = new WhiteHorse1();\n        h.eat();\n    }\n\n}\n\nclass Horse1 {\n    public void eat() {\n        System.out.println(&quot;horse eatting&quot;);\n    }\n}\n\nclass WhiteHorse1 extends Horse1 {\n    @Override\n    public void eat() {\n        System.out.println(&quot;WhiteHorse1 horse eatting&quot;);\n    }\n}\n\nclass BlackHorse1 extends Horse1 {\n    @Override\n    public void eat() {\n        System.out.println(&quot;BlackHorse1 horse eatting&quot;);\n    }\n}\n</code></pre><blockquote>\n<p>打印结果：<br>WhiteHorse1 horse eatting</p>\n</blockquote>\n<p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>\n<h4 id=\"宗量\"><a href=\"#宗量\" class=\"headerlink\" title=\"宗量\"></a>宗量</h4><p>一个方法所属的对象叫做方法的接收者；<br>方法的接收者与方法的参数统称为方法的宗量。</p>\n<p>根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言和多分派语言。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。</p>\n<p>Java是动态的单分派语言，因为动态分派仅仅会考虑到方法的接收者类型。<br>Java又是静态的多分派语言，因为他对重载方法的分派会考虑到方法的接收者类型以及方法的所有参数的类型。</p>\n<p>在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在Java语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态的单分派的特征。</p>\n"},{"title":"适配器模式","date":"2017-06-21T00:00:00.000Z","_content":"\n#### 定义 ####\n\n适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(wrapper)。适配器模式有类的适配器模式和对象的适配器模式两种。\n  \n#### 模式结构 ####\n\n##### 类适配器模式 #####\n\n- Target：目标角色。所期待得到的接口。由于是类适配器模式，因此目标是接口不是类。\n- Adapee：源角色。限制需要适配的接口。\n- Adapter：适配器角色。适配器类是本模式的核心。适配器把源转换为目标。\n \n![类图](/images/adapter_pattern_class_diagram_1.png)\n\n##### 对象适配器模式 #####\n\n![类图](/images/adapter_pattern_class_diagram_2.png)\n\n#### 时序图 ####\n\n![时序图](/images/adapter_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\t\n##### 类适配器模式 #####\n\n目标角色：\n\tpackage AdapterPattern;\n\n\tpublic interface Target {\n\t\n\t\t/**\n\t\t * 源类{@link Adaptee}}中已存在\n\t\t */\n\t\tvoid sampleOperation1();\n\t\n\t\t/**\n\t\t * 源类{@link Adaptee}}中需要添加\n\t\t */\n\t\tvoid sampleOperation2();\n\t\n\t}\n\n源角色：\n\t\n\t\tpackage AdapterPattern;\n\t\n\tpublic class Adaptee {\n\t\tpublic void sampleOperation1() {\n\t\t}\n\t}\n\n适配器角色：\n\n\tpackage AdapterPattern;\n\t\n\tpublic class Adapter extends Adaptee implements Target {\n\t\n\t\t/**\n\t\t * 源类{@link Adaptee}}中没有，需要扩展的方法\n\t\t */\n\t\t@Override\n\t\tpublic void sampleOperation2() {\n\t\t\tSystem.out.println(\"扩展方法\");\n\t\t}\n\t\n\t}\n\n##### 对象适配器模式 #####\n\n源、目标角色都不变，只是在适配器类中，增加对源对引用，代码如下：\n\t\n\tpackage AdapterPattern;\n\t\n\tpublic class ObjectAdapter implements Target {\n\t\tAdaptee a;\n\t\n\t\tpublic ObjectAdapter(Adaptee a) {\n\t\t\tthis.a = a;\n\t\t}\n\t\n\t\t@Override\n\t\tpublic void sampleOperation1() {\n\t\t\ta.sampleOperation1();\n\t\t}\n\t\n\t\t@Override\n\t\tpublic void sampleOperation2() {\n\t\t\t// 扩充方法\n\t\t}\n\t}\n\n\n\n#### 分析 ####\n\n- 通常，客户端通过目标类的接口访问目标提供的服务。有时，现有的类功能上可以满足，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。\n- 适配器提供客户类需要的接口，把客户类的请求转化为对适配器的相应接口的调用。`也就是说，当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法`，这个过程对客户类是透明的，客户类并不直接访问适配者类。\n\n##### 优点 #####\n\n- 将目标类和适配者类解耦，通过引入一个适配类来重用现有的适配者类，而无需修改原代码\n- 增加类类的透明性和复用性\n- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换/增加适配器\n- 类适配器模式中，由于适配器类是适配者类的子类，因此可以在适配器类中置换一下适配者的方法，使得适配器更加灵活\n- 对象适配器模式中，一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。\n\n##### 缺点 #####\n\n-  类适配器中，java、C#不支持多继承，一次最多只能适配一个适配者类，并且目标不能为具体类，使用有局限性，不能将一个适配者类和它的子类都适配到目标接口\n-  对象适配器中，无法很好的置换适配者类的方法。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。\n \n#### 扩展-缺省适配器 ####\n\n简单理解：接口-抽象类-实现类\n如果接口中定义的方法过多，可以先用一个抽象类，以空方法实现即`平庸实现`，然后具体实现类根据需要实现。\n也叫做单接口适配器模式。\n\n这个用的多一些。好像模版方法。\n\n\n\n\n","source":"_posts/2017-06-21-design-patterns-adapter.md","raw":"---\ntitle: 适配器模式\ndate: 2017-06-21\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(wrapper)。适配器模式有类的适配器模式和对象的适配器模式两种。\n  \n#### 模式结构 ####\n\n##### 类适配器模式 #####\n\n- Target：目标角色。所期待得到的接口。由于是类适配器模式，因此目标是接口不是类。\n- Adapee：源角色。限制需要适配的接口。\n- Adapter：适配器角色。适配器类是本模式的核心。适配器把源转换为目标。\n \n![类图](/images/adapter_pattern_class_diagram_1.png)\n\n##### 对象适配器模式 #####\n\n![类图](/images/adapter_pattern_class_diagram_2.png)\n\n#### 时序图 ####\n\n![时序图](/images/adapter_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\t\n##### 类适配器模式 #####\n\n目标角色：\n\tpackage AdapterPattern;\n\n\tpublic interface Target {\n\t\n\t\t/**\n\t\t * 源类{@link Adaptee}}中已存在\n\t\t */\n\t\tvoid sampleOperation1();\n\t\n\t\t/**\n\t\t * 源类{@link Adaptee}}中需要添加\n\t\t */\n\t\tvoid sampleOperation2();\n\t\n\t}\n\n源角色：\n\t\n\t\tpackage AdapterPattern;\n\t\n\tpublic class Adaptee {\n\t\tpublic void sampleOperation1() {\n\t\t}\n\t}\n\n适配器角色：\n\n\tpackage AdapterPattern;\n\t\n\tpublic class Adapter extends Adaptee implements Target {\n\t\n\t\t/**\n\t\t * 源类{@link Adaptee}}中没有，需要扩展的方法\n\t\t */\n\t\t@Override\n\t\tpublic void sampleOperation2() {\n\t\t\tSystem.out.println(\"扩展方法\");\n\t\t}\n\t\n\t}\n\n##### 对象适配器模式 #####\n\n源、目标角色都不变，只是在适配器类中，增加对源对引用，代码如下：\n\t\n\tpackage AdapterPattern;\n\t\n\tpublic class ObjectAdapter implements Target {\n\t\tAdaptee a;\n\t\n\t\tpublic ObjectAdapter(Adaptee a) {\n\t\t\tthis.a = a;\n\t\t}\n\t\n\t\t@Override\n\t\tpublic void sampleOperation1() {\n\t\t\ta.sampleOperation1();\n\t\t}\n\t\n\t\t@Override\n\t\tpublic void sampleOperation2() {\n\t\t\t// 扩充方法\n\t\t}\n\t}\n\n\n\n#### 分析 ####\n\n- 通常，客户端通过目标类的接口访问目标提供的服务。有时，现有的类功能上可以满足，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。\n- 适配器提供客户类需要的接口，把客户类的请求转化为对适配器的相应接口的调用。`也就是说，当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法`，这个过程对客户类是透明的，客户类并不直接访问适配者类。\n\n##### 优点 #####\n\n- 将目标类和适配者类解耦，通过引入一个适配类来重用现有的适配者类，而无需修改原代码\n- 增加类类的透明性和复用性\n- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换/增加适配器\n- 类适配器模式中，由于适配器类是适配者类的子类，因此可以在适配器类中置换一下适配者的方法，使得适配器更加灵活\n- 对象适配器模式中，一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。\n\n##### 缺点 #####\n\n-  类适配器中，java、C#不支持多继承，一次最多只能适配一个适配者类，并且目标不能为具体类，使用有局限性，不能将一个适配者类和它的子类都适配到目标接口\n-  对象适配器中，无法很好的置换适配者类的方法。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。\n \n#### 扩展-缺省适配器 ####\n\n简单理解：接口-抽象类-实现类\n如果接口中定义的方法过多，可以先用一个抽象类，以空方法实现即`平庸实现`，然后具体实现类根据需要实现。\n也叫做单接口适配器模式。\n\n这个用的多一些。好像模版方法。\n\n\n\n\n","slug":"design-patterns-adapter","published":1,"updated":"2017-08-17T02:50:55.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1h1005w2sivlsdm7qpm","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(wrapper)。适配器模式有类的适配器模式和对象的适配器模式两种。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><h5 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h5><ul>\n<li>Target：目标角色。所期待得到的接口。由于是类适配器模式，因此目标是接口不是类。</li>\n<li>Adapee：源角色。限制需要适配的接口。</li>\n<li>Adapter：适配器角色。适配器类是本模式的核心。适配器把源转换为目标。</li>\n</ul>\n<p><img src=\"/images/adapter_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<h5 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h5><p><img src=\"/images/adapter_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/adapter_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><h5 id=\"类适配器模式-1\"><a href=\"#类适配器模式-1\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h5><p>目标角色：<br>    package AdapterPattern;</p>\n<pre><code>public interface Target {\n\n    /**\n     * 源类{@link Adaptee}}中已存在\n     */\n    void sampleOperation1();\n\n    /**\n     * 源类{@link Adaptee}}中需要添加\n     */\n    void sampleOperation2();\n\n}\n</code></pre><p>源角色：</p>\n<pre><code>    package AdapterPattern;\n\npublic class Adaptee {\n    public void sampleOperation1() {\n    }\n}\n</code></pre><p>适配器角色：</p>\n<pre><code>package AdapterPattern;\n\npublic class Adapter extends Adaptee implements Target {\n\n    /**\n     * 源类{@link Adaptee}}中没有，需要扩展的方法\n     */\n    @Override\n    public void sampleOperation2() {\n        System.out.println(&quot;扩展方法&quot;);\n    }\n\n}\n</code></pre><h5 id=\"对象适配器模式-1\"><a href=\"#对象适配器模式-1\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h5><p>源、目标角色都不变，只是在适配器类中，增加对源对引用，代码如下：</p>\n<pre><code>package AdapterPattern;\n\npublic class ObjectAdapter implements Target {\n    Adaptee a;\n\n    public ObjectAdapter(Adaptee a) {\n        this.a = a;\n    }\n\n    @Override\n    public void sampleOperation1() {\n        a.sampleOperation1();\n    }\n\n    @Override\n    public void sampleOperation2() {\n        // 扩充方法\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>通常，客户端通过目标类的接口访问目标提供的服务。有时，现有的类功能上可以满足，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li>\n<li>适配器提供客户类需要的接口，把客户类的请求转化为对适配器的相应接口的调用。<code>也就是说，当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法</code>，这个过程对客户类是透明的，客户类并不直接访问适配者类。</li>\n</ul>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>将目标类和适配者类解耦，通过引入一个适配类来重用现有的适配者类，而无需修改原代码</li>\n<li>增加类类的透明性和复用性</li>\n<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换/增加适配器</li>\n<li>类适配器模式中，由于适配器类是适配者类的子类，因此可以在适配器类中置换一下适配者的方法，使得适配器更加灵活</li>\n<li>对象适配器模式中，一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>类适配器中，java、C#不支持多继承，一次最多只能适配一个适配者类，并且目标不能为具体类，使用有局限性，不能将一个适配者类和它的子类都适配到目标接口</li>\n<li>对象适配器中，无法很好的置换适配者类的方法。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>\n</ul>\n<h4 id=\"扩展-缺省适配器\"><a href=\"#扩展-缺省适配器\" class=\"headerlink\" title=\"扩展-缺省适配器\"></a>扩展-缺省适配器</h4><p>简单理解：接口-抽象类-实现类<br>如果接口中定义的方法过多，可以先用一个抽象类，以空方法实现即<code>平庸实现</code>，然后具体实现类根据需要实现。<br>也叫做单接口适配器模式。</p>\n<p>这个用的多一些。好像模版方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>适配器模式：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(wrapper)。适配器模式有类的适配器模式和对象的适配器模式两种。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><h5 id=\"类适配器模式\"><a href=\"#类适配器模式\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h5><ul>\n<li>Target：目标角色。所期待得到的接口。由于是类适配器模式，因此目标是接口不是类。</li>\n<li>Adapee：源角色。限制需要适配的接口。</li>\n<li>Adapter：适配器角色。适配器类是本模式的核心。适配器把源转换为目标。</li>\n</ul>\n<p><img src=\"/images/adapter_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<h5 id=\"对象适配器模式\"><a href=\"#对象适配器模式\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h5><p><img src=\"/images/adapter_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/adapter_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><h5 id=\"类适配器模式-1\"><a href=\"#类适配器模式-1\" class=\"headerlink\" title=\"类适配器模式\"></a>类适配器模式</h5><p>目标角色：<br>    package AdapterPattern;</p>\n<pre><code>public interface Target {\n\n    /**\n     * 源类{@link Adaptee}}中已存在\n     */\n    void sampleOperation1();\n\n    /**\n     * 源类{@link Adaptee}}中需要添加\n     */\n    void sampleOperation2();\n\n}\n</code></pre><p>源角色：</p>\n<pre><code>    package AdapterPattern;\n\npublic class Adaptee {\n    public void sampleOperation1() {\n    }\n}\n</code></pre><p>适配器角色：</p>\n<pre><code>package AdapterPattern;\n\npublic class Adapter extends Adaptee implements Target {\n\n    /**\n     * 源类{@link Adaptee}}中没有，需要扩展的方法\n     */\n    @Override\n    public void sampleOperation2() {\n        System.out.println(&quot;扩展方法&quot;);\n    }\n\n}\n</code></pre><h5 id=\"对象适配器模式-1\"><a href=\"#对象适配器模式-1\" class=\"headerlink\" title=\"对象适配器模式\"></a>对象适配器模式</h5><p>源、目标角色都不变，只是在适配器类中，增加对源对引用，代码如下：</p>\n<pre><code>package AdapterPattern;\n\npublic class ObjectAdapter implements Target {\n    Adaptee a;\n\n    public ObjectAdapter(Adaptee a) {\n        this.a = a;\n    }\n\n    @Override\n    public void sampleOperation1() {\n        a.sampleOperation1();\n    }\n\n    @Override\n    public void sampleOperation2() {\n        // 扩充方法\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>通常，客户端通过目标类的接口访问目标提供的服务。有时，现有的类功能上可以满足，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li>\n<li>适配器提供客户类需要的接口，把客户类的请求转化为对适配器的相应接口的调用。<code>也就是说，当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法</code>，这个过程对客户类是透明的，客户类并不直接访问适配者类。</li>\n</ul>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>将目标类和适配者类解耦，通过引入一个适配类来重用现有的适配者类，而无需修改原代码</li>\n<li>增加类类的透明性和复用性</li>\n<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换/增加适配器</li>\n<li>类适配器模式中，由于适配器类是适配者类的子类，因此可以在适配器类中置换一下适配者的方法，使得适配器更加灵活</li>\n<li>对象适配器模式中，一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>类适配器中，java、C#不支持多继承，一次最多只能适配一个适配者类，并且目标不能为具体类，使用有局限性，不能将一个适配者类和它的子类都适配到目标接口</li>\n<li>对象适配器中，无法很好的置换适配者类的方法。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>\n</ul>\n<h4 id=\"扩展-缺省适配器\"><a href=\"#扩展-缺省适配器\" class=\"headerlink\" title=\"扩展-缺省适配器\"></a>扩展-缺省适配器</h4><p>简单理解：接口-抽象类-实现类<br>如果接口中定义的方法过多，可以先用一个抽象类，以空方法实现即<code>平庸实现</code>，然后具体实现类根据需要实现。<br>也叫做单接口适配器模式。</p>\n<p>这个用的多一些。好像模版方法。</p>\n"},{"title":"桥接模式","date":"2017-06-22T00:00:00.000Z","_content":"\n#### 定义 ####\n\n桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。\n  \n#### 模式结构 ####\n \n- Abstraction： 抽象化角色，里面维持一个实现化实例的引用\n- RefinedAbstraction：扩展抽象化角色，改变和修正父类对抽象化的定义\n- Implementor：实现化角色。给出实现化角色的接口，但不给出具体的实现。这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作\n- ConcreteImplementor：具体实现化角色。\n\n如图所示，两个继承等级结构之间存在一座桥梁即Abstraction持有Implementor的一个引用。\n \n![类图](/images/bridge_pattern_class_diagram.png)\n \n#### 时序图 ####\n\n![时序图](/images/bridge_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/BridgePattern)\n\n#### 分析 ####\n \n理解桥接模式，重点需要理解如何将抽象化（abstraction）与实现化（implementor）脱耦，使得二者可以独立地变化。\n\n##### 优点 #####\n\n- 分离抽象接口及其实现部分\n- 桥接模式有时类似于多继承方案，但是多继承方案违背类类的单一职责原则，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法\n- 桥接模式提高了 系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统\n- 实现细节对客户透明，可以对用户隐藏实现细节\n \n##### 缺点 #####\n\n- 桥接模式会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者对抽象进行设计与编程\n- 桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围有一定的局限性\n\n#### 扩展 ####\n\n桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。有时在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。\n\n#### 举例 ####\n\n- 跨平台的播放器(播放器、平台两个维度)\n- OA的提醒消息（消息类型、发送方式两个维度）\n\n\n \n\n\n\n\n","source":"_posts/2017-06-22-design-patterns-bridge.md","raw":"---\ntitle: 桥接模式\ndate: 2017-06-22\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。\n  \n#### 模式结构 ####\n \n- Abstraction： 抽象化角色，里面维持一个实现化实例的引用\n- RefinedAbstraction：扩展抽象化角色，改变和修正父类对抽象化的定义\n- Implementor：实现化角色。给出实现化角色的接口，但不给出具体的实现。这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作\n- ConcreteImplementor：具体实现化角色。\n\n如图所示，两个继承等级结构之间存在一座桥梁即Abstraction持有Implementor的一个引用。\n \n![类图](/images/bridge_pattern_class_diagram.png)\n \n#### 时序图 ####\n\n![时序图](/images/bridge_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/BridgePattern)\n\n#### 分析 ####\n \n理解桥接模式，重点需要理解如何将抽象化（abstraction）与实现化（implementor）脱耦，使得二者可以独立地变化。\n\n##### 优点 #####\n\n- 分离抽象接口及其实现部分\n- 桥接模式有时类似于多继承方案，但是多继承方案违背类类的单一职责原则，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法\n- 桥接模式提高了 系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统\n- 实现细节对客户透明，可以对用户隐藏实现细节\n \n##### 缺点 #####\n\n- 桥接模式会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者对抽象进行设计与编程\n- 桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围有一定的局限性\n\n#### 扩展 ####\n\n桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。有时在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。\n\n#### 举例 ####\n\n- 跨平台的播放器(播放器、平台两个维度)\n- OA的提醒消息（消息类型、发送方式两个维度）\n\n\n \n\n\n\n\n","slug":"design-patterns-bridge","published":1,"updated":"2017-08-17T02:50:58.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1h5005z2sivfn8cqeo6","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Abstraction： 抽象化角色，里面维持一个实现化实例的引用</li>\n<li>RefinedAbstraction：扩展抽象化角色，改变和修正父类对抽象化的定义</li>\n<li>Implementor：实现化角色。给出实现化角色的接口，但不给出具体的实现。这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作</li>\n<li>ConcreteImplementor：具体实现化角色。</li>\n</ul>\n<p>如图所示，两个继承等级结构之间存在一座桥梁即Abstraction持有Implementor的一个引用。</p>\n<p><img src=\"/images/bridge_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/bridge_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/BridgePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>理解桥接模式，重点需要理解如何将抽象化（abstraction）与实现化（implementor）脱耦，使得二者可以独立地变化。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>分离抽象接口及其实现部分</li>\n<li>桥接模式有时类似于多继承方案，但是多继承方案违背类类的单一职责原则，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法</li>\n<li>桥接模式提高了 系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</li>\n<li>实现细节对客户透明，可以对用户隐藏实现细节</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>桥接模式会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者对抽象进行设计与编程</li>\n<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围有一定的局限性</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。有时在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><ul>\n<li>跨平台的播放器(播放器、平台两个维度)</li>\n<li>OA的提醒消息（消息类型、发送方式两个维度）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Abstraction： 抽象化角色，里面维持一个实现化实例的引用</li>\n<li>RefinedAbstraction：扩展抽象化角色，改变和修正父类对抽象化的定义</li>\n<li>Implementor：实现化角色。给出实现化角色的接口，但不给出具体的实现。这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作</li>\n<li>ConcreteImplementor：具体实现化角色。</li>\n</ul>\n<p>如图所示，两个继承等级结构之间存在一座桥梁即Abstraction持有Implementor的一个引用。</p>\n<p><img src=\"/images/bridge_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/bridge_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/BridgePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>理解桥接模式，重点需要理解如何将抽象化（abstraction）与实现化（implementor）脱耦，使得二者可以独立地变化。</p>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>分离抽象接口及其实现部分</li>\n<li>桥接模式有时类似于多继承方案，但是多继承方案违背类类的单一职责原则，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法</li>\n<li>桥接模式提高了 系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</li>\n<li>实现细节对客户透明，可以对用户隐藏实现细节</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>桥接模式会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者对抽象进行设计与编程</li>\n<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此使用范围有一定的局限性</li>\n</ul>\n<h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。有时在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><ul>\n<li>跨平台的播放器(播放器、平台两个维度)</li>\n<li>OA的提醒消息（消息类型、发送方式两个维度）</li>\n</ul>\n"},{"title":"组合模式","date":"2017-06-26T00:00:00.000Z","_content":"\n#### 定义 ####\n\n组合模式(Composite Pattern):组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性，组合模式又可以称为“整体-部分”（Part-Whole）模式，它是一种对象结构型模式。\n \n#### 模式结构 ####\n\n- Component：抽象构件。给参加组合的对象定义公共的接口及其默认行为，可以用来管理所有的子对象。在安全式中，可以为接口，不定义具体的方法；在透明式中，定义为抽象类，给出具体的操作及默认处理。\n- Leaf：树叶构件。没有下级子对象的对象。\n- Composite：具体构件。拥有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add,get,remove\n\n##### 安全式组合模式 #####\n \n![类图](/images/composite_pattern_class_diagram_1.png)\n\n##### 透明式组合模式 #####\n \n![类图](/images/composite_pattern_class_diagram_2.png)\n  \n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CompositePattern)\n\n#### 分析 ####\n\n##### 安全式 #####\n\n- 具体构件给出了add、get、remove等方法的声明和实现，而树叶构件类则没有，这样是安全的做法，客户端不可能错误的调用树叶构件的方法，因为树叶构件没有这些方法\n- 由于树叶类和树枝类具有不同的接口，无法面向抽象编程\n\n##### 透明式 #####\n\n- 透明式要求所有的具体构件类、树叶类，均符合一个固定的接口\n- 客户端调用的时候，不再需要区分树枝类、树叶类，可以面向接口编程，对客户端来说，是透明的\n\n \n \n \n\n \n\n\n\n \n\n\n\n\n","source":"_posts/2017-06-26-design-patterns-composite.md","raw":"---\ntitle: 组合模式\ndate: 2017-06-26\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n组合模式(Composite Pattern):组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性，组合模式又可以称为“整体-部分”（Part-Whole）模式，它是一种对象结构型模式。\n \n#### 模式结构 ####\n\n- Component：抽象构件。给参加组合的对象定义公共的接口及其默认行为，可以用来管理所有的子对象。在安全式中，可以为接口，不定义具体的方法；在透明式中，定义为抽象类，给出具体的操作及默认处理。\n- Leaf：树叶构件。没有下级子对象的对象。\n- Composite：具体构件。拥有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add,get,remove\n\n##### 安全式组合模式 #####\n \n![类图](/images/composite_pattern_class_diagram_1.png)\n\n##### 透明式组合模式 #####\n \n![类图](/images/composite_pattern_class_diagram_2.png)\n  \n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CompositePattern)\n\n#### 分析 ####\n\n##### 安全式 #####\n\n- 具体构件给出了add、get、remove等方法的声明和实现，而树叶构件类则没有，这样是安全的做法，客户端不可能错误的调用树叶构件的方法，因为树叶构件没有这些方法\n- 由于树叶类和树枝类具有不同的接口，无法面向抽象编程\n\n##### 透明式 #####\n\n- 透明式要求所有的具体构件类、树叶类，均符合一个固定的接口\n- 客户端调用的时候，不再需要区分树枝类、树叶类，可以面向接口编程，对客户端来说，是透明的\n\n \n \n \n\n \n\n\n\n \n\n\n\n\n","slug":"design-patterns-composite","published":1,"updated":"2017-08-17T02:51:09.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1h700622siv6t8ueo79","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>组合模式(Composite Pattern):组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性，组合模式又可以称为“整体-部分”（Part-Whole）模式，它是一种对象结构型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Component：抽象构件。给参加组合的对象定义公共的接口及其默认行为，可以用来管理所有的子对象。在安全式中，可以为接口，不定义具体的方法；在透明式中，定义为抽象类，给出具体的操作及默认处理。</li>\n<li>Leaf：树叶构件。没有下级子对象的对象。</li>\n<li>Composite：具体构件。拥有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add,get,remove</li>\n</ul>\n<h5 id=\"安全式组合模式\"><a href=\"#安全式组合模式\" class=\"headerlink\" title=\"安全式组合模式\"></a>安全式组合模式</h5><p><img src=\"/images/composite_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<h5 id=\"透明式组合模式\"><a href=\"#透明式组合模式\" class=\"headerlink\" title=\"透明式组合模式\"></a>透明式组合模式</h5><p><img src=\"/images/composite_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CompositePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"安全式\"><a href=\"#安全式\" class=\"headerlink\" title=\"安全式\"></a>安全式</h5><ul>\n<li>具体构件给出了add、get、remove等方法的声明和实现，而树叶构件类则没有，这样是安全的做法，客户端不可能错误的调用树叶构件的方法，因为树叶构件没有这些方法</li>\n<li>由于树叶类和树枝类具有不同的接口，无法面向抽象编程</li>\n</ul>\n<h5 id=\"透明式\"><a href=\"#透明式\" class=\"headerlink\" title=\"透明式\"></a>透明式</h5><ul>\n<li>透明式要求所有的具体构件类、树叶类，均符合一个固定的接口</li>\n<li>客户端调用的时候，不再需要区分树枝类、树叶类，可以面向接口编程，对客户端来说，是透明的</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>组合模式(Composite Pattern):组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象和组合对象的使用具有一致性，组合模式又可以称为“整体-部分”（Part-Whole）模式，它是一种对象结构型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Component：抽象构件。给参加组合的对象定义公共的接口及其默认行为，可以用来管理所有的子对象。在安全式中，可以为接口，不定义具体的方法；在透明式中，定义为抽象类，给出具体的操作及默认处理。</li>\n<li>Leaf：树叶构件。没有下级子对象的对象。</li>\n<li>Composite：具体构件。拥有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add,get,remove</li>\n</ul>\n<h5 id=\"安全式组合模式\"><a href=\"#安全式组合模式\" class=\"headerlink\" title=\"安全式组合模式\"></a>安全式组合模式</h5><p><img src=\"/images/composite_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<h5 id=\"透明式组合模式\"><a href=\"#透明式组合模式\" class=\"headerlink\" title=\"透明式组合模式\"></a>透明式组合模式</h5><p><img src=\"/images/composite_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/CompositePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"安全式\"><a href=\"#安全式\" class=\"headerlink\" title=\"安全式\"></a>安全式</h5><ul>\n<li>具体构件给出了add、get、remove等方法的声明和实现，而树叶构件类则没有，这样是安全的做法，客户端不可能错误的调用树叶构件的方法，因为树叶构件没有这些方法</li>\n<li>由于树叶类和树枝类具有不同的接口，无法面向抽象编程</li>\n</ul>\n<h5 id=\"透明式\"><a href=\"#透明式\" class=\"headerlink\" title=\"透明式\"></a>透明式</h5><ul>\n<li>透明式要求所有的具体构件类、树叶类，均符合一个固定的接口</li>\n<li>客户端调用的时候，不再需要区分树枝类、树叶类，可以面向接口编程，对客户端来说，是透明的</li>\n</ul>\n"},{"title":"装饰模式","date":"2017-06-23T00:00:00.000Z","_content":"\n#### 定义 ####\n\n装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。其别名也称为包装器（Wrapper），与适配器模式的别名相同，但是他们适用于不同的场合。装饰模式也有人称之为“油漆工模式”。\n  \n#### 模式结构 ####\n\n- Component:抽象构件角色。给出一个接口，以规范准备接收附加责任的对象。\n- ConcreteComponent：具体构件角色。定义一个将要接收附加责任的类。\n- Decorator：装饰角色。持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。\n- ConcreteDecorator：具体装饰角色。负责给构件对象添加责任。\n\n![类图](/images/decorator_pattern_class_diagram_1.png)\n\n> 如果只有一个具体组件(ConcreteComponent)，可以考虑去掉抽象组件类(Component)，把Decorator做为一个ConcreteComponent子类。\n\n![类图](/images/decorator_pattern_class_diagram_2.png)\n\n> 如果只有ConcreteDecorator，那么没必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。\n\n![类图](/images/decorator_pattern_class_diagram_3.png)\n \n#### 时序图 ####\n\n![时序图](/images/decorator_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/DecoratorPattern)\n\n#### 分析 ####\n \n- 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。\n- 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n \n\n##### 优点 #####\n\n- 通过一种动态方式来扩展一个对象的功能，通过配置文件在运行时选择不同的装饰器，从而实现不同的行为\n- 具体构件类和具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”\n   \n##### 缺点 #####\n\n- 装饰模式会产生许多小对象，这些对象的区别在于它们之间相互连接的方式不同，会增加系统的复杂度 \n- 比继承更加灵活，也比继承更加容易出错，排错比较困难，对于多次装饰的对象，调试更加繁琐\n\n#### 应用 ####\n\n- 修改一个final类\n- 动态、透明的添加/撤销对象的职责\n- 系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长\n\n#### 扩展-透明性要求 ####\n\n装饰模式对客户端的透明性要求程序不要声明一个具体类型（ConcreteComponent）的变量，而应当声明一个Component类型的变量。\n\n然而纯粹的装饰很难找到，在增强性能的时候，需要增加新的公开的方法，这就意味着客户端可以声明具体类型，从而调用具体装饰器中的新增方法。\n\n半透明装饰模式是介于装饰模式和适配器模式之间的。大多装饰模式实际上是半透明的，这样的装饰模式也称作半装饰、半适配器模式。\n\n\n#### 开发中应用 ####\n\nupdate@2017年7月17日11:16:45\n\n需求：需要一个垂直，自动滑动的ViewPager。\n\n我已有一个横向，自动滑动的ViewPager。打算使用装饰者设计模式，添加垂直滑动的行为。\n\n分析：\n\n- ViewPager只有一个实现类，所以装饰类可以直接继承该具体实现类\n- 由于又只有一个具体装饰类，可以省略掉抽象装饰类\n\n结果：退化为继承\n\n本来的目的是使用装饰者模式，来增加行为。现在由于需求比较简单，使用继承即可。\n \n\n\n\n\n","source":"_posts/2017-06-23-design-patterns-decorator.md","raw":"---\ntitle: 装饰模式\ndate: 2017-06-23\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。其别名也称为包装器（Wrapper），与适配器模式的别名相同，但是他们适用于不同的场合。装饰模式也有人称之为“油漆工模式”。\n  \n#### 模式结构 ####\n\n- Component:抽象构件角色。给出一个接口，以规范准备接收附加责任的对象。\n- ConcreteComponent：具体构件角色。定义一个将要接收附加责任的类。\n- Decorator：装饰角色。持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。\n- ConcreteDecorator：具体装饰角色。负责给构件对象添加责任。\n\n![类图](/images/decorator_pattern_class_diagram_1.png)\n\n> 如果只有一个具体组件(ConcreteComponent)，可以考虑去掉抽象组件类(Component)，把Decorator做为一个ConcreteComponent子类。\n\n![类图](/images/decorator_pattern_class_diagram_2.png)\n\n> 如果只有ConcreteDecorator，那么没必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。\n\n![类图](/images/decorator_pattern_class_diagram_3.png)\n \n#### 时序图 ####\n\n![时序图](/images/decorator_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/DecoratorPattern)\n\n#### 分析 ####\n \n- 与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。\n- 使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。\n \n\n##### 优点 #####\n\n- 通过一种动态方式来扩展一个对象的功能，通过配置文件在运行时选择不同的装饰器，从而实现不同的行为\n- 具体构件类和具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”\n   \n##### 缺点 #####\n\n- 装饰模式会产生许多小对象，这些对象的区别在于它们之间相互连接的方式不同，会增加系统的复杂度 \n- 比继承更加灵活，也比继承更加容易出错，排错比较困难，对于多次装饰的对象，调试更加繁琐\n\n#### 应用 ####\n\n- 修改一个final类\n- 动态、透明的添加/撤销对象的职责\n- 系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长\n\n#### 扩展-透明性要求 ####\n\n装饰模式对客户端的透明性要求程序不要声明一个具体类型（ConcreteComponent）的变量，而应当声明一个Component类型的变量。\n\n然而纯粹的装饰很难找到，在增强性能的时候，需要增加新的公开的方法，这就意味着客户端可以声明具体类型，从而调用具体装饰器中的新增方法。\n\n半透明装饰模式是介于装饰模式和适配器模式之间的。大多装饰模式实际上是半透明的，这样的装饰模式也称作半装饰、半适配器模式。\n\n\n#### 开发中应用 ####\n\nupdate@2017年7月17日11:16:45\n\n需求：需要一个垂直，自动滑动的ViewPager。\n\n我已有一个横向，自动滑动的ViewPager。打算使用装饰者设计模式，添加垂直滑动的行为。\n\n分析：\n\n- ViewPager只有一个实现类，所以装饰类可以直接继承该具体实现类\n- 由于又只有一个具体装饰类，可以省略掉抽象装饰类\n\n结果：退化为继承\n\n本来的目的是使用装饰者模式，来增加行为。现在由于需求比较简单，使用继承即可。\n \n\n\n\n\n","slug":"design-patterns-decorator","published":1,"updated":"2017-08-17T02:51:02.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1h900652sivqr34hxzw","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。其别名也称为包装器（Wrapper），与适配器模式的别名相同，但是他们适用于不同的场合。装饰模式也有人称之为“油漆工模式”。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Component:抽象构件角色。给出一个接口，以规范准备接收附加责任的对象。</li>\n<li>ConcreteComponent：具体构件角色。定义一个将要接收附加责任的类。</li>\n<li>Decorator：装饰角色。持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。</li>\n<li>ConcreteDecorator：具体装饰角色。负责给构件对象添加责任。</li>\n</ul>\n<p><img src=\"/images/decorator_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<blockquote>\n<p>如果只有一个具体组件(ConcreteComponent)，可以考虑去掉抽象组件类(Component)，把Decorator做为一个ConcreteComponent子类。</p>\n</blockquote>\n<p><img src=\"/images/decorator_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<blockquote>\n<p>如果只有ConcreteDecorator，那么没必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。</p>\n</blockquote>\n<p><img src=\"/images/decorator_pattern_class_diagram_3.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/decorator_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/DecoratorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。</li>\n<li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>\n</ul>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>通过一种动态方式来扩展一个对象的功能，通过配置文件在运行时选择不同的装饰器，从而实现不同的行为</li>\n<li>具体构件类和具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>装饰模式会产生许多小对象，这些对象的区别在于它们之间相互连接的方式不同，会增加系统的复杂度 </li>\n<li>比继承更加灵活，也比继承更加容易出错，排错比较困难，对于多次装饰的对象，调试更加繁琐</li>\n</ul>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ul>\n<li>修改一个final类</li>\n<li>动态、透明的添加/撤销对象的职责</li>\n<li>系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li>\n</ul>\n<h4 id=\"扩展-透明性要求\"><a href=\"#扩展-透明性要求\" class=\"headerlink\" title=\"扩展-透明性要求\"></a>扩展-透明性要求</h4><p>装饰模式对客户端的透明性要求程序不要声明一个具体类型（ConcreteComponent）的变量，而应当声明一个Component类型的变量。</p>\n<p>然而纯粹的装饰很难找到，在增强性能的时候，需要增加新的公开的方法，这就意味着客户端可以声明具体类型，从而调用具体装饰器中的新增方法。</p>\n<p>半透明装饰模式是介于装饰模式和适配器模式之间的。大多装饰模式实际上是半透明的，这样的装饰模式也称作半装饰、半适配器模式。</p>\n<h4 id=\"开发中应用\"><a href=\"#开发中应用\" class=\"headerlink\" title=\"开发中应用\"></a>开发中应用</h4><p>update@2017年7月17日11:16:45</p>\n<p>需求：需要一个垂直，自动滑动的ViewPager。</p>\n<p>我已有一个横向，自动滑动的ViewPager。打算使用装饰者设计模式，添加垂直滑动的行为。</p>\n<p>分析：</p>\n<ul>\n<li>ViewPager只有一个实现类，所以装饰类可以直接继承该具体实现类</li>\n<li>由于又只有一个具体装饰类，可以省略掉抽象装饰类</li>\n</ul>\n<p>结果：退化为继承</p>\n<p>本来的目的是使用装饰者模式，来增加行为。现在由于需求比较简单，使用继承即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>装饰模式（Decorator Pattern）：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。其别名也称为包装器（Wrapper），与适配器模式的别名相同，但是他们适用于不同的场合。装饰模式也有人称之为“油漆工模式”。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Component:抽象构件角色。给出一个接口，以规范准备接收附加责任的对象。</li>\n<li>ConcreteComponent：具体构件角色。定义一个将要接收附加责任的类。</li>\n<li>Decorator：装饰角色。持有一个构件对象的实例，并定义一个与抽象构件接口一致的接口。</li>\n<li>ConcreteDecorator：具体装饰角色。负责给构件对象添加责任。</li>\n</ul>\n<p><img src=\"/images/decorator_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<blockquote>\n<p>如果只有一个具体组件(ConcreteComponent)，可以考虑去掉抽象组件类(Component)，把Decorator做为一个ConcreteComponent子类。</p>\n</blockquote>\n<p><img src=\"/images/decorator_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<blockquote>\n<p>如果只有ConcreteDecorator，那么没必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。</p>\n</blockquote>\n<p><img src=\"/images/decorator_pattern_class_diagram_3.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/decorator_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/DecoratorPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。</li>\n<li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>\n</ul>\n<h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>通过一种动态方式来扩展一个对象的功能，通过配置文件在运行时选择不同的装饰器，从而实现不同的行为</li>\n<li>具体构件类和具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>装饰模式会产生许多小对象，这些对象的区别在于它们之间相互连接的方式不同，会增加系统的复杂度 </li>\n<li>比继承更加灵活，也比继承更加容易出错，排错比较困难，对于多次装饰的对象，调试更加繁琐</li>\n</ul>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><ul>\n<li>修改一个final类</li>\n<li>动态、透明的添加/撤销对象的职责</li>\n<li>系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li>\n</ul>\n<h4 id=\"扩展-透明性要求\"><a href=\"#扩展-透明性要求\" class=\"headerlink\" title=\"扩展-透明性要求\"></a>扩展-透明性要求</h4><p>装饰模式对客户端的透明性要求程序不要声明一个具体类型（ConcreteComponent）的变量，而应当声明一个Component类型的变量。</p>\n<p>然而纯粹的装饰很难找到，在增强性能的时候，需要增加新的公开的方法，这就意味着客户端可以声明具体类型，从而调用具体装饰器中的新增方法。</p>\n<p>半透明装饰模式是介于装饰模式和适配器模式之间的。大多装饰模式实际上是半透明的，这样的装饰模式也称作半装饰、半适配器模式。</p>\n<h4 id=\"开发中应用\"><a href=\"#开发中应用\" class=\"headerlink\" title=\"开发中应用\"></a>开发中应用</h4><p>update@2017年7月17日11:16:45</p>\n<p>需求：需要一个垂直，自动滑动的ViewPager。</p>\n<p>我已有一个横向，自动滑动的ViewPager。打算使用装饰者设计模式，添加垂直滑动的行为。</p>\n<p>分析：</p>\n<ul>\n<li>ViewPager只有一个实现类，所以装饰类可以直接继承该具体实现类</li>\n<li>由于又只有一个具体装饰类，可以省略掉抽象装饰类</li>\n</ul>\n<p>结果：退化为继承</p>\n<p>本来的目的是使用装饰者模式，来增加行为。现在由于需求比较简单，使用继承即可。</p>\n"},{"title":"外观模式","date":"2017-06-26T00:00:00.000Z","_content":"\n#### 定义 ####\n\n外观模式(facade pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。\n\n注意：facade大概读音“佛撒的”，不要读做“非K特” ==！\n  \n#### 模式结构 ####\n\n- Facade：外观角色\n- SubSystem：子系统角色\n\n![类图](/images/facade_pattern_class_diagram.png)\n  \n#### 时序图 ####\n\n![时序图](/images/facade_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FacadePattern)\n\n\tpackage FacadePattern;\n\t\n\t/**\n\t * 不要通过继承一个门面类，为某个子系统增加行为。<br/>\n\t * \n\t * 使用装饰、适配器等为具体的子系统添加行为。<br/>\n\t * \n\t * Facade只是为子系统提供一个集中化和简化的沟通管道，不能向子系统中添加行为。<br/>\n\t * \n\t * final只能阻止继承，不能阻止通过其他方式添加行为，这个需要依靠开发者的自律的，是个缺点。<br/>\n\t * \n\t * 外观类可以有多个，因此可以引入抽象外观类来对系统进行改进。<br/>\n\t * \n\t * 这样又和策略模式相似了，策略是行为型，外观是对象型。\n\t * @author sxx.xu\n\t *\n\t */\n\tpublic final class Facade {\n\t\n\t\tpublic void operation() {\n\t\t\tSystemA a = new SystemA();\n\t\t\tSystemB b = new SystemB();\n\t\n\t\t\ta.operationA();\n\t\t\tb.operationB();\n\t\t}\n\t}\n\n********\n\t\n\tpackage FacadePattern;\n\t\n\t/**\n\t * 可以同时有多个子系统类，每个子系统都不是一个单独的类，而是一个类的集合。<br/>\n\t * \n\t * 子系统可以被客户端调用，也可以被外观调用。<br/>\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class SystemA {\n\t\n\t\tpublic void operationA() {\n\t\t\tSystem.out.println(\"SystemA operation\");\n\t\t}\n\t}\n\n#### 分析 ####\n\n\n##### 优点 #####\n\n- 根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。\n- 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度\n- 外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道\n\n##### 缺点 #####\n\n-  不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多限制则减少了可变性和灵活性\n-  在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”\n\n \n\n\n\n \n\n\n\n\n","source":"_posts/2017-06-26-design-patterns-facade.md","raw":"---\ntitle: 外观模式\ndate: 2017-06-26\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n外观模式(facade pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。\n\n注意：facade大概读音“佛撒的”，不要读做“非K特” ==！\n  \n#### 模式结构 ####\n\n- Facade：外观角色\n- SubSystem：子系统角色\n\n![类图](/images/facade_pattern_class_diagram.png)\n  \n#### 时序图 ####\n\n![时序图](/images/facade_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FacadePattern)\n\n\tpackage FacadePattern;\n\t\n\t/**\n\t * 不要通过继承一个门面类，为某个子系统增加行为。<br/>\n\t * \n\t * 使用装饰、适配器等为具体的子系统添加行为。<br/>\n\t * \n\t * Facade只是为子系统提供一个集中化和简化的沟通管道，不能向子系统中添加行为。<br/>\n\t * \n\t * final只能阻止继承，不能阻止通过其他方式添加行为，这个需要依靠开发者的自律的，是个缺点。<br/>\n\t * \n\t * 外观类可以有多个，因此可以引入抽象外观类来对系统进行改进。<br/>\n\t * \n\t * 这样又和策略模式相似了，策略是行为型，外观是对象型。\n\t * @author sxx.xu\n\t *\n\t */\n\tpublic final class Facade {\n\t\n\t\tpublic void operation() {\n\t\t\tSystemA a = new SystemA();\n\t\t\tSystemB b = new SystemB();\n\t\n\t\t\ta.operationA();\n\t\t\tb.operationB();\n\t\t}\n\t}\n\n********\n\t\n\tpackage FacadePattern;\n\t\n\t/**\n\t * 可以同时有多个子系统类，每个子系统都不是一个单独的类，而是一个类的集合。<br/>\n\t * \n\t * 子系统可以被客户端调用，也可以被外观调用。<br/>\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class SystemA {\n\t\n\t\tpublic void operationA() {\n\t\t\tSystem.out.println(\"SystemA operation\");\n\t\t}\n\t}\n\n#### 分析 ####\n\n\n##### 优点 #####\n\n- 根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。\n- 外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度\n- 外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道\n\n##### 缺点 #####\n\n-  不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多限制则减少了可变性和灵活性\n-  在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”\n\n \n\n\n\n \n\n\n\n\n","slug":"design-patterns-facade","published":1,"updated":"2017-08-17T02:51:15.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hc00682siv68w5a2xh","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>外观模式(facade pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>\n<p>注意：facade大概读音“佛撒的”，不要读做“非K特” ==！</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Facade：外观角色</li>\n<li>SubSystem：子系统角色</li>\n</ul>\n<p><img src=\"/images/facade_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/facade_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FacadePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<pre><code>package FacadePattern;\n\n/**\n * 不要通过继承一个门面类，为某个子系统增加行为。&lt;br/&gt;\n * \n * 使用装饰、适配器等为具体的子系统添加行为。&lt;br/&gt;\n * \n * Facade只是为子系统提供一个集中化和简化的沟通管道，不能向子系统中添加行为。&lt;br/&gt;\n * \n * final只能阻止继承，不能阻止通过其他方式添加行为，这个需要依靠开发者的自律的，是个缺点。&lt;br/&gt;\n * \n * 外观类可以有多个，因此可以引入抽象外观类来对系统进行改进。&lt;br/&gt;\n * \n * 这样又和策略模式相似了，策略是行为型，外观是对象型。\n * @author sxx.xu\n *\n */\npublic final class Facade {\n\n    public void operation() {\n        SystemA a = new SystemA();\n        SystemB b = new SystemB();\n\n        a.operationA();\n        b.operationB();\n    }\n}\n</code></pre><hr>\n<pre><code>package FacadePattern;\n\n/**\n * 可以同时有多个子系统类，每个子系统都不是一个单独的类，而是一个类的集合。&lt;br/&gt;\n * \n * 子系统可以被客户端调用，也可以被外观调用。&lt;br/&gt;\n * \n * @author sxx.xu\n *\n */\npublic class SystemA {\n\n    public void operationA() {\n        System.out.println(&quot;SystemA operation&quot;);\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</li>\n<li>外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度</li>\n<li>外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多限制则减少了可变性和灵活性</li>\n<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>外观模式(facade pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>\n<p>注意：facade大概读音“佛撒的”，不要读做“非K特” ==！</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Facade：外观角色</li>\n<li>SubSystem：子系统角色</li>\n</ul>\n<p><img src=\"/images/facade_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/facade_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FacadePattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<pre><code>package FacadePattern;\n\n/**\n * 不要通过继承一个门面类，为某个子系统增加行为。&lt;br/&gt;\n * \n * 使用装饰、适配器等为具体的子系统添加行为。&lt;br/&gt;\n * \n * Facade只是为子系统提供一个集中化和简化的沟通管道，不能向子系统中添加行为。&lt;br/&gt;\n * \n * final只能阻止继承，不能阻止通过其他方式添加行为，这个需要依靠开发者的自律的，是个缺点。&lt;br/&gt;\n * \n * 外观类可以有多个，因此可以引入抽象外观类来对系统进行改进。&lt;br/&gt;\n * \n * 这样又和策略模式相似了，策略是行为型，外观是对象型。\n * @author sxx.xu\n *\n */\npublic final class Facade {\n\n    public void operation() {\n        SystemA a = new SystemA();\n        SystemB b = new SystemB();\n\n        a.operationA();\n        b.operationB();\n    }\n}\n</code></pre><hr>\n<pre><code>package FacadePattern;\n\n/**\n * 可以同时有多个子系统类，每个子系统都不是一个单独的类，而是一个类的集合。&lt;br/&gt;\n * \n * 子系统可以被客户端调用，也可以被外观调用。&lt;br/&gt;\n * \n * @author sxx.xu\n *\n */\npublic class SystemA {\n\n    public void operationA() {\n        System.out.println(&quot;SystemA operation&quot;);\n    }\n}\n</code></pre><h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</li>\n<li>外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度</li>\n<li>外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多限制则减少了可变性和灵活性</li>\n<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</li>\n</ul>\n"},{"title":"享元模式","date":"2017-06-27T00:00:00.000Z","_content":"\n#### 定义 ####\n\n享元模式(flyweight pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。\n  \n#### 模式结构 ####\n\n- Flyweight：抽象享元角色。给出抽象接口，定义具体享元角色需要实现的方法\n- ConcreteFlyweight：具体享元角色。实现抽象享元角色，如果有内蕴状态，必须负责为内蕴状态提供存储空间。\n- ConcreteCompositeFlyweight：复合享元角色。复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成多个本身是单纯享元对象的组合。复合享元对象又称作不可共享的享元对象。\n- FlyweightFactory：享元工厂角色。负责创建和管理享元角色。\n\n\n##### 单纯享元模式 #####\n\n![类图](/images/flyweight_pattern_class_diagram_1.png)\n\n##### 组合享元模式 #####\n\n![类图](/images/flyweight_pattern_class_diagram_2.png)\n  \n#### 时序图 ####\n\n![时序图](/images/flyweight_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FlyweightPattern)\n\n#### 分析 ####\n\n##### 优点 #####\n\n- 它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份\n- 外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享\n\n##### 缺点 #####\n\n-  使系统更加复杂，需要分离出内部状态和外部状态，使逻辑复杂化\n-  为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长\n\n \n\n\n\n \n\n\n\n\n","source":"_posts/2017-06-27-design-patterns-flyweight.md","raw":"---\ntitle: 享元模式\ndate: 2017-06-27\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n享元模式(flyweight pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。\n  \n#### 模式结构 ####\n\n- Flyweight：抽象享元角色。给出抽象接口，定义具体享元角色需要实现的方法\n- ConcreteFlyweight：具体享元角色。实现抽象享元角色，如果有内蕴状态，必须负责为内蕴状态提供存储空间。\n- ConcreteCompositeFlyweight：复合享元角色。复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成多个本身是单纯享元对象的组合。复合享元对象又称作不可共享的享元对象。\n- FlyweightFactory：享元工厂角色。负责创建和管理享元角色。\n\n\n##### 单纯享元模式 #####\n\n![类图](/images/flyweight_pattern_class_diagram_1.png)\n\n##### 组合享元模式 #####\n\n![类图](/images/flyweight_pattern_class_diagram_2.png)\n  \n#### 时序图 ####\n\n![时序图](/images/flyweight_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FlyweightPattern)\n\n#### 分析 ####\n\n##### 优点 #####\n\n- 它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份\n- 外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享\n\n##### 缺点 #####\n\n-  使系统更加复杂，需要分离出内部状态和外部状态，使逻辑复杂化\n-  为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长\n\n \n\n\n\n \n\n\n\n\n","slug":"design-patterns-flyweight","published":1,"updated":"2017-08-17T02:51:20.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hg006b2sivb1i39ep0","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>享元模式(flyweight pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Flyweight：抽象享元角色。给出抽象接口，定义具体享元角色需要实现的方法</li>\n<li>ConcreteFlyweight：具体享元角色。实现抽象享元角色，如果有内蕴状态，必须负责为内蕴状态提供存储空间。</li>\n<li>ConcreteCompositeFlyweight：复合享元角色。复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成多个本身是单纯享元对象的组合。复合享元对象又称作不可共享的享元对象。</li>\n<li>FlyweightFactory：享元工厂角色。负责创建和管理享元角色。</li>\n</ul>\n<h5 id=\"单纯享元模式\"><a href=\"#单纯享元模式\" class=\"headerlink\" title=\"单纯享元模式\"></a>单纯享元模式</h5><p><img src=\"/images/flyweight_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<h5 id=\"组合享元模式\"><a href=\"#组合享元模式\" class=\"headerlink\" title=\"组合享元模式\"></a>组合享元模式</h5><p><img src=\"/images/flyweight_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/flyweight_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FlyweightPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份</li>\n<li>外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>使系统更加复杂，需要分离出内部状态和外部状态，使逻辑复杂化</li>\n<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>享元模式(flyweight pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>Flyweight：抽象享元角色。给出抽象接口，定义具体享元角色需要实现的方法</li>\n<li>ConcreteFlyweight：具体享元角色。实现抽象享元角色，如果有内蕴状态，必须负责为内蕴状态提供存储空间。</li>\n<li>ConcreteCompositeFlyweight：复合享元角色。复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成多个本身是单纯享元对象的组合。复合享元对象又称作不可共享的享元对象。</li>\n<li>FlyweightFactory：享元工厂角色。负责创建和管理享元角色。</li>\n</ul>\n<h5 id=\"单纯享元模式\"><a href=\"#单纯享元模式\" class=\"headerlink\" title=\"单纯享元模式\"></a>单纯享元模式</h5><p><img src=\"/images/flyweight_pattern_class_diagram_1.png\" alt=\"类图\"></p>\n<h5 id=\"组合享元模式\"><a href=\"#组合享元模式\" class=\"headerlink\" title=\"组合享元模式\"></a>组合享元模式</h5><p><img src=\"/images/flyweight_pattern_class_diagram_2.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/flyweight_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/FlyweightPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份</li>\n<li>外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>使系统更加复杂，需要分离出内部状态和外部状态，使逻辑复杂化</li>\n<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</li>\n</ul>\n"},{"title":"《图解HTTP》第3、4章","date":"2017-07-03T00:00:00.000Z","_content":"\n#### HTTP报文 ####\n\n- 使用HTTP协议进行交互的信息称为HTTP报文，有请求报文、响应报文两种\n- 报文大致可分为报文首部和报文主体两块，两者由一个空行隔开，报文主体不一定有\n- 请求行：包含用于请求的方法，请求URI和HTTP版本\n- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本\n- 首部字段：包含表示请求和响应的各种条件和属性的各类首部\n- 其他：可能包含HTTP的RFC里未定义的首部，如Cookie等\n\n\n#### 内容协商 ####\n\n内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等做为判断的基准。\n\n- 服务器驱动协商：由服务端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息做为判定的依据，并不一定能筛选出最优内容\n- 客户端驱动协商：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。\n- 透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。\n\n#### 常用的14个HTTP状态码 ####\n\n##### 2xx成功 #####\n- 200 从客户端发来的请求在服务端被正常处理的\n- 204 请求已经成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体，比如浏览器请求，返回204，那么浏览器页面不发生更新\n- 206 客户端进行了范围请求，服务器成功执行了。响应报文中包含由Content-Range指定范围的实体内容\n\n##### 3xx 重定向 #####\n\n- 301 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI\n- 302 临时性重定向\n- 303 由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源\n- 304 客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。304和重定向没有关系\n- 307 临时性重定向\n\n##### 4xx 客户端错误 #####\n\n- 400 请求报文中存在语法错误，需要修改请求的内容后再次发送请求\n- 401 表示发送的请求需要有通过HTTP认证，如果之前已经进行过一次请求，则表示用户认证失败，当浏览器初次接收到401响应，会弹出认证用的对话窗口\n- 403 请求资源的访问被服务器拒绝\n- 404 无法找到请求的资源，也可以在403时拒绝请求且不想说明理由时使用\n\n##### 5xx 服务器错误 #####\n\n- 500 服务端在执行请求时发生了错误\n- 503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\n\n ","source":"_posts/2017-07-03-net-work-day02.md","raw":"---\ntitle: 《图解HTTP》第3、4章\ndate: 2017-07-03\ntags: 网络\ncategories: NetWork\n---\n\n#### HTTP报文 ####\n\n- 使用HTTP协议进行交互的信息称为HTTP报文，有请求报文、响应报文两种\n- 报文大致可分为报文首部和报文主体两块，两者由一个空行隔开，报文主体不一定有\n- 请求行：包含用于请求的方法，请求URI和HTTP版本\n- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本\n- 首部字段：包含表示请求和响应的各种条件和属性的各类首部\n- 其他：可能包含HTTP的RFC里未定义的首部，如Cookie等\n\n\n#### 内容协商 ####\n\n内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等做为判断的基准。\n\n- 服务器驱动协商：由服务端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息做为判定的依据，并不一定能筛选出最优内容\n- 客户端驱动协商：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。\n- 透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。\n\n#### 常用的14个HTTP状态码 ####\n\n##### 2xx成功 #####\n- 200 从客户端发来的请求在服务端被正常处理的\n- 204 请求已经成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体，比如浏览器请求，返回204，那么浏览器页面不发生更新\n- 206 客户端进行了范围请求，服务器成功执行了。响应报文中包含由Content-Range指定范围的实体内容\n\n##### 3xx 重定向 #####\n\n- 301 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI\n- 302 临时性重定向\n- 303 由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源\n- 304 客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。304和重定向没有关系\n- 307 临时性重定向\n\n##### 4xx 客户端错误 #####\n\n- 400 请求报文中存在语法错误，需要修改请求的内容后再次发送请求\n- 401 表示发送的请求需要有通过HTTP认证，如果之前已经进行过一次请求，则表示用户认证失败，当浏览器初次接收到401响应，会弹出认证用的对话窗口\n- 403 请求资源的访问被服务器拒绝\n- 404 无法找到请求的资源，也可以在403时拒绝请求且不想说明理由时使用\n\n##### 5xx 服务器错误 #####\n\n- 500 服务端在执行请求时发生了错误\n- 503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\n\n ","slug":"net-work-day02","published":1,"updated":"2017-08-17T02:51:42.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hi006e2siv38apb4l5","content":"<h4 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h4><ul>\n<li>使用HTTP协议进行交互的信息称为HTTP报文，有请求报文、响应报文两种</li>\n<li>报文大致可分为报文首部和报文主体两块，两者由一个空行隔开，报文主体不一定有</li>\n<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>\n<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>\n<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>\n<li>其他：可能包含HTTP的RFC里未定义的首部，如Cookie等</li>\n</ul>\n<h4 id=\"内容协商\"><a href=\"#内容协商\" class=\"headerlink\" title=\"内容协商\"></a>内容协商</h4><p>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等做为判断的基准。</p>\n<ul>\n<li>服务器驱动协商：由服务端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息做为判定的依据，并不一定能筛选出最优内容</li>\n<li>客户端驱动协商：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。</li>\n<li>透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li>\n</ul>\n<h4 id=\"常用的14个HTTP状态码\"><a href=\"#常用的14个HTTP状态码\" class=\"headerlink\" title=\"常用的14个HTTP状态码\"></a>常用的14个HTTP状态码</h4><h5 id=\"2xx成功\"><a href=\"#2xx成功\" class=\"headerlink\" title=\"2xx成功\"></a>2xx成功</h5><ul>\n<li>200 从客户端发来的请求在服务端被正常处理的</li>\n<li>204 请求已经成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体，比如浏览器请求，返回204，那么浏览器页面不发生更新</li>\n<li>206 客户端进行了范围请求，服务器成功执行了。响应报文中包含由Content-Range指定范围的实体内容</li>\n</ul>\n<h5 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h5><ul>\n<li>301 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</li>\n<li>302 临时性重定向</li>\n<li>303 由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>\n<li>304 客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。304和重定向没有关系</li>\n<li>307 临时性重定向</li>\n</ul>\n<h5 id=\"4xx-客户端错误\"><a href=\"#4xx-客户端错误\" class=\"headerlink\" title=\"4xx 客户端错误\"></a>4xx 客户端错误</h5><ul>\n<li>400 请求报文中存在语法错误，需要修改请求的内容后再次发送请求</li>\n<li>401 表示发送的请求需要有通过HTTP认证，如果之前已经进行过一次请求，则表示用户认证失败，当浏览器初次接收到401响应，会弹出认证用的对话窗口</li>\n<li>403 请求资源的访问被服务器拒绝</li>\n<li>404 无法找到请求的资源，也可以在403时拒绝请求且不想说明理由时使用</li>\n</ul>\n<h5 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx 服务器错误\"></a>5xx 服务器错误</h5><ul>\n<li>500 服务端在执行请求时发生了错误</li>\n<li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h4><ul>\n<li>使用HTTP协议进行交互的信息称为HTTP报文，有请求报文、响应报文两种</li>\n<li>报文大致可分为报文首部和报文主体两块，两者由一个空行隔开，报文主体不一定有</li>\n<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>\n<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>\n<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>\n<li>其他：可能包含HTTP的RFC里未定义的首部，如Cookie等</li>\n</ul>\n<h4 id=\"内容协商\"><a href=\"#内容协商\" class=\"headerlink\" title=\"内容协商\"></a>内容协商</h4><p>内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等做为判断的基准。</p>\n<ul>\n<li>服务器驱动协商：由服务端进行内容协商。以请求的首部字段为参考，在服务端自动处理。但对用户来说，以浏览器发送的信息做为判定的依据，并不一定能筛选出最优内容</li>\n<li>客户端驱动协商：由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面。</li>\n<li>透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li>\n</ul>\n<h4 id=\"常用的14个HTTP状态码\"><a href=\"#常用的14个HTTP状态码\" class=\"headerlink\" title=\"常用的14个HTTP状态码\"></a>常用的14个HTTP状态码</h4><h5 id=\"2xx成功\"><a href=\"#2xx成功\" class=\"headerlink\" title=\"2xx成功\"></a>2xx成功</h5><ul>\n<li>200 从客户端发来的请求在服务端被正常处理的</li>\n<li>204 请求已经成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体，比如浏览器请求，返回204，那么浏览器页面不发生更新</li>\n<li>206 客户端进行了范围请求，服务器成功执行了。响应报文中包含由Content-Range指定范围的实体内容</li>\n</ul>\n<h5 id=\"3xx-重定向\"><a href=\"#3xx-重定向\" class=\"headerlink\" title=\"3xx 重定向\"></a>3xx 重定向</h5><ul>\n<li>301 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</li>\n<li>302 临时性重定向</li>\n<li>303 由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>\n<li>304 客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。304和重定向没有关系</li>\n<li>307 临时性重定向</li>\n</ul>\n<h5 id=\"4xx-客户端错误\"><a href=\"#4xx-客户端错误\" class=\"headerlink\" title=\"4xx 客户端错误\"></a>4xx 客户端错误</h5><ul>\n<li>400 请求报文中存在语法错误，需要修改请求的内容后再次发送请求</li>\n<li>401 表示发送的请求需要有通过HTTP认证，如果之前已经进行过一次请求，则表示用户认证失败，当浏览器初次接收到401响应，会弹出认证用的对话窗口</li>\n<li>403 请求资源的访问被服务器拒绝</li>\n<li>404 无法找到请求的资源，也可以在403时拒绝请求且不想说明理由时使用</li>\n</ul>\n<h5 id=\"5xx-服务器错误\"><a href=\"#5xx-服务器错误\" class=\"headerlink\" title=\"5xx 服务器错误\"></a>5xx 服务器错误</h5><ul>\n<li>500 服务端在执行请求时发生了错误</li>\n<li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>\n</ul>\n"},{"title":"《图解HTTP》第1、2章","date":"2017-06-29T00:00:00.000Z","_content":"#### tcp/ip的分层管理 ####\n\n- 应用层 http、ftp、dns\n- 传输层 tcp-提供可靠的字节流服务、udp\n- 网络层 ip协议，作用是把各种数据包传送给对方\n- 数据链路层 硬件相关\n\n#### tcp/ip通信传输流 ####\n\n利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从数据链路层往上走。假下如图是客户端想要看某个web页面的http请求：\n\n![通信传输流](/images/tcp-ip通信传输流.png)\n\n- 在应用层，使用HTTP协议，发出请求，此处会先请求DNS服务，获取请求网址对应的IP地址\n- 在传输层(TCP协议)，把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文段上打上标记序号及端口号后[可靠地]转发给网络层\n- 在网络层(IP协议)，增加做为通信目的地的MAC地址后转发给链路层，接收端的服务器在链路层收到数据，按序往上层发送直至应用层\n\n发送端在层与层之间传输数据时，没经过一层必定会被打上一个该层所属的首部信息。在接收端则反之。\n\n\n#### TCP三次握手 ####\n\n- 发送端发送待遇SYN的数据包\n- 接收端接收到后，发送带有SYN/ACK标志的数据包表示确认信息\n- 发送端再回传一个带有ACK的数据包，代表“握手”结束\n- 如果在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包\n \n#### http 方法 ####\n\n- get\n- post\n- delete\n- put\n- header\n- options\n- trace\n- connect\n- link 1.0\n- unlink 1.0\n\n#### HTTP 持久链接 ####\n\n![持久连接](/images/HTTP持久连接.png)\n\nkeep-alive,只要任意一端没有明确提出断开连接，则保持TCP连接状态。\nHTTP/1.1中，连接默认是持久连接\nHTTP是无状态的协议，可以使用Cookie来保存状态","source":"_posts/2017-06-29-net-work-day01.md","raw":"---\ntitle: 《图解HTTP》第1、2章\ndate: 2017-06-29\ntags: 网络\ncategories: NetWork\n---\n#### tcp/ip的分层管理 ####\n\n- 应用层 http、ftp、dns\n- 传输层 tcp-提供可靠的字节流服务、udp\n- 网络层 ip协议，作用是把各种数据包传送给对方\n- 数据链路层 硬件相关\n\n#### tcp/ip通信传输流 ####\n\n利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从数据链路层往上走。假下如图是客户端想要看某个web页面的http请求：\n\n![通信传输流](/images/tcp-ip通信传输流.png)\n\n- 在应用层，使用HTTP协议，发出请求，此处会先请求DNS服务，获取请求网址对应的IP地址\n- 在传输层(TCP协议)，把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文段上打上标记序号及端口号后[可靠地]转发给网络层\n- 在网络层(IP协议)，增加做为通信目的地的MAC地址后转发给链路层，接收端的服务器在链路层收到数据，按序往上层发送直至应用层\n\n发送端在层与层之间传输数据时，没经过一层必定会被打上一个该层所属的首部信息。在接收端则反之。\n\n\n#### TCP三次握手 ####\n\n- 发送端发送待遇SYN的数据包\n- 接收端接收到后，发送带有SYN/ACK标志的数据包表示确认信息\n- 发送端再回传一个带有ACK的数据包，代表“握手”结束\n- 如果在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包\n \n#### http 方法 ####\n\n- get\n- post\n- delete\n- put\n- header\n- options\n- trace\n- connect\n- link 1.0\n- unlink 1.0\n\n#### HTTP 持久链接 ####\n\n![持久连接](/images/HTTP持久连接.png)\n\nkeep-alive,只要任意一端没有明确提出断开连接，则保持TCP连接状态。\nHTTP/1.1中，连接默认是持久连接\nHTTP是无状态的协议，可以使用Cookie来保存状态","slug":"net-work-day01","published":1,"updated":"2017-08-17T02:51:37.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hk006h2sivghq68slr","content":"<h4 id=\"tcp-ip的分层管理\"><a href=\"#tcp-ip的分层管理\" class=\"headerlink\" title=\"tcp/ip的分层管理\"></a>tcp/ip的分层管理</h4><ul>\n<li>应用层 http、ftp、dns</li>\n<li>传输层 tcp-提供可靠的字节流服务、udp</li>\n<li>网络层 ip协议，作用是把各种数据包传送给对方</li>\n<li>数据链路层 硬件相关</li>\n</ul>\n<h4 id=\"tcp-ip通信传输流\"><a href=\"#tcp-ip通信传输流\" class=\"headerlink\" title=\"tcp/ip通信传输流\"></a>tcp/ip通信传输流</h4><p>利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从数据链路层往上走。假下如图是客户端想要看某个web页面的http请求：</p>\n<p><img src=\"/images/tcp-ip通信传输流.png\" alt=\"通信传输流\"></p>\n<ul>\n<li>在应用层，使用HTTP协议，发出请求，此处会先请求DNS服务，获取请求网址对应的IP地址</li>\n<li>在传输层(TCP协议)，把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文段上打上标记序号及端口号后[可靠地]转发给网络层</li>\n<li>在网络层(IP协议)，增加做为通信目的地的MAC地址后转发给链路层，接收端的服务器在链路层收到数据，按序往上层发送直至应用层</li>\n</ul>\n<p>发送端在层与层之间传输数据时，没经过一层必定会被打上一个该层所属的首部信息。在接收端则反之。</p>\n<h4 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h4><ul>\n<li>发送端发送待遇SYN的数据包</li>\n<li>接收端接收到后，发送带有SYN/ACK标志的数据包表示确认信息</li>\n<li>发送端再回传一个带有ACK的数据包，代表“握手”结束</li>\n<li>如果在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包</li>\n</ul>\n<h4 id=\"http-方法\"><a href=\"#http-方法\" class=\"headerlink\" title=\"http 方法\"></a>http 方法</h4><ul>\n<li>get</li>\n<li>post</li>\n<li>delete</li>\n<li>put</li>\n<li>header</li>\n<li>options</li>\n<li>trace</li>\n<li>connect</li>\n<li>link 1.0</li>\n<li>unlink 1.0</li>\n</ul>\n<h4 id=\"HTTP-持久链接\"><a href=\"#HTTP-持久链接\" class=\"headerlink\" title=\"HTTP 持久链接\"></a>HTTP 持久链接</h4><p><img src=\"/images/HTTP持久连接.png\" alt=\"持久连接\"></p>\n<p>keep-alive,只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>HTTP/1.1中，连接默认是持久连接<br>HTTP是无状态的协议，可以使用Cookie来保存状态</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"tcp-ip的分层管理\"><a href=\"#tcp-ip的分层管理\" class=\"headerlink\" title=\"tcp/ip的分层管理\"></a>tcp/ip的分层管理</h4><ul>\n<li>应用层 http、ftp、dns</li>\n<li>传输层 tcp-提供可靠的字节流服务、udp</li>\n<li>网络层 ip协议，作用是把各种数据包传送给对方</li>\n<li>数据链路层 硬件相关</li>\n</ul>\n<h4 id=\"tcp-ip通信传输流\"><a href=\"#tcp-ip通信传输流\" class=\"headerlink\" title=\"tcp/ip通信传输流\"></a>tcp/ip通信传输流</h4><p>利用TCP/IP协议进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从数据链路层往上走。假下如图是客户端想要看某个web页面的http请求：</p>\n<p><img src=\"/images/tcp-ip通信传输流.png\" alt=\"通信传输流\"></p>\n<ul>\n<li>在应用层，使用HTTP协议，发出请求，此处会先请求DNS服务，获取请求网址对应的IP地址</li>\n<li>在传输层(TCP协议)，把从应用层处收到的数据(HTTP请求报文)进行分割，并在各个报文段上打上标记序号及端口号后[可靠地]转发给网络层</li>\n<li>在网络层(IP协议)，增加做为通信目的地的MAC地址后转发给链路层，接收端的服务器在链路层收到数据，按序往上层发送直至应用层</li>\n</ul>\n<p>发送端在层与层之间传输数据时，没经过一层必定会被打上一个该层所属的首部信息。在接收端则反之。</p>\n<h4 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h4><ul>\n<li>发送端发送待遇SYN的数据包</li>\n<li>接收端接收到后，发送带有SYN/ACK标志的数据包表示确认信息</li>\n<li>发送端再回传一个带有ACK的数据包，代表“握手”结束</li>\n<li>如果在握手过程中某个阶段中断，TCP协议会再次以相同的顺序发送相同的数据包</li>\n</ul>\n<h4 id=\"http-方法\"><a href=\"#http-方法\" class=\"headerlink\" title=\"http 方法\"></a>http 方法</h4><ul>\n<li>get</li>\n<li>post</li>\n<li>delete</li>\n<li>put</li>\n<li>header</li>\n<li>options</li>\n<li>trace</li>\n<li>connect</li>\n<li>link 1.0</li>\n<li>unlink 1.0</li>\n</ul>\n<h4 id=\"HTTP-持久链接\"><a href=\"#HTTP-持久链接\" class=\"headerlink\" title=\"HTTP 持久链接\"></a>HTTP 持久链接</h4><p><img src=\"/images/HTTP持久连接.png\" alt=\"持久连接\"></p>\n<p>keep-alive,只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>HTTP/1.1中，连接默认是持久连接<br>HTTP是无状态的协议，可以使用Cookie来保存状态</p>\n"},{"title":"代理模式","date":"2017-06-28T00:00:00.000Z","_content":"\n#### 定义 ####\n\n代理模式(proxy pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理的英文叫做Proxy或者Surrogate，它是一种对象结构型模式。\n  \n#### 模式结构 ####\n\n- subject：抽象对象角色。声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象\n- realSubject：代理对象所代表的目标对象\n- proxy：代理对象角色。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象\n\n![类图](/images/proxy_pattern_class_diagram.png)\n  \n#### 时序图 ####\n\n![时序图](/images/proxy_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ProxyPattern)\n\n#### 分析 ####\n\n##### 优点 #####\n\n- 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度\n- 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求\n- 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统的资源消耗，对系统进行优化并提高运行速度\n- 保护代理，可以控制对真实对象的使用权限\n\n##### 缺点 #####\n\n-  由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢\n-  实现代理模式需要额外的工作，有些代理模式实现非常复杂\n\n#### 扩展-代理的应用 ####\n\n- 远程（Remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又叫做大使。\n- 虚拟（Virtual）代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。\n- Copy-on-Write代理：这是虚拟代理的一种，把克隆操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销比较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。\n- 保护（Protect of Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。\n- 缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。\n- 防火墙（Firewall）代理：保护目标不让恶意用户接近。\n- 同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突\n- 智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。\n- 图片代理：对大图浏览的控制。用户访问是先不加载真实的大图，而是通过代理对象的方法来进行处理，在该方法中，先使用一个线程为客户加载一个小图，然后在后天使用另一个线程加载大图。当需要浏览大图片时，再显示大图。如果用户浏览大图时，图片加载还没完成，可以再启动一个线程来显示相应的提示信息。\n- 动态代理：较为高级的代理模式，典型应用是Spring AOP。\n\n\n\n \n\n\n\n\n","source":"_posts/2017-06-28-design-patterns-proxy.md","raw":"---\ntitle: 代理模式\ndate: 2017-06-28\ntags: 设计模式\ncategories: Design Pattern\n---\n\n#### 定义 ####\n\n代理模式(proxy pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理的英文叫做Proxy或者Surrogate，它是一种对象结构型模式。\n  \n#### 模式结构 ####\n\n- subject：抽象对象角色。声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象\n- realSubject：代理对象所代表的目标对象\n- proxy：代理对象角色。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象\n\n![类图](/images/proxy_pattern_class_diagram.png)\n  \n#### 时序图 ####\n\n![时序图](/images/proxy_pattern_sequence_diagram.png)\n\n#### 代码 ####\n\n[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ProxyPattern)\n\n#### 分析 ####\n\n##### 优点 #####\n\n- 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度\n- 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求\n- 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统的资源消耗，对系统进行优化并提高运行速度\n- 保护代理，可以控制对真实对象的使用权限\n\n##### 缺点 #####\n\n-  由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢\n-  实现代理模式需要额外的工作，有些代理模式实现非常复杂\n\n#### 扩展-代理的应用 ####\n\n- 远程（Remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又叫做大使。\n- 虚拟（Virtual）代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。\n- Copy-on-Write代理：这是虚拟代理的一种，把克隆操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销比较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。\n- 保护（Protect of Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。\n- 缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。\n- 防火墙（Firewall）代理：保护目标不让恶意用户接近。\n- 同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突\n- 智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。\n- 图片代理：对大图浏览的控制。用户访问是先不加载真实的大图，而是通过代理对象的方法来进行处理，在该方法中，先使用一个线程为客户加载一个小图，然后在后天使用另一个线程加载大图。当需要浏览大图片时，再显示大图。如果用户浏览大图时，图片加载还没完成，可以再启动一个线程来显示相应的提示信息。\n- 动态代理：较为高级的代理模式，典型应用是Spring AOP。\n\n\n\n \n\n\n\n\n","slug":"design-patterns-proxy","published":1,"updated":"2017-08-17T02:51:26.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1ho006l2sivaw0o4hxn","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>代理模式(proxy pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理的英文叫做Proxy或者Surrogate，它是一种对象结构型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>subject：抽象对象角色。声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象</li>\n<li>realSubject：代理对象所代表的目标对象</li>\n<li>proxy：代理对象角色。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象</li>\n</ul>\n<p><img src=\"/images/proxy_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/proxy_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ProxyPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>\n<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求</li>\n<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统的资源消耗，对系统进行优化并提高运行速度</li>\n<li>保护代理，可以控制对真实对象的使用权限</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢</li>\n<li>实现代理模式需要额外的工作，有些代理模式实现非常复杂</li>\n</ul>\n<h4 id=\"扩展-代理的应用\"><a href=\"#扩展-代理的应用\" class=\"headerlink\" title=\"扩展-代理的应用\"></a>扩展-代理的应用</h4><ul>\n<li>远程（Remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又叫做大使。</li>\n<li>虚拟（Virtual）代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>\n<li>Copy-on-Write代理：这是虚拟代理的一种，把克隆操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销比较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>\n<li>保护（Protect of Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>\n<li>缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>\n<li>防火墙（Firewall）代理：保护目标不让恶意用户接近。</li>\n<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突</li>\n<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。</li>\n<li>图片代理：对大图浏览的控制。用户访问是先不加载真实的大图，而是通过代理对象的方法来进行处理，在该方法中，先使用一个线程为客户加载一个小图，然后在后天使用另一个线程加载大图。当需要浏览大图片时，再显示大图。如果用户浏览大图时，图片加载还没完成，可以再启动一个线程来显示相应的提示信息。</li>\n<li>动态代理：较为高级的代理模式，典型应用是Spring AOP。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>代理模式(proxy pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理的英文叫做Proxy或者Surrogate，它是一种对象结构型模式。</p>\n<h4 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h4><ul>\n<li>subject：抽象对象角色。声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象</li>\n<li>realSubject：代理对象所代表的目标对象</li>\n<li>proxy：代理对象角色。代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象</li>\n</ul>\n<p><img src=\"/images/proxy_pattern_class_diagram.png\" alt=\"类图\"></p>\n<h4 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h4><p><img src=\"/images/proxy_pattern_sequence_diagram.png\" alt=\"时序图\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><a href=\"https://github.com/xusx1024/DesignPatternDemoCode/tree/master/ProxyPattern\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>\n<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求</li>\n<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统的资源消耗，对系统进行优化并提高运行速度</li>\n<li>保护代理，可以控制对真实对象的使用权限</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢</li>\n<li>实现代理模式需要额外的工作，有些代理模式实现非常复杂</li>\n</ul>\n<h4 id=\"扩展-代理的应用\"><a href=\"#扩展-代理的应用\" class=\"headerlink\" title=\"扩展-代理的应用\"></a>扩展-代理的应用</h4><ul>\n<li>远程（Remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中，远程代理又叫做大使。</li>\n<li>虚拟（Virtual）代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>\n<li>Copy-on-Write代理：这是虚拟代理的一种，把克隆操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销比较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>\n<li>保护（Protect of Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>\n<li>缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>\n<li>防火墙（Firewall）代理：保护目标不让恶意用户接近。</li>\n<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突</li>\n<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。</li>\n<li>图片代理：对大图浏览的控制。用户访问是先不加载真实的大图，而是通过代理对象的方法来进行处理，在该方法中，先使用一个线程为客户加载一个小图，然后在后天使用另一个线程加载大图。当需要浏览大图片时，再显示大图。如果用户浏览大图时，图片加载还没完成，可以再启动一个线程来显示相应的提示信息。</li>\n<li>动态代理：较为高级的代理模式，典型应用是Spring AOP。</li>\n</ul>\n"},{"title":"AndroidManifest.xml中的uses-feature标签","date":"2017-07-03T00:00:00.000Z","_content":"\n#### 引子 ####\n\n如果你有一个装有android 1.5的设备，你可能会注意到一些高版本的应用没有在手机上的Android Market中显示。这必定是应用使用了<uses-feature>的结果。\n\n\n#### 语法 ####\n\t\n\t<uses-feature\n\t  android:name=\"string\"\n\t  android:required=[\"true\" | \"false\"]\n\t  android:glEsVersion=\"integer\" />\n\n##### android:name #####\n\n以描述字符串形式指定应用使用的单一硬件或软件功能。详见:[HERE](https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#features-reference)\n\t\n\t<uses-feature android:name=\"android.hardware.bluetooth\" />\n\t<uses-feature android:name=\"android.hardware.camera\" />\n\n##### android:required #####\n\n- android:required=\"true\":当设备不具有该指定功能时，应用无法正常工作，或设计为无法正常工作\n- android:required=\"false\"：如果设备具有该功能，应用会在必要时优先使用该功能，但应用设计为不使用该指定功能也可正常工作\n- 默认为true\n\n\t \t\t<uses-feature \n\t        android:name=\"android.hardware.camera\"\n\t        android:required=false />\n\n##### android:glEsVersion #####\n\n应用需要的OpenGL ES版本。高16位表示主版本号，低16位表示次版本号。例如2.0 --> 0x00020000;3.2 --> 0x00030002\n\n\t<uses-feature android:glEsVersion=\"0x00020000\" required=\"true\"/>\n\n- 如果指定多个，将使用数值最高的\n- 如果没有指定，系统假定只需要OpenGL ES 1.0\n \n#### 注意 ####\n\n- <uses-feature> 声明的用途是将您的应用依赖的硬件和软件功能集通知任何外部实体\n- 一般而言，您始终都应确保为应用需要的所有功能声明 <uses-feature> 元素\n- Android 系统本身在安装应用前不会检查设备是否提供相应的功能支持\n- 其他服务（如 Google Play）或应用可能会在处理您的应用或与其交互的过程中检查它的 <uses-feature> 声明\n- 如果minSdkVersion<=4或者targetSdkVersion<=4,googlePlay将不对该标签做任何过滤\n- 蓝牙、相机、麦克风、定位、wifi、触屏、USB\n- 输入法、多媒体、屏幕界面(小控件、壁纸等)\n\n\n\n\n\n\nhttps://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required","source":"_posts/2017-07-03-uses-feature.md","raw":"---\ntitle: AndroidManifest.xml中的uses-feature标签\ndate: 2017-07-03\ntags: android\ncategories: Android \n---\n\n#### 引子 ####\n\n如果你有一个装有android 1.5的设备，你可能会注意到一些高版本的应用没有在手机上的Android Market中显示。这必定是应用使用了<uses-feature>的结果。\n\n\n#### 语法 ####\n\t\n\t<uses-feature\n\t  android:name=\"string\"\n\t  android:required=[\"true\" | \"false\"]\n\t  android:glEsVersion=\"integer\" />\n\n##### android:name #####\n\n以描述字符串形式指定应用使用的单一硬件或软件功能。详见:[HERE](https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#features-reference)\n\t\n\t<uses-feature android:name=\"android.hardware.bluetooth\" />\n\t<uses-feature android:name=\"android.hardware.camera\" />\n\n##### android:required #####\n\n- android:required=\"true\":当设备不具有该指定功能时，应用无法正常工作，或设计为无法正常工作\n- android:required=\"false\"：如果设备具有该功能，应用会在必要时优先使用该功能，但应用设计为不使用该指定功能也可正常工作\n- 默认为true\n\n\t \t\t<uses-feature \n\t        android:name=\"android.hardware.camera\"\n\t        android:required=false />\n\n##### android:glEsVersion #####\n\n应用需要的OpenGL ES版本。高16位表示主版本号，低16位表示次版本号。例如2.0 --> 0x00020000;3.2 --> 0x00030002\n\n\t<uses-feature android:glEsVersion=\"0x00020000\" required=\"true\"/>\n\n- 如果指定多个，将使用数值最高的\n- 如果没有指定，系统假定只需要OpenGL ES 1.0\n \n#### 注意 ####\n\n- <uses-feature> 声明的用途是将您的应用依赖的硬件和软件功能集通知任何外部实体\n- 一般而言，您始终都应确保为应用需要的所有功能声明 <uses-feature> 元素\n- Android 系统本身在安装应用前不会检查设备是否提供相应的功能支持\n- 其他服务（如 Google Play）或应用可能会在处理您的应用或与其交互的过程中检查它的 <uses-feature> 声明\n- 如果minSdkVersion<=4或者targetSdkVersion<=4,googlePlay将不对该标签做任何过滤\n- 蓝牙、相机、麦克风、定位、wifi、触屏、USB\n- 输入法、多媒体、屏幕界面(小控件、壁纸等)\n\n\n\n\n\n\nhttps://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required","slug":"uses-feature","published":1,"updated":"2017-11-16T08:28:46.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hs006o2sivkh5volhc","content":"<h4 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h4><p>如果你有一个装有android 1.5的设备，你可能会注意到一些高版本的应用没有在手机上的Android Market中显示。这必定是应用使用了<uses-feature>的结果。</uses-feature></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code>&lt;uses-feature\n  android:name=&quot;string&quot;\n  android:required=[&quot;true&quot; | &quot;false&quot;]\n  android:glEsVersion=&quot;integer&quot; /&gt;\n</code></pre><h5 id=\"android-name\"><a href=\"#android-name\" class=\"headerlink\" title=\"android:name\"></a>android:name</h5><p>以描述字符串形式指定应用使用的单一硬件或软件功能。详见:<a href=\"https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#features-reference\" target=\"_blank\" rel=\"external\">HERE</a></p>\n<pre><code>&lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot; /&gt;\n&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;\n</code></pre><h5 id=\"android-required\"><a href=\"#android-required\" class=\"headerlink\" title=\"android:required\"></a>android:required</h5><ul>\n<li>android:required=”true”:当设备不具有该指定功能时，应用无法正常工作，或设计为无法正常工作</li>\n<li>android:required=”false”：如果设备具有该功能，应用会在必要时优先使用该功能，但应用设计为不使用该指定功能也可正常工作</li>\n<li><p>默认为true</p>\n<pre><code> &lt;uses-feature \nandroid:name=&quot;android.hardware.camera&quot;\nandroid:required=false /&gt;\n</code></pre></li>\n</ul>\n<h5 id=\"android-glEsVersion\"><a href=\"#android-glEsVersion\" class=\"headerlink\" title=\"android:glEsVersion\"></a>android:glEsVersion</h5><p>应用需要的OpenGL ES版本。高16位表示主版本号，低16位表示次版本号。例如2.0 –&gt; 0x00020000;3.2 –&gt; 0x00030002</p>\n<pre><code>&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; required=&quot;true&quot;/&gt;\n</code></pre><ul>\n<li>如果指定多个，将使用数值最高的</li>\n<li>如果没有指定，系统假定只需要OpenGL ES 1.0</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><uses-feature> 声明的用途是将您的应用依赖的硬件和软件功能集通知任何外部实体</uses-feature></li>\n<li>一般而言，您始终都应确保为应用需要的所有功能声明 <uses-feature> 元素</uses-feature></li>\n<li>Android 系统本身在安装应用前不会检查设备是否提供相应的功能支持</li>\n<li>其他服务（如 Google Play）或应用可能会在处理您的应用或与其交互的过程中检查它的 <uses-feature> 声明</uses-feature></li>\n<li>如果minSdkVersion&lt;=4或者targetSdkVersion&lt;=4,googlePlay将不对该标签做任何过滤</li>\n<li>蓝牙、相机、麦克风、定位、wifi、触屏、USB</li>\n<li>输入法、多媒体、屏幕界面(小控件、壁纸等)</li>\n</ul>\n<p><a href=\"https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required\" target=\"_blank\" rel=\"external\">https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h4><p>如果你有一个装有android 1.5的设备，你可能会注意到一些高版本的应用没有在手机上的Android Market中显示。这必定是应用使用了<uses-feature>的结果。</uses-feature></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code>&lt;uses-feature\n  android:name=&quot;string&quot;\n  android:required=[&quot;true&quot; | &quot;false&quot;]\n  android:glEsVersion=&quot;integer&quot; /&gt;\n</code></pre><h5 id=\"android-name\"><a href=\"#android-name\" class=\"headerlink\" title=\"android:name\"></a>android:name</h5><p>以描述字符串形式指定应用使用的单一硬件或软件功能。详见:<a href=\"https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#features-reference\" target=\"_blank\" rel=\"external\">HERE</a></p>\n<pre><code>&lt;uses-feature android:name=&quot;android.hardware.bluetooth&quot; /&gt;\n&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;\n</code></pre><h5 id=\"android-required\"><a href=\"#android-required\" class=\"headerlink\" title=\"android:required\"></a>android:required</h5><ul>\n<li>android:required=”true”:当设备不具有该指定功能时，应用无法正常工作，或设计为无法正常工作</li>\n<li>android:required=”false”：如果设备具有该功能，应用会在必要时优先使用该功能，但应用设计为不使用该指定功能也可正常工作</li>\n<li><p>默认为true</p>\n<pre><code> &lt;uses-feature \nandroid:name=&quot;android.hardware.camera&quot;\nandroid:required=false /&gt;\n</code></pre></li>\n</ul>\n<h5 id=\"android-glEsVersion\"><a href=\"#android-glEsVersion\" class=\"headerlink\" title=\"android:glEsVersion\"></a>android:glEsVersion</h5><p>应用需要的OpenGL ES版本。高16位表示主版本号，低16位表示次版本号。例如2.0 –&gt; 0x00020000;3.2 –&gt; 0x00030002</p>\n<pre><code>&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; required=&quot;true&quot;/&gt;\n</code></pre><ul>\n<li>如果指定多个，将使用数值最高的</li>\n<li>如果没有指定，系统假定只需要OpenGL ES 1.0</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><uses-feature> 声明的用途是将您的应用依赖的硬件和软件功能集通知任何外部实体</uses-feature></li>\n<li>一般而言，您始终都应确保为应用需要的所有功能声明 <uses-feature> 元素</uses-feature></li>\n<li>Android 系统本身在安装应用前不会检查设备是否提供相应的功能支持</li>\n<li>其他服务（如 Google Play）或应用可能会在处理您的应用或与其交互的过程中检查它的 <uses-feature> 声明</uses-feature></li>\n<li>如果minSdkVersion&lt;=4或者targetSdkVersion&lt;=4,googlePlay将不对该标签做任何过滤</li>\n<li>蓝牙、相机、麦克风、定位、wifi、触屏、USB</li>\n<li>输入法、多媒体、屏幕界面(小控件、壁纸等)</li>\n</ul>\n<p><a href=\"https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required\" target=\"_blank\" rel=\"external\">https://developer.android.google.cn/guide/topics/manifest/uses-feature-element.html?hl=zh-cn#required</a></p>\n"},{"title":"《图解HTTP》第5、6、7章","date":"2017-07-05T00:00:00.000Z","_content":"\n#### 代理 ####\n\n- 接收客户端请求，转发至源服务器\n- 缓存请求，减少网络带宽流量\n- 过滤请求\n- 访问日志记录\n- 多级代理，每通过一级会添加via首部，即可追踪报文的转发，还可避免请求回环的发生，经常和TRACE方法一起使用\n- 透明/非透明代理：是否对报文内容进行加工\n\n#### 网关 ####\n\n- 利用网关可以由HTTP请求转化为其他协议通信\n- 网关和代理的工作机制十分相似，网关能使通信线路上的服务器提供非HTTP协议服务\n- 利用网关能提高通信的安全性\n\n#### 隧道 ####\n\n- 安全：可使用SSL等加密手段进行通信\n- 透明：隧道不解析HTTP请求，请求保持原样中转给之后的服务器\n\n#### 资源的缓存 ####\n\n- 代理服务器缓存\n- 客户端缓存\n- 减少流量带宽\n- 减少服务器压力\n- 减少响应时间\n- 确定缓存的有效期\n\n#### HTTP 首部 ####\n\n- HTTP首部字段重复的情况：根据浏览器不同，结果可能并不一致，有些优先处理先出现的，有些处理后出现的字段\n- 请求首部、响应首部、通用首部、内容首部具体字段\n\n#### HTTP的缺点 ####\n\n- 明文通信可能会被窃听\n- 不验证通信方的身份，可能遭遇伪装：使用SSL[Secure Socket Layer]认证\n- 无法证明报文的完整性，有可能遭遇篡改：中间人攻击\n\n#### HTTPS #### \n\n- HTTP + 加密 + 认证 + 完整性保护 = HTTPS\n- HTTPS并非新协议，通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。HTTPS即身披SSL协议外壳的HTTP\n\n\n#### 用户身份认证 ####\n\n- SSL认证 - 计算机\n- 表单认证 - 用户\n\n#### 对Web应用的攻击 ####\n\n- 主动攻击服务器：针对服务器上的资源，代表手法：SQL注入和OS命令注入\n- 被动攻击服务器：诱使用户出发陷阱，窃取用户信息，代表手法：跨站脚本攻击、跨站点请求伪造\n\t- 可利用用户的身份攻击企业内部网络\n\n##### 跨站脚本攻击 #####\n\nCross-Site  Scripting,XSS :是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。\n\n- 输入框中增加窃取用户名、密码的script。\n- 窃取用户的Cookie\n\n##### SQL注入攻击 #####\n\nSQL Injection：是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。\n破坏SQL语句结构。\n\n##### OS命令注入攻击 #####\n\nOS命令注入攻击(OS Command Injection)是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。可从Web应用中通过Shell来调用操作系统命令，通过OS注入攻击可执行OS上安装着的各种程序。\n\n##### HTTP首部注入攻击 #####\n\nHTTP首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。\n\n向首部主体内添加内容的攻击称为HTTP响应截断攻击。\n\n- 设置Cookie信息\n- 重定向至指定URL\n- 显示任意的主体\n\n#### 因设置或设计上的缺陷引发的安全漏洞 ####\n\n- 强制浏览：浏览那些原本非自愿公开的文件\n- 不正确的错误消息处理：Web应用的错误信息包含对攻击者有用的信息。Web应用不必在用户的浏览画面上展示详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。\n- 开放重定向：对指定的任意URL作重定向跳转的功能，假如重定向到恶意的Web网站，那么用户就会被诱导至那个Web网站。\n\n#### 会话引发的安全漏洞 ####\n\n- 会话劫持：攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。\n- 会话固定攻击：强制用户使用攻击者指定的会话ID，属于被动攻击。\n- 跨站点请求伪造：攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。\n\n#### 其他安全漏洞 ####\n\n- 密码破解：密码试错[穷举法，字典攻击]、密码破解\n- 点击劫持：界面伪装\n- dos攻击：让运行中的服务呈停止状态的攻击。\n\t- 集中利用访问请求[发送大量合法请求]造成资源过载，导致资源用尽，服务停止\n\t- 通过攻击安全漏洞使服务停止\n- 后门程序250：开发设置的隐藏入口\n\n\n\n\n\n\n","source":"_posts/2017-07-05-net-work-day03.md","raw":"---\ntitle: 《图解HTTP》第5、6、7章\ndate: 2017-07-05\ntags: 网络\ncategories: NetWork\n---\n\n#### 代理 ####\n\n- 接收客户端请求，转发至源服务器\n- 缓存请求，减少网络带宽流量\n- 过滤请求\n- 访问日志记录\n- 多级代理，每通过一级会添加via首部，即可追踪报文的转发，还可避免请求回环的发生，经常和TRACE方法一起使用\n- 透明/非透明代理：是否对报文内容进行加工\n\n#### 网关 ####\n\n- 利用网关可以由HTTP请求转化为其他协议通信\n- 网关和代理的工作机制十分相似，网关能使通信线路上的服务器提供非HTTP协议服务\n- 利用网关能提高通信的安全性\n\n#### 隧道 ####\n\n- 安全：可使用SSL等加密手段进行通信\n- 透明：隧道不解析HTTP请求，请求保持原样中转给之后的服务器\n\n#### 资源的缓存 ####\n\n- 代理服务器缓存\n- 客户端缓存\n- 减少流量带宽\n- 减少服务器压力\n- 减少响应时间\n- 确定缓存的有效期\n\n#### HTTP 首部 ####\n\n- HTTP首部字段重复的情况：根据浏览器不同，结果可能并不一致，有些优先处理先出现的，有些处理后出现的字段\n- 请求首部、响应首部、通用首部、内容首部具体字段\n\n#### HTTP的缺点 ####\n\n- 明文通信可能会被窃听\n- 不验证通信方的身份，可能遭遇伪装：使用SSL[Secure Socket Layer]认证\n- 无法证明报文的完整性，有可能遭遇篡改：中间人攻击\n\n#### HTTPS #### \n\n- HTTP + 加密 + 认证 + 完整性保护 = HTTPS\n- HTTPS并非新协议，通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。HTTPS即身披SSL协议外壳的HTTP\n\n\n#### 用户身份认证 ####\n\n- SSL认证 - 计算机\n- 表单认证 - 用户\n\n#### 对Web应用的攻击 ####\n\n- 主动攻击服务器：针对服务器上的资源，代表手法：SQL注入和OS命令注入\n- 被动攻击服务器：诱使用户出发陷阱，窃取用户信息，代表手法：跨站脚本攻击、跨站点请求伪造\n\t- 可利用用户的身份攻击企业内部网络\n\n##### 跨站脚本攻击 #####\n\nCross-Site  Scripting,XSS :是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。\n\n- 输入框中增加窃取用户名、密码的script。\n- 窃取用户的Cookie\n\n##### SQL注入攻击 #####\n\nSQL Injection：是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。\n破坏SQL语句结构。\n\n##### OS命令注入攻击 #####\n\nOS命令注入攻击(OS Command Injection)是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。可从Web应用中通过Shell来调用操作系统命令，通过OS注入攻击可执行OS上安装着的各种程序。\n\n##### HTTP首部注入攻击 #####\n\nHTTP首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。\n\n向首部主体内添加内容的攻击称为HTTP响应截断攻击。\n\n- 设置Cookie信息\n- 重定向至指定URL\n- 显示任意的主体\n\n#### 因设置或设计上的缺陷引发的安全漏洞 ####\n\n- 强制浏览：浏览那些原本非自愿公开的文件\n- 不正确的错误消息处理：Web应用的错误信息包含对攻击者有用的信息。Web应用不必在用户的浏览画面上展示详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。\n- 开放重定向：对指定的任意URL作重定向跳转的功能，假如重定向到恶意的Web网站，那么用户就会被诱导至那个Web网站。\n\n#### 会话引发的安全漏洞 ####\n\n- 会话劫持：攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。\n- 会话固定攻击：强制用户使用攻击者指定的会话ID，属于被动攻击。\n- 跨站点请求伪造：攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。\n\n#### 其他安全漏洞 ####\n\n- 密码破解：密码试错[穷举法，字典攻击]、密码破解\n- 点击劫持：界面伪装\n- dos攻击：让运行中的服务呈停止状态的攻击。\n\t- 集中利用访问请求[发送大量合法请求]造成资源过载，导致资源用尽，服务停止\n\t- 通过攻击安全漏洞使服务停止\n- 后门程序250：开发设置的隐藏入口\n\n\n\n\n\n\n","slug":"net-work-day03","published":1,"updated":"2017-08-17T02:52:00.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hv006r2sivfbqnzegp","content":"<h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><ul>\n<li>接收客户端请求，转发至源服务器</li>\n<li>缓存请求，减少网络带宽流量</li>\n<li>过滤请求</li>\n<li>访问日志记录</li>\n<li>多级代理，每通过一级会添加via首部，即可追踪报文的转发，还可避免请求回环的发生，经常和TRACE方法一起使用</li>\n<li>透明/非透明代理：是否对报文内容进行加工</li>\n</ul>\n<h4 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h4><ul>\n<li>利用网关可以由HTTP请求转化为其他协议通信</li>\n<li>网关和代理的工作机制十分相似，网关能使通信线路上的服务器提供非HTTP协议服务</li>\n<li>利用网关能提高通信的安全性</li>\n</ul>\n<h4 id=\"隧道\"><a href=\"#隧道\" class=\"headerlink\" title=\"隧道\"></a>隧道</h4><ul>\n<li>安全：可使用SSL等加密手段进行通信</li>\n<li>透明：隧道不解析HTTP请求，请求保持原样中转给之后的服务器</li>\n</ul>\n<h4 id=\"资源的缓存\"><a href=\"#资源的缓存\" class=\"headerlink\" title=\"资源的缓存\"></a>资源的缓存</h4><ul>\n<li>代理服务器缓存</li>\n<li>客户端缓存</li>\n<li>减少流量带宽</li>\n<li>减少服务器压力</li>\n<li>减少响应时间</li>\n<li>确定缓存的有效期</li>\n</ul>\n<h4 id=\"HTTP-首部\"><a href=\"#HTTP-首部\" class=\"headerlink\" title=\"HTTP 首部\"></a>HTTP 首部</h4><ul>\n<li>HTTP首部字段重复的情况：根据浏览器不同，结果可能并不一致，有些优先处理先出现的，有些处理后出现的字段</li>\n<li>请求首部、响应首部、通用首部、内容首部具体字段</li>\n</ul>\n<h4 id=\"HTTP的缺点\"><a href=\"#HTTP的缺点\" class=\"headerlink\" title=\"HTTP的缺点\"></a>HTTP的缺点</h4><ul>\n<li>明文通信可能会被窃听</li>\n<li>不验证通信方的身份，可能遭遇伪装：使用SSL[Secure Socket Layer]认证</li>\n<li>无法证明报文的完整性，有可能遭遇篡改：中间人攻击</li>\n</ul>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><ul>\n<li>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</li>\n<li>HTTPS并非新协议，通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。HTTPS即身披SSL协议外壳的HTTP</li>\n</ul>\n<h4 id=\"用户身份认证\"><a href=\"#用户身份认证\" class=\"headerlink\" title=\"用户身份认证\"></a>用户身份认证</h4><ul>\n<li>SSL认证 - 计算机</li>\n<li>表单认证 - 用户</li>\n</ul>\n<h4 id=\"对Web应用的攻击\"><a href=\"#对Web应用的攻击\" class=\"headerlink\" title=\"对Web应用的攻击\"></a>对Web应用的攻击</h4><ul>\n<li>主动攻击服务器：针对服务器上的资源，代表手法：SQL注入和OS命令注入</li>\n<li>被动攻击服务器：诱使用户出发陷阱，窃取用户信息，代表手法：跨站脚本攻击、跨站点请求伪造<ul>\n<li>可利用用户的身份攻击企业内部网络</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"跨站脚本攻击\"><a href=\"#跨站脚本攻击\" class=\"headerlink\" title=\"跨站脚本攻击\"></a>跨站脚本攻击</h5><p>Cross-Site  Scripting,XSS :是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。</p>\n<ul>\n<li>输入框中增加窃取用户名、密码的script。</li>\n<li>窃取用户的Cookie</li>\n</ul>\n<h5 id=\"SQL注入攻击\"><a href=\"#SQL注入攻击\" class=\"headerlink\" title=\"SQL注入攻击\"></a>SQL注入攻击</h5><p>SQL Injection：是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。<br>破坏SQL语句结构。</p>\n<h5 id=\"OS命令注入攻击\"><a href=\"#OS命令注入攻击\" class=\"headerlink\" title=\"OS命令注入攻击\"></a>OS命令注入攻击</h5><p>OS命令注入攻击(OS Command Injection)是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。可从Web应用中通过Shell来调用操作系统命令，通过OS注入攻击可执行OS上安装着的各种程序。</p>\n<h5 id=\"HTTP首部注入攻击\"><a href=\"#HTTP首部注入攻击\" class=\"headerlink\" title=\"HTTP首部注入攻击\"></a>HTTP首部注入攻击</h5><p>HTTP首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p>\n<p>向首部主体内添加内容的攻击称为HTTP响应截断攻击。</p>\n<ul>\n<li>设置Cookie信息</li>\n<li>重定向至指定URL</li>\n<li>显示任意的主体</li>\n</ul>\n<h4 id=\"因设置或设计上的缺陷引发的安全漏洞\"><a href=\"#因设置或设计上的缺陷引发的安全漏洞\" class=\"headerlink\" title=\"因设置或设计上的缺陷引发的安全漏洞\"></a>因设置或设计上的缺陷引发的安全漏洞</h4><ul>\n<li>强制浏览：浏览那些原本非自愿公开的文件</li>\n<li>不正确的错误消息处理：Web应用的错误信息包含对攻击者有用的信息。Web应用不必在用户的浏览画面上展示详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。</li>\n<li>开放重定向：对指定的任意URL作重定向跳转的功能，假如重定向到恶意的Web网站，那么用户就会被诱导至那个Web网站。</li>\n</ul>\n<h4 id=\"会话引发的安全漏洞\"><a href=\"#会话引发的安全漏洞\" class=\"headerlink\" title=\"会话引发的安全漏洞\"></a>会话引发的安全漏洞</h4><ul>\n<li>会话劫持：攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。</li>\n<li>会话固定攻击：强制用户使用攻击者指定的会话ID，属于被动攻击。</li>\n<li>跨站点请求伪造：攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</li>\n</ul>\n<h4 id=\"其他安全漏洞\"><a href=\"#其他安全漏洞\" class=\"headerlink\" title=\"其他安全漏洞\"></a>其他安全漏洞</h4><ul>\n<li>密码破解：密码试错[穷举法，字典攻击]、密码破解</li>\n<li>点击劫持：界面伪装</li>\n<li>dos攻击：让运行中的服务呈停止状态的攻击。<ul>\n<li>集中利用访问请求[发送大量合法请求]造成资源过载，导致资源用尽，服务停止</li>\n<li>通过攻击安全漏洞使服务停止</li>\n</ul>\n</li>\n<li>后门程序250：开发设置的隐藏入口</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><ul>\n<li>接收客户端请求，转发至源服务器</li>\n<li>缓存请求，减少网络带宽流量</li>\n<li>过滤请求</li>\n<li>访问日志记录</li>\n<li>多级代理，每通过一级会添加via首部，即可追踪报文的转发，还可避免请求回环的发生，经常和TRACE方法一起使用</li>\n<li>透明/非透明代理：是否对报文内容进行加工</li>\n</ul>\n<h4 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h4><ul>\n<li>利用网关可以由HTTP请求转化为其他协议通信</li>\n<li>网关和代理的工作机制十分相似，网关能使通信线路上的服务器提供非HTTP协议服务</li>\n<li>利用网关能提高通信的安全性</li>\n</ul>\n<h4 id=\"隧道\"><a href=\"#隧道\" class=\"headerlink\" title=\"隧道\"></a>隧道</h4><ul>\n<li>安全：可使用SSL等加密手段进行通信</li>\n<li>透明：隧道不解析HTTP请求，请求保持原样中转给之后的服务器</li>\n</ul>\n<h4 id=\"资源的缓存\"><a href=\"#资源的缓存\" class=\"headerlink\" title=\"资源的缓存\"></a>资源的缓存</h4><ul>\n<li>代理服务器缓存</li>\n<li>客户端缓存</li>\n<li>减少流量带宽</li>\n<li>减少服务器压力</li>\n<li>减少响应时间</li>\n<li>确定缓存的有效期</li>\n</ul>\n<h4 id=\"HTTP-首部\"><a href=\"#HTTP-首部\" class=\"headerlink\" title=\"HTTP 首部\"></a>HTTP 首部</h4><ul>\n<li>HTTP首部字段重复的情况：根据浏览器不同，结果可能并不一致，有些优先处理先出现的，有些处理后出现的字段</li>\n<li>请求首部、响应首部、通用首部、内容首部具体字段</li>\n</ul>\n<h4 id=\"HTTP的缺点\"><a href=\"#HTTP的缺点\" class=\"headerlink\" title=\"HTTP的缺点\"></a>HTTP的缺点</h4><ul>\n<li>明文通信可能会被窃听</li>\n<li>不验证通信方的身份，可能遭遇伪装：使用SSL[Secure Socket Layer]认证</li>\n<li>无法证明报文的完整性，有可能遭遇篡改：中间人攻击</li>\n</ul>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h4><ul>\n<li>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</li>\n<li>HTTPS并非新协议，通常HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信。HTTPS即身披SSL协议外壳的HTTP</li>\n</ul>\n<h4 id=\"用户身份认证\"><a href=\"#用户身份认证\" class=\"headerlink\" title=\"用户身份认证\"></a>用户身份认证</h4><ul>\n<li>SSL认证 - 计算机</li>\n<li>表单认证 - 用户</li>\n</ul>\n<h4 id=\"对Web应用的攻击\"><a href=\"#对Web应用的攻击\" class=\"headerlink\" title=\"对Web应用的攻击\"></a>对Web应用的攻击</h4><ul>\n<li>主动攻击服务器：针对服务器上的资源，代表手法：SQL注入和OS命令注入</li>\n<li>被动攻击服务器：诱使用户出发陷阱，窃取用户信息，代表手法：跨站脚本攻击、跨站点请求伪造<ul>\n<li>可利用用户的身份攻击企业内部网络</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"跨站脚本攻击\"><a href=\"#跨站脚本攻击\" class=\"headerlink\" title=\"跨站脚本攻击\"></a>跨站脚本攻击</h5><p>Cross-Site  Scripting,XSS :是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。</p>\n<ul>\n<li>输入框中增加窃取用户名、密码的script。</li>\n<li>窃取用户的Cookie</li>\n</ul>\n<h5 id=\"SQL注入攻击\"><a href=\"#SQL注入攻击\" class=\"headerlink\" title=\"SQL注入攻击\"></a>SQL注入攻击</h5><p>SQL Injection：是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。<br>破坏SQL语句结构。</p>\n<h5 id=\"OS命令注入攻击\"><a href=\"#OS命令注入攻击\" class=\"headerlink\" title=\"OS命令注入攻击\"></a>OS命令注入攻击</h5><p>OS命令注入攻击(OS Command Injection)是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。可从Web应用中通过Shell来调用操作系统命令，通过OS注入攻击可执行OS上安装着的各种程序。</p>\n<h5 id=\"HTTP首部注入攻击\"><a href=\"#HTTP首部注入攻击\" class=\"headerlink\" title=\"HTTP首部注入攻击\"></a>HTTP首部注入攻击</h5><p>HTTP首部注入攻击(HTTP Header Injection)是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p>\n<p>向首部主体内添加内容的攻击称为HTTP响应截断攻击。</p>\n<ul>\n<li>设置Cookie信息</li>\n<li>重定向至指定URL</li>\n<li>显示任意的主体</li>\n</ul>\n<h4 id=\"因设置或设计上的缺陷引发的安全漏洞\"><a href=\"#因设置或设计上的缺陷引发的安全漏洞\" class=\"headerlink\" title=\"因设置或设计上的缺陷引发的安全漏洞\"></a>因设置或设计上的缺陷引发的安全漏洞</h4><ul>\n<li>强制浏览：浏览那些原本非自愿公开的文件</li>\n<li>不正确的错误消息处理：Web应用的错误信息包含对攻击者有用的信息。Web应用不必在用户的浏览画面上展示详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。</li>\n<li>开放重定向：对指定的任意URL作重定向跳转的功能，假如重定向到恶意的Web网站，那么用户就会被诱导至那个Web网站。</li>\n</ul>\n<h4 id=\"会话引发的安全漏洞\"><a href=\"#会话引发的安全漏洞\" class=\"headerlink\" title=\"会话引发的安全漏洞\"></a>会话引发的安全漏洞</h4><ul>\n<li>会话劫持：攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的。</li>\n<li>会话固定攻击：强制用户使用攻击者指定的会话ID，属于被动攻击。</li>\n<li>跨站点请求伪造：攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。</li>\n</ul>\n<h4 id=\"其他安全漏洞\"><a href=\"#其他安全漏洞\" class=\"headerlink\" title=\"其他安全漏洞\"></a>其他安全漏洞</h4><ul>\n<li>密码破解：密码试错[穷举法，字典攻击]、密码破解</li>\n<li>点击劫持：界面伪装</li>\n<li>dos攻击：让运行中的服务呈停止状态的攻击。<ul>\n<li>集中利用访问请求[发送大量合法请求]造成资源过载，导致资源用尽，服务停止</li>\n<li>通过攻击安全漏洞使服务停止</li>\n</ul>\n</li>\n<li>后门程序250：开发设置的隐藏入口</li>\n</ul>\n"},{"title":"android - 消除非受检的警告","date":"2017-07-14T00:00:00.000Z","_content":"\n#### using setjavascriptenabled can introduce xss vulnerabilities into your application ####\n\n在WebView中，如果你启用js，kotlin代码如下：\n\n\twebview.settings.javaScriptEnabled = true\n\n会得到题目的警告提示。\n\n原因是：启用js可能不安全，如果你真的需要，好好检查这些js。\n消除：\n\n\t@SuppressLint(\"SetJavaScriptEnabled\")\n\n####  `WebView.addJavascriptInterface` should not be called with minSdkVersion < 17 for security reasons: JavaScript can use reflection to manipulate application ####\n\n在WebView中，如果添加JS调用Java代码，kotlin代码如下：\n\n\twebview.addJavascriptInterface(JsObject(), \"onClick\")\n\n会得到题目的警告提示。\n\n原因题目说的很清楚，“JavaScript可以通过反射操作应用”\n\n官方的说明：[JavaScript安全不](https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29)\n\n一篇不错的[blog](http://blog.csdn.net/leehong2005/article/details/11808557)\n\n可以确定的是4.2，也就是17，JELLY BEAN之前，可以获取到SD读写权限，然后操作你的联系人、短信、etc\n\n这个问题相当的经典。一般的应用估计都不会修复它。但如果应用用户太大，不得不修复。\n\n\n#### 加载JS的时机 ####\n\n引申问题，你有一段JS，何时加载？\n\n- onLoadResource\n- doUpdateVisitedHistory\n- onPageStarted\n- onPageFinished\n- onReceivedTitle\n- onProgressChanged\n\n#### setRenderPriority(android.webkit.WebSettings.RenderPriority)' is deprecated ####\n\n源码中：\n\n> It is not recommended to adjust thread priorities, and this will not be supported in future versions.\n\n#### webView 加载缓慢 ####\n\n\t if (Build.VERSION.SDK_INT >= 19) {//4.4，KK\n\t            mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, null);\n\t        }\n\t        else {\n\t            mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\n\t        }\n\n#### This Handler class should be static or leaks might occur (anonymous android.os.Handler) ####\n\n我们在使用Handler发送消息时，往往使用内部类来实现Handler，这样可能导致内存泄露。\n\n原因：\n\nhandler实例做为一个嵌套类，确切的说是做为一个内部类时，默认持有外部类的引用，\n\n假设外部类为`SampleActivity`，并且Handler里有延时执行的任务，并且Activity提前finish\n\n这样，由于activity的引用还在Handler的延时任务里，GC判定，该Activity虽然finish，但是不可回收，此时就发生了内存泄露\n\n解决：\n\nHandler使用静态内部类\n\nHandler类中使用弱引用维护对activity的引用：\n\t\n\tprivate static class MyHandler extends Handler {\n\t    private final WeakReference<SampleActivity> mActivity;\n\t\n\t    public MyHandler(SampleActivity activity) {\n\t      mActivity = new WeakReference<SampleActivity>(activity);\n\t    }\n\t\n\t    @Override\n\t    public void handleMessage(Message msg) {\n\t      SampleActivity activity = mActivity.get();\n\t      if (activity != null) {\n\t        // ...\n\t      }\n\t    }\n\t  }\n\t\n\t  private final MyHandler mHandler = new MyHandler(this);\n\n[E文传送](http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html)\n[译文传送](http://www.jianshu.com/p/1b39416f1508)\n\n\n#### Warning:(168, 72) Unchecked assignment: 'java.util.List' to 'java.util.List<com.xxx.greendao.xxBean>'. Reason: 'queries' has raw type, so result of list is erased ####\n\n只能添加指定类型，不会有警告：\n\n\t  ArrayList<String> arr = new ArrayList<String>();\n\n如果添加了String之外的类型，会有编译时警告：\n\n\t  ArrayList<String> arr = new ArrayList();\n\n这就是raw type，可以添加Object类型的对象，此时会提示`Unchecked assignment...`，\n\n\t  ArrayList arr = new ArrayList<String>();\n\n考察如下DEMO，可以编译通过，但是运行异常：\n\t\n\timport java.util.ArrayList;\n\t\n\tpublic class TestRawType {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t  ArrayList arr = new ArrayList<String>();\n\t\t\t  \n\t\t\t  arr.add(\"qwer\");\n\t\t\t  arr.add(1234);\n\t\t\t  arr.add(new Integer(2));\n\t\t\t  \n\t\t\t  System.out.println(arr.toString());\n\t\t\t\n\t\t\t  for(Object o : arr){\n\t\t\t\t  System.out.println((String)o);\n\t\t\t  }\n\t\t}\n\t\n\t}\n\n\n> 控制台输出：[qwer, 1234, 2]\nqwer\nException in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tat TestRawType.main(TestRawType.java:17)\n\n\n更加详细的解释，参考《effective java》 2nd 第23条：请不要在新代码中使用原生态类型\n\n\n####  Static member 'android.support.v4.app.FragmentActivity.RESULT_OK' accessed via instance reference ####\n\n原因：通过实例引用了某个类的静态变量，如下：\n\n\tgetActivity().RESULT_OK\n\n修改：\n\t\n\tActivity.RESULT_OK;\n\n`update @ 2017年7月14日18:50:52`\n\n\n####  Dangling Javadoc comment ####\n\n原因：悬空的注释（在你导出文档时，可能会丢失）\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017-07-14-android-notes.md","raw":"---\ntitle: android - 消除非受检的警告\ndate: 2017-07-14\ntags: android\ncategories: Android \n---\n\n#### using setjavascriptenabled can introduce xss vulnerabilities into your application ####\n\n在WebView中，如果你启用js，kotlin代码如下：\n\n\twebview.settings.javaScriptEnabled = true\n\n会得到题目的警告提示。\n\n原因是：启用js可能不安全，如果你真的需要，好好检查这些js。\n消除：\n\n\t@SuppressLint(\"SetJavaScriptEnabled\")\n\n####  `WebView.addJavascriptInterface` should not be called with minSdkVersion < 17 for security reasons: JavaScript can use reflection to manipulate application ####\n\n在WebView中，如果添加JS调用Java代码，kotlin代码如下：\n\n\twebview.addJavascriptInterface(JsObject(), \"onClick\")\n\n会得到题目的警告提示。\n\n原因题目说的很清楚，“JavaScript可以通过反射操作应用”\n\n官方的说明：[JavaScript安全不](https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29)\n\n一篇不错的[blog](http://blog.csdn.net/leehong2005/article/details/11808557)\n\n可以确定的是4.2，也就是17，JELLY BEAN之前，可以获取到SD读写权限，然后操作你的联系人、短信、etc\n\n这个问题相当的经典。一般的应用估计都不会修复它。但如果应用用户太大，不得不修复。\n\n\n#### 加载JS的时机 ####\n\n引申问题，你有一段JS，何时加载？\n\n- onLoadResource\n- doUpdateVisitedHistory\n- onPageStarted\n- onPageFinished\n- onReceivedTitle\n- onProgressChanged\n\n#### setRenderPriority(android.webkit.WebSettings.RenderPriority)' is deprecated ####\n\n源码中：\n\n> It is not recommended to adjust thread priorities, and this will not be supported in future versions.\n\n#### webView 加载缓慢 ####\n\n\t if (Build.VERSION.SDK_INT >= 19) {//4.4，KK\n\t            mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, null);\n\t        }\n\t        else {\n\t            mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\n\t        }\n\n#### This Handler class should be static or leaks might occur (anonymous android.os.Handler) ####\n\n我们在使用Handler发送消息时，往往使用内部类来实现Handler，这样可能导致内存泄露。\n\n原因：\n\nhandler实例做为一个嵌套类，确切的说是做为一个内部类时，默认持有外部类的引用，\n\n假设外部类为`SampleActivity`，并且Handler里有延时执行的任务，并且Activity提前finish\n\n这样，由于activity的引用还在Handler的延时任务里，GC判定，该Activity虽然finish，但是不可回收，此时就发生了内存泄露\n\n解决：\n\nHandler使用静态内部类\n\nHandler类中使用弱引用维护对activity的引用：\n\t\n\tprivate static class MyHandler extends Handler {\n\t    private final WeakReference<SampleActivity> mActivity;\n\t\n\t    public MyHandler(SampleActivity activity) {\n\t      mActivity = new WeakReference<SampleActivity>(activity);\n\t    }\n\t\n\t    @Override\n\t    public void handleMessage(Message msg) {\n\t      SampleActivity activity = mActivity.get();\n\t      if (activity != null) {\n\t        // ...\n\t      }\n\t    }\n\t  }\n\t\n\t  private final MyHandler mHandler = new MyHandler(this);\n\n[E文传送](http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html)\n[译文传送](http://www.jianshu.com/p/1b39416f1508)\n\n\n#### Warning:(168, 72) Unchecked assignment: 'java.util.List' to 'java.util.List<com.xxx.greendao.xxBean>'. Reason: 'queries' has raw type, so result of list is erased ####\n\n只能添加指定类型，不会有警告：\n\n\t  ArrayList<String> arr = new ArrayList<String>();\n\n如果添加了String之外的类型，会有编译时警告：\n\n\t  ArrayList<String> arr = new ArrayList();\n\n这就是raw type，可以添加Object类型的对象，此时会提示`Unchecked assignment...`，\n\n\t  ArrayList arr = new ArrayList<String>();\n\n考察如下DEMO，可以编译通过，但是运行异常：\n\t\n\timport java.util.ArrayList;\n\t\n\tpublic class TestRawType {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t  ArrayList arr = new ArrayList<String>();\n\t\t\t  \n\t\t\t  arr.add(\"qwer\");\n\t\t\t  arr.add(1234);\n\t\t\t  arr.add(new Integer(2));\n\t\t\t  \n\t\t\t  System.out.println(arr.toString());\n\t\t\t\n\t\t\t  for(Object o : arr){\n\t\t\t\t  System.out.println((String)o);\n\t\t\t  }\n\t\t}\n\t\n\t}\n\n\n> 控制台输出：[qwer, 1234, 2]\nqwer\nException in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\n\tat TestRawType.main(TestRawType.java:17)\n\n\n更加详细的解释，参考《effective java》 2nd 第23条：请不要在新代码中使用原生态类型\n\n\n####  Static member 'android.support.v4.app.FragmentActivity.RESULT_OK' accessed via instance reference ####\n\n原因：通过实例引用了某个类的静态变量，如下：\n\n\tgetActivity().RESULT_OK\n\n修改：\n\t\n\tActivity.RESULT_OK;\n\n`update @ 2017年7月14日18:50:52`\n\n\n####  Dangling Javadoc comment ####\n\n原因：悬空的注释（在你导出文档时，可能会丢失）\n\n\n\n\n\n\n\n\n\n\n","slug":"android-notes","published":1,"updated":"2017-11-16T08:28:12.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1hy006v2siv3ko2tg5m","content":"<h4 id=\"using-setjavascriptenabled-can-introduce-xss-vulnerabilities-into-your-application\"><a href=\"#using-setjavascriptenabled-can-introduce-xss-vulnerabilities-into-your-application\" class=\"headerlink\" title=\"using setjavascriptenabled can introduce xss vulnerabilities into your application\"></a>using setjavascriptenabled can introduce xss vulnerabilities into your application</h4><p>在WebView中，如果你启用js，kotlin代码如下：</p>\n<pre><code>webview.settings.javaScriptEnabled = true\n</code></pre><p>会得到题目的警告提示。</p>\n<p>原因是：启用js可能不安全，如果你真的需要，好好检查这些js。<br>消除：</p>\n<pre><code>@SuppressLint(&quot;SetJavaScriptEnabled&quot;)\n</code></pre><h4 id=\"WebView-addJavascriptInterface-should-not-be-called-with-minSdkVersion-lt-17-for-security-reasons-JavaScript-can-use-reflection-to-manipulate-application\"><a href=\"#WebView-addJavascriptInterface-should-not-be-called-with-minSdkVersion-lt-17-for-security-reasons-JavaScript-can-use-reflection-to-manipulate-application\" class=\"headerlink\" title=\"WebView.addJavascriptInterface should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application\"></a><code>WebView.addJavascriptInterface</code> should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application</h4><p>在WebView中，如果添加JS调用Java代码，kotlin代码如下：</p>\n<pre><code>webview.addJavascriptInterface(JsObject(), &quot;onClick&quot;)\n</code></pre><p>会得到题目的警告提示。</p>\n<p>原因题目说的很清楚，“JavaScript可以通过反射操作应用”</p>\n<p>官方的说明：<a href=\"https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29\" target=\"_blank\" rel=\"external\">JavaScript安全不</a></p>\n<p>一篇不错的<a href=\"http://blog.csdn.net/leehong2005/article/details/11808557\" target=\"_blank\" rel=\"external\">blog</a></p>\n<p>可以确定的是4.2，也就是17，JELLY BEAN之前，可以获取到SD读写权限，然后操作你的联系人、短信、etc</p>\n<p>这个问题相当的经典。一般的应用估计都不会修复它。但如果应用用户太大，不得不修复。</p>\n<h4 id=\"加载JS的时机\"><a href=\"#加载JS的时机\" class=\"headerlink\" title=\"加载JS的时机\"></a>加载JS的时机</h4><p>引申问题，你有一段JS，何时加载？</p>\n<ul>\n<li>onLoadResource</li>\n<li>doUpdateVisitedHistory</li>\n<li>onPageStarted</li>\n<li>onPageFinished</li>\n<li>onReceivedTitle</li>\n<li>onProgressChanged</li>\n</ul>\n<h4 id=\"setRenderPriority-android-webkit-WebSettings-RenderPriority-’-is-deprecated\"><a href=\"#setRenderPriority-android-webkit-WebSettings-RenderPriority-’-is-deprecated\" class=\"headerlink\" title=\"setRenderPriority(android.webkit.WebSettings.RenderPriority)’ is deprecated\"></a>setRenderPriority(android.webkit.WebSettings.RenderPriority)’ is deprecated</h4><p>源码中：</p>\n<blockquote>\n<p>It is not recommended to adjust thread priorities, and this will not be supported in future versions.</p>\n</blockquote>\n<h4 id=\"webView-加载缓慢\"><a href=\"#webView-加载缓慢\" class=\"headerlink\" title=\"webView 加载缓慢\"></a>webView 加载缓慢</h4><pre><code>if (Build.VERSION.SDK_INT &gt;= 19) {//4.4，KK\n           mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, null);\n       }\n       else {\n           mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\n       }\n</code></pre><h4 id=\"This-Handler-class-should-be-static-or-leaks-might-occur-anonymous-android-os-Handler\"><a href=\"#This-Handler-class-should-be-static-or-leaks-might-occur-anonymous-android-os-Handler\" class=\"headerlink\" title=\"This Handler class should be static or leaks might occur (anonymous android.os.Handler)\"></a>This Handler class should be static or leaks might occur (anonymous android.os.Handler)</h4><p>我们在使用Handler发送消息时，往往使用内部类来实现Handler，这样可能导致内存泄露。</p>\n<p>原因：</p>\n<p>handler实例做为一个嵌套类，确切的说是做为一个内部类时，默认持有外部类的引用，</p>\n<p>假设外部类为<code>SampleActivity</code>，并且Handler里有延时执行的任务，并且Activity提前finish</p>\n<p>这样，由于activity的引用还在Handler的延时任务里，GC判定，该Activity虽然finish，但是不可回收，此时就发生了内存泄露</p>\n<p>解决：</p>\n<p>Handler使用静态内部类</p>\n<p>Handler类中使用弱引用维护对activity的引用：</p>\n<pre><code>private static class MyHandler extends Handler {\n    private final WeakReference&lt;SampleActivity&gt; mActivity;\n\n    public MyHandler(SampleActivity activity) {\n      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n      SampleActivity activity = mActivity.get();\n      if (activity != null) {\n        // ...\n      }\n    }\n  }\n\n  private final MyHandler mHandler = new MyHandler(this);\n</code></pre><p><a href=\"http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html\" target=\"_blank\" rel=\"external\">E文传送</a><br><a href=\"http://www.jianshu.com/p/1b39416f1508\" target=\"_blank\" rel=\"external\">译文传送</a></p>\n<h4 id=\"Warning-168-72-Unchecked-assignment-‘java-util-List’-to-‘java-util-List‘-Reason-‘queries’-has-raw-type-so-result-of-list-is-erased\"><a href=\"#Warning-168-72-Unchecked-assignment-‘java-util-List’-to-‘java-util-List‘-Reason-‘queries’-has-raw-type-so-result-of-list-is-erased\" class=\"headerlink\" title=\"Warning:(168, 72) Unchecked assignment: ‘java.util.List’ to ‘java.util.List‘. Reason: ‘queries’ has raw type, so result of list is erased\"></a>Warning:(168, 72) Unchecked assignment: ‘java.util.List’ to ‘java.util.List<com.xxx.greendao.xxbean>‘. Reason: ‘queries’ has raw type, so result of list is erased</com.xxx.greendao.xxbean></h4><p>只能添加指定类型，不会有警告：</p>\n<pre><code>ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();\n</code></pre><p>如果添加了String之外的类型，会有编译时警告：</p>\n<pre><code>ArrayList&lt;String&gt; arr = new ArrayList();\n</code></pre><p>这就是raw type，可以添加Object类型的对象，此时会提示<code>Unchecked assignment...</code>，</p>\n<pre><code>ArrayList arr = new ArrayList&lt;String&gt;();\n</code></pre><p>考察如下DEMO，可以编译通过，但是运行异常：</p>\n<pre><code>import java.util.ArrayList;\n\npublic class TestRawType {\n\n    public static void main(String[] args) {\n          ArrayList arr = new ArrayList&lt;String&gt;();\n\n          arr.add(&quot;qwer&quot;);\n          arr.add(1234);\n          arr.add(new Integer(2));\n\n          System.out.println(arr.toString());\n\n          for(Object o : arr){\n              System.out.println((String)o);\n          }\n    }\n\n}\n</code></pre><blockquote>\n<p>控制台输出：[qwer, 1234, 2]<br>qwer<br>Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String<br>    at TestRawType.main(TestRawType.java:17)</p>\n</blockquote>\n<p>更加详细的解释，参考《effective java》 2nd 第23条：请不要在新代码中使用原生态类型</p>\n<h4 id=\"Static-member-‘android-support-v4-app-FragmentActivity-RESULT-OK’-accessed-via-instance-reference\"><a href=\"#Static-member-‘android-support-v4-app-FragmentActivity-RESULT-OK’-accessed-via-instance-reference\" class=\"headerlink\" title=\"Static member ‘android.support.v4.app.FragmentActivity.RESULT_OK’ accessed via instance reference\"></a>Static member ‘android.support.v4.app.FragmentActivity.RESULT_OK’ accessed via instance reference</h4><p>原因：通过实例引用了某个类的静态变量，如下：</p>\n<pre><code>getActivity().RESULT_OK\n</code></pre><p>修改：</p>\n<pre><code>Activity.RESULT_OK;\n</code></pre><p><code>update @ 2017年7月14日18:50:52</code></p>\n<h4 id=\"Dangling-Javadoc-comment\"><a href=\"#Dangling-Javadoc-comment\" class=\"headerlink\" title=\"Dangling Javadoc comment\"></a>Dangling Javadoc comment</h4><p>原因：悬空的注释（在你导出文档时，可能会丢失）</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"using-setjavascriptenabled-can-introduce-xss-vulnerabilities-into-your-application\"><a href=\"#using-setjavascriptenabled-can-introduce-xss-vulnerabilities-into-your-application\" class=\"headerlink\" title=\"using setjavascriptenabled can introduce xss vulnerabilities into your application\"></a>using setjavascriptenabled can introduce xss vulnerabilities into your application</h4><p>在WebView中，如果你启用js，kotlin代码如下：</p>\n<pre><code>webview.settings.javaScriptEnabled = true\n</code></pre><p>会得到题目的警告提示。</p>\n<p>原因是：启用js可能不安全，如果你真的需要，好好检查这些js。<br>消除：</p>\n<pre><code>@SuppressLint(&quot;SetJavaScriptEnabled&quot;)\n</code></pre><h4 id=\"WebView-addJavascriptInterface-should-not-be-called-with-minSdkVersion-lt-17-for-security-reasons-JavaScript-can-use-reflection-to-manipulate-application\"><a href=\"#WebView-addJavascriptInterface-should-not-be-called-with-minSdkVersion-lt-17-for-security-reasons-JavaScript-can-use-reflection-to-manipulate-application\" class=\"headerlink\" title=\"WebView.addJavascriptInterface should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application\"></a><code>WebView.addJavascriptInterface</code> should not be called with minSdkVersion &lt; 17 for security reasons: JavaScript can use reflection to manipulate application</h4><p>在WebView中，如果添加JS调用Java代码，kotlin代码如下：</p>\n<pre><code>webview.addJavascriptInterface(JsObject(), &quot;onClick&quot;)\n</code></pre><p>会得到题目的警告提示。</p>\n<p>原因题目说的很清楚，“JavaScript可以通过反射操作应用”</p>\n<p>官方的说明：<a href=\"https://developer.android.com/reference/android/webkit/WebView.html#addJavascriptInterface%28java.lang.Object,%20java.lang.String%29\" target=\"_blank\" rel=\"external\">JavaScript安全不</a></p>\n<p>一篇不错的<a href=\"http://blog.csdn.net/leehong2005/article/details/11808557\" target=\"_blank\" rel=\"external\">blog</a></p>\n<p>可以确定的是4.2，也就是17，JELLY BEAN之前，可以获取到SD读写权限，然后操作你的联系人、短信、etc</p>\n<p>这个问题相当的经典。一般的应用估计都不会修复它。但如果应用用户太大，不得不修复。</p>\n<h4 id=\"加载JS的时机\"><a href=\"#加载JS的时机\" class=\"headerlink\" title=\"加载JS的时机\"></a>加载JS的时机</h4><p>引申问题，你有一段JS，何时加载？</p>\n<ul>\n<li>onLoadResource</li>\n<li>doUpdateVisitedHistory</li>\n<li>onPageStarted</li>\n<li>onPageFinished</li>\n<li>onReceivedTitle</li>\n<li>onProgressChanged</li>\n</ul>\n<h4 id=\"setRenderPriority-android-webkit-WebSettings-RenderPriority-’-is-deprecated\"><a href=\"#setRenderPriority-android-webkit-WebSettings-RenderPriority-’-is-deprecated\" class=\"headerlink\" title=\"setRenderPriority(android.webkit.WebSettings.RenderPriority)’ is deprecated\"></a>setRenderPriority(android.webkit.WebSettings.RenderPriority)’ is deprecated</h4><p>源码中：</p>\n<blockquote>\n<p>It is not recommended to adjust thread priorities, and this will not be supported in future versions.</p>\n</blockquote>\n<h4 id=\"webView-加载缓慢\"><a href=\"#webView-加载缓慢\" class=\"headerlink\" title=\"webView 加载缓慢\"></a>webView 加载缓慢</h4><pre><code>if (Build.VERSION.SDK_INT &gt;= 19) {//4.4，KK\n           mWebView.setLayerType(View.LAYER_TYPE_HARDWARE, null);\n       }\n       else {\n           mWebView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\n       }\n</code></pre><h4 id=\"This-Handler-class-should-be-static-or-leaks-might-occur-anonymous-android-os-Handler\"><a href=\"#This-Handler-class-should-be-static-or-leaks-might-occur-anonymous-android-os-Handler\" class=\"headerlink\" title=\"This Handler class should be static or leaks might occur (anonymous android.os.Handler)\"></a>This Handler class should be static or leaks might occur (anonymous android.os.Handler)</h4><p>我们在使用Handler发送消息时，往往使用内部类来实现Handler，这样可能导致内存泄露。</p>\n<p>原因：</p>\n<p>handler实例做为一个嵌套类，确切的说是做为一个内部类时，默认持有外部类的引用，</p>\n<p>假设外部类为<code>SampleActivity</code>，并且Handler里有延时执行的任务，并且Activity提前finish</p>\n<p>这样，由于activity的引用还在Handler的延时任务里，GC判定，该Activity虽然finish，但是不可回收，此时就发生了内存泄露</p>\n<p>解决：</p>\n<p>Handler使用静态内部类</p>\n<p>Handler类中使用弱引用维护对activity的引用：</p>\n<pre><code>private static class MyHandler extends Handler {\n    private final WeakReference&lt;SampleActivity&gt; mActivity;\n\n    public MyHandler(SampleActivity activity) {\n      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);\n    }\n\n    @Override\n    public void handleMessage(Message msg) {\n      SampleActivity activity = mActivity.get();\n      if (activity != null) {\n        // ...\n      }\n    }\n  }\n\n  private final MyHandler mHandler = new MyHandler(this);\n</code></pre><p><a href=\"http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html\" target=\"_blank\" rel=\"external\">E文传送</a><br><a href=\"http://www.jianshu.com/p/1b39416f1508\" target=\"_blank\" rel=\"external\">译文传送</a></p>\n<h4 id=\"Warning-168-72-Unchecked-assignment-‘java-util-List’-to-‘java-util-List‘-Reason-‘queries’-has-raw-type-so-result-of-list-is-erased\"><a href=\"#Warning-168-72-Unchecked-assignment-‘java-util-List’-to-‘java-util-List‘-Reason-‘queries’-has-raw-type-so-result-of-list-is-erased\" class=\"headerlink\" title=\"Warning:(168, 72) Unchecked assignment: ‘java.util.List’ to ‘java.util.List‘. Reason: ‘queries’ has raw type, so result of list is erased\"></a>Warning:(168, 72) Unchecked assignment: ‘java.util.List’ to ‘java.util.List<com.xxx.greendao.xxbean>‘. Reason: ‘queries’ has raw type, so result of list is erased</com.xxx.greendao.xxbean></h4><p>只能添加指定类型，不会有警告：</p>\n<pre><code>ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();\n</code></pre><p>如果添加了String之外的类型，会有编译时警告：</p>\n<pre><code>ArrayList&lt;String&gt; arr = new ArrayList();\n</code></pre><p>这就是raw type，可以添加Object类型的对象，此时会提示<code>Unchecked assignment...</code>，</p>\n<pre><code>ArrayList arr = new ArrayList&lt;String&gt;();\n</code></pre><p>考察如下DEMO，可以编译通过，但是运行异常：</p>\n<pre><code>import java.util.ArrayList;\n\npublic class TestRawType {\n\n    public static void main(String[] args) {\n          ArrayList arr = new ArrayList&lt;String&gt;();\n\n          arr.add(&quot;qwer&quot;);\n          arr.add(1234);\n          arr.add(new Integer(2));\n\n          System.out.println(arr.toString());\n\n          for(Object o : arr){\n              System.out.println((String)o);\n          }\n    }\n\n}\n</code></pre><blockquote>\n<p>控制台输出：[qwer, 1234, 2]<br>qwer<br>Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String<br>    at TestRawType.main(TestRawType.java:17)</p>\n</blockquote>\n<p>更加详细的解释，参考《effective java》 2nd 第23条：请不要在新代码中使用原生态类型</p>\n<h4 id=\"Static-member-‘android-support-v4-app-FragmentActivity-RESULT-OK’-accessed-via-instance-reference\"><a href=\"#Static-member-‘android-support-v4-app-FragmentActivity-RESULT-OK’-accessed-via-instance-reference\" class=\"headerlink\" title=\"Static member ‘android.support.v4.app.FragmentActivity.RESULT_OK’ accessed via instance reference\"></a>Static member ‘android.support.v4.app.FragmentActivity.RESULT_OK’ accessed via instance reference</h4><p>原因：通过实例引用了某个类的静态变量，如下：</p>\n<pre><code>getActivity().RESULT_OK\n</code></pre><p>修改：</p>\n<pre><code>Activity.RESULT_OK;\n</code></pre><p><code>update @ 2017年7月14日18:50:52</code></p>\n<h4 id=\"Dangling-Javadoc-comment\"><a href=\"#Dangling-Javadoc-comment\" class=\"headerlink\" title=\"Dangling Javadoc comment\"></a>Dangling Javadoc comment</h4><p>原因：悬空的注释（在你导出文档时，可能会丢失）</p>\n"},{"title":"Raspbarry first","date":"2017-08-17T00:00:00.000Z","_content":"\n想要利用树莓派+DuerOS做一个可以人机交互的家用终端。\n大概可以给讲故事，背诗词，报时，报天气。\n车载大概可以导航，实时路况，广播之类。\n\n \n ","source":"_posts/2017-08-17-raspbarry-first.md","raw":"---\ntitle: Raspbarry first\ndate: 2017-08-17\ntags: raspbarry\ncategories: Others\n---\n\n想要利用树莓派+DuerOS做一个可以人机交互的家用终端。\n大概可以给讲故事，背诗词，报时，报天气。\n车载大概可以导航，实时路况，广播之类。\n\n \n ","slug":"raspbarry-first","published":1,"updated":"2017-11-16T08:34:56.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1i1006y2sivpauq0u2z","content":"<p>想要利用树莓派+DuerOS做一个可以人机交互的家用终端。<br>大概可以给讲故事，背诗词，报时，报天气。<br>车载大概可以导航，实时路况，广播之类。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想要利用树莓派+DuerOS做一个可以人机交互的家用终端。<br>大概可以给讲故事，背诗词，报时，报天气。<br>车载大概可以导航，实时路况，广播之类。</p>\n"},{"layout":"post","title":"Android系统服务：AccountManager","date":"2017-08-17T00:00:00.000Z","_content":" \n\n#### 前面 ####\n  \n以`AccountManager`为例，read the fucking code.\n#### 协议 ####\n\n可以看到该类遵循Apache协议。也就是说允许商用，私用，分发，修改，专利授权，附件协议，作者不允许商标使用，不承担责任。\n\n详细的各种协议区分，请看：[here](http://xusx1024.com/2017/08/22/license-introduce/)\n\n#### package ####\n\n类所在的包：`package android.accounts;` \n\n- AbstractAccountAuthenticator\n- Account\n- AccountAuthenticatorActivity\n- AccountAuthenticatorResponse\n- AccountManagerCallback\n- AccountManagerFuture\n- AccountsException\n- AuthenticatorDescription\n- AuthenticatorException\n- NetworkErrorException\n- OnAccountsUpdateListener\n- OperationCanceledException\n\n\n#### 类说明 ####\n\nThis class provides access to a centralized registry of the user's online accounts.  \nThe user enters credentials (username and password) once per account, granting applications access to online resources with \"one-click\" approval.\n\n此类提供了用户在线账户集中注册的访问。\n用户为每个账户输入用户密码作为证书，准许应用通过一次授权访问在线资源。\n\n<p>Different online services have different ways of handling accounts and authentication, so the account manager uses pluggable <em>authenticator</em> modules for different <em>account types</em>. \nAuthenticators (which may be written by third parties) handle the actual details of validating account credentials and storing account information.  \nFor example, Google, Facebook, and Microsoft Exchange each have their own authenticator.\n\n不同的线上服务处理账户和认证有不同的方式，因此账户管理者为不同的账户类型应用可插拔的认证模块。\n验证者(也许是第三方写入)处理具体的账户证书细节，并且存储账户信息。\n例如：Google，Facebook,Microsoft Exchange有各自的验证者。\n\n<p>Many servers support some notion[概念] of an <em>authentication token</em>, which can be used to authenticate a request to the server without sending the user's actual password.  \n(Auth tokens are normally created with a separate request which does include the user's credentials.) \nAccountManager can generate auth tokens for applications, so the application doesn't need to handle passwords directly. \nAuth tokens are normally reusable and cached by AccountManager, but must be refreshed periodically[定期]. \nIt's the responsibility of applications to <em>invalidate</em> auth tokens when they stop working so the AccountManager knows it needs to regenerate them.\n\n许多服务支持认证令牌的概念，可以无需用户确切的密码，即可向服务端认证一个请求。\n(授权令牌通常创建在包含用户证书的一个单独的请求里。)\n账户管理者可以为应用生成授权令牌，因此应用无需直接操作密码。\n授权令牌通常是可重用的并由账户管理者缓存，但必须定期刷新。\n当授权令牌停止工作时，应用的职责是废止这些授权，账户管理者依此得知需要重新生成。\n\n<p>Applications accessing a server normally go through these steps:\n\n<ul>\n<li>Get an instance of AccountManager using {@link #get(Context)}.\n\n<li>List the available accounts using {@link #getAccountsByType} or {@link #getAccountsByTypeAndFeatures}.  \nNormally applications will only be interested in accounts with one particular <em>type</em>, which identifies the authenticator.  \nAccount <em>features</em> are used to identify particular account subtypes and capabilities[功能].  \nBoth the account type and features are authenticator-specific strings, and must be known by the application in coordination with its preferred authenticators.\n\n<li>Select one or more of the available accounts, possibly by asking the user for their preference.  \nIf no suitable accounts are available, {@link #addAccount} may be called to prompt the user to create an account of the appropriate type.\n\n<li><b>Important:</b> If the application is using a previously remembered account selection, it must make sure the account is still in the list of accounts returned by {@link #getAccountsByType}.  Requesting an auth token for an account no longer on the device results in an undefined failure.\n\n<li>Request an auth token for the selected account(s) using one of the {@link #getAuthToken} methods or related helpers.  \nRefer to the description of each method for exact usage and error handling details.\n\n<li>Make the request using the auth token.  The form of the auth token, the format of the request, and the protocol used are all specific to the service you are accessing.  \nThe application may use whatever network and protocol libraries are useful.\n\n<li><b>Important:</b> If the request fails with an authentication error, it could be that a cached auth token is stale and no longer honored by the server.  \nThe application must call {@link #invalidateAuthToken} to remove the token from the cache, otherwise requests will continue failing!  \nAfter invalidating the auth token, immediately go back to the \"Request an auth token\" step above.  \nIf the process fails the second time, then it can be treated as a \"genuine\" authentication failure and the user notified or other appropriate actions taken.\n</ul>\n\n应用访问服务一般有以下几个步骤：\n<ul>\n<li>使用`get(Context)`获取账户管理者的实例\n<li>使用`getAccountsByType`或者`getAccountsByTypeAndFeatures`列出可用的账户。\n通常应用只会被一个特定类型所吸引，该类型可用于识别验证者。\n账户特征用来识别特定的账户子类型和功能。\n账户类型和特征是验证者特定的字符串，必须由应用程序与其首选验证着协调知道。\n<li>选一或多个可用账户，可能通过询问用户的偏好。\n如果没有适合的账户可用，指示用户调用`addAccount`创建一个适当类型的账户。\n<li><b>重要：</b>如果应用程序正在使用以前记录的账户选择，一定要确保此账户仍在`getAccountsByType`返回的账户列表里。\n为不再在设备上的账户请求授权令牌，会导致未定义的错误。\n<li>为选择的账户请求授权令牌使用`getAuthToken`方法，或者相关的帮助者。\n参考各个方法的描述，以确定用例使用、错误处理细节。\n<li>使用授权令牌发起请求。令牌的形式，请求的格式，使用的协议，这些都由你正在访问的服务指定。\n应用程序可以使用任何网络和协议库都是可用的。\n<li><b>重要：</b>如果请求失败出现了授权错误，可能是缓存的令牌陈旧，不再由服务器兑现。\n应用程序必须调用`invalidateAuthToken`去移除缓存的令牌，否则请求就会持续失败！\n废止授权令牌之后，可以直接重复上面的步骤。\n如果第二次操作也失败，就可以被对待为真实身份认证失败，用户需要被通知或采取别的行动.\n</ul>\n\n<p>Some AccountManager methods may need to interact with the user to prompt for credentials, present options, or ask the user to add an account.\nThe caller may choose whether to allow AccountManager to directly launch the necessary user interface and wait for the user, or to return an Intent which the caller may use to launch the interface, or (in some cases) to install a notification which the user can select at any time to launch the interface.\nTo have AccountManager launch the interface directly, the caller must supply the current foreground {@link Activity} context.\n\n一些账户管理者方法也许需要与用户交互来提示凭据，呈现选项，或要求用户添加一个账户。\n调用者可以选择允许账户管理者直接登录必要的用户接口并且等待用户返回，也可以返回一个可以用来登录用户接口的意图，也可以展示一个通知，用户可以在任意时间选择去登录该接口。\n要让账户管理者直接登录接口，调用者必须提供当前前台活动的上下文。\n\n<p>Many AccountManager methods take {@link AccountManagerCallback} and {@link Handler} as parameters.  \nThese methods return immediately and run asynchronously. \nIf a callback is provided then {@link AccountManagerCallback#run} will be invoked on the Handler's thread when the request completes, successfully or not.\nThe result is retrieved by calling {@link AccountManagerFuture#getResult()} on the {@link AccountManagerFuture} returned by the method (and also passed to the callback).  \nThis method waits for the operation to complete (if necessary) and either returns the result or throws an exception if an error occurred during the operation.  \nTo make the request synchronously, call {@link AccountManagerFuture#getResult()} immediately on receiving the future from the method; no callback need be supplied.\n\n<p>许多账户管理者持有`AccountManagerCallback`和`Handler`实例作为参数。\n这些方法会异步执行并且立即返回。\n如果一个回调被提供，在请求完成，成功或失败时，`AccountManagerCallback`将会在Handler的线程中被调用。\n结果检索调用的方法是`AccountManagerFuture#getResult()`。\n如果有必要，此方法等待操作的完成并且无论是返回结果或是在操作过程中产生错误并抛出异常。\n为了异步执行请求，在接受到方法的未来时，直接调用` AccountManagerFuture#getResult()`；不需要提供回调。\n\n<p>Requests which may block, including {@link AccountManagerFuture#getResult()}, must never be called on the application's main event thread.  \nThese operations throw {@link IllegalStateException} if they are used on the main thread.\n\n请求也许会阻塞，包括`AccountManagerFuture#getResult()`,绝对禁止在应用程序的主线程调用。\n否则，这些操作会抛出`IllegalStateException`异常。\n\n#### 变量 ####\n\n##### 静态常量 #####\n\n- `ERROR_CODE_REMOTE_EXCEPTION`:远程异常\n- `ERROR_CODE_NETWORK_ERROR`:网络错误\n- `ERROR_CODE_CANCELED`:取消\n- `ERROR_CODE_INVALID_RESPONSE`:无效的响应\n- `ERROR_CODE_UNSUPPORTED_OPERATION`:不支持的操作\n- `ERROR_CODE_BAD_ARGUMENTS`:错误的参数\n- `ERROR_CODE_BAD_REQUEST`:错误的请求\n- `ERROR_CODE_BAD_AUTHENTICATION`:错误的授权\n- `ERROR_CODE_BAD_AUTHENTICATION`:错误的已注册用户\n- `ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE`:当前账户类型管理失效错误\n- `KEY_ACCOUNT_NAME`:传值常量键，用于获取账户名\n- `KEY_ACCOUNT_TYPE`:传值常量键，用于获取账户类型值\n- `KEY_AUTHTOKEN`:传值常量键，用于获取授权令牌\n- `KEY_INTENT`:传值常量键，用于启动相关的用户接口页面\n- `KEY_PASSWORD`:传值常量键，用于获取密码\n- `KEY_ACCOUNTS`:传值常量键，用于获取账户\n- `KEY_ACCOUNT_AUTHENTICATOR_RESPONSE`:传值常量键，用于获取账户授权响应\n- `KEY_ACCOUNT_MANAGER_RESPONSE`:传值常量键，用于获取账户管理者响应\n- `KEY_AUTHENTICATOR_TYPES`:传值常量键，用于获取授权类型\n- `KEY_AUTH_FAILED_MESSAGE`:授权失败信息\n- `KEY_AUTH_TOKEN_LABEL`:授权令牌标签\n- `KEY_BOOLEAN_RESULT`:结果布尔值\n- `KEY_ERROR_CODE`:错误码\n- `KEY_ERROR_MESSAGE`:错误消息\n- `KEY_USERDATA`:用户数据\n- `KEY_LAST_AUTHENTICATED_TIME`:上次授权时间\n- `KEY_CALLER_UID`:调用者的UID\n- `KEY_CALLER_PID`:调用者的PID\n- `KEY_ANDROID_PACKAGE_NAME`:Android包名\n- `KEY_NOTIFY_ON_FAILURE`:授权失败时是否提示，boolean值\n- `ACTION_AUTHENTICATOR_INTENT`:`android.accounts.AccountAuthenticator`\n- `AUTHENTICATOR_META_DATA_NAME`:`android.accounts.AccountAuthenticator`\n- `AUTHENTICATOR_ATTRIBUTES_NAME`:授权者的name属性\n\n#### 构造方法 ####\n\n\t public AccountManager(Context context, IAccountManager service) {\n        mContext = context;\n        mService = service;\n        mMainHandler = new Handler(mContext.getMainLooper());\n     }\n\n不会用到，获取一个账户管理者的实例，使用如下方法即可：\n\t\n\t public static AccountManager get(Context context) {\n\t        if (context == null) throw new IllegalArgumentException(\"context is null\");\n\t        return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);\n\t    }\n\t\n#### 类结构 ####\n\n`public class AccountManager{ ... }`\n\npublic的类，没有实现任何接口。\n\n##### 内部类-AmsTask #####\n\n`private abstract class AmsTask extends FutureTask<Bundle> implements AccountManagerFuture<Bundle> { ... }`\n\n看类修饰符：\n- abstract ： 说明该类是一个模板类，必定有抽象方法，需要被子类化，实现具体的操作，\n- private：子类化应该是在外部类中\n符合Java编码原则：使用函数对象代替策略。使类和成员的可访问性最小化。\n\n该类继承自一个可取消的异步计算，实现了一个处理计算结果的回调。\n\n发现`AccountManagerFuture` 和`Future`两个接口的行为是一样的，一个在`android.accounts`里，另一个在`java.util.concurrent`.\n\nAmsTask的构造方法为public，由于父类`FutureTask`的构造，必须要求传递`Callable`实例，如果没有这个实例，就会`NullPointerException`，所以直接在此截断抛出了。\n因此，虽然传递了Callable，却禁止使用了，使用的还是Future。\n\n\t  public AmsTask(Activity activity, Handler handler, AccountManagerCallback<Bundle> callback) {\n            super(new Callable<Bundle>() {\n                public Bundle call() throws Exception {\n                    throw new IllegalStateException(\"this should never be called\");\n                }\n            });\n\n            mHandler = handler;\n            mCallback = callback;\n            mActivity = activity;\n            mResponse = new Response();\n        }\n\n-  abstract void doWork()  由函数对象来具体实现操作\n-  AccountManagerFuture<Bundle> start() 开始执行`doWork()`\n-  void set(Bundle bundle) 父类方法，把结果设置给指定的Future，除非Future已经有结果或者已经被取消\n-  Bundle getResult()、Bundle getResult(long timeout, TimeUnit unit)、Bundle internalGetResult(Long timeout, TimeUnit unit) 获取处理结果\n> getResult最后都调用了`internalGetResult`方法。大概流程如下：\n> - 判断线程是否执行结束\n> - 判断时间是否为null或已结束\n> - 获取结果\n> - 异常后取消线程执行\n\n确保当前线程不在主线程的代码：\n\n\tprivate void ensureNotOnMainThread() {\n        final Looper looper = Looper.myLooper();\n        if (looper != null && looper == mContext.getMainLooper()) {\n            final IllegalStateException exception = new IllegalStateException(\n                    \"calling this from your main thread can lead to deadlock\");\n            Log.e(TAG, \"calling this from your main thread can lead to deadlock and/or ANRs\",\n                    exception);\n            if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.FROYO) {\n                throw exception;\n            }\n        }\n    }\n\n跟踪到`FutureTask`的`get`方法里，这里返回父类的一个Object实例：`outcome`存放我们想要的结果对象。\n\n在`get`里还有许多操作，比如判断线程执行的状态：\n- NEW         \n- COMPLETING  \n- NORMAL      \n- EXCEPTIONAL \n- CANCELLED   \n- INTERRUPTING\n- INTERRUPTED \n\n我看到在操作线程状态的时候，使用了该类：`private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();`，用来保证原子操作，确定一个线程是`RUNNER`,`WAITER`.\n这是一个JDK私有API，在Java9的时候可能移除，并使用`java.util.concurrent.LockSupport`实现。下面摘抄一段说明：\n\n> 原子访问是`sun.misc.Unsafe`被广泛应用的特性之一，特性包括简单的put、get操作(带有volatile语义或不带有volatile语义)以及比较并交换(compare and swap，CAS)操作。\n\t\n##### AmsTask的内部类-Response #####\n\nAmsTask中有一个public的Response的引用。\n\n操作一：`onResult`\n\n> 响应有结果，跳转至用户提供的Activity，或是重试，再次调用`doWork()`，否则把响应数据bundle设置回父类的`outcome`里\n\n操作二：`onError`\n\n> 取消线程的执行\n\n##### 内部类-BaseFutureTask #####\n\n可以看到这是一个抽象类，我们只要知道什么是需要子类实现的，什么是已经实现的。\n\n\t protected void postRunnableToHandler(Runnable runnable) {\n            Handler handler = (mHandler == null) ? mMainHandler : mHandler;\n            handler.post(runnable);\n        }\n\n把Runnable加入消息队列，可以当前线程的handler执行。\n\n`abstract void doWork()`  由函数对象来具体实现操作\n`abstract T bundleToResult(Bundle bundle)` 由函数对象来具体实现操作\n\n##### BaseFutureTask的内部类-Response #####\n\n- onResult 调用外部类的`bundleToResult`\n- onError 中断线程，抛出异常\n\n##### 内部类-Future2Task #####\n\n* BaseFutureTask的子类，同时也是个抽象类，实现了`internalGetResult`，具体的贱`AmsTask$internalGetResult`\n\n##### 内部类-GetAuthTokenByTypeAndFeaturesTask #####\n\n`AmsTask`的子类，顾名思义，根据类型和特征获取授权令牌的任务。\n\n`doWork()`的作用：\n- 根据类型和特征尝试获取已授权账户\n- 未获取到账户，如果提示添加账户的activity为空，则把`KEY_ACCOUNT_NAME`,`KEY_ACCOUNT_TYPE`,`KEY_AUTHTOKEN`置为空，并返回\n- 未获取到账户，如果提示添加账户的activity不为空，调用`addAccount`方法，这是一个Future，可以中断和等待结果的子线程\n- 如果只获取到一个账户，获取AuthToken，放入响应\n- 如果获取到了多个账户，启动`android.accounts.ChooseAccountActivity`,选择一个后，获取AuthToken，放入响应\n\n#### 主要方法 ####\n\n##### sanitizeResult #####\n\n\t  public static Bundle sanitizeResult(Bundle result) {\n\t        if (result != null) {\n\t            if (result.containsKey(KEY_AUTHTOKEN)\n\t                    && !TextUtils.isEmpty(result.getString(KEY_AUTHTOKEN))) {\n\t                final Bundle newResult = new Bundle(result);\n\t                newResult.putString(KEY_AUTHTOKEN, \"<omitted for logging purposes>\");\n\t                return newResult;\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n如果返回的结果bundle中包含`KEY_AUTHTOKEN`，就把这个值变成“为了日志的目的而省略”，是对结果做一次“消毒”\n\n##### IAccountManager相关 #####\n\n- getPassword\n- setPassword\n- clearPassword\n- getUserData\n- setUserData\n- getAuthenticatorTypes：此处返回一个数组，一个账户可以有多重类型，不需要权限\n- getAuthenticatorTypesAsUser：需要权限，或者相同的用户\n- getAccounts：需要权限\n- getAccountsAsUser\n- getAccountsForPackage：调用者可用的账户列表\n- updateAppPermission：仅被系统页面调用，不包含于SDK中\n- getAuthTokenLabel：获取与认证者相关联的用户友好标签，返回一个Future\n- hasFeatures：需要权限，指定的账户是拥有指定的权限。可用在任意线程，但返回结果不可用于主线程。\n- getAccountsByTypeAndFeatures：需要权限，根据类型和功能获取账户列表\n- addAccount\n- addSharedAccount\n- addAccountExplicitly：直接添加一个账户。这个方法不会刷新最近一次的时间戳，需要主动`notifyAccountAuthenticated`。但是，如果该方法触发了`addAccount()`或者`addAccountAsUser`，就不需要刷新时间戳，可以自动刷新了。可在主线程调用此方法。需要API22以上。\n- notifyAccountAuthenticated：通知系统账户刚刚被授权。可被其他程序用来验证账户。只有在授权成功方可调用。主线程不安全的。\n- renameAccount：先移除已有的账户，再添加重命名后的账户。\n- getPreviousName：获取改名前的名字，可能返回null，主线程安全的。\n- removeAccount：如果有，就从AccountManager删除账户，不会从服务器上删除。API22之前调用需要权限。\n- removeAccountAsUser\n- invalidateAuthToken：从AccountManager的缓存中移除授权。API22之前需要权限。\n- peekAuthToken：从缓存中取授权令牌，如果没有，生成一个新的，不会链接服务器。\n- setAuthToken\n- getAuthToken\n- getAuthTokenByFeatures\n- blockingGetAuthToken：会阻塞，不要在主线程调用，API22之前需要权限\n- copyAccountToUser\n- confirmCredentialsAsUser：\n- updateCredentials\n- editProperties：提供一个用户修改授权设置的机会。\n- ensureNotOnMainThread：确保不在主线程\n- postToHandler\n- convertErrorToException\n- newChooseAccountIntent：提供给用户一个可选账户的列表\n\n#### DEMO ####\n\n[AccountManagerDemo](https://github.com/xusx1024/AccountManagerDemo)\n","source":"_posts/2017-08-17-android-system-service-Account-Manager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：AccountManager\ndate:   2017-08-17\ncategories: Android System Framework\ntag: android\n---\n \n\n#### 前面 ####\n  \n以`AccountManager`为例，read the fucking code.\n#### 协议 ####\n\n可以看到该类遵循Apache协议。也就是说允许商用，私用，分发，修改，专利授权，附件协议，作者不允许商标使用，不承担责任。\n\n详细的各种协议区分，请看：[here](http://xusx1024.com/2017/08/22/license-introduce/)\n\n#### package ####\n\n类所在的包：`package android.accounts;` \n\n- AbstractAccountAuthenticator\n- Account\n- AccountAuthenticatorActivity\n- AccountAuthenticatorResponse\n- AccountManagerCallback\n- AccountManagerFuture\n- AccountsException\n- AuthenticatorDescription\n- AuthenticatorException\n- NetworkErrorException\n- OnAccountsUpdateListener\n- OperationCanceledException\n\n\n#### 类说明 ####\n\nThis class provides access to a centralized registry of the user's online accounts.  \nThe user enters credentials (username and password) once per account, granting applications access to online resources with \"one-click\" approval.\n\n此类提供了用户在线账户集中注册的访问。\n用户为每个账户输入用户密码作为证书，准许应用通过一次授权访问在线资源。\n\n<p>Different online services have different ways of handling accounts and authentication, so the account manager uses pluggable <em>authenticator</em> modules for different <em>account types</em>. \nAuthenticators (which may be written by third parties) handle the actual details of validating account credentials and storing account information.  \nFor example, Google, Facebook, and Microsoft Exchange each have their own authenticator.\n\n不同的线上服务处理账户和认证有不同的方式，因此账户管理者为不同的账户类型应用可插拔的认证模块。\n验证者(也许是第三方写入)处理具体的账户证书细节，并且存储账户信息。\n例如：Google，Facebook,Microsoft Exchange有各自的验证者。\n\n<p>Many servers support some notion[概念] of an <em>authentication token</em>, which can be used to authenticate a request to the server without sending the user's actual password.  \n(Auth tokens are normally created with a separate request which does include the user's credentials.) \nAccountManager can generate auth tokens for applications, so the application doesn't need to handle passwords directly. \nAuth tokens are normally reusable and cached by AccountManager, but must be refreshed periodically[定期]. \nIt's the responsibility of applications to <em>invalidate</em> auth tokens when they stop working so the AccountManager knows it needs to regenerate them.\n\n许多服务支持认证令牌的概念，可以无需用户确切的密码，即可向服务端认证一个请求。\n(授权令牌通常创建在包含用户证书的一个单独的请求里。)\n账户管理者可以为应用生成授权令牌，因此应用无需直接操作密码。\n授权令牌通常是可重用的并由账户管理者缓存，但必须定期刷新。\n当授权令牌停止工作时，应用的职责是废止这些授权，账户管理者依此得知需要重新生成。\n\n<p>Applications accessing a server normally go through these steps:\n\n<ul>\n<li>Get an instance of AccountManager using {@link #get(Context)}.\n\n<li>List the available accounts using {@link #getAccountsByType} or {@link #getAccountsByTypeAndFeatures}.  \nNormally applications will only be interested in accounts with one particular <em>type</em>, which identifies the authenticator.  \nAccount <em>features</em> are used to identify particular account subtypes and capabilities[功能].  \nBoth the account type and features are authenticator-specific strings, and must be known by the application in coordination with its preferred authenticators.\n\n<li>Select one or more of the available accounts, possibly by asking the user for their preference.  \nIf no suitable accounts are available, {@link #addAccount} may be called to prompt the user to create an account of the appropriate type.\n\n<li><b>Important:</b> If the application is using a previously remembered account selection, it must make sure the account is still in the list of accounts returned by {@link #getAccountsByType}.  Requesting an auth token for an account no longer on the device results in an undefined failure.\n\n<li>Request an auth token for the selected account(s) using one of the {@link #getAuthToken} methods or related helpers.  \nRefer to the description of each method for exact usage and error handling details.\n\n<li>Make the request using the auth token.  The form of the auth token, the format of the request, and the protocol used are all specific to the service you are accessing.  \nThe application may use whatever network and protocol libraries are useful.\n\n<li><b>Important:</b> If the request fails with an authentication error, it could be that a cached auth token is stale and no longer honored by the server.  \nThe application must call {@link #invalidateAuthToken} to remove the token from the cache, otherwise requests will continue failing!  \nAfter invalidating the auth token, immediately go back to the \"Request an auth token\" step above.  \nIf the process fails the second time, then it can be treated as a \"genuine\" authentication failure and the user notified or other appropriate actions taken.\n</ul>\n\n应用访问服务一般有以下几个步骤：\n<ul>\n<li>使用`get(Context)`获取账户管理者的实例\n<li>使用`getAccountsByType`或者`getAccountsByTypeAndFeatures`列出可用的账户。\n通常应用只会被一个特定类型所吸引，该类型可用于识别验证者。\n账户特征用来识别特定的账户子类型和功能。\n账户类型和特征是验证者特定的字符串，必须由应用程序与其首选验证着协调知道。\n<li>选一或多个可用账户，可能通过询问用户的偏好。\n如果没有适合的账户可用，指示用户调用`addAccount`创建一个适当类型的账户。\n<li><b>重要：</b>如果应用程序正在使用以前记录的账户选择，一定要确保此账户仍在`getAccountsByType`返回的账户列表里。\n为不再在设备上的账户请求授权令牌，会导致未定义的错误。\n<li>为选择的账户请求授权令牌使用`getAuthToken`方法，或者相关的帮助者。\n参考各个方法的描述，以确定用例使用、错误处理细节。\n<li>使用授权令牌发起请求。令牌的形式，请求的格式，使用的协议，这些都由你正在访问的服务指定。\n应用程序可以使用任何网络和协议库都是可用的。\n<li><b>重要：</b>如果请求失败出现了授权错误，可能是缓存的令牌陈旧，不再由服务器兑现。\n应用程序必须调用`invalidateAuthToken`去移除缓存的令牌，否则请求就会持续失败！\n废止授权令牌之后，可以直接重复上面的步骤。\n如果第二次操作也失败，就可以被对待为真实身份认证失败，用户需要被通知或采取别的行动.\n</ul>\n\n<p>Some AccountManager methods may need to interact with the user to prompt for credentials, present options, or ask the user to add an account.\nThe caller may choose whether to allow AccountManager to directly launch the necessary user interface and wait for the user, or to return an Intent which the caller may use to launch the interface, or (in some cases) to install a notification which the user can select at any time to launch the interface.\nTo have AccountManager launch the interface directly, the caller must supply the current foreground {@link Activity} context.\n\n一些账户管理者方法也许需要与用户交互来提示凭据，呈现选项，或要求用户添加一个账户。\n调用者可以选择允许账户管理者直接登录必要的用户接口并且等待用户返回，也可以返回一个可以用来登录用户接口的意图，也可以展示一个通知，用户可以在任意时间选择去登录该接口。\n要让账户管理者直接登录接口，调用者必须提供当前前台活动的上下文。\n\n<p>Many AccountManager methods take {@link AccountManagerCallback} and {@link Handler} as parameters.  \nThese methods return immediately and run asynchronously. \nIf a callback is provided then {@link AccountManagerCallback#run} will be invoked on the Handler's thread when the request completes, successfully or not.\nThe result is retrieved by calling {@link AccountManagerFuture#getResult()} on the {@link AccountManagerFuture} returned by the method (and also passed to the callback).  \nThis method waits for the operation to complete (if necessary) and either returns the result or throws an exception if an error occurred during the operation.  \nTo make the request synchronously, call {@link AccountManagerFuture#getResult()} immediately on receiving the future from the method; no callback need be supplied.\n\n<p>许多账户管理者持有`AccountManagerCallback`和`Handler`实例作为参数。\n这些方法会异步执行并且立即返回。\n如果一个回调被提供，在请求完成，成功或失败时，`AccountManagerCallback`将会在Handler的线程中被调用。\n结果检索调用的方法是`AccountManagerFuture#getResult()`。\n如果有必要，此方法等待操作的完成并且无论是返回结果或是在操作过程中产生错误并抛出异常。\n为了异步执行请求，在接受到方法的未来时，直接调用` AccountManagerFuture#getResult()`；不需要提供回调。\n\n<p>Requests which may block, including {@link AccountManagerFuture#getResult()}, must never be called on the application's main event thread.  \nThese operations throw {@link IllegalStateException} if they are used on the main thread.\n\n请求也许会阻塞，包括`AccountManagerFuture#getResult()`,绝对禁止在应用程序的主线程调用。\n否则，这些操作会抛出`IllegalStateException`异常。\n\n#### 变量 ####\n\n##### 静态常量 #####\n\n- `ERROR_CODE_REMOTE_EXCEPTION`:远程异常\n- `ERROR_CODE_NETWORK_ERROR`:网络错误\n- `ERROR_CODE_CANCELED`:取消\n- `ERROR_CODE_INVALID_RESPONSE`:无效的响应\n- `ERROR_CODE_UNSUPPORTED_OPERATION`:不支持的操作\n- `ERROR_CODE_BAD_ARGUMENTS`:错误的参数\n- `ERROR_CODE_BAD_REQUEST`:错误的请求\n- `ERROR_CODE_BAD_AUTHENTICATION`:错误的授权\n- `ERROR_CODE_BAD_AUTHENTICATION`:错误的已注册用户\n- `ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE`:当前账户类型管理失效错误\n- `KEY_ACCOUNT_NAME`:传值常量键，用于获取账户名\n- `KEY_ACCOUNT_TYPE`:传值常量键，用于获取账户类型值\n- `KEY_AUTHTOKEN`:传值常量键，用于获取授权令牌\n- `KEY_INTENT`:传值常量键，用于启动相关的用户接口页面\n- `KEY_PASSWORD`:传值常量键，用于获取密码\n- `KEY_ACCOUNTS`:传值常量键，用于获取账户\n- `KEY_ACCOUNT_AUTHENTICATOR_RESPONSE`:传值常量键，用于获取账户授权响应\n- `KEY_ACCOUNT_MANAGER_RESPONSE`:传值常量键，用于获取账户管理者响应\n- `KEY_AUTHENTICATOR_TYPES`:传值常量键，用于获取授权类型\n- `KEY_AUTH_FAILED_MESSAGE`:授权失败信息\n- `KEY_AUTH_TOKEN_LABEL`:授权令牌标签\n- `KEY_BOOLEAN_RESULT`:结果布尔值\n- `KEY_ERROR_CODE`:错误码\n- `KEY_ERROR_MESSAGE`:错误消息\n- `KEY_USERDATA`:用户数据\n- `KEY_LAST_AUTHENTICATED_TIME`:上次授权时间\n- `KEY_CALLER_UID`:调用者的UID\n- `KEY_CALLER_PID`:调用者的PID\n- `KEY_ANDROID_PACKAGE_NAME`:Android包名\n- `KEY_NOTIFY_ON_FAILURE`:授权失败时是否提示，boolean值\n- `ACTION_AUTHENTICATOR_INTENT`:`android.accounts.AccountAuthenticator`\n- `AUTHENTICATOR_META_DATA_NAME`:`android.accounts.AccountAuthenticator`\n- `AUTHENTICATOR_ATTRIBUTES_NAME`:授权者的name属性\n\n#### 构造方法 ####\n\n\t public AccountManager(Context context, IAccountManager service) {\n        mContext = context;\n        mService = service;\n        mMainHandler = new Handler(mContext.getMainLooper());\n     }\n\n不会用到，获取一个账户管理者的实例，使用如下方法即可：\n\t\n\t public static AccountManager get(Context context) {\n\t        if (context == null) throw new IllegalArgumentException(\"context is null\");\n\t        return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);\n\t    }\n\t\n#### 类结构 ####\n\n`public class AccountManager{ ... }`\n\npublic的类，没有实现任何接口。\n\n##### 内部类-AmsTask #####\n\n`private abstract class AmsTask extends FutureTask<Bundle> implements AccountManagerFuture<Bundle> { ... }`\n\n看类修饰符：\n- abstract ： 说明该类是一个模板类，必定有抽象方法，需要被子类化，实现具体的操作，\n- private：子类化应该是在外部类中\n符合Java编码原则：使用函数对象代替策略。使类和成员的可访问性最小化。\n\n该类继承自一个可取消的异步计算，实现了一个处理计算结果的回调。\n\n发现`AccountManagerFuture` 和`Future`两个接口的行为是一样的，一个在`android.accounts`里，另一个在`java.util.concurrent`.\n\nAmsTask的构造方法为public，由于父类`FutureTask`的构造，必须要求传递`Callable`实例，如果没有这个实例，就会`NullPointerException`，所以直接在此截断抛出了。\n因此，虽然传递了Callable，却禁止使用了，使用的还是Future。\n\n\t  public AmsTask(Activity activity, Handler handler, AccountManagerCallback<Bundle> callback) {\n            super(new Callable<Bundle>() {\n                public Bundle call() throws Exception {\n                    throw new IllegalStateException(\"this should never be called\");\n                }\n            });\n\n            mHandler = handler;\n            mCallback = callback;\n            mActivity = activity;\n            mResponse = new Response();\n        }\n\n-  abstract void doWork()  由函数对象来具体实现操作\n-  AccountManagerFuture<Bundle> start() 开始执行`doWork()`\n-  void set(Bundle bundle) 父类方法，把结果设置给指定的Future，除非Future已经有结果或者已经被取消\n-  Bundle getResult()、Bundle getResult(long timeout, TimeUnit unit)、Bundle internalGetResult(Long timeout, TimeUnit unit) 获取处理结果\n> getResult最后都调用了`internalGetResult`方法。大概流程如下：\n> - 判断线程是否执行结束\n> - 判断时间是否为null或已结束\n> - 获取结果\n> - 异常后取消线程执行\n\n确保当前线程不在主线程的代码：\n\n\tprivate void ensureNotOnMainThread() {\n        final Looper looper = Looper.myLooper();\n        if (looper != null && looper == mContext.getMainLooper()) {\n            final IllegalStateException exception = new IllegalStateException(\n                    \"calling this from your main thread can lead to deadlock\");\n            Log.e(TAG, \"calling this from your main thread can lead to deadlock and/or ANRs\",\n                    exception);\n            if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.FROYO) {\n                throw exception;\n            }\n        }\n    }\n\n跟踪到`FutureTask`的`get`方法里，这里返回父类的一个Object实例：`outcome`存放我们想要的结果对象。\n\n在`get`里还有许多操作，比如判断线程执行的状态：\n- NEW         \n- COMPLETING  \n- NORMAL      \n- EXCEPTIONAL \n- CANCELLED   \n- INTERRUPTING\n- INTERRUPTED \n\n我看到在操作线程状态的时候，使用了该类：`private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();`，用来保证原子操作，确定一个线程是`RUNNER`,`WAITER`.\n这是一个JDK私有API，在Java9的时候可能移除，并使用`java.util.concurrent.LockSupport`实现。下面摘抄一段说明：\n\n> 原子访问是`sun.misc.Unsafe`被广泛应用的特性之一，特性包括简单的put、get操作(带有volatile语义或不带有volatile语义)以及比较并交换(compare and swap，CAS)操作。\n\t\n##### AmsTask的内部类-Response #####\n\nAmsTask中有一个public的Response的引用。\n\n操作一：`onResult`\n\n> 响应有结果，跳转至用户提供的Activity，或是重试，再次调用`doWork()`，否则把响应数据bundle设置回父类的`outcome`里\n\n操作二：`onError`\n\n> 取消线程的执行\n\n##### 内部类-BaseFutureTask #####\n\n可以看到这是一个抽象类，我们只要知道什么是需要子类实现的，什么是已经实现的。\n\n\t protected void postRunnableToHandler(Runnable runnable) {\n            Handler handler = (mHandler == null) ? mMainHandler : mHandler;\n            handler.post(runnable);\n        }\n\n把Runnable加入消息队列，可以当前线程的handler执行。\n\n`abstract void doWork()`  由函数对象来具体实现操作\n`abstract T bundleToResult(Bundle bundle)` 由函数对象来具体实现操作\n\n##### BaseFutureTask的内部类-Response #####\n\n- onResult 调用外部类的`bundleToResult`\n- onError 中断线程，抛出异常\n\n##### 内部类-Future2Task #####\n\n* BaseFutureTask的子类，同时也是个抽象类，实现了`internalGetResult`，具体的贱`AmsTask$internalGetResult`\n\n##### 内部类-GetAuthTokenByTypeAndFeaturesTask #####\n\n`AmsTask`的子类，顾名思义，根据类型和特征获取授权令牌的任务。\n\n`doWork()`的作用：\n- 根据类型和特征尝试获取已授权账户\n- 未获取到账户，如果提示添加账户的activity为空，则把`KEY_ACCOUNT_NAME`,`KEY_ACCOUNT_TYPE`,`KEY_AUTHTOKEN`置为空，并返回\n- 未获取到账户，如果提示添加账户的activity不为空，调用`addAccount`方法，这是一个Future，可以中断和等待结果的子线程\n- 如果只获取到一个账户，获取AuthToken，放入响应\n- 如果获取到了多个账户，启动`android.accounts.ChooseAccountActivity`,选择一个后，获取AuthToken，放入响应\n\n#### 主要方法 ####\n\n##### sanitizeResult #####\n\n\t  public static Bundle sanitizeResult(Bundle result) {\n\t        if (result != null) {\n\t            if (result.containsKey(KEY_AUTHTOKEN)\n\t                    && !TextUtils.isEmpty(result.getString(KEY_AUTHTOKEN))) {\n\t                final Bundle newResult = new Bundle(result);\n\t                newResult.putString(KEY_AUTHTOKEN, \"<omitted for logging purposes>\");\n\t                return newResult;\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n如果返回的结果bundle中包含`KEY_AUTHTOKEN`，就把这个值变成“为了日志的目的而省略”，是对结果做一次“消毒”\n\n##### IAccountManager相关 #####\n\n- getPassword\n- setPassword\n- clearPassword\n- getUserData\n- setUserData\n- getAuthenticatorTypes：此处返回一个数组，一个账户可以有多重类型，不需要权限\n- getAuthenticatorTypesAsUser：需要权限，或者相同的用户\n- getAccounts：需要权限\n- getAccountsAsUser\n- getAccountsForPackage：调用者可用的账户列表\n- updateAppPermission：仅被系统页面调用，不包含于SDK中\n- getAuthTokenLabel：获取与认证者相关联的用户友好标签，返回一个Future\n- hasFeatures：需要权限，指定的账户是拥有指定的权限。可用在任意线程，但返回结果不可用于主线程。\n- getAccountsByTypeAndFeatures：需要权限，根据类型和功能获取账户列表\n- addAccount\n- addSharedAccount\n- addAccountExplicitly：直接添加一个账户。这个方法不会刷新最近一次的时间戳，需要主动`notifyAccountAuthenticated`。但是，如果该方法触发了`addAccount()`或者`addAccountAsUser`，就不需要刷新时间戳，可以自动刷新了。可在主线程调用此方法。需要API22以上。\n- notifyAccountAuthenticated：通知系统账户刚刚被授权。可被其他程序用来验证账户。只有在授权成功方可调用。主线程不安全的。\n- renameAccount：先移除已有的账户，再添加重命名后的账户。\n- getPreviousName：获取改名前的名字，可能返回null，主线程安全的。\n- removeAccount：如果有，就从AccountManager删除账户，不会从服务器上删除。API22之前调用需要权限。\n- removeAccountAsUser\n- invalidateAuthToken：从AccountManager的缓存中移除授权。API22之前需要权限。\n- peekAuthToken：从缓存中取授权令牌，如果没有，生成一个新的，不会链接服务器。\n- setAuthToken\n- getAuthToken\n- getAuthTokenByFeatures\n- blockingGetAuthToken：会阻塞，不要在主线程调用，API22之前需要权限\n- copyAccountToUser\n- confirmCredentialsAsUser：\n- updateCredentials\n- editProperties：提供一个用户修改授权设置的机会。\n- ensureNotOnMainThread：确保不在主线程\n- postToHandler\n- convertErrorToException\n- newChooseAccountIntent：提供给用户一个可选账户的列表\n\n#### DEMO ####\n\n[AccountManagerDemo](https://github.com/xusx1024/AccountManagerDemo)\n","slug":"android-system-service-Account-Manager","published":1,"updated":"2017-09-29T09:23:44.538Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1i400712sivmkq9va83","content":"<h4 id=\"前面\"><a href=\"#前面\" class=\"headerlink\" title=\"前面\"></a>前面</h4><p>以<code>AccountManager</code>为例，read the fucking code.</p>\n<h4 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h4><p>可以看到该类遵循Apache协议。也就是说允许商用，私用，分发，修改，专利授权，附件协议，作者不允许商标使用，不承担责任。</p>\n<p>详细的各种协议区分，请看：<a href=\"http://xusx1024.com/2017/08/22/license-introduce/\" target=\"_blank\" rel=\"external\">here</a></p>\n<h4 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h4><p>类所在的包：<code>package android.accounts;</code> </p>\n<ul>\n<li>AbstractAccountAuthenticator</li>\n<li>Account</li>\n<li>AccountAuthenticatorActivity</li>\n<li>AccountAuthenticatorResponse</li>\n<li>AccountManagerCallback</li>\n<li>AccountManagerFuture</li>\n<li>AccountsException</li>\n<li>AuthenticatorDescription</li>\n<li>AuthenticatorException</li>\n<li>NetworkErrorException</li>\n<li>OnAccountsUpdateListener</li>\n<li>OperationCanceledException</li>\n</ul>\n<h4 id=\"类说明\"><a href=\"#类说明\" class=\"headerlink\" title=\"类说明\"></a>类说明</h4><p>This class provides access to a centralized registry of the user’s online accounts.<br>The user enters credentials (username and password) once per account, granting applications access to online resources with “one-click” approval.</p>\n<p>此类提供了用户在线账户集中注册的访问。<br>用户为每个账户输入用户密码作为证书，准许应用通过一次授权访问在线资源。</p>\n<p></p><p>Different online services have different ways of handling accounts and authentication, so the account manager uses pluggable <em>authenticator</em> modules for different <em>account types</em>.<br>Authenticators (which may be written by third parties) handle the actual details of validating account credentials and storing account information.<br>For example, Google, Facebook, and Microsoft Exchange each have their own authenticator.</p>\n<p>不同的线上服务处理账户和认证有不同的方式，因此账户管理者为不同的账户类型应用可插拔的认证模块。<br>验证者(也许是第三方写入)处理具体的账户证书细节，并且存储账户信息。<br>例如：Google，Facebook,Microsoft Exchange有各自的验证者。</p>\n<p></p><p>Many servers support some notion[概念] of an <em>authentication token</em>, which can be used to authenticate a request to the server without sending the user’s actual password.<br>(Auth tokens are normally created with a separate request which does include the user’s credentials.)<br>AccountManager can generate auth tokens for applications, so the application doesn’t need to handle passwords directly.<br>Auth tokens are normally reusable and cached by AccountManager, but must be refreshed periodically[定期].<br>It’s the responsibility of applications to <em>invalidate</em> auth tokens when they stop working so the AccountManager knows it needs to regenerate them.</p>\n<p>许多服务支持认证令牌的概念，可以无需用户确切的密码，即可向服务端认证一个请求。<br>(授权令牌通常创建在包含用户证书的一个单独的请求里。)<br>账户管理者可以为应用生成授权令牌，因此应用无需直接操作密码。<br>授权令牌通常是可重用的并由账户管理者缓存，但必须定期刷新。<br>当授权令牌停止工作时，应用的职责是废止这些授权，账户管理者依此得知需要重新生成。</p>\n<p></p><p>Applications accessing a server normally go through these steps:</p>\n<ul><br><li>Get an instance of AccountManager using {@link #get(Context)}.<br><br></li><li>List the available accounts using {@link #getAccountsByType} or {@link #getAccountsByTypeAndFeatures}.<br>Normally applications will only be interested in accounts with one particular <em>type</em>, which identifies the authenticator.<br>Account <em>features</em> are used to identify particular account subtypes and capabilities[功能].<br>Both the account type and features are authenticator-specific strings, and must be known by the application in coordination with its preferred authenticators.<br><br></li><li>Select one or more of the available accounts, possibly by asking the user for their preference.<br>If no suitable accounts are available, {@link #addAccount} may be called to prompt the user to create an account of the appropriate type.<br><br></li><li><b>Important:</b> If the application is using a previously remembered account selection, it must make sure the account is still in the list of accounts returned by {@link #getAccountsByType}.  Requesting an auth token for an account no longer on the device results in an undefined failure.<br><br></li><li>Request an auth token for the selected account(s) using one of the {@link #getAuthToken} methods or related helpers.<br>Refer to the description of each method for exact usage and error handling details.<br><br></li><li>Make the request using the auth token.  The form of the auth token, the format of the request, and the protocol used are all specific to the service you are accessing.<br>The application may use whatever network and protocol libraries are useful.<br><br></li><li><b>Important:</b> If the request fails with an authentication error, it could be that a cached auth token is stale and no longer honored by the server.<br>The application must call {@link #invalidateAuthToken} to remove the token from the cache, otherwise requests will continue failing!<br>After invalidating the auth token, immediately go back to the “Request an auth token” step above.<br>If the process fails the second time, then it can be treated as a “genuine” authentication failure and the user notified or other appropriate actions taken.<br></li></ul>\n\n<p>应用访问服务一般有以下几个步骤：</p>\n<ul><br><li>使用<code>get(Context)</code>获取账户管理者的实例<br></li><li>使用<code>getAccountsByType</code>或者<code>getAccountsByTypeAndFeatures</code>列出可用的账户。<br>通常应用只会被一个特定类型所吸引，该类型可用于识别验证者。<br>账户特征用来识别特定的账户子类型和功能。<br>账户类型和特征是验证者特定的字符串，必须由应用程序与其首选验证着协调知道。<br></li><li>选一或多个可用账户，可能通过询问用户的偏好。<br>如果没有适合的账户可用，指示用户调用<code>addAccount</code>创建一个适当类型的账户。<br></li><li><b>重要：</b>如果应用程序正在使用以前记录的账户选择，一定要确保此账户仍在<code>getAccountsByType</code>返回的账户列表里。<br>为不再在设备上的账户请求授权令牌，会导致未定义的错误。<br></li><li>为选择的账户请求授权令牌使用<code>getAuthToken</code>方法，或者相关的帮助者。<br>参考各个方法的描述，以确定用例使用、错误处理细节。<br></li><li>使用授权令牌发起请求。令牌的形式，请求的格式，使用的协议，这些都由你正在访问的服务指定。<br>应用程序可以使用任何网络和协议库都是可用的。<br></li><li><b>重要：</b>如果请求失败出现了授权错误，可能是缓存的令牌陈旧，不再由服务器兑现。<br>应用程序必须调用<code>invalidateAuthToken</code>去移除缓存的令牌，否则请求就会持续失败！<br>废止授权令牌之后，可以直接重复上面的步骤。<br>如果第二次操作也失败，就可以被对待为真实身份认证失败，用户需要被通知或采取别的行动.<br></li></ul>\n\n<p></p><p>Some AccountManager methods may need to interact with the user to prompt for credentials, present options, or ask the user to add an account.<br>The caller may choose whether to allow AccountManager to directly launch the necessary user interface and wait for the user, or to return an Intent which the caller may use to launch the interface, or (in some cases) to install a notification which the user can select at any time to launch the interface.<br>To have AccountManager launch the interface directly, the caller must supply the current foreground {@link Activity} context.</p>\n<p>一些账户管理者方法也许需要与用户交互来提示凭据，呈现选项，或要求用户添加一个账户。<br>调用者可以选择允许账户管理者直接登录必要的用户接口并且等待用户返回，也可以返回一个可以用来登录用户接口的意图，也可以展示一个通知，用户可以在任意时间选择去登录该接口。<br>要让账户管理者直接登录接口，调用者必须提供当前前台活动的上下文。</p>\n<p></p><p>Many AccountManager methods take {@link AccountManagerCallback} and {@link Handler} as parameters.<br>These methods return immediately and run asynchronously.<br>If a callback is provided then {@link AccountManagerCallback#run} will be invoked on the Handler’s thread when the request completes, successfully or not.<br>The result is retrieved by calling {@link AccountManagerFuture#getResult()} on the {@link AccountManagerFuture} returned by the method (and also passed to the callback).<br>This method waits for the operation to complete (if necessary) and either returns the result or throws an exception if an error occurred during the operation.<br>To make the request synchronously, call {@link AccountManagerFuture#getResult()} immediately on receiving the future from the method; no callback need be supplied.</p>\n<p></p><p>许多账户管理者持有<code>AccountManagerCallback</code>和<code>Handler</code>实例作为参数。<br>这些方法会异步执行并且立即返回。<br>如果一个回调被提供，在请求完成，成功或失败时，<code>AccountManagerCallback</code>将会在Handler的线程中被调用。<br>结果检索调用的方法是<code>AccountManagerFuture#getResult()</code>。<br>如果有必要，此方法等待操作的完成并且无论是返回结果或是在操作过程中产生错误并抛出异常。<br>为了异步执行请求，在接受到方法的未来时，直接调用<code>AccountManagerFuture#getResult()</code>；不需要提供回调。</p>\n<p></p><p>Requests which may block, including {@link AccountManagerFuture#getResult()}, must never be called on the application’s main event thread.<br>These operations throw {@link IllegalStateException} if they are used on the main thread.</p>\n<p>请求也许会阻塞，包括<code>AccountManagerFuture#getResult()</code>,绝对禁止在应用程序的主线程调用。<br>否则，这些操作会抛出<code>IllegalStateException</code>异常。</p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><h5 id=\"静态常量\"><a href=\"#静态常量\" class=\"headerlink\" title=\"静态常量\"></a>静态常量</h5><ul>\n<li><code>ERROR_CODE_REMOTE_EXCEPTION</code>:远程异常</li>\n<li><code>ERROR_CODE_NETWORK_ERROR</code>:网络错误</li>\n<li><code>ERROR_CODE_CANCELED</code>:取消</li>\n<li><code>ERROR_CODE_INVALID_RESPONSE</code>:无效的响应</li>\n<li><code>ERROR_CODE_UNSUPPORTED_OPERATION</code>:不支持的操作</li>\n<li><code>ERROR_CODE_BAD_ARGUMENTS</code>:错误的参数</li>\n<li><code>ERROR_CODE_BAD_REQUEST</code>:错误的请求</li>\n<li><code>ERROR_CODE_BAD_AUTHENTICATION</code>:错误的授权</li>\n<li><code>ERROR_CODE_BAD_AUTHENTICATION</code>:错误的已注册用户</li>\n<li><code>ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE</code>:当前账户类型管理失效错误</li>\n<li><code>KEY_ACCOUNT_NAME</code>:传值常量键，用于获取账户名</li>\n<li><code>KEY_ACCOUNT_TYPE</code>:传值常量键，用于获取账户类型值</li>\n<li><code>KEY_AUTHTOKEN</code>:传值常量键，用于获取授权令牌</li>\n<li><code>KEY_INTENT</code>:传值常量键，用于启动相关的用户接口页面</li>\n<li><code>KEY_PASSWORD</code>:传值常量键，用于获取密码</li>\n<li><code>KEY_ACCOUNTS</code>:传值常量键，用于获取账户</li>\n<li><code>KEY_ACCOUNT_AUTHENTICATOR_RESPONSE</code>:传值常量键，用于获取账户授权响应</li>\n<li><code>KEY_ACCOUNT_MANAGER_RESPONSE</code>:传值常量键，用于获取账户管理者响应</li>\n<li><code>KEY_AUTHENTICATOR_TYPES</code>:传值常量键，用于获取授权类型</li>\n<li><code>KEY_AUTH_FAILED_MESSAGE</code>:授权失败信息</li>\n<li><code>KEY_AUTH_TOKEN_LABEL</code>:授权令牌标签</li>\n<li><code>KEY_BOOLEAN_RESULT</code>:结果布尔值</li>\n<li><code>KEY_ERROR_CODE</code>:错误码</li>\n<li><code>KEY_ERROR_MESSAGE</code>:错误消息</li>\n<li><code>KEY_USERDATA</code>:用户数据</li>\n<li><code>KEY_LAST_AUTHENTICATED_TIME</code>:上次授权时间</li>\n<li><code>KEY_CALLER_UID</code>:调用者的UID</li>\n<li><code>KEY_CALLER_PID</code>:调用者的PID</li>\n<li><code>KEY_ANDROID_PACKAGE_NAME</code>:Android包名</li>\n<li><code>KEY_NOTIFY_ON_FAILURE</code>:授权失败时是否提示，boolean值</li>\n<li><code>ACTION_AUTHENTICATOR_INTENT</code>:<code>android.accounts.AccountAuthenticator</code></li>\n<li><code>AUTHENTICATOR_META_DATA_NAME</code>:<code>android.accounts.AccountAuthenticator</code></li>\n<li><code>AUTHENTICATOR_ATTRIBUTES_NAME</code>:授权者的name属性</li>\n</ul>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><pre><code>public AccountManager(Context context, IAccountManager service) {\n   mContext = context;\n   mService = service;\n   mMainHandler = new Handler(mContext.getMainLooper());\n}\n</code></pre><p>不会用到，获取一个账户管理者的实例，使用如下方法即可：</p>\n<pre><code>public static AccountManager get(Context context) {\n       if (context == null) throw new IllegalArgumentException(&quot;context is null&quot;);\n       return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);\n   }\n</code></pre><h4 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h4><p><code>public class AccountManager{ ... }</code></p>\n<p>public的类，没有实现任何接口。</p>\n<h5 id=\"内部类-AmsTask\"><a href=\"#内部类-AmsTask\" class=\"headerlink\" title=\"内部类-AmsTask\"></a>内部类-AmsTask</h5><p><code>private abstract class AmsTask extends FutureTask&lt;Bundle&gt; implements AccountManagerFuture&lt;Bundle&gt; { ... }</code></p>\n<p>看类修饰符：</p>\n<ul>\n<li>abstract ： 说明该类是一个模板类，必定有抽象方法，需要被子类化，实现具体的操作，</li>\n<li>private：子类化应该是在外部类中<br>符合Java编码原则：使用函数对象代替策略。使类和成员的可访问性最小化。</li>\n</ul>\n<p>该类继承自一个可取消的异步计算，实现了一个处理计算结果的回调。</p>\n<p>发现<code>AccountManagerFuture</code> 和<code>Future</code>两个接口的行为是一样的，一个在<code>android.accounts</code>里，另一个在<code>java.util.concurrent</code>.</p>\n<p>AmsTask的构造方法为public，由于父类<code>FutureTask</code>的构造，必须要求传递<code>Callable</code>实例，如果没有这个实例，就会<code>NullPointerException</code>，所以直接在此截断抛出了。<br>因此，虽然传递了Callable，却禁止使用了，使用的还是Future。</p>\n<pre><code>public AmsTask(Activity activity, Handler handler, AccountManagerCallback&lt;Bundle&gt; callback) {\n      super(new Callable&lt;Bundle&gt;() {\n          public Bundle call() throws Exception {\n              throw new IllegalStateException(&quot;this should never be called&quot;);\n          }\n      });\n\n      mHandler = handler;\n      mCallback = callback;\n      mActivity = activity;\n      mResponse = new Response();\n  }\n</code></pre><ul>\n<li>abstract void doWork()  由函数对象来具体实现操作</li>\n<li>AccountManagerFuture<bundle> start() 开始执行<code>doWork()</code></bundle></li>\n<li>void set(Bundle bundle) 父类方法，把结果设置给指定的Future，除非Future已经有结果或者已经被取消</li>\n<li>Bundle getResult()、Bundle getResult(long timeout, TimeUnit unit)、Bundle internalGetResult(Long timeout, TimeUnit unit) 获取处理结果<blockquote>\n<p>getResult最后都调用了<code>internalGetResult</code>方法。大概流程如下：</p>\n<ul>\n<li>判断线程是否执行结束</li>\n<li>判断时间是否为null或已结束</li>\n<li>获取结果</li>\n<li>异常后取消线程执行</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>确保当前线程不在主线程的代码：</p>\n<pre><code>private void ensureNotOnMainThread() {\n    final Looper looper = Looper.myLooper();\n    if (looper != null &amp;&amp; looper == mContext.getMainLooper()) {\n        final IllegalStateException exception = new IllegalStateException(\n                &quot;calling this from your main thread can lead to deadlock&quot;);\n        Log.e(TAG, &quot;calling this from your main thread can lead to deadlock and/or ANRs&quot;,\n                exception);\n        if (mContext.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.FROYO) {\n            throw exception;\n        }\n    }\n}\n</code></pre><p>跟踪到<code>FutureTask</code>的<code>get</code>方法里，这里返回父类的一个Object实例：<code>outcome</code>存放我们想要的结果对象。</p>\n<p>在<code>get</code>里还有许多操作，比如判断线程执行的状态：</p>\n<ul>\n<li>NEW         </li>\n<li>COMPLETING  </li>\n<li>NORMAL      </li>\n<li>EXCEPTIONAL </li>\n<li>CANCELLED   </li>\n<li>INTERRUPTING</li>\n<li>INTERRUPTED </li>\n</ul>\n<p>我看到在操作线程状态的时候，使用了该类：<code>private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</code>，用来保证原子操作，确定一个线程是<code>RUNNER</code>,<code>WAITER</code>.<br>这是一个JDK私有API，在Java9的时候可能移除，并使用<code>java.util.concurrent.LockSupport</code>实现。下面摘抄一段说明：</p>\n<blockquote>\n<p>原子访问是<code>sun.misc.Unsafe</code>被广泛应用的特性之一，特性包括简单的put、get操作(带有volatile语义或不带有volatile语义)以及比较并交换(compare and swap，CAS)操作。</p>\n</blockquote>\n<h5 id=\"AmsTask的内部类-Response\"><a href=\"#AmsTask的内部类-Response\" class=\"headerlink\" title=\"AmsTask的内部类-Response\"></a>AmsTask的内部类-Response</h5><p>AmsTask中有一个public的Response的引用。</p>\n<p>操作一：<code>onResult</code></p>\n<blockquote>\n<p>响应有结果，跳转至用户提供的Activity，或是重试，再次调用<code>doWork()</code>，否则把响应数据bundle设置回父类的<code>outcome</code>里</p>\n</blockquote>\n<p>操作二：<code>onError</code></p>\n<blockquote>\n<p>取消线程的执行</p>\n</blockquote>\n<h5 id=\"内部类-BaseFutureTask\"><a href=\"#内部类-BaseFutureTask\" class=\"headerlink\" title=\"内部类-BaseFutureTask\"></a>内部类-BaseFutureTask</h5><p>可以看到这是一个抽象类，我们只要知道什么是需要子类实现的，什么是已经实现的。</p>\n<pre><code>protected void postRunnableToHandler(Runnable runnable) {\n       Handler handler = (mHandler == null) ? mMainHandler : mHandler;\n       handler.post(runnable);\n   }\n</code></pre><p>把Runnable加入消息队列，可以当前线程的handler执行。</p>\n<p><code>abstract void doWork()</code>  由函数对象来具体实现操作<br><code>abstract T bundleToResult(Bundle bundle)</code> 由函数对象来具体实现操作</p>\n<h5 id=\"BaseFutureTask的内部类-Response\"><a href=\"#BaseFutureTask的内部类-Response\" class=\"headerlink\" title=\"BaseFutureTask的内部类-Response\"></a>BaseFutureTask的内部类-Response</h5><ul>\n<li>onResult 调用外部类的<code>bundleToResult</code></li>\n<li>onError 中断线程，抛出异常</li>\n</ul>\n<h5 id=\"内部类-Future2Task\"><a href=\"#内部类-Future2Task\" class=\"headerlink\" title=\"内部类-Future2Task\"></a>内部类-Future2Task</h5><ul>\n<li>BaseFutureTask的子类，同时也是个抽象类，实现了<code>internalGetResult</code>，具体的贱<code>AmsTask$internalGetResult</code></li>\n</ul>\n<h5 id=\"内部类-GetAuthTokenByTypeAndFeaturesTask\"><a href=\"#内部类-GetAuthTokenByTypeAndFeaturesTask\" class=\"headerlink\" title=\"内部类-GetAuthTokenByTypeAndFeaturesTask\"></a>内部类-GetAuthTokenByTypeAndFeaturesTask</h5><p><code>AmsTask</code>的子类，顾名思义，根据类型和特征获取授权令牌的任务。</p>\n<p><code>doWork()</code>的作用：</p>\n<ul>\n<li>根据类型和特征尝试获取已授权账户</li>\n<li>未获取到账户，如果提示添加账户的activity为空，则把<code>KEY_ACCOUNT_NAME</code>,<code>KEY_ACCOUNT_TYPE</code>,<code>KEY_AUTHTOKEN</code>置为空，并返回</li>\n<li>未获取到账户，如果提示添加账户的activity不为空，调用<code>addAccount</code>方法，这是一个Future，可以中断和等待结果的子线程</li>\n<li>如果只获取到一个账户，获取AuthToken，放入响应</li>\n<li>如果获取到了多个账户，启动<code>android.accounts.ChooseAccountActivity</code>,选择一个后，获取AuthToken，放入响应</li>\n</ul>\n<h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><h5 id=\"sanitizeResult\"><a href=\"#sanitizeResult\" class=\"headerlink\" title=\"sanitizeResult\"></a>sanitizeResult</h5><pre><code>public static Bundle sanitizeResult(Bundle result) {\n      if (result != null) {\n          if (result.containsKey(KEY_AUTHTOKEN)\n                  &amp;&amp; !TextUtils.isEmpty(result.getString(KEY_AUTHTOKEN))) {\n              final Bundle newResult = new Bundle(result);\n              newResult.putString(KEY_AUTHTOKEN, &quot;&lt;omitted for logging purposes&gt;&quot;);\n              return newResult;\n          }\n      }\n      return result;\n  }\n</code></pre><p>如果返回的结果bundle中包含<code>KEY_AUTHTOKEN</code>，就把这个值变成“为了日志的目的而省略”，是对结果做一次“消毒”</p>\n<h5 id=\"IAccountManager相关\"><a href=\"#IAccountManager相关\" class=\"headerlink\" title=\"IAccountManager相关\"></a>IAccountManager相关</h5><ul>\n<li>getPassword</li>\n<li>setPassword</li>\n<li>clearPassword</li>\n<li>getUserData</li>\n<li>setUserData</li>\n<li>getAuthenticatorTypes：此处返回一个数组，一个账户可以有多重类型，不需要权限</li>\n<li>getAuthenticatorTypesAsUser：需要权限，或者相同的用户</li>\n<li>getAccounts：需要权限</li>\n<li>getAccountsAsUser</li>\n<li>getAccountsForPackage：调用者可用的账户列表</li>\n<li>updateAppPermission：仅被系统页面调用，不包含于SDK中</li>\n<li>getAuthTokenLabel：获取与认证者相关联的用户友好标签，返回一个Future</li>\n<li>hasFeatures：需要权限，指定的账户是拥有指定的权限。可用在任意线程，但返回结果不可用于主线程。</li>\n<li>getAccountsByTypeAndFeatures：需要权限，根据类型和功能获取账户列表</li>\n<li>addAccount</li>\n<li>addSharedAccount</li>\n<li>addAccountExplicitly：直接添加一个账户。这个方法不会刷新最近一次的时间戳，需要主动<code>notifyAccountAuthenticated</code>。但是，如果该方法触发了<code>addAccount()</code>或者<code>addAccountAsUser</code>，就不需要刷新时间戳，可以自动刷新了。可在主线程调用此方法。需要API22以上。</li>\n<li>notifyAccountAuthenticated：通知系统账户刚刚被授权。可被其他程序用来验证账户。只有在授权成功方可调用。主线程不安全的。</li>\n<li>renameAccount：先移除已有的账户，再添加重命名后的账户。</li>\n<li>getPreviousName：获取改名前的名字，可能返回null，主线程安全的。</li>\n<li>removeAccount：如果有，就从AccountManager删除账户，不会从服务器上删除。API22之前调用需要权限。</li>\n<li>removeAccountAsUser</li>\n<li>invalidateAuthToken：从AccountManager的缓存中移除授权。API22之前需要权限。</li>\n<li>peekAuthToken：从缓存中取授权令牌，如果没有，生成一个新的，不会链接服务器。</li>\n<li>setAuthToken</li>\n<li>getAuthToken</li>\n<li>getAuthTokenByFeatures</li>\n<li>blockingGetAuthToken：会阻塞，不要在主线程调用，API22之前需要权限</li>\n<li>copyAccountToUser</li>\n<li>confirmCredentialsAsUser：</li>\n<li>updateCredentials</li>\n<li>editProperties：提供一个用户修改授权设置的机会。</li>\n<li>ensureNotOnMainThread：确保不在主线程</li>\n<li>postToHandler</li>\n<li>convertErrorToException</li>\n<li>newChooseAccountIntent：提供给用户一个可选账户的列表</li>\n</ul>\n<h4 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h4><p><a href=\"https://github.com/xusx1024/AccountManagerDemo\" target=\"_blank\" rel=\"external\">AccountManagerDemo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前面\"><a href=\"#前面\" class=\"headerlink\" title=\"前面\"></a>前面</h4><p>以<code>AccountManager</code>为例，read the fucking code.</p>\n<h4 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h4><p>可以看到该类遵循Apache协议。也就是说允许商用，私用，分发，修改，专利授权，附件协议，作者不允许商标使用，不承担责任。</p>\n<p>详细的各种协议区分，请看：<a href=\"http://xusx1024.com/2017/08/22/license-introduce/\" target=\"_blank\" rel=\"external\">here</a></p>\n<h4 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h4><p>类所在的包：<code>package android.accounts;</code> </p>\n<ul>\n<li>AbstractAccountAuthenticator</li>\n<li>Account</li>\n<li>AccountAuthenticatorActivity</li>\n<li>AccountAuthenticatorResponse</li>\n<li>AccountManagerCallback</li>\n<li>AccountManagerFuture</li>\n<li>AccountsException</li>\n<li>AuthenticatorDescription</li>\n<li>AuthenticatorException</li>\n<li>NetworkErrorException</li>\n<li>OnAccountsUpdateListener</li>\n<li>OperationCanceledException</li>\n</ul>\n<h4 id=\"类说明\"><a href=\"#类说明\" class=\"headerlink\" title=\"类说明\"></a>类说明</h4><p>This class provides access to a centralized registry of the user’s online accounts.<br>The user enters credentials (username and password) once per account, granting applications access to online resources with “one-click” approval.</p>\n<p>此类提供了用户在线账户集中注册的访问。<br>用户为每个账户输入用户密码作为证书，准许应用通过一次授权访问在线资源。</p>\n<p></p><p>Different online services have different ways of handling accounts and authentication, so the account manager uses pluggable <em>authenticator</em> modules for different <em>account types</em>.<br>Authenticators (which may be written by third parties) handle the actual details of validating account credentials and storing account information.<br>For example, Google, Facebook, and Microsoft Exchange each have their own authenticator.</p>\n<p>不同的线上服务处理账户和认证有不同的方式，因此账户管理者为不同的账户类型应用可插拔的认证模块。<br>验证者(也许是第三方写入)处理具体的账户证书细节，并且存储账户信息。<br>例如：Google，Facebook,Microsoft Exchange有各自的验证者。</p>\n<p></p><p>Many servers support some notion[概念] of an <em>authentication token</em>, which can be used to authenticate a request to the server without sending the user’s actual password.<br>(Auth tokens are normally created with a separate request which does include the user’s credentials.)<br>AccountManager can generate auth tokens for applications, so the application doesn’t need to handle passwords directly.<br>Auth tokens are normally reusable and cached by AccountManager, but must be refreshed periodically[定期].<br>It’s the responsibility of applications to <em>invalidate</em> auth tokens when they stop working so the AccountManager knows it needs to regenerate them.</p>\n<p>许多服务支持认证令牌的概念，可以无需用户确切的密码，即可向服务端认证一个请求。<br>(授权令牌通常创建在包含用户证书的一个单独的请求里。)<br>账户管理者可以为应用生成授权令牌，因此应用无需直接操作密码。<br>授权令牌通常是可重用的并由账户管理者缓存，但必须定期刷新。<br>当授权令牌停止工作时，应用的职责是废止这些授权，账户管理者依此得知需要重新生成。</p>\n<p></p><p>Applications accessing a server normally go through these steps:</p>\n<ul><br><li>Get an instance of AccountManager using {@link #get(Context)}.<br><br></li><li>List the available accounts using {@link #getAccountsByType} or {@link #getAccountsByTypeAndFeatures}.<br>Normally applications will only be interested in accounts with one particular <em>type</em>, which identifies the authenticator.<br>Account <em>features</em> are used to identify particular account subtypes and capabilities[功能].<br>Both the account type and features are authenticator-specific strings, and must be known by the application in coordination with its preferred authenticators.<br><br></li><li>Select one or more of the available accounts, possibly by asking the user for their preference.<br>If no suitable accounts are available, {@link #addAccount} may be called to prompt the user to create an account of the appropriate type.<br><br></li><li><b>Important:</b> If the application is using a previously remembered account selection, it must make sure the account is still in the list of accounts returned by {@link #getAccountsByType}.  Requesting an auth token for an account no longer on the device results in an undefined failure.<br><br></li><li>Request an auth token for the selected account(s) using one of the {@link #getAuthToken} methods or related helpers.<br>Refer to the description of each method for exact usage and error handling details.<br><br></li><li>Make the request using the auth token.  The form of the auth token, the format of the request, and the protocol used are all specific to the service you are accessing.<br>The application may use whatever network and protocol libraries are useful.<br><br></li><li><b>Important:</b> If the request fails with an authentication error, it could be that a cached auth token is stale and no longer honored by the server.<br>The application must call {@link #invalidateAuthToken} to remove the token from the cache, otherwise requests will continue failing!<br>After invalidating the auth token, immediately go back to the “Request an auth token” step above.<br>If the process fails the second time, then it can be treated as a “genuine” authentication failure and the user notified or other appropriate actions taken.<br></li></ul>\n\n<p>应用访问服务一般有以下几个步骤：</p>\n<ul><br><li>使用<code>get(Context)</code>获取账户管理者的实例<br></li><li>使用<code>getAccountsByType</code>或者<code>getAccountsByTypeAndFeatures</code>列出可用的账户。<br>通常应用只会被一个特定类型所吸引，该类型可用于识别验证者。<br>账户特征用来识别特定的账户子类型和功能。<br>账户类型和特征是验证者特定的字符串，必须由应用程序与其首选验证着协调知道。<br></li><li>选一或多个可用账户，可能通过询问用户的偏好。<br>如果没有适合的账户可用，指示用户调用<code>addAccount</code>创建一个适当类型的账户。<br></li><li><b>重要：</b>如果应用程序正在使用以前记录的账户选择，一定要确保此账户仍在<code>getAccountsByType</code>返回的账户列表里。<br>为不再在设备上的账户请求授权令牌，会导致未定义的错误。<br></li><li>为选择的账户请求授权令牌使用<code>getAuthToken</code>方法，或者相关的帮助者。<br>参考各个方法的描述，以确定用例使用、错误处理细节。<br></li><li>使用授权令牌发起请求。令牌的形式，请求的格式，使用的协议，这些都由你正在访问的服务指定。<br>应用程序可以使用任何网络和协议库都是可用的。<br></li><li><b>重要：</b>如果请求失败出现了授权错误，可能是缓存的令牌陈旧，不再由服务器兑现。<br>应用程序必须调用<code>invalidateAuthToken</code>去移除缓存的令牌，否则请求就会持续失败！<br>废止授权令牌之后，可以直接重复上面的步骤。<br>如果第二次操作也失败，就可以被对待为真实身份认证失败，用户需要被通知或采取别的行动.<br></li></ul>\n\n<p></p><p>Some AccountManager methods may need to interact with the user to prompt for credentials, present options, or ask the user to add an account.<br>The caller may choose whether to allow AccountManager to directly launch the necessary user interface and wait for the user, or to return an Intent which the caller may use to launch the interface, or (in some cases) to install a notification which the user can select at any time to launch the interface.<br>To have AccountManager launch the interface directly, the caller must supply the current foreground {@link Activity} context.</p>\n<p>一些账户管理者方法也许需要与用户交互来提示凭据，呈现选项，或要求用户添加一个账户。<br>调用者可以选择允许账户管理者直接登录必要的用户接口并且等待用户返回，也可以返回一个可以用来登录用户接口的意图，也可以展示一个通知，用户可以在任意时间选择去登录该接口。<br>要让账户管理者直接登录接口，调用者必须提供当前前台活动的上下文。</p>\n<p></p><p>Many AccountManager methods take {@link AccountManagerCallback} and {@link Handler} as parameters.<br>These methods return immediately and run asynchronously.<br>If a callback is provided then {@link AccountManagerCallback#run} will be invoked on the Handler’s thread when the request completes, successfully or not.<br>The result is retrieved by calling {@link AccountManagerFuture#getResult()} on the {@link AccountManagerFuture} returned by the method (and also passed to the callback).<br>This method waits for the operation to complete (if necessary) and either returns the result or throws an exception if an error occurred during the operation.<br>To make the request synchronously, call {@link AccountManagerFuture#getResult()} immediately on receiving the future from the method; no callback need be supplied.</p>\n<p></p><p>许多账户管理者持有<code>AccountManagerCallback</code>和<code>Handler</code>实例作为参数。<br>这些方法会异步执行并且立即返回。<br>如果一个回调被提供，在请求完成，成功或失败时，<code>AccountManagerCallback</code>将会在Handler的线程中被调用。<br>结果检索调用的方法是<code>AccountManagerFuture#getResult()</code>。<br>如果有必要，此方法等待操作的完成并且无论是返回结果或是在操作过程中产生错误并抛出异常。<br>为了异步执行请求，在接受到方法的未来时，直接调用<code>AccountManagerFuture#getResult()</code>；不需要提供回调。</p>\n<p></p><p>Requests which may block, including {@link AccountManagerFuture#getResult()}, must never be called on the application’s main event thread.<br>These operations throw {@link IllegalStateException} if they are used on the main thread.</p>\n<p>请求也许会阻塞，包括<code>AccountManagerFuture#getResult()</code>,绝对禁止在应用程序的主线程调用。<br>否则，这些操作会抛出<code>IllegalStateException</code>异常。</p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><h5 id=\"静态常量\"><a href=\"#静态常量\" class=\"headerlink\" title=\"静态常量\"></a>静态常量</h5><ul>\n<li><code>ERROR_CODE_REMOTE_EXCEPTION</code>:远程异常</li>\n<li><code>ERROR_CODE_NETWORK_ERROR</code>:网络错误</li>\n<li><code>ERROR_CODE_CANCELED</code>:取消</li>\n<li><code>ERROR_CODE_INVALID_RESPONSE</code>:无效的响应</li>\n<li><code>ERROR_CODE_UNSUPPORTED_OPERATION</code>:不支持的操作</li>\n<li><code>ERROR_CODE_BAD_ARGUMENTS</code>:错误的参数</li>\n<li><code>ERROR_CODE_BAD_REQUEST</code>:错误的请求</li>\n<li><code>ERROR_CODE_BAD_AUTHENTICATION</code>:错误的授权</li>\n<li><code>ERROR_CODE_BAD_AUTHENTICATION</code>:错误的已注册用户</li>\n<li><code>ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE</code>:当前账户类型管理失效错误</li>\n<li><code>KEY_ACCOUNT_NAME</code>:传值常量键，用于获取账户名</li>\n<li><code>KEY_ACCOUNT_TYPE</code>:传值常量键，用于获取账户类型值</li>\n<li><code>KEY_AUTHTOKEN</code>:传值常量键，用于获取授权令牌</li>\n<li><code>KEY_INTENT</code>:传值常量键，用于启动相关的用户接口页面</li>\n<li><code>KEY_PASSWORD</code>:传值常量键，用于获取密码</li>\n<li><code>KEY_ACCOUNTS</code>:传值常量键，用于获取账户</li>\n<li><code>KEY_ACCOUNT_AUTHENTICATOR_RESPONSE</code>:传值常量键，用于获取账户授权响应</li>\n<li><code>KEY_ACCOUNT_MANAGER_RESPONSE</code>:传值常量键，用于获取账户管理者响应</li>\n<li><code>KEY_AUTHENTICATOR_TYPES</code>:传值常量键，用于获取授权类型</li>\n<li><code>KEY_AUTH_FAILED_MESSAGE</code>:授权失败信息</li>\n<li><code>KEY_AUTH_TOKEN_LABEL</code>:授权令牌标签</li>\n<li><code>KEY_BOOLEAN_RESULT</code>:结果布尔值</li>\n<li><code>KEY_ERROR_CODE</code>:错误码</li>\n<li><code>KEY_ERROR_MESSAGE</code>:错误消息</li>\n<li><code>KEY_USERDATA</code>:用户数据</li>\n<li><code>KEY_LAST_AUTHENTICATED_TIME</code>:上次授权时间</li>\n<li><code>KEY_CALLER_UID</code>:调用者的UID</li>\n<li><code>KEY_CALLER_PID</code>:调用者的PID</li>\n<li><code>KEY_ANDROID_PACKAGE_NAME</code>:Android包名</li>\n<li><code>KEY_NOTIFY_ON_FAILURE</code>:授权失败时是否提示，boolean值</li>\n<li><code>ACTION_AUTHENTICATOR_INTENT</code>:<code>android.accounts.AccountAuthenticator</code></li>\n<li><code>AUTHENTICATOR_META_DATA_NAME</code>:<code>android.accounts.AccountAuthenticator</code></li>\n<li><code>AUTHENTICATOR_ATTRIBUTES_NAME</code>:授权者的name属性</li>\n</ul>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><pre><code>public AccountManager(Context context, IAccountManager service) {\n   mContext = context;\n   mService = service;\n   mMainHandler = new Handler(mContext.getMainLooper());\n}\n</code></pre><p>不会用到，获取一个账户管理者的实例，使用如下方法即可：</p>\n<pre><code>public static AccountManager get(Context context) {\n       if (context == null) throw new IllegalArgumentException(&quot;context is null&quot;);\n       return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);\n   }\n</code></pre><h4 id=\"类结构\"><a href=\"#类结构\" class=\"headerlink\" title=\"类结构\"></a>类结构</h4><p><code>public class AccountManager{ ... }</code></p>\n<p>public的类，没有实现任何接口。</p>\n<h5 id=\"内部类-AmsTask\"><a href=\"#内部类-AmsTask\" class=\"headerlink\" title=\"内部类-AmsTask\"></a>内部类-AmsTask</h5><p><code>private abstract class AmsTask extends FutureTask&lt;Bundle&gt; implements AccountManagerFuture&lt;Bundle&gt; { ... }</code></p>\n<p>看类修饰符：</p>\n<ul>\n<li>abstract ： 说明该类是一个模板类，必定有抽象方法，需要被子类化，实现具体的操作，</li>\n<li>private：子类化应该是在外部类中<br>符合Java编码原则：使用函数对象代替策略。使类和成员的可访问性最小化。</li>\n</ul>\n<p>该类继承自一个可取消的异步计算，实现了一个处理计算结果的回调。</p>\n<p>发现<code>AccountManagerFuture</code> 和<code>Future</code>两个接口的行为是一样的，一个在<code>android.accounts</code>里，另一个在<code>java.util.concurrent</code>.</p>\n<p>AmsTask的构造方法为public，由于父类<code>FutureTask</code>的构造，必须要求传递<code>Callable</code>实例，如果没有这个实例，就会<code>NullPointerException</code>，所以直接在此截断抛出了。<br>因此，虽然传递了Callable，却禁止使用了，使用的还是Future。</p>\n<pre><code>public AmsTask(Activity activity, Handler handler, AccountManagerCallback&lt;Bundle&gt; callback) {\n      super(new Callable&lt;Bundle&gt;() {\n          public Bundle call() throws Exception {\n              throw new IllegalStateException(&quot;this should never be called&quot;);\n          }\n      });\n\n      mHandler = handler;\n      mCallback = callback;\n      mActivity = activity;\n      mResponse = new Response();\n  }\n</code></pre><ul>\n<li>abstract void doWork()  由函数对象来具体实现操作</li>\n<li>AccountManagerFuture<bundle> start() 开始执行<code>doWork()</code></bundle></li>\n<li>void set(Bundle bundle) 父类方法，把结果设置给指定的Future，除非Future已经有结果或者已经被取消</li>\n<li>Bundle getResult()、Bundle getResult(long timeout, TimeUnit unit)、Bundle internalGetResult(Long timeout, TimeUnit unit) 获取处理结果<blockquote>\n<p>getResult最后都调用了<code>internalGetResult</code>方法。大概流程如下：</p>\n<ul>\n<li>判断线程是否执行结束</li>\n<li>判断时间是否为null或已结束</li>\n<li>获取结果</li>\n<li>异常后取消线程执行</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>确保当前线程不在主线程的代码：</p>\n<pre><code>private void ensureNotOnMainThread() {\n    final Looper looper = Looper.myLooper();\n    if (looper != null &amp;&amp; looper == mContext.getMainLooper()) {\n        final IllegalStateException exception = new IllegalStateException(\n                &quot;calling this from your main thread can lead to deadlock&quot;);\n        Log.e(TAG, &quot;calling this from your main thread can lead to deadlock and/or ANRs&quot;,\n                exception);\n        if (mContext.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.FROYO) {\n            throw exception;\n        }\n    }\n}\n</code></pre><p>跟踪到<code>FutureTask</code>的<code>get</code>方法里，这里返回父类的一个Object实例：<code>outcome</code>存放我们想要的结果对象。</p>\n<p>在<code>get</code>里还有许多操作，比如判断线程执行的状态：</p>\n<ul>\n<li>NEW         </li>\n<li>COMPLETING  </li>\n<li>NORMAL      </li>\n<li>EXCEPTIONAL </li>\n<li>CANCELLED   </li>\n<li>INTERRUPTING</li>\n<li>INTERRUPTED </li>\n</ul>\n<p>我看到在操作线程状态的时候，使用了该类：<code>private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();</code>，用来保证原子操作，确定一个线程是<code>RUNNER</code>,<code>WAITER</code>.<br>这是一个JDK私有API，在Java9的时候可能移除，并使用<code>java.util.concurrent.LockSupport</code>实现。下面摘抄一段说明：</p>\n<blockquote>\n<p>原子访问是<code>sun.misc.Unsafe</code>被广泛应用的特性之一，特性包括简单的put、get操作(带有volatile语义或不带有volatile语义)以及比较并交换(compare and swap，CAS)操作。</p>\n</blockquote>\n<h5 id=\"AmsTask的内部类-Response\"><a href=\"#AmsTask的内部类-Response\" class=\"headerlink\" title=\"AmsTask的内部类-Response\"></a>AmsTask的内部类-Response</h5><p>AmsTask中有一个public的Response的引用。</p>\n<p>操作一：<code>onResult</code></p>\n<blockquote>\n<p>响应有结果，跳转至用户提供的Activity，或是重试，再次调用<code>doWork()</code>，否则把响应数据bundle设置回父类的<code>outcome</code>里</p>\n</blockquote>\n<p>操作二：<code>onError</code></p>\n<blockquote>\n<p>取消线程的执行</p>\n</blockquote>\n<h5 id=\"内部类-BaseFutureTask\"><a href=\"#内部类-BaseFutureTask\" class=\"headerlink\" title=\"内部类-BaseFutureTask\"></a>内部类-BaseFutureTask</h5><p>可以看到这是一个抽象类，我们只要知道什么是需要子类实现的，什么是已经实现的。</p>\n<pre><code>protected void postRunnableToHandler(Runnable runnable) {\n       Handler handler = (mHandler == null) ? mMainHandler : mHandler;\n       handler.post(runnable);\n   }\n</code></pre><p>把Runnable加入消息队列，可以当前线程的handler执行。</p>\n<p><code>abstract void doWork()</code>  由函数对象来具体实现操作<br><code>abstract T bundleToResult(Bundle bundle)</code> 由函数对象来具体实现操作</p>\n<h5 id=\"BaseFutureTask的内部类-Response\"><a href=\"#BaseFutureTask的内部类-Response\" class=\"headerlink\" title=\"BaseFutureTask的内部类-Response\"></a>BaseFutureTask的内部类-Response</h5><ul>\n<li>onResult 调用外部类的<code>bundleToResult</code></li>\n<li>onError 中断线程，抛出异常</li>\n</ul>\n<h5 id=\"内部类-Future2Task\"><a href=\"#内部类-Future2Task\" class=\"headerlink\" title=\"内部类-Future2Task\"></a>内部类-Future2Task</h5><ul>\n<li>BaseFutureTask的子类，同时也是个抽象类，实现了<code>internalGetResult</code>，具体的贱<code>AmsTask$internalGetResult</code></li>\n</ul>\n<h5 id=\"内部类-GetAuthTokenByTypeAndFeaturesTask\"><a href=\"#内部类-GetAuthTokenByTypeAndFeaturesTask\" class=\"headerlink\" title=\"内部类-GetAuthTokenByTypeAndFeaturesTask\"></a>内部类-GetAuthTokenByTypeAndFeaturesTask</h5><p><code>AmsTask</code>的子类，顾名思义，根据类型和特征获取授权令牌的任务。</p>\n<p><code>doWork()</code>的作用：</p>\n<ul>\n<li>根据类型和特征尝试获取已授权账户</li>\n<li>未获取到账户，如果提示添加账户的activity为空，则把<code>KEY_ACCOUNT_NAME</code>,<code>KEY_ACCOUNT_TYPE</code>,<code>KEY_AUTHTOKEN</code>置为空，并返回</li>\n<li>未获取到账户，如果提示添加账户的activity不为空，调用<code>addAccount</code>方法，这是一个Future，可以中断和等待结果的子线程</li>\n<li>如果只获取到一个账户，获取AuthToken，放入响应</li>\n<li>如果获取到了多个账户，启动<code>android.accounts.ChooseAccountActivity</code>,选择一个后，获取AuthToken，放入响应</li>\n</ul>\n<h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><h5 id=\"sanitizeResult\"><a href=\"#sanitizeResult\" class=\"headerlink\" title=\"sanitizeResult\"></a>sanitizeResult</h5><pre><code>public static Bundle sanitizeResult(Bundle result) {\n      if (result != null) {\n          if (result.containsKey(KEY_AUTHTOKEN)\n                  &amp;&amp; !TextUtils.isEmpty(result.getString(KEY_AUTHTOKEN))) {\n              final Bundle newResult = new Bundle(result);\n              newResult.putString(KEY_AUTHTOKEN, &quot;&lt;omitted for logging purposes&gt;&quot;);\n              return newResult;\n          }\n      }\n      return result;\n  }\n</code></pre><p>如果返回的结果bundle中包含<code>KEY_AUTHTOKEN</code>，就把这个值变成“为了日志的目的而省略”，是对结果做一次“消毒”</p>\n<h5 id=\"IAccountManager相关\"><a href=\"#IAccountManager相关\" class=\"headerlink\" title=\"IAccountManager相关\"></a>IAccountManager相关</h5><ul>\n<li>getPassword</li>\n<li>setPassword</li>\n<li>clearPassword</li>\n<li>getUserData</li>\n<li>setUserData</li>\n<li>getAuthenticatorTypes：此处返回一个数组，一个账户可以有多重类型，不需要权限</li>\n<li>getAuthenticatorTypesAsUser：需要权限，或者相同的用户</li>\n<li>getAccounts：需要权限</li>\n<li>getAccountsAsUser</li>\n<li>getAccountsForPackage：调用者可用的账户列表</li>\n<li>updateAppPermission：仅被系统页面调用，不包含于SDK中</li>\n<li>getAuthTokenLabel：获取与认证者相关联的用户友好标签，返回一个Future</li>\n<li>hasFeatures：需要权限，指定的账户是拥有指定的权限。可用在任意线程，但返回结果不可用于主线程。</li>\n<li>getAccountsByTypeAndFeatures：需要权限，根据类型和功能获取账户列表</li>\n<li>addAccount</li>\n<li>addSharedAccount</li>\n<li>addAccountExplicitly：直接添加一个账户。这个方法不会刷新最近一次的时间戳，需要主动<code>notifyAccountAuthenticated</code>。但是，如果该方法触发了<code>addAccount()</code>或者<code>addAccountAsUser</code>，就不需要刷新时间戳，可以自动刷新了。可在主线程调用此方法。需要API22以上。</li>\n<li>notifyAccountAuthenticated：通知系统账户刚刚被授权。可被其他程序用来验证账户。只有在授权成功方可调用。主线程不安全的。</li>\n<li>renameAccount：先移除已有的账户，再添加重命名后的账户。</li>\n<li>getPreviousName：获取改名前的名字，可能返回null，主线程安全的。</li>\n<li>removeAccount：如果有，就从AccountManager删除账户，不会从服务器上删除。API22之前调用需要权限。</li>\n<li>removeAccountAsUser</li>\n<li>invalidateAuthToken：从AccountManager的缓存中移除授权。API22之前需要权限。</li>\n<li>peekAuthToken：从缓存中取授权令牌，如果没有，生成一个新的，不会链接服务器。</li>\n<li>setAuthToken</li>\n<li>getAuthToken</li>\n<li>getAuthTokenByFeatures</li>\n<li>blockingGetAuthToken：会阻塞，不要在主线程调用，API22之前需要权限</li>\n<li>copyAccountToUser</li>\n<li>confirmCredentialsAsUser：</li>\n<li>updateCredentials</li>\n<li>editProperties：提供一个用户修改授权设置的机会。</li>\n<li>ensureNotOnMainThread：确保不在主线程</li>\n<li>postToHandler</li>\n<li>convertErrorToException</li>\n<li>newChooseAccountIntent：提供给用户一个可选账户的列表</li>\n</ul>\n<h4 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h4><p><a href=\"https://github.com/xusx1024/AccountManagerDemo\" target=\"_blank\" rel=\"external\">AccountManagerDemo</a></p>\n"},{"title":"Android系统服务：ActivityManager","date":"2017-09-29T00:00:00.000Z","_content":"\n#### 提要 ####\nAMS作为重要的系统服务，涉及到的知识如下：\n* [Binder机制](https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/Binder.md)\n* [AIDL机制](https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/aidldemo/README.md)\n* [Zygote](https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/zygot.md)机制，即系统启动过程，包括SystemServer的初始化\n* 应用程序启动过程\n* Activity的启动过程\n\nAMS相关的应用：\n* manifest文件中activity标签的所有属性\t\n* adb shell am * 相关的命令\n* ActivityManager 相关的API使用\n\n \n","source":"_posts/2017-09-29-android-system-service-Activity-Manager.md","raw":"---\ntitle: Android系统服务：ActivityManager\ndate: 2017-09-29\ntags: android\ncategories: Android System Framework\n---\n\n#### 提要 ####\nAMS作为重要的系统服务，涉及到的知识如下：\n* [Binder机制](https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/Binder.md)\n* [AIDL机制](https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/aidldemo/README.md)\n* [Zygote](https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/zygot.md)机制，即系统启动过程，包括SystemServer的初始化\n* 应用程序启动过程\n* Activity的启动过程\n\nAMS相关的应用：\n* manifest文件中activity标签的所有属性\t\n* adb shell am * 相关的命令\n* ActivityManager 相关的API使用\n\n \n","slug":"android-system-service-Activity-Manager","published":1,"updated":"2017-12-19T02:25:48.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1i700752sivra6k6ujl","content":"<h4 id=\"提要\"><a href=\"#提要\" class=\"headerlink\" title=\"提要\"></a>提要</h4><p>AMS作为重要的系统服务，涉及到的知识如下：</p>\n<ul>\n<li><a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/Binder.md\" target=\"_blank\" rel=\"external\">Binder机制</a></li>\n<li><a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/aidldemo/README.md\" target=\"_blank\" rel=\"external\">AIDL机制</a></li>\n<li><a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/zygot.md\" target=\"_blank\" rel=\"external\">Zygote</a>机制，即系统启动过程，包括SystemServer的初始化</li>\n<li>应用程序启动过程</li>\n<li>Activity的启动过程</li>\n</ul>\n<p>AMS相关的应用：</p>\n<ul>\n<li>manifest文件中activity标签的所有属性    </li>\n<li>adb shell am * 相关的命令</li>\n<li>ActivityManager 相关的API使用</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"提要\"><a href=\"#提要\" class=\"headerlink\" title=\"提要\"></a>提要</h4><p>AMS作为重要的系统服务，涉及到的知识如下：</p>\n<ul>\n<li><a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/Binder.md\" target=\"_blank\" rel=\"external\">Binder机制</a></li>\n<li><a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/aidldemo/README.md\" target=\"_blank\" rel=\"external\">AIDL机制</a></li>\n<li><a href=\"https://github.com/xusx1024/AndroidSystemServiceSample/blob/master/doc/zygot.md\" target=\"_blank\" rel=\"external\">Zygote</a>机制，即系统启动过程，包括SystemServer的初始化</li>\n<li>应用程序启动过程</li>\n<li>Activity的启动过程</li>\n</ul>\n<p>AMS相关的应用：</p>\n<ul>\n<li>manifest文件中activity标签的所有属性    </li>\n<li>adb shell am * 相关的命令</li>\n<li>ActivityManager 相关的API使用</li>\n</ul>\n"},{"title":"拂拭","date":"2017-09-19T00:00:00.000Z","_content":"\n#### 2017年9月19日 ####\n\n 夫君子之行：静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学需静也，才需学也，非学无以广才，非志无以成学。淫慢则不能励精，险燥则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！\n\n ","source":"_posts/2017-09-19-be-better.md","raw":"---\ntitle: 拂拭\ndate: 2017-09-19\ntags: 杂项\ncategories: Others\n---\n\n#### 2017年9月19日 ####\n\n 夫君子之行：静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学需静也，才需学也，非学无以广才，非志无以成学。淫慢则不能励精，险燥则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！\n\n ","slug":"be-better","published":1,"updated":"2017-11-16T08:33:34.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1i900782sivrvd9qr6r","content":"<h4 id=\"2017年9月19日\"><a href=\"#2017年9月19日\" class=\"headerlink\" title=\"2017年9月19日\"></a>2017年9月19日</h4><p> 夫君子之行：静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学需静也，才需学也，非学无以广才，非志无以成学。淫慢则不能励精，险燥则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"2017年9月19日\"><a href=\"#2017年9月19日\" class=\"headerlink\" title=\"2017年9月19日\"></a>2017年9月19日</h4><p> 夫君子之行：静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学需静也，才需学也，非学无以广才，非志无以成学。淫慢则不能励精，险燥则不能冶性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！</p>\n"},{"title":"Zygote","date":"2017-11-17T00:00:00.000Z","_content":"\n \n# zygot 孵化器\n\n* [系统启动 zygote 进程](#系统启动-zygote-进程)\n* [系统进入zygote进程](#系统进入-zygote-进程)\n  * [启用无多线程模式](#启用无多线程模式)\n  * [获取底层传入main函数的参数](#获取底层传入-main-函数的参数)\n  * [注册Socket，用于进程间通信](#注册-Socket-，用于进程间通信)\n  * [预加载公共类与资源](#预加载公共类与资源)\n    * [预加载公共类](#预加载公共类)\n    * [预加载公共资源](#预加载公共资源)\n  * [停止无多线程模式](#停止无多线程模式)\n  * [创建SystemServer](#创建-SystemServer)\n  * [等待接受应用的socket请求](#等待接受应用的-socket-请求)\n* [孵化SystemServer进程](#孵化-systemserver-进程)\n* [孵化 Application 进程](#孵化-application-进程)\n* [Tips](#tips)\n\n### 系统启动 zygote 进程\n即android系统的启动，分为以下几步：\n- _启动电源以及系统启动_\n  按下电源键时，引导芯片代码开始从预定义的地方(固化在ROM)开始执行。加载引导程序Bootloader到RAM，然后执行\n- _引导程序Bootloader_\n  引导程序是在Android OS开始运行前的一个小程序，它的主要作用是把OS拉起来并运行\n- _Linux内核启动_\n  内核启动时，设置缓存，被保护存储器，加载列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找init文件，\n  然后启动root进程或者系统的第一个进程\n- _init进程启动_\n    - 创建一些文件夹并挂载设备\n    - 初始化和启动属性服务(类似win平台的注册表)\n    - 解析init.rc配置文件并启动zygote进程\n\n\n[android 系统启动过程](http://blog.jobbole.com/67931/)\n\n[init.rc代码启动zygote进程](http://blog.csdn.net/fu_kevin0606/article/details/53469076)\n\n[Android初始化语言](http://blog.csdn.net/hongbochen1223/article/details/56331690)\n\n[init.rc源码](https://github.com/StephenRJ/cm12_system_core_rootdir)，基于aosp的，是cm的，cm现在也没了。。\n\n![p](/images/app_main.png)\n\n### 系统进入 zygote 进程\n即zygote的初始化，在调用完ZygoteInit的main函数后，Zygote就进入了Java世界，在此可以看到启动动画。\n![p](/images/ZygoteInit.png)\n\n* 启用无多线程模式\n\n  标志着孵化器开始，确保创建子线程会抛出异常\n  考虑到多线程下，资源尚未加载完成的处理问题\n```\nZygoteHooks.startZygoteNoThreadCreation();\n```\n\n* 获取底层传入main函数的参数\n```\n   boolean startSystemServer = false;\n   String socketName = \"zygote\"; //socketName为zygote\n   String abiList = null;\n   for (int i = 1; i < argv.length; i++) {\n       if (\"start-system-server\".equals(argv[i])) {\n           startSystemServer = true; //start-system-server 在参数列表中，startSystemServer为true\n       } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n           abiList = argv[i].substring(ABI_LIST_ARG.length());//设置abi列表\n       } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n           socketName = argv[i].substring(SOCKET_NAME_ARG.length()); //如果参数列表指定了socketName，就重新设置socketName\n       } else {\n           throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n       }\n   }\n```\n* 注册Socket，用于进程间通信\n\n   Socket的监听方式为使用Linux系统调用select()函数监听文件描述符，当该文件描述符上有数据时，自动触发中断，在中断处理函数中去读取文件描述符上的数据。\n```\n   private static void registerZygoteSocket(String socketName) {\n       if (sServerSocket == null) {\n           int fileDesc;\n           final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;//拼接完整的socketName\n           try {\n               String env = System.getenv(fullSocketName);//获取环境变量\n               fileDesc = Integer.parseInt(env);\n           } catch (RuntimeException ex) {\n               throw new RuntimeException(fullSocketName + \" unset or invalid\", ex);\n           }\n   \n           try {\n               FileDescriptor fd = new FileDescriptor();\n               fd.setInt$(fileDesc);//设置文件描述符\n               sServerSocket = new LocalServerSocket(fd);\n           } catch (IOException ex) {\n               throw new RuntimeException(\n                       \"Error binding to local socket '\" + fileDesc + \"'\", ex);\n           }\n       }\n   }\n```\n   \n   \n\n* 预加载公共类与资源\n\n    在Android系统中有很多的公共资源，所有的程序都会用到。而Zygote创建应用程序进程过程，其实就是复制自身进程地址空间作为应用程序进程的地址空间，因此在Zygote中\n    加载的类和资源都可以由Zygote孵化的应用程序共享。因此可以在Zygote中加载公共类与资源，当某个应用程序启动时，只要加载自身特有的类与资源即可，可以提高软件的启动速度。\n    代价是增加了系统重启的时间。\n    \n```\n\n    static void preload() {\n        Log.d(TAG, \"begin preload\");\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"BeginIcuCachePinning\");\n        beginIcuCachePinning();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadClasses\");\n        preloadClasses();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadResources\");\n        preloadResources();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadOpenGL\");\n        preloadOpenGL();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        preloadSharedLibraries();\n        preloadTextResources();\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        endIcuCachePinning();\n        warmUpJcaProviders();\n        Log.d(TAG, \"end preload\");\n    }\n```\n  \n  * 预加载公共类\n```\n\n    /**\n     * The path of a file that contains classes to preload.\n     * 预加载类的文件路径\n     */\n    private static final String PRELOADED_CLASSES = \"/system/etc/preloaded-classes\";\n    private static final int UNPRIVILEGED_GID = 9999;\n    private static final int ROOT_UID = 0;\n    \n    private static void preloadClasses() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        InputStream is;\n        try {\n            is = new FileInputStream(PRELOADED_CLASSES);//将classes文件转变为文件输入流\n        } catch (FileNotFoundException e) {\n            Log.e(TAG, \"Couldn't find \" + PRELOADED_CLASSES + \".\");\n            return;\n        }\n\n        Log.i(TAG, \"Preloading classes...\");\n        long startTime = SystemClock.uptimeMillis();//开始预加载的时间\n\n        // Drop root perms while running static initializers.\n        // 运行静态初始化时，废弃root权限\n        final int reuid = Os.getuid();\n        final int regid = Os.getgid();\n\n        // We need to drop root perms only if we're already root. In the case of \"wrapped\"\n        // processes (see WrapperInit), this function is called from an unprivileged uid\n        // and gid.\n        // 已经root的设备我们需要废弃root权限。\n        boolean droppedPriviliges = false;\n        if (reuid == ROOT_UID && regid == ROOT_GID) {\n            try {\n                Os.setregid(ROOT_GID, UNPRIVILEGED_GID);\n                Os.setreuid(ROOT_UID, UNPRIVILEGED_UID);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"Failed to drop root\", ex);\n            }\n\n            droppedPriviliges = true;//废弃root特权\n        }\n\n        // Alter the target heap utilization.  With explicit GCs this\n        // is not likely to have any effect.\n        float defaultUtilization = runtime.getTargetHeapUtilization();\n        runtime.setTargetHeapUtilization(0.8f);\n\n        try {\n            BufferedReader br\n                = new BufferedReader(new InputStreamReader(is), 256);//classes文件输入流封装成BufferReader\n\n            int count = 0;\n            String line;\n            while ((line = br.readLine()) != null) {\n                // Skip comments and blank lines.\n                // 过滤空行\n                line = line.trim();\n                if (line.startsWith(\"#\") || line.equals(\"\")) {\n                    continue;\n                }\n\n                Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadClass \" + line);\n                try {\n                    if (false) {\n                        Log.v(TAG, \"Preloading \" + line + \"...\");\n                    }\n                    // Load and explicitly initialize the given class. Use\n                    // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups\n                    // (to derive the caller's class-loader). Use true to force initialization, and\n                    // null for the boot classpath class-loader (could as well cache the\n                    // class-loader of this class in a variable).\n                    // 加载并且明确地初始化指定的类\n                    // 使用反射避免重复的栈查找\n                    // true用来强制初始化\n                    // null表示使用根路径的类加载器\n                    Class.forName(line, true, null);\n                    count++;\n                } catch (ClassNotFoundException e) {\n                    Log.w(TAG, \"Class not found for preloading: \" + line);\n                } catch (UnsatisfiedLinkError e) {\n                    Log.w(TAG, \"Problem preloading \" + line + \": \" + e);\n                } catch (Throwable t) {\n                    Log.e(TAG, \"Error preloading \" + line + \".\", t);\n                    if (t instanceof Error) {\n                        throw (Error) t;\n                    }\n                    if (t instanceof RuntimeException) {\n                        throw (RuntimeException) t;\n                    }\n                    throw new RuntimeException(t);\n                }\n                Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n            }\n\n            Log.i(TAG, \"...preloaded \" + count + \" classes in \"\n                    + (SystemClock.uptimeMillis()-startTime) + \"ms.\");//打印预加载时间\n        } catch (IOException e) {\n            Log.e(TAG, \"Error reading \" + PRELOADED_CLASSES + \".\", e);\n        } finally {\n            IoUtils.closeQuietly(is);\n            // Restore default.\n            runtime.setTargetHeapUtilization(defaultUtilization);\n\n            // Fill in dex caches with classes, fields, and methods brought in by preloading.\n            // 用预加载的类，字段，方法填充dex缓存空间。\n            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadDexCaches\");\n            runtime.preloadDexCaches();\n            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n\n            // Bring back root. We'll need it later if we're in the zygote.\n            // 恢复root权限。如果在zygote中，待会儿要用。\n            if (droppedPriviliges) {\n                try {\n                    Os.setreuid(ROOT_UID, ROOT_UID);\n                    Os.setregid(ROOT_GID, ROOT_GID);\n                } catch (ErrnoException ex) {\n                    throw new RuntimeException(\"Failed to restore root\", ex);\n                }\n            }\n        }\n    }\n```\n\n  * 预加载公共资源\n\n```\n    /**\n     * Used to pre-load resources.  We hold a global reference on it so it\n     * never gets destroyed.\n     * 用来预加载资源。对其持有全局引用，因此永远不会被销毁。\n     */\n    private static Resources mResources;\n    private static void preloadResources() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        try {\n            mResources = Resources.getSystem();\n            mResources.startPreloading();\n            if (PRELOAD_RESOURCES) {\n                Log.i(TAG, \"Preloading resources...\");\n\n                long startTime = SystemClock.uptimeMillis();\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);//要预加载的资源\n                int N = preloadDrawables(ar); //预加载drawables\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");//预加载drawables使用的时间\n\n                startTime = SystemClock.uptimeMillis();\n                ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_color_state_lists);\n                N = preloadColorStateLists(ar);//预加载color state\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");//预加载color state使用的时间\n\n                //The device supports freeform window management. Windows have title bars and can be moved\n                //and resized. If you set this to true, you also need to add\n                //PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT feature to your device specification.\n                //The duplication is necessary, because this information is used before the features are\n                //available to the system.\n                if (mResources.getBoolean(\n                        com.android.internal.R.bool.config_freeformWindowManagement)) {\n                        //如果支持自由的窗口管理，预加载多窗口drawables\n                    startTime = SystemClock.uptimeMillis();\n                    ar = mResources.obtainTypedArray(\n                            com.android.internal.R.array.preloaded_freeform_multi_window_drawables);\n                    N = preloadDrawables(ar);\n                    ar.recycle();\n                    Log.i(TAG, \"...preloaded \" + N + \" resource in \"\n                            + (SystemClock.uptimeMillis() - startTime) + \"ms.\");\n                }\n            }\n            mResources.finishPreloading();\n        } catch (RuntimeException e) {\n            Log.w(TAG, \"Failure preloading resources\", e);\n        }\n    }\n```\n* 停止无多线程模式\n```\n   ZygoteHooks.stopZygoteNoThreadCreation();\n```\n* 创建SystemServer\n\n```\n  if (startSystemServer) {   //startSysteServer为true  \n      startSystemServer(abiList, socketName);     \n  } \n```\n  [孵化 SystemServer 进程](#孵化 SystemServer 进程)\n\n* 等待接受应用的socket请求\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n\n### 孵化 SystemServer 进程\n![system_server](/imges/system_server.png)\n\n```\n    /**\n     * Prepare the arguments and fork for the system server process.\n     */\n    private static boolean startSystemServer(String abiList, String socketName)\n            throws MethodAndArgsCaller, RuntimeException {\n        long capabilities = posixCapabilitiesAsBits(\n            OsConstants.CAP_IPC_LOCK,\n            OsConstants.CAP_KILL,\n            OsConstants.CAP_NET_ADMIN,\n            OsConstants.CAP_NET_BIND_SERVICE,\n            OsConstants.CAP_NET_BROADCAST,\n            OsConstants.CAP_NET_RAW,\n            OsConstants.CAP_SYS_MODULE,\n            OsConstants.CAP_SYS_NICE,\n            OsConstants.CAP_SYS_RESOURCE,\n            OsConstants.CAP_SYS_TIME,\n            OsConstants.CAP_SYS_TTY_CONFIG\n        );\n        /* Containers run without this capability, so avoid setting it in that case */\n        if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) {\n            capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);\n        }\n        /* Hardcoded command line to start the system server */\n        String args[] = {\n            \"--setuid=1000\",\n            \"--setgid=1000\",\n            \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010\",\n            \"--capabilities=\" + capabilities + \",\" + capabilities,\n            \"--nice-name=system_server\",//进程名字\n            \"--runtime-args\",\n            \"com.android.server.SystemServer\",//包名\n        };\n        ZygoteConnection.Arguments parsedArgs = null;\n\n        int pid;\n\n        try {\n            parsedArgs = new ZygoteConnection.Arguments(args);//参数封装\n            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(//孵化系统服务进程，尝试获取pid\n                    parsedArgs.uid, parsedArgs.gid,\n                    parsedArgs.gids,\n                    parsedArgs.debugFlags,\n                    null,\n                    parsedArgs.permittedCapabilities,\n                    parsedArgs.effectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {//fork子进程成功\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            handleSystemServerProcess(parsedArgs);//运行系统服务，SystemServer拥有了自己的进程\n        }\n\n        return true;\n    }\n\n```\n  * 创建SystemServer进程，android的所有服务循环框架都建立在SystemServer上\n\n```\n    public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {\n        VM_HOOKS.preFork();// 停止所有守护进程\n        int pid = nativeForkSystemServer( //native函数孵化进程\n                uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);\n        // Enable tracing as soon as we enter the system_server.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n        }\n        VM_HOOKS.postForkCommon(); // 重新运行各个守护进程\n        return pid;\n    }\n    \n    native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int debugFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);\n```\n\n    调用底层进行fork system server进程。如果创建出的进程pid=0，说明该进程为Zygote的子进程，系统会为其设置uid，gid\n    如果pid > 0 ，说明该进程为SystemServer的进程号，Zygote会检查一下该进程有没有died，如果true，重启Zygote进程。\n    SystemServer进程创建完成后，就会重新启动垃圾回收后台进程。\n   \n* 运行SystemServer\n\n```\n    /**\n     * Finish remaining work for the newly forked system server process.\n     */\n    private static void handleSystemServerProcess(\n            ZygoteConnection.Arguments parsedArgs)\n            throws ZygoteInit.MethodAndArgsCaller {\n\n        closeServerSocket(); //关闭zygote中的socket\n\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);// 设置进程名\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); // 获取SystemServer的classpath\n        if (systemServerClasspath != null) {\n            performSystemServerDexOpt(systemServerClasspath); //对改路径中的文件做dexopt优化\n        }\n\n        if (parsedArgs.invokeWith != null) {\n            String[] args = parsedArgs.remainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);\n            }\n\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n        } else {\n            ClassLoader cl = null;\n            if (systemServerClasspath != null) {\n            // 为SystemServer创建ClassLoader，使其可以进入平台的私有本地类库\n                cl = createSystemServerClassLoader(systemServerClasspath,\n                                                   parsedArgs.targetSdkVersion);\n\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             * 将剩余的参数传递给SystemServer\n             */\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n```\n\n\nSystemServer.main中创建线程注册各种service到servicemanager中。\n\n#### HOME启动\n\n在启动完所有的Android服务后，通知各个服务，系统已经准备就绪。\n\nstartSystemUi 方法启动HOME界面。\n\n至此，android系统完成了引导过程，这是ACTION_BOOT_COMPLETED开机启动广播就会发出去。\n\n### 孵化 Application 进程\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n\n    native private static int nativeForkAndSpecialize(int uid, int gid, int[] gids,int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir);\n```\n\n### Tips   \n- 为所有Java程序复刻一个虚拟机实例\n- 应用程序的入口是`ActivityThread$main()`，而zygote就是为应用程序创建进程的\n- 大部分应用程序由zygote创建进程，但是系统引导进程、init进程不是\n  #### android中的zygote分两块\n  1. C/C++编写的zygote，主要用来为系统服务和应用程序复刻进程的\n  2. Java编写的zygote接口，负责为系统服务和应用程序调用C/C++ zygote接口执行复刻，创建虚拟机进程\n  \n  #### android中的service分两种\n  1. NativeService\n  2. SystemService，即本project示例集所研究\n","source":"_posts/2017-11-17-android-zygote.md","raw":"---\ntitle: Zygote\ndate: 2017-11-17\ntags: android\ncategories: Android\n---\n\n \n# zygot 孵化器\n\n* [系统启动 zygote 进程](#系统启动-zygote-进程)\n* [系统进入zygote进程](#系统进入-zygote-进程)\n  * [启用无多线程模式](#启用无多线程模式)\n  * [获取底层传入main函数的参数](#获取底层传入-main-函数的参数)\n  * [注册Socket，用于进程间通信](#注册-Socket-，用于进程间通信)\n  * [预加载公共类与资源](#预加载公共类与资源)\n    * [预加载公共类](#预加载公共类)\n    * [预加载公共资源](#预加载公共资源)\n  * [停止无多线程模式](#停止无多线程模式)\n  * [创建SystemServer](#创建-SystemServer)\n  * [等待接受应用的socket请求](#等待接受应用的-socket-请求)\n* [孵化SystemServer进程](#孵化-systemserver-进程)\n* [孵化 Application 进程](#孵化-application-进程)\n* [Tips](#tips)\n\n### 系统启动 zygote 进程\n即android系统的启动，分为以下几步：\n- _启动电源以及系统启动_\n  按下电源键时，引导芯片代码开始从预定义的地方(固化在ROM)开始执行。加载引导程序Bootloader到RAM，然后执行\n- _引导程序Bootloader_\n  引导程序是在Android OS开始运行前的一个小程序，它的主要作用是把OS拉起来并运行\n- _Linux内核启动_\n  内核启动时，设置缓存，被保护存储器，加载列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找init文件，\n  然后启动root进程或者系统的第一个进程\n- _init进程启动_\n    - 创建一些文件夹并挂载设备\n    - 初始化和启动属性服务(类似win平台的注册表)\n    - 解析init.rc配置文件并启动zygote进程\n\n\n[android 系统启动过程](http://blog.jobbole.com/67931/)\n\n[init.rc代码启动zygote进程](http://blog.csdn.net/fu_kevin0606/article/details/53469076)\n\n[Android初始化语言](http://blog.csdn.net/hongbochen1223/article/details/56331690)\n\n[init.rc源码](https://github.com/StephenRJ/cm12_system_core_rootdir)，基于aosp的，是cm的，cm现在也没了。。\n\n![p](/images/app_main.png)\n\n### 系统进入 zygote 进程\n即zygote的初始化，在调用完ZygoteInit的main函数后，Zygote就进入了Java世界，在此可以看到启动动画。\n![p](/images/ZygoteInit.png)\n\n* 启用无多线程模式\n\n  标志着孵化器开始，确保创建子线程会抛出异常\n  考虑到多线程下，资源尚未加载完成的处理问题\n```\nZygoteHooks.startZygoteNoThreadCreation();\n```\n\n* 获取底层传入main函数的参数\n```\n   boolean startSystemServer = false;\n   String socketName = \"zygote\"; //socketName为zygote\n   String abiList = null;\n   for (int i = 1; i < argv.length; i++) {\n       if (\"start-system-server\".equals(argv[i])) {\n           startSystemServer = true; //start-system-server 在参数列表中，startSystemServer为true\n       } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n           abiList = argv[i].substring(ABI_LIST_ARG.length());//设置abi列表\n       } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n           socketName = argv[i].substring(SOCKET_NAME_ARG.length()); //如果参数列表指定了socketName，就重新设置socketName\n       } else {\n           throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n       }\n   }\n```\n* 注册Socket，用于进程间通信\n\n   Socket的监听方式为使用Linux系统调用select()函数监听文件描述符，当该文件描述符上有数据时，自动触发中断，在中断处理函数中去读取文件描述符上的数据。\n```\n   private static void registerZygoteSocket(String socketName) {\n       if (sServerSocket == null) {\n           int fileDesc;\n           final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;//拼接完整的socketName\n           try {\n               String env = System.getenv(fullSocketName);//获取环境变量\n               fileDesc = Integer.parseInt(env);\n           } catch (RuntimeException ex) {\n               throw new RuntimeException(fullSocketName + \" unset or invalid\", ex);\n           }\n   \n           try {\n               FileDescriptor fd = new FileDescriptor();\n               fd.setInt$(fileDesc);//设置文件描述符\n               sServerSocket = new LocalServerSocket(fd);\n           } catch (IOException ex) {\n               throw new RuntimeException(\n                       \"Error binding to local socket '\" + fileDesc + \"'\", ex);\n           }\n       }\n   }\n```\n   \n   \n\n* 预加载公共类与资源\n\n    在Android系统中有很多的公共资源，所有的程序都会用到。而Zygote创建应用程序进程过程，其实就是复制自身进程地址空间作为应用程序进程的地址空间，因此在Zygote中\n    加载的类和资源都可以由Zygote孵化的应用程序共享。因此可以在Zygote中加载公共类与资源，当某个应用程序启动时，只要加载自身特有的类与资源即可，可以提高软件的启动速度。\n    代价是增加了系统重启的时间。\n    \n```\n\n    static void preload() {\n        Log.d(TAG, \"begin preload\");\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"BeginIcuCachePinning\");\n        beginIcuCachePinning();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadClasses\");\n        preloadClasses();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadResources\");\n        preloadResources();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadOpenGL\");\n        preloadOpenGL();\n        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n        preloadSharedLibraries();\n        preloadTextResources();\n        // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n        // for memory sharing purposes.\n        WebViewFactory.prepareWebViewInZygote();\n        endIcuCachePinning();\n        warmUpJcaProviders();\n        Log.d(TAG, \"end preload\");\n    }\n```\n  \n  * 预加载公共类\n```\n\n    /**\n     * The path of a file that contains classes to preload.\n     * 预加载类的文件路径\n     */\n    private static final String PRELOADED_CLASSES = \"/system/etc/preloaded-classes\";\n    private static final int UNPRIVILEGED_GID = 9999;\n    private static final int ROOT_UID = 0;\n    \n    private static void preloadClasses() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        InputStream is;\n        try {\n            is = new FileInputStream(PRELOADED_CLASSES);//将classes文件转变为文件输入流\n        } catch (FileNotFoundException e) {\n            Log.e(TAG, \"Couldn't find \" + PRELOADED_CLASSES + \".\");\n            return;\n        }\n\n        Log.i(TAG, \"Preloading classes...\");\n        long startTime = SystemClock.uptimeMillis();//开始预加载的时间\n\n        // Drop root perms while running static initializers.\n        // 运行静态初始化时，废弃root权限\n        final int reuid = Os.getuid();\n        final int regid = Os.getgid();\n\n        // We need to drop root perms only if we're already root. In the case of \"wrapped\"\n        // processes (see WrapperInit), this function is called from an unprivileged uid\n        // and gid.\n        // 已经root的设备我们需要废弃root权限。\n        boolean droppedPriviliges = false;\n        if (reuid == ROOT_UID && regid == ROOT_GID) {\n            try {\n                Os.setregid(ROOT_GID, UNPRIVILEGED_GID);\n                Os.setreuid(ROOT_UID, UNPRIVILEGED_UID);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"Failed to drop root\", ex);\n            }\n\n            droppedPriviliges = true;//废弃root特权\n        }\n\n        // Alter the target heap utilization.  With explicit GCs this\n        // is not likely to have any effect.\n        float defaultUtilization = runtime.getTargetHeapUtilization();\n        runtime.setTargetHeapUtilization(0.8f);\n\n        try {\n            BufferedReader br\n                = new BufferedReader(new InputStreamReader(is), 256);//classes文件输入流封装成BufferReader\n\n            int count = 0;\n            String line;\n            while ((line = br.readLine()) != null) {\n                // Skip comments and blank lines.\n                // 过滤空行\n                line = line.trim();\n                if (line.startsWith(\"#\") || line.equals(\"\")) {\n                    continue;\n                }\n\n                Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadClass \" + line);\n                try {\n                    if (false) {\n                        Log.v(TAG, \"Preloading \" + line + \"...\");\n                    }\n                    // Load and explicitly initialize the given class. Use\n                    // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups\n                    // (to derive the caller's class-loader). Use true to force initialization, and\n                    // null for the boot classpath class-loader (could as well cache the\n                    // class-loader of this class in a variable).\n                    // 加载并且明确地初始化指定的类\n                    // 使用反射避免重复的栈查找\n                    // true用来强制初始化\n                    // null表示使用根路径的类加载器\n                    Class.forName(line, true, null);\n                    count++;\n                } catch (ClassNotFoundException e) {\n                    Log.w(TAG, \"Class not found for preloading: \" + line);\n                } catch (UnsatisfiedLinkError e) {\n                    Log.w(TAG, \"Problem preloading \" + line + \": \" + e);\n                } catch (Throwable t) {\n                    Log.e(TAG, \"Error preloading \" + line + \".\", t);\n                    if (t instanceof Error) {\n                        throw (Error) t;\n                    }\n                    if (t instanceof RuntimeException) {\n                        throw (RuntimeException) t;\n                    }\n                    throw new RuntimeException(t);\n                }\n                Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n            }\n\n            Log.i(TAG, \"...preloaded \" + count + \" classes in \"\n                    + (SystemClock.uptimeMillis()-startTime) + \"ms.\");//打印预加载时间\n        } catch (IOException e) {\n            Log.e(TAG, \"Error reading \" + PRELOADED_CLASSES + \".\", e);\n        } finally {\n            IoUtils.closeQuietly(is);\n            // Restore default.\n            runtime.setTargetHeapUtilization(defaultUtilization);\n\n            // Fill in dex caches with classes, fields, and methods brought in by preloading.\n            // 用预加载的类，字段，方法填充dex缓存空间。\n            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadDexCaches\");\n            runtime.preloadDexCaches();\n            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n\n            // Bring back root. We'll need it later if we're in the zygote.\n            // 恢复root权限。如果在zygote中，待会儿要用。\n            if (droppedPriviliges) {\n                try {\n                    Os.setreuid(ROOT_UID, ROOT_UID);\n                    Os.setregid(ROOT_GID, ROOT_GID);\n                } catch (ErrnoException ex) {\n                    throw new RuntimeException(\"Failed to restore root\", ex);\n                }\n            }\n        }\n    }\n```\n\n  * 预加载公共资源\n\n```\n    /**\n     * Used to pre-load resources.  We hold a global reference on it so it\n     * never gets destroyed.\n     * 用来预加载资源。对其持有全局引用，因此永远不会被销毁。\n     */\n    private static Resources mResources;\n    private static void preloadResources() {\n        final VMRuntime runtime = VMRuntime.getRuntime();\n\n        try {\n            mResources = Resources.getSystem();\n            mResources.startPreloading();\n            if (PRELOAD_RESOURCES) {\n                Log.i(TAG, \"Preloading resources...\");\n\n                long startTime = SystemClock.uptimeMillis();\n                TypedArray ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_drawables);//要预加载的资源\n                int N = preloadDrawables(ar); //预加载drawables\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");//预加载drawables使用的时间\n\n                startTime = SystemClock.uptimeMillis();\n                ar = mResources.obtainTypedArray(\n                        com.android.internal.R.array.preloaded_color_state_lists);\n                N = preloadColorStateLists(ar);//预加载color state\n                ar.recycle();\n                Log.i(TAG, \"...preloaded \" + N + \" resources in \"\n                        + (SystemClock.uptimeMillis()-startTime) + \"ms.\");//预加载color state使用的时间\n\n                //The device supports freeform window management. Windows have title bars and can be moved\n                //and resized. If you set this to true, you also need to add\n                //PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT feature to your device specification.\n                //The duplication is necessary, because this information is used before the features are\n                //available to the system.\n                if (mResources.getBoolean(\n                        com.android.internal.R.bool.config_freeformWindowManagement)) {\n                        //如果支持自由的窗口管理，预加载多窗口drawables\n                    startTime = SystemClock.uptimeMillis();\n                    ar = mResources.obtainTypedArray(\n                            com.android.internal.R.array.preloaded_freeform_multi_window_drawables);\n                    N = preloadDrawables(ar);\n                    ar.recycle();\n                    Log.i(TAG, \"...preloaded \" + N + \" resource in \"\n                            + (SystemClock.uptimeMillis() - startTime) + \"ms.\");\n                }\n            }\n            mResources.finishPreloading();\n        } catch (RuntimeException e) {\n            Log.w(TAG, \"Failure preloading resources\", e);\n        }\n    }\n```\n* 停止无多线程模式\n```\n   ZygoteHooks.stopZygoteNoThreadCreation();\n```\n* 创建SystemServer\n\n```\n  if (startSystemServer) {   //startSysteServer为true  \n      startSystemServer(abiList, socketName);     \n  } \n```\n  [孵化 SystemServer 进程](#孵化 SystemServer 进程)\n\n* 等待接受应用的socket请求\n\n```\n    private static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(sServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n                if (i == 0) {\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    boolean done = peers.get(i).runOnce();\n                    if (done) {\n                        peers.remove(i);\n                        fds.remove(i);\n                    }\n                }\n            }\n        }\n    }\n```\n\n\n### 孵化 SystemServer 进程\n![system_server](/imges/system_server.png)\n\n```\n    /**\n     * Prepare the arguments and fork for the system server process.\n     */\n    private static boolean startSystemServer(String abiList, String socketName)\n            throws MethodAndArgsCaller, RuntimeException {\n        long capabilities = posixCapabilitiesAsBits(\n            OsConstants.CAP_IPC_LOCK,\n            OsConstants.CAP_KILL,\n            OsConstants.CAP_NET_ADMIN,\n            OsConstants.CAP_NET_BIND_SERVICE,\n            OsConstants.CAP_NET_BROADCAST,\n            OsConstants.CAP_NET_RAW,\n            OsConstants.CAP_SYS_MODULE,\n            OsConstants.CAP_SYS_NICE,\n            OsConstants.CAP_SYS_RESOURCE,\n            OsConstants.CAP_SYS_TIME,\n            OsConstants.CAP_SYS_TTY_CONFIG\n        );\n        /* Containers run without this capability, so avoid setting it in that case */\n        if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) {\n            capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);\n        }\n        /* Hardcoded command line to start the system server */\n        String args[] = {\n            \"--setuid=1000\",\n            \"--setgid=1000\",\n            \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010\",\n            \"--capabilities=\" + capabilities + \",\" + capabilities,\n            \"--nice-name=system_server\",//进程名字\n            \"--runtime-args\",\n            \"com.android.server.SystemServer\",//包名\n        };\n        ZygoteConnection.Arguments parsedArgs = null;\n\n        int pid;\n\n        try {\n            parsedArgs = new ZygoteConnection.Arguments(args);//参数封装\n            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n            /* Request to fork the system server process */\n            pid = Zygote.forkSystemServer(//孵化系统服务进程，尝试获取pid\n                    parsedArgs.uid, parsedArgs.gid,\n                    parsedArgs.gids,\n                    parsedArgs.debugFlags,\n                    null,\n                    parsedArgs.permittedCapabilities,\n                    parsedArgs.effectiveCapabilities);\n        } catch (IllegalArgumentException ex) {\n            throw new RuntimeException(ex);\n        }\n\n        /* For child process */\n        if (pid == 0) {//fork子进程成功\n            if (hasSecondZygote(abiList)) {\n                waitForSecondaryZygote(socketName);\n            }\n\n            handleSystemServerProcess(parsedArgs);//运行系统服务，SystemServer拥有了自己的进程\n        }\n\n        return true;\n    }\n\n```\n  * 创建SystemServer进程，android的所有服务循环框架都建立在SystemServer上\n\n```\n    public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {\n        VM_HOOKS.preFork();// 停止所有守护进程\n        int pid = nativeForkSystemServer( //native函数孵化进程\n                uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);\n        // Enable tracing as soon as we enter the system_server.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n        }\n        VM_HOOKS.postForkCommon(); // 重新运行各个守护进程\n        return pid;\n    }\n    \n    native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int debugFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);\n```\n\n    调用底层进行fork system server进程。如果创建出的进程pid=0，说明该进程为Zygote的子进程，系统会为其设置uid，gid\n    如果pid > 0 ，说明该进程为SystemServer的进程号，Zygote会检查一下该进程有没有died，如果true，重启Zygote进程。\n    SystemServer进程创建完成后，就会重新启动垃圾回收后台进程。\n   \n* 运行SystemServer\n\n```\n    /**\n     * Finish remaining work for the newly forked system server process.\n     */\n    private static void handleSystemServerProcess(\n            ZygoteConnection.Arguments parsedArgs)\n            throws ZygoteInit.MethodAndArgsCaller {\n\n        closeServerSocket(); //关闭zygote中的socket\n\n        // set umask to 0077 so new files and directories will default to owner-only permissions.\n        Os.umask(S_IRWXG | S_IRWXO);\n\n        if (parsedArgs.niceName != null) {\n            Process.setArgV0(parsedArgs.niceName);// 设置进程名\n        }\n\n        final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); // 获取SystemServer的classpath\n        if (systemServerClasspath != null) {\n            performSystemServerDexOpt(systemServerClasspath); //对改路径中的文件做dexopt优化\n        }\n\n        if (parsedArgs.invokeWith != null) {\n            String[] args = parsedArgs.remainingArgs;\n            // If we have a non-null system server class path, we'll have to duplicate the\n            // existing arguments and append the classpath to it. ART will handle the classpath\n            // correctly when we exec a new process.\n            if (systemServerClasspath != null) {\n                String[] amendedArgs = new String[args.length + 2];\n                amendedArgs[0] = \"-cp\";\n                amendedArgs[1] = systemServerClasspath;\n                System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);\n            }\n\n            WrapperInit.execApplication(parsedArgs.invokeWith,\n                    parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                    VMRuntime.getCurrentInstructionSet(), null, args);\n        } else {\n            ClassLoader cl = null;\n            if (systemServerClasspath != null) {\n            // 为SystemServer创建ClassLoader，使其可以进入平台的私有本地类库\n                cl = createSystemServerClassLoader(systemServerClasspath,\n                                                   parsedArgs.targetSdkVersion);\n\n                Thread.currentThread().setContextClassLoader(cl);\n            }\n\n            /*\n             * Pass the remaining arguments to SystemServer.\n             * 将剩余的参数传递给SystemServer\n             */\n            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n        }\n\n        /* should never reach here */\n    }\n```\n\n\nSystemServer.main中创建线程注册各种service到servicemanager中。\n\n#### HOME启动\n\n在启动完所有的Android服务后，通知各个服务，系统已经准备就绪。\n\nstartSystemUi 方法启动HOME界面。\n\n至此，android系统完成了引导过程，这是ACTION_BOOT_COMPLETED开机启动广播就会发出去。\n\n### 孵化 Application 进程\n\n```\n    public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir) {\n        VM_HOOKS.preFork();\n        int pid = nativeForkAndSpecialize(\n                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,\n                  instructionSet, appDataDir);\n        // Enable tracing as soon as possible for the child process.\n        if (pid == 0) {\n            Trace.setTracingEnabled(true);\n\n            // Note that this event ends at the end of handleChildProc,\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"PostFork\");\n        }\n        VM_HOOKS.postForkCommon();\n        return pid;\n    }\n\n    native private static int nativeForkAndSpecialize(int uid, int gid, int[] gids,int debugFlags,\n          int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,\n          String instructionSet, String appDataDir);\n```\n\n### Tips   \n- 为所有Java程序复刻一个虚拟机实例\n- 应用程序的入口是`ActivityThread$main()`，而zygote就是为应用程序创建进程的\n- 大部分应用程序由zygote创建进程，但是系统引导进程、init进程不是\n  #### android中的zygote分两块\n  1. C/C++编写的zygote，主要用来为系统服务和应用程序复刻进程的\n  2. Java编写的zygote接口，负责为系统服务和应用程序调用C/C++ zygote接口执行复刻，创建虚拟机进程\n  \n  #### android中的service分两种\n  1. NativeService\n  2. SystemService，即本project示例集所研究\n","slug":"android-zygote","published":1,"updated":"2017-11-17T01:54:33.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1id007b2sivcph643vp","content":"<h1 id=\"zygot-孵化器\"><a href=\"#zygot-孵化器\" class=\"headerlink\" title=\"zygot 孵化器\"></a>zygot 孵化器</h1><ul>\n<li><a href=\"#系统启动-zygote-进程\">系统启动 zygote 进程</a></li>\n<li><a href=\"#系统进入-zygote-进程\">系统进入zygote进程</a><ul>\n<li><a href=\"#启用无多线程模式\">启用无多线程模式</a></li>\n<li><a href=\"#获取底层传入-main-函数的参数\">获取底层传入main函数的参数</a></li>\n<li><a href=\"#注册-Socket-，用于进程间通信\">注册Socket，用于进程间通信</a></li>\n<li><a href=\"#预加载公共类与资源\">预加载公共类与资源</a><ul>\n<li><a href=\"#预加载公共类\">预加载公共类</a></li>\n<li><a href=\"#预加载公共资源\">预加载公共资源</a></li>\n</ul>\n</li>\n<li><a href=\"#停止无多线程模式\">停止无多线程模式</a></li>\n<li><a href=\"#创建-SystemServer\">创建SystemServer</a></li>\n<li><a href=\"#等待接受应用的-socket-请求\">等待接受应用的socket请求</a></li>\n</ul>\n</li>\n<li><a href=\"#孵化-systemserver-进程\">孵化SystemServer进程</a></li>\n<li><a href=\"#孵化-application-进程\">孵化 Application 进程</a></li>\n<li><a href=\"#tips\">Tips</a></li>\n</ul>\n<h3 id=\"系统启动-zygote-进程\"><a href=\"#系统启动-zygote-进程\" class=\"headerlink\" title=\"系统启动 zygote 进程\"></a>系统启动 zygote 进程</h3><p>即android系统的启动，分为以下几步：</p>\n<ul>\n<li><em>启动电源以及系统启动</em><br>按下电源键时，引导芯片代码开始从预定义的地方(固化在ROM)开始执行。加载引导程序Bootloader到RAM，然后执行</li>\n<li><em>引导程序Bootloader</em><br>引导程序是在Android OS开始运行前的一个小程序，它的主要作用是把OS拉起来并运行</li>\n<li><em>Linux内核启动</em><br>内核启动时，设置缓存，被保护存储器，加载列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找init文件，<br>然后启动root进程或者系统的第一个进程</li>\n<li><em>init进程启动</em><ul>\n<li>创建一些文件夹并挂载设备</li>\n<li>初始化和启动属性服务(类似win平台的注册表)</li>\n<li>解析init.rc配置文件并启动zygote进程</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://blog.jobbole.com/67931/\" target=\"_blank\" rel=\"external\">android 系统启动过程</a></p>\n<p><a href=\"http://blog.csdn.net/fu_kevin0606/article/details/53469076\" target=\"_blank\" rel=\"external\">init.rc代码启动zygote进程</a></p>\n<p><a href=\"http://blog.csdn.net/hongbochen1223/article/details/56331690\" target=\"_blank\" rel=\"external\">Android初始化语言</a></p>\n<p><a href=\"https://github.com/StephenRJ/cm12_system_core_rootdir\" target=\"_blank\" rel=\"external\">init.rc源码</a>，基于aosp的，是cm的，cm现在也没了。。</p>\n<p><img src=\"/images/app_main.png\" alt=\"p\"></p>\n<h3 id=\"系统进入-zygote-进程\"><a href=\"#系统进入-zygote-进程\" class=\"headerlink\" title=\"系统进入 zygote 进程\"></a>系统进入 zygote 进程</h3><p>即zygote的初始化，在调用完ZygoteInit的main函数后，Zygote就进入了Java世界，在此可以看到启动动画。<br><img src=\"/images/ZygoteInit.png\" alt=\"p\"></p>\n<ul>\n<li><p>启用无多线程模式</p>\n<p>标志着孵化器开始，确保创建子线程会抛出异常<br>考虑到多线程下，资源尚未加载完成的处理问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZygoteHooks.startZygoteNoThreadCreation();</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取底层传入main函数的参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean startSystemServer = false;</div><div class=\"line\">String socketName = &quot;zygote&quot;; //socketName为zygote</div><div class=\"line\">String abiList = null;</div><div class=\"line\">for (int i = 1; i &lt; argv.length; i++) &#123;</div><div class=\"line\">    if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</div><div class=\"line\">        startSystemServer = true; //start-system-server 在参数列表中，startSystemServer为true</div><div class=\"line\">    &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class=\"line\">        abiList = argv[i].substring(ABI_LIST_ARG.length());//设置abi列表</div><div class=\"line\">    &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class=\"line\">        socketName = argv[i].substring(SOCKET_NAME_ARG.length()); //如果参数列表指定了socketName，就重新设置socketName</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>注册Socket，用于进程间通信</p>\n<p> Socket的监听方式为使用Linux系统调用select()函数监听文件描述符，当该文件描述符上有数据时，自动触发中断，在中断处理函数中去读取文件描述符上的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void registerZygoteSocket(String socketName) &#123;</div><div class=\"line\">    if (sServerSocket == null) &#123;</div><div class=\"line\">        int fileDesc;</div><div class=\"line\">        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;//拼接完整的socketName</div><div class=\"line\">        try &#123;</div><div class=\"line\">            String env = System.getenv(fullSocketName);//获取环境变量</div><div class=\"line\">            fileDesc = Integer.parseInt(env);</div><div class=\"line\">        &#125; catch (RuntimeException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileDescriptor fd = new FileDescriptor();</div><div class=\"line\">            fd.setInt$(fileDesc);//设置文件描述符</div><div class=\"line\">            sServerSocket = new LocalServerSocket(fd);</div><div class=\"line\">        &#125; catch (IOException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(</div><div class=\"line\">                    &quot;Error binding to local socket &apos;&quot; + fileDesc + &quot;&apos;&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>预加载公共类与资源</p>\n<p>  在Android系统中有很多的公共资源，所有的程序都会用到。而Zygote创建应用程序进程过程，其实就是复制自身进程地址空间作为应用程序进程的地址空间，因此在Zygote中<br>  加载的类和资源都可以由Zygote孵化的应用程序共享。因此可以在Zygote中加载公共类与资源，当某个应用程序启动时，只要加载自身特有的类与资源即可，可以提高软件的启动速度。<br>  代价是增加了系统重启的时间。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">static void preload() &#123;</div><div class=\"line\">    Log.d(TAG, &quot;begin preload&quot;);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;BeginIcuCachePinning&quot;);</div><div class=\"line\">    beginIcuCachePinning();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadClasses&quot;);</div><div class=\"line\">    preloadClasses();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadResources&quot;);</div><div class=\"line\">    preloadResources();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadOpenGL&quot;);</div><div class=\"line\">    preloadOpenGL();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    preloadSharedLibraries();</div><div class=\"line\">    preloadTextResources();</div><div class=\"line\">    // Ask the WebViewFactory to do any initialization that must run in the zygote process,</div><div class=\"line\">    // for memory sharing purposes.</div><div class=\"line\">    WebViewFactory.prepareWebViewInZygote();</div><div class=\"line\">    endIcuCachePinning();</div><div class=\"line\">    warmUpJcaProviders();</div><div class=\"line\">    Log.d(TAG, &quot;end preload&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>预加载公共类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * The path of a file that contains classes to preload.</div><div class=\"line\"> * 预加载类的文件路径</div><div class=\"line\"> */</div><div class=\"line\">private static final String PRELOADED_CLASSES = &quot;/system/etc/preloaded-classes&quot;;</div><div class=\"line\">private static final int UNPRIVILEGED_GID = 9999;</div><div class=\"line\">private static final int ROOT_UID = 0;</div><div class=\"line\"></div><div class=\"line\">private static void preloadClasses() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    InputStream is;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        is = new FileInputStream(PRELOADED_CLASSES);//将classes文件转变为文件输入流</div><div class=\"line\">    &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Couldn&apos;t find &quot; + PRELOADED_CLASSES + &quot;.&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Log.i(TAG, &quot;Preloading classes...&quot;);</div><div class=\"line\">    long startTime = SystemClock.uptimeMillis();//开始预加载的时间</div><div class=\"line\"></div><div class=\"line\">    // Drop root perms while running static initializers.</div><div class=\"line\">    // 运行静态初始化时，废弃root权限</div><div class=\"line\">    final int reuid = Os.getuid();</div><div class=\"line\">    final int regid = Os.getgid();</div><div class=\"line\"></div><div class=\"line\">    // We need to drop root perms only if we&apos;re already root. In the case of &quot;wrapped&quot;</div><div class=\"line\">    // processes (see WrapperInit), this function is called from an unprivileged uid</div><div class=\"line\">    // and gid.</div><div class=\"line\">    // 已经root的设备我们需要废弃root权限。</div><div class=\"line\">    boolean droppedPriviliges = false;</div><div class=\"line\">    if (reuid == ROOT_UID &amp;&amp; regid == ROOT_GID) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.setregid(ROOT_GID, UNPRIVILEGED_GID);</div><div class=\"line\">            Os.setreuid(ROOT_UID, UNPRIVILEGED_UID);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;Failed to drop root&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        droppedPriviliges = true;//废弃root特权</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Alter the target heap utilization.  With explicit GCs this</div><div class=\"line\">    // is not likely to have any effect.</div><div class=\"line\">    float defaultUtilization = runtime.getTargetHeapUtilization();</div><div class=\"line\">    runtime.setTargetHeapUtilization(0.8f);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        BufferedReader br</div><div class=\"line\">            = new BufferedReader(new InputStreamReader(is), 256);//classes文件输入流封装成BufferReader</div><div class=\"line\"></div><div class=\"line\">        int count = 0;</div><div class=\"line\">        String line;</div><div class=\"line\">        while ((line = br.readLine()) != null) &#123;</div><div class=\"line\">            // Skip comments and blank lines.</div><div class=\"line\">            // 过滤空行</div><div class=\"line\">            line = line.trim();</div><div class=\"line\">            if (line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;)) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadClass &quot; + line);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (false) &#123;</div><div class=\"line\">                    Log.v(TAG, &quot;Preloading &quot; + line + &quot;...&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Load and explicitly initialize the given class. Use</div><div class=\"line\">                // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups</div><div class=\"line\">                // (to derive the caller&apos;s class-loader). Use true to force initialization, and</div><div class=\"line\">                // null for the boot classpath class-loader (could as well cache the</div><div class=\"line\">                // class-loader of this class in a variable).</div><div class=\"line\">                // 加载并且明确地初始化指定的类</div><div class=\"line\">                // 使用反射避免重复的栈查找</div><div class=\"line\">                // true用来强制初始化</div><div class=\"line\">                // null表示使用根路径的类加载器</div><div class=\"line\">                Class.forName(line, true, null);</div><div class=\"line\">                count++;</div><div class=\"line\">            &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;Class not found for preloading: &quot; + line);</div><div class=\"line\">            &#125; catch (UnsatisfiedLinkError e) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;Problem preloading &quot; + line + &quot;: &quot; + e);</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                Log.e(TAG, &quot;Error preloading &quot; + line + &quot;.&quot;, t);</div><div class=\"line\">                if (t instanceof Error) &#123;</div><div class=\"line\">                    throw (Error) t;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (t instanceof RuntimeException) &#123;</div><div class=\"line\">                    throw (RuntimeException) t;</div><div class=\"line\">                &#125;</div><div class=\"line\">                throw new RuntimeException(t);</div><div class=\"line\">            &#125;</div><div class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Log.i(TAG, &quot;...preloaded &quot; + count + &quot; classes in &quot;</div><div class=\"line\">                + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);//打印预加载时间</div><div class=\"line\">    &#125; catch (IOException e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Error reading &quot; + PRELOADED_CLASSES + &quot;.&quot;, e);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        IoUtils.closeQuietly(is);</div><div class=\"line\">        // Restore default.</div><div class=\"line\">        runtime.setTargetHeapUtilization(defaultUtilization);</div><div class=\"line\"></div><div class=\"line\">        // Fill in dex caches with classes, fields, and methods brought in by preloading.</div><div class=\"line\">        // 用预加载的类，字段，方法填充dex缓存空间。</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadDexCaches&quot;);</div><div class=\"line\">        runtime.preloadDexCaches();</div><div class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\"></div><div class=\"line\">        // Bring back root. We&apos;ll need it later if we&apos;re in the zygote.</div><div class=\"line\">        // 恢复root权限。如果在zygote中，待会儿要用。</div><div class=\"line\">        if (droppedPriviliges) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                Os.setreuid(ROOT_UID, ROOT_UID);</div><div class=\"line\">                Os.setregid(ROOT_GID, ROOT_GID);</div><div class=\"line\">            &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Failed to restore root&quot;, ex);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>预加载公共资源</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Used to pre-load resources.  We hold a global reference on it so it</div><div class=\"line\"> * never gets destroyed.</div><div class=\"line\"> * 用来预加载资源。对其持有全局引用，因此永远不会被销毁。</div><div class=\"line\"> */</div><div class=\"line\">private static Resources mResources;</div><div class=\"line\">private static void preloadResources() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        mResources = Resources.getSystem();</div><div class=\"line\">        mResources.startPreloading();</div><div class=\"line\">        if (PRELOAD_RESOURCES) &#123;</div><div class=\"line\">            Log.i(TAG, &quot;Preloading resources...&quot;);</div><div class=\"line\"></div><div class=\"line\">            long startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_drawables);//要预加载的资源</div><div class=\"line\">            int N = preloadDrawables(ar); //预加载drawables</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);//预加载drawables使用的时间</div><div class=\"line\"></div><div class=\"line\">            startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_color_state_lists);</div><div class=\"line\">            N = preloadColorStateLists(ar);//预加载color state</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);//预加载color state使用的时间</div><div class=\"line\"></div><div class=\"line\">            //The device supports freeform window management. Windows have title bars and can be moved</div><div class=\"line\">            //and resized. If you set this to true, you also need to add</div><div class=\"line\">            //PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT feature to your device specification.</div><div class=\"line\">            //The duplication is necessary, because this information is used before the features are</div><div class=\"line\">            //available to the system.</div><div class=\"line\">            if (mResources.getBoolean(</div><div class=\"line\">                    com.android.internal.R.bool.config_freeformWindowManagement)) &#123;</div><div class=\"line\">                    //如果支持自由的窗口管理，预加载多窗口drawables</div><div class=\"line\">                startTime = SystemClock.uptimeMillis();</div><div class=\"line\">                ar = mResources.obtainTypedArray(</div><div class=\"line\">                        com.android.internal.R.array.preloaded_freeform_multi_window_drawables);</div><div class=\"line\">                N = preloadDrawables(ar);</div><div class=\"line\">                ar.recycle();</div><div class=\"line\">                Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resource in &quot;</div><div class=\"line\">                        + (SystemClock.uptimeMillis() - startTime) + &quot;ms.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mResources.finishPreloading();</div><div class=\"line\">    &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">        Log.w(TAG, &quot;Failure preloading resources&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>停止无多线程模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZygoteHooks.stopZygoteNoThreadCreation();</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建SystemServer</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (startSystemServer) &#123;   //startSysteServer为true  </div><div class=\"line\">    startSystemServer(abiList, socketName);     </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  <a href=\"#孵化 SystemServer 进程\">孵化 SystemServer 进程</a></p>\n<ul>\n<li>等待接受应用的socket请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"孵化-SystemServer-进程\"><a href=\"#孵化-SystemServer-进程\" class=\"headerlink\" title=\"孵化 SystemServer 进程\"></a>孵化 SystemServer 进程</h3><p><img src=\"/imges/system_server.png\" alt=\"system_server\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Prepare the arguments and fork for the system server process.</div><div class=\"line\"> */</div><div class=\"line\">private static boolean startSystemServer(String abiList, String socketName)</div><div class=\"line\">        throws MethodAndArgsCaller, RuntimeException &#123;</div><div class=\"line\">    long capabilities = posixCapabilitiesAsBits(</div><div class=\"line\">        OsConstants.CAP_IPC_LOCK,</div><div class=\"line\">        OsConstants.CAP_KILL,</div><div class=\"line\">        OsConstants.CAP_NET_ADMIN,</div><div class=\"line\">        OsConstants.CAP_NET_BIND_SERVICE,</div><div class=\"line\">        OsConstants.CAP_NET_BROADCAST,</div><div class=\"line\">        OsConstants.CAP_NET_RAW,</div><div class=\"line\">        OsConstants.CAP_SYS_MODULE,</div><div class=\"line\">        OsConstants.CAP_SYS_NICE,</div><div class=\"line\">        OsConstants.CAP_SYS_RESOURCE,</div><div class=\"line\">        OsConstants.CAP_SYS_TIME,</div><div class=\"line\">        OsConstants.CAP_SYS_TTY_CONFIG</div><div class=\"line\">    );</div><div class=\"line\">    /* Containers run without this capability, so avoid setting it in that case */</div><div class=\"line\">    if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) &#123;</div><div class=\"line\">        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /* Hardcoded command line to start the system server */</div><div class=\"line\">    String args[] = &#123;</div><div class=\"line\">        &quot;--setuid=1000&quot;,</div><div class=\"line\">        &quot;--setgid=1000&quot;,</div><div class=\"line\">        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010&quot;,</div><div class=\"line\">        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,</div><div class=\"line\">        &quot;--nice-name=system_server&quot;,//进程名字</div><div class=\"line\">        &quot;--runtime-args&quot;,</div><div class=\"line\">        &quot;com.android.server.SystemServer&quot;,//包名</div><div class=\"line\">    &#125;;</div><div class=\"line\">    ZygoteConnection.Arguments parsedArgs = null;</div><div class=\"line\"></div><div class=\"line\">    int pid;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        parsedArgs = new ZygoteConnection.Arguments(args);//参数封装</div><div class=\"line\">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">        /* Request to fork the system server process */</div><div class=\"line\">        pid = Zygote.forkSystemServer(//孵化系统服务进程，尝试获取pid</div><div class=\"line\">                parsedArgs.uid, parsedArgs.gid,</div><div class=\"line\">                parsedArgs.gids,</div><div class=\"line\">                parsedArgs.debugFlags,</div><div class=\"line\">                null,</div><div class=\"line\">                parsedArgs.permittedCapabilities,</div><div class=\"line\">                parsedArgs.effectiveCapabilities);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* For child process */</div><div class=\"line\">    if (pid == 0) &#123;//fork子进程成功</div><div class=\"line\">        if (hasSecondZygote(abiList)) &#123;</div><div class=\"line\">            waitForSecondaryZygote(socketName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        handleSystemServerProcess(parsedArgs);//运行系统服务，SystemServer拥有了自己的进程</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>创建SystemServer进程，android的所有服务循环框架都建立在SystemServer上</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();// 停止所有守护进程</div><div class=\"line\">    int pid = nativeForkSystemServer( //native函数孵化进程</div><div class=\"line\">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\">    // Enable tracing as soon as we enter the system_server.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon(); // 重新运行各个守护进程</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);</div></pre></td></tr></table></figure>\n<pre><code>调用底层进行fork system server进程。如果创建出的进程pid=0，说明该进程为Zygote的子进程，系统会为其设置uid，gid\n如果pid &gt; 0 ，说明该进程为SystemServer的进程号，Zygote会检查一下该进程有没有died，如果true，重启Zygote进程。\nSystemServer进程创建完成后，就会重新启动垃圾回收后台进程。\n</code></pre><ul>\n<li>运行SystemServer</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Finish remaining work for the newly forked system server process.</div><div class=\"line\"> */</div><div class=\"line\">private static void handleSystemServerProcess(</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">    closeServerSocket(); //关闭zygote中的socket</div><div class=\"line\"></div><div class=\"line\">    // set umask to 0077 so new files and directories will default to owner-only permissions.</div><div class=\"line\">    Os.umask(S_IRWXG | S_IRWXO);</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.niceName != null) &#123;</div><div class=\"line\">        Process.setArgV0(parsedArgs.niceName);// 设置进程名</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;); // 获取SystemServer的classpath</div><div class=\"line\">    if (systemServerClasspath != null) &#123;</div><div class=\"line\">        performSystemServerDexOpt(systemServerClasspath); //对改路径中的文件做dexopt优化</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">        String[] args = parsedArgs.remainingArgs;</div><div class=\"line\">        // If we have a non-null system server class path, we&apos;ll have to duplicate the</div><div class=\"line\">        // existing arguments and append the classpath to it. ART will handle the classpath</div><div class=\"line\">        // correctly when we exec a new process.</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            String[] amendedArgs = new String[args.length + 2];</div><div class=\"line\">            amendedArgs[0] = &quot;-cp&quot;;</div><div class=\"line\">            amendedArgs[1] = systemServerClasspath;</div><div class=\"line\">            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">                VMRuntime.getCurrentInstructionSet(), null, args);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ClassLoader cl = null;</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">        // 为SystemServer创建ClassLoader，使其可以进入平台的私有本地类库</div><div class=\"line\">            cl = createSystemServerClassLoader(systemServerClasspath,</div><div class=\"line\">                                               parsedArgs.targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">            Thread.currentThread().setContextClassLoader(cl);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * Pass the remaining arguments to SystemServer.</div><div class=\"line\">         * 将剩余的参数传递给SystemServer</div><div class=\"line\">         */</div><div class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* should never reach here */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SystemServer.main中创建线程注册各种service到servicemanager中。</p>\n<h4 id=\"HOME启动\"><a href=\"#HOME启动\" class=\"headerlink\" title=\"HOME启动\"></a>HOME启动</h4><p>在启动完所有的Android服务后，通知各个服务，系统已经准备就绪。</p>\n<p>startSystemUi 方法启动HOME界面。</p>\n<p>至此，android系统完成了引导过程，这是ACTION_BOOT_COMPLETED开机启动广播就会发出去。</p>\n<h3 id=\"孵化-Application-进程\"><a href=\"#孵化-Application-进程\" class=\"headerlink\" title=\"孵化 Application 进程\"></a>孵化 Application 进程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">native private static int nativeForkAndSpecialize(int uid, int gid, int[] gids,int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir);</div></pre></td></tr></table></figure>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>为所有Java程序复刻一个虚拟机实例</li>\n<li>应用程序的入口是<code>ActivityThread$main()</code>，而zygote就是为应用程序创建进程的</li>\n<li><p>大部分应用程序由zygote创建进程，但是系统引导进程、init进程不是</p>\n<h4 id=\"android中的zygote分两块\"><a href=\"#android中的zygote分两块\" class=\"headerlink\" title=\"android中的zygote分两块\"></a>android中的zygote分两块</h4><ol>\n<li>C/C++编写的zygote，主要用来为系统服务和应用程序复刻进程的</li>\n<li>Java编写的zygote接口，负责为系统服务和应用程序调用C/C++ zygote接口执行复刻，创建虚拟机进程</li>\n</ol>\n<h4 id=\"android中的service分两种\"><a href=\"#android中的service分两种\" class=\"headerlink\" title=\"android中的service分两种\"></a>android中的service分两种</h4><ol>\n<li>NativeService</li>\n<li>SystemService，即本project示例集所研究</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"zygot-孵化器\"><a href=\"#zygot-孵化器\" class=\"headerlink\" title=\"zygot 孵化器\"></a>zygot 孵化器</h1><ul>\n<li><a href=\"#系统启动-zygote-进程\">系统启动 zygote 进程</a></li>\n<li><a href=\"#系统进入-zygote-进程\">系统进入zygote进程</a><ul>\n<li><a href=\"#启用无多线程模式\">启用无多线程模式</a></li>\n<li><a href=\"#获取底层传入-main-函数的参数\">获取底层传入main函数的参数</a></li>\n<li><a href=\"#注册-Socket-，用于进程间通信\">注册Socket，用于进程间通信</a></li>\n<li><a href=\"#预加载公共类与资源\">预加载公共类与资源</a><ul>\n<li><a href=\"#预加载公共类\">预加载公共类</a></li>\n<li><a href=\"#预加载公共资源\">预加载公共资源</a></li>\n</ul>\n</li>\n<li><a href=\"#停止无多线程模式\">停止无多线程模式</a></li>\n<li><a href=\"#创建-SystemServer\">创建SystemServer</a></li>\n<li><a href=\"#等待接受应用的-socket-请求\">等待接受应用的socket请求</a></li>\n</ul>\n</li>\n<li><a href=\"#孵化-systemserver-进程\">孵化SystemServer进程</a></li>\n<li><a href=\"#孵化-application-进程\">孵化 Application 进程</a></li>\n<li><a href=\"#tips\">Tips</a></li>\n</ul>\n<h3 id=\"系统启动-zygote-进程\"><a href=\"#系统启动-zygote-进程\" class=\"headerlink\" title=\"系统启动 zygote 进程\"></a>系统启动 zygote 进程</h3><p>即android系统的启动，分为以下几步：</p>\n<ul>\n<li><em>启动电源以及系统启动</em><br>按下电源键时，引导芯片代码开始从预定义的地方(固化在ROM)开始执行。加载引导程序Bootloader到RAM，然后执行</li>\n<li><em>引导程序Bootloader</em><br>引导程序是在Android OS开始运行前的一个小程序，它的主要作用是把OS拉起来并运行</li>\n<li><em>Linux内核启动</em><br>内核启动时，设置缓存，被保护存储器，加载列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找init文件，<br>然后启动root进程或者系统的第一个进程</li>\n<li><em>init进程启动</em><ul>\n<li>创建一些文件夹并挂载设备</li>\n<li>初始化和启动属性服务(类似win平台的注册表)</li>\n<li>解析init.rc配置文件并启动zygote进程</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://blog.jobbole.com/67931/\" target=\"_blank\" rel=\"external\">android 系统启动过程</a></p>\n<p><a href=\"http://blog.csdn.net/fu_kevin0606/article/details/53469076\" target=\"_blank\" rel=\"external\">init.rc代码启动zygote进程</a></p>\n<p><a href=\"http://blog.csdn.net/hongbochen1223/article/details/56331690\" target=\"_blank\" rel=\"external\">Android初始化语言</a></p>\n<p><a href=\"https://github.com/StephenRJ/cm12_system_core_rootdir\" target=\"_blank\" rel=\"external\">init.rc源码</a>，基于aosp的，是cm的，cm现在也没了。。</p>\n<p><img src=\"/images/app_main.png\" alt=\"p\"></p>\n<h3 id=\"系统进入-zygote-进程\"><a href=\"#系统进入-zygote-进程\" class=\"headerlink\" title=\"系统进入 zygote 进程\"></a>系统进入 zygote 进程</h3><p>即zygote的初始化，在调用完ZygoteInit的main函数后，Zygote就进入了Java世界，在此可以看到启动动画。<br><img src=\"/images/ZygoteInit.png\" alt=\"p\"></p>\n<ul>\n<li><p>启用无多线程模式</p>\n<p>标志着孵化器开始，确保创建子线程会抛出异常<br>考虑到多线程下，资源尚未加载完成的处理问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZygoteHooks.startZygoteNoThreadCreation();</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取底层传入main函数的参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean startSystemServer = false;</div><div class=\"line\">String socketName = &quot;zygote&quot;; //socketName为zygote</div><div class=\"line\">String abiList = null;</div><div class=\"line\">for (int i = 1; i &lt; argv.length; i++) &#123;</div><div class=\"line\">    if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</div><div class=\"line\">        startSystemServer = true; //start-system-server 在参数列表中，startSystemServer为true</div><div class=\"line\">    &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</div><div class=\"line\">        abiList = argv[i].substring(ABI_LIST_ARG.length());//设置abi列表</div><div class=\"line\">    &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</div><div class=\"line\">        socketName = argv[i].substring(SOCKET_NAME_ARG.length()); //如果参数列表指定了socketName，就重新设置socketName</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>注册Socket，用于进程间通信</p>\n<p> Socket的监听方式为使用Linux系统调用select()函数监听文件描述符，当该文件描述符上有数据时，自动触发中断，在中断处理函数中去读取文件描述符上的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void registerZygoteSocket(String socketName) &#123;</div><div class=\"line\">    if (sServerSocket == null) &#123;</div><div class=\"line\">        int fileDesc;</div><div class=\"line\">        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;//拼接完整的socketName</div><div class=\"line\">        try &#123;</div><div class=\"line\">            String env = System.getenv(fullSocketName);//获取环境变量</div><div class=\"line\">            fileDesc = Integer.parseInt(env);</div><div class=\"line\">        &#125; catch (RuntimeException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            FileDescriptor fd = new FileDescriptor();</div><div class=\"line\">            fd.setInt$(fileDesc);//设置文件描述符</div><div class=\"line\">            sServerSocket = new LocalServerSocket(fd);</div><div class=\"line\">        &#125; catch (IOException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(</div><div class=\"line\">                    &quot;Error binding to local socket &apos;&quot; + fileDesc + &quot;&apos;&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>预加载公共类与资源</p>\n<p>  在Android系统中有很多的公共资源，所有的程序都会用到。而Zygote创建应用程序进程过程，其实就是复制自身进程地址空间作为应用程序进程的地址空间，因此在Zygote中<br>  加载的类和资源都可以由Zygote孵化的应用程序共享。因此可以在Zygote中加载公共类与资源，当某个应用程序启动时，只要加载自身特有的类与资源即可，可以提高软件的启动速度。<br>  代价是增加了系统重启的时间。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">static void preload() &#123;</div><div class=\"line\">    Log.d(TAG, &quot;begin preload&quot;);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;BeginIcuCachePinning&quot;);</div><div class=\"line\">    beginIcuCachePinning();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadClasses&quot;);</div><div class=\"line\">    preloadClasses();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadResources&quot;);</div><div class=\"line\">    preloadResources();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadOpenGL&quot;);</div><div class=\"line\">    preloadOpenGL();</div><div class=\"line\">    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">    preloadSharedLibraries();</div><div class=\"line\">    preloadTextResources();</div><div class=\"line\">    // Ask the WebViewFactory to do any initialization that must run in the zygote process,</div><div class=\"line\">    // for memory sharing purposes.</div><div class=\"line\">    WebViewFactory.prepareWebViewInZygote();</div><div class=\"line\">    endIcuCachePinning();</div><div class=\"line\">    warmUpJcaProviders();</div><div class=\"line\">    Log.d(TAG, &quot;end preload&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>预加载公共类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * The path of a file that contains classes to preload.</div><div class=\"line\"> * 预加载类的文件路径</div><div class=\"line\"> */</div><div class=\"line\">private static final String PRELOADED_CLASSES = &quot;/system/etc/preloaded-classes&quot;;</div><div class=\"line\">private static final int UNPRIVILEGED_GID = 9999;</div><div class=\"line\">private static final int ROOT_UID = 0;</div><div class=\"line\"></div><div class=\"line\">private static void preloadClasses() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    InputStream is;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        is = new FileInputStream(PRELOADED_CLASSES);//将classes文件转变为文件输入流</div><div class=\"line\">    &#125; catch (FileNotFoundException e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Couldn&apos;t find &quot; + PRELOADED_CLASSES + &quot;.&quot;);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    Log.i(TAG, &quot;Preloading classes...&quot;);</div><div class=\"line\">    long startTime = SystemClock.uptimeMillis();//开始预加载的时间</div><div class=\"line\"></div><div class=\"line\">    // Drop root perms while running static initializers.</div><div class=\"line\">    // 运行静态初始化时，废弃root权限</div><div class=\"line\">    final int reuid = Os.getuid();</div><div class=\"line\">    final int regid = Os.getgid();</div><div class=\"line\"></div><div class=\"line\">    // We need to drop root perms only if we&apos;re already root. In the case of &quot;wrapped&quot;</div><div class=\"line\">    // processes (see WrapperInit), this function is called from an unprivileged uid</div><div class=\"line\">    // and gid.</div><div class=\"line\">    // 已经root的设备我们需要废弃root权限。</div><div class=\"line\">    boolean droppedPriviliges = false;</div><div class=\"line\">    if (reuid == ROOT_UID &amp;&amp; regid == ROOT_GID) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.setregid(ROOT_GID, UNPRIVILEGED_GID);</div><div class=\"line\">            Os.setreuid(ROOT_UID, UNPRIVILEGED_UID);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;Failed to drop root&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        droppedPriviliges = true;//废弃root特权</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Alter the target heap utilization.  With explicit GCs this</div><div class=\"line\">    // is not likely to have any effect.</div><div class=\"line\">    float defaultUtilization = runtime.getTargetHeapUtilization();</div><div class=\"line\">    runtime.setTargetHeapUtilization(0.8f);</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        BufferedReader br</div><div class=\"line\">            = new BufferedReader(new InputStreamReader(is), 256);//classes文件输入流封装成BufferReader</div><div class=\"line\"></div><div class=\"line\">        int count = 0;</div><div class=\"line\">        String line;</div><div class=\"line\">        while ((line = br.readLine()) != null) &#123;</div><div class=\"line\">            // Skip comments and blank lines.</div><div class=\"line\">            // 过滤空行</div><div class=\"line\">            line = line.trim();</div><div class=\"line\">            if (line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;)) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadClass &quot; + line);</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (false) &#123;</div><div class=\"line\">                    Log.v(TAG, &quot;Preloading &quot; + line + &quot;...&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Load and explicitly initialize the given class. Use</div><div class=\"line\">                // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups</div><div class=\"line\">                // (to derive the caller&apos;s class-loader). Use true to force initialization, and</div><div class=\"line\">                // null for the boot classpath class-loader (could as well cache the</div><div class=\"line\">                // class-loader of this class in a variable).</div><div class=\"line\">                // 加载并且明确地初始化指定的类</div><div class=\"line\">                // 使用反射避免重复的栈查找</div><div class=\"line\">                // true用来强制初始化</div><div class=\"line\">                // null表示使用根路径的类加载器</div><div class=\"line\">                Class.forName(line, true, null);</div><div class=\"line\">                count++;</div><div class=\"line\">            &#125; catch (ClassNotFoundException e) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;Class not found for preloading: &quot; + line);</div><div class=\"line\">            &#125; catch (UnsatisfiedLinkError e) &#123;</div><div class=\"line\">                Log.w(TAG, &quot;Problem preloading &quot; + line + &quot;: &quot; + e);</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                Log.e(TAG, &quot;Error preloading &quot; + line + &quot;.&quot;, t);</div><div class=\"line\">                if (t instanceof Error) &#123;</div><div class=\"line\">                    throw (Error) t;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (t instanceof RuntimeException) &#123;</div><div class=\"line\">                    throw (RuntimeException) t;</div><div class=\"line\">                &#125;</div><div class=\"line\">                throw new RuntimeException(t);</div><div class=\"line\">            &#125;</div><div class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Log.i(TAG, &quot;...preloaded &quot; + count + &quot; classes in &quot;</div><div class=\"line\">                + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);//打印预加载时间</div><div class=\"line\">    &#125; catch (IOException e) &#123;</div><div class=\"line\">        Log.e(TAG, &quot;Error reading &quot; + PRELOADED_CLASSES + &quot;.&quot;, e);</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        IoUtils.closeQuietly(is);</div><div class=\"line\">        // Restore default.</div><div class=\"line\">        runtime.setTargetHeapUtilization(defaultUtilization);</div><div class=\"line\"></div><div class=\"line\">        // Fill in dex caches with classes, fields, and methods brought in by preloading.</div><div class=\"line\">        // 用预加载的类，字段，方法填充dex缓存空间。</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadDexCaches&quot;);</div><div class=\"line\">        runtime.preloadDexCaches();</div><div class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);</div><div class=\"line\"></div><div class=\"line\">        // Bring back root. We&apos;ll need it later if we&apos;re in the zygote.</div><div class=\"line\">        // 恢复root权限。如果在zygote中，待会儿要用。</div><div class=\"line\">        if (droppedPriviliges) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                Os.setreuid(ROOT_UID, ROOT_UID);</div><div class=\"line\">                Os.setregid(ROOT_GID, ROOT_GID);</div><div class=\"line\">            &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Failed to restore root&quot;, ex);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>预加载公共资源</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Used to pre-load resources.  We hold a global reference on it so it</div><div class=\"line\"> * never gets destroyed.</div><div class=\"line\"> * 用来预加载资源。对其持有全局引用，因此永远不会被销毁。</div><div class=\"line\"> */</div><div class=\"line\">private static Resources mResources;</div><div class=\"line\">private static void preloadResources() &#123;</div><div class=\"line\">    final VMRuntime runtime = VMRuntime.getRuntime();</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        mResources = Resources.getSystem();</div><div class=\"line\">        mResources.startPreloading();</div><div class=\"line\">        if (PRELOAD_RESOURCES) &#123;</div><div class=\"line\">            Log.i(TAG, &quot;Preloading resources...&quot;);</div><div class=\"line\"></div><div class=\"line\">            long startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            TypedArray ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_drawables);//要预加载的资源</div><div class=\"line\">            int N = preloadDrawables(ar); //预加载drawables</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);//预加载drawables使用的时间</div><div class=\"line\"></div><div class=\"line\">            startTime = SystemClock.uptimeMillis();</div><div class=\"line\">            ar = mResources.obtainTypedArray(</div><div class=\"line\">                    com.android.internal.R.array.preloaded_color_state_lists);</div><div class=\"line\">            N = preloadColorStateLists(ar);//预加载color state</div><div class=\"line\">            ar.recycle();</div><div class=\"line\">            Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resources in &quot;</div><div class=\"line\">                    + (SystemClock.uptimeMillis()-startTime) + &quot;ms.&quot;);//预加载color state使用的时间</div><div class=\"line\"></div><div class=\"line\">            //The device supports freeform window management. Windows have title bars and can be moved</div><div class=\"line\">            //and resized. If you set this to true, you also need to add</div><div class=\"line\">            //PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT feature to your device specification.</div><div class=\"line\">            //The duplication is necessary, because this information is used before the features are</div><div class=\"line\">            //available to the system.</div><div class=\"line\">            if (mResources.getBoolean(</div><div class=\"line\">                    com.android.internal.R.bool.config_freeformWindowManagement)) &#123;</div><div class=\"line\">                    //如果支持自由的窗口管理，预加载多窗口drawables</div><div class=\"line\">                startTime = SystemClock.uptimeMillis();</div><div class=\"line\">                ar = mResources.obtainTypedArray(</div><div class=\"line\">                        com.android.internal.R.array.preloaded_freeform_multi_window_drawables);</div><div class=\"line\">                N = preloadDrawables(ar);</div><div class=\"line\">                ar.recycle();</div><div class=\"line\">                Log.i(TAG, &quot;...preloaded &quot; + N + &quot; resource in &quot;</div><div class=\"line\">                        + (SystemClock.uptimeMillis() - startTime) + &quot;ms.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mResources.finishPreloading();</div><div class=\"line\">    &#125; catch (RuntimeException e) &#123;</div><div class=\"line\">        Log.w(TAG, &quot;Failure preloading resources&quot;, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>停止无多线程模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ZygoteHooks.stopZygoteNoThreadCreation();</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建SystemServer</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (startSystemServer) &#123;   //startSysteServer为true  </div><div class=\"line\">    startSystemServer(abiList, socketName);     </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  <a href=\"#孵化 SystemServer 进程\">孵化 SystemServer 进程</a></p>\n<ul>\n<li>等待接受应用的socket请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</div><div class=\"line\">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</div><div class=\"line\">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</div><div class=\"line\"></div><div class=\"line\">    fds.add(sServerSocket.getFileDescriptor());</div><div class=\"line\">    peers.add(null);</div><div class=\"line\"></div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</div><div class=\"line\">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</div><div class=\"line\">            pollFds[i] = new StructPollfd();</div><div class=\"line\">            pollFds[i].fd = fds.get(i);</div><div class=\"line\">            pollFds[i].events = (short) POLLIN;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            Os.poll(pollFds, -1);</div><div class=\"line\">        &#125; catch (ErrnoException ex) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;poll failed&quot;, ex);</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</div><div class=\"line\">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</div><div class=\"line\">                peers.add(newPeer);</div><div class=\"line\">                fds.add(newPeer.getFileDesciptor());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                boolean done = peers.get(i).runOnce();</div><div class=\"line\">                if (done) &#123;</div><div class=\"line\">                    peers.remove(i);</div><div class=\"line\">                    fds.remove(i);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"孵化-SystemServer-进程\"><a href=\"#孵化-SystemServer-进程\" class=\"headerlink\" title=\"孵化 SystemServer 进程\"></a>孵化 SystemServer 进程</h3><p><img src=\"/imges/system_server.png\" alt=\"system_server\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Prepare the arguments and fork for the system server process.</div><div class=\"line\"> */</div><div class=\"line\">private static boolean startSystemServer(String abiList, String socketName)</div><div class=\"line\">        throws MethodAndArgsCaller, RuntimeException &#123;</div><div class=\"line\">    long capabilities = posixCapabilitiesAsBits(</div><div class=\"line\">        OsConstants.CAP_IPC_LOCK,</div><div class=\"line\">        OsConstants.CAP_KILL,</div><div class=\"line\">        OsConstants.CAP_NET_ADMIN,</div><div class=\"line\">        OsConstants.CAP_NET_BIND_SERVICE,</div><div class=\"line\">        OsConstants.CAP_NET_BROADCAST,</div><div class=\"line\">        OsConstants.CAP_NET_RAW,</div><div class=\"line\">        OsConstants.CAP_SYS_MODULE,</div><div class=\"line\">        OsConstants.CAP_SYS_NICE,</div><div class=\"line\">        OsConstants.CAP_SYS_RESOURCE,</div><div class=\"line\">        OsConstants.CAP_SYS_TIME,</div><div class=\"line\">        OsConstants.CAP_SYS_TTY_CONFIG</div><div class=\"line\">    );</div><div class=\"line\">    /* Containers run without this capability, so avoid setting it in that case */</div><div class=\"line\">    if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) &#123;</div><div class=\"line\">        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /* Hardcoded command line to start the system server */</div><div class=\"line\">    String args[] = &#123;</div><div class=\"line\">        &quot;--setuid=1000&quot;,</div><div class=\"line\">        &quot;--setgid=1000&quot;,</div><div class=\"line\">        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010&quot;,</div><div class=\"line\">        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,</div><div class=\"line\">        &quot;--nice-name=system_server&quot;,//进程名字</div><div class=\"line\">        &quot;--runtime-args&quot;,</div><div class=\"line\">        &quot;com.android.server.SystemServer&quot;,//包名</div><div class=\"line\">    &#125;;</div><div class=\"line\">    ZygoteConnection.Arguments parsedArgs = null;</div><div class=\"line\"></div><div class=\"line\">    int pid;</div><div class=\"line\"></div><div class=\"line\">    try &#123;</div><div class=\"line\">        parsedArgs = new ZygoteConnection.Arguments(args);//参数封装</div><div class=\"line\">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</div><div class=\"line\">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</div><div class=\"line\"></div><div class=\"line\">        /* Request to fork the system server process */</div><div class=\"line\">        pid = Zygote.forkSystemServer(//孵化系统服务进程，尝试获取pid</div><div class=\"line\">                parsedArgs.uid, parsedArgs.gid,</div><div class=\"line\">                parsedArgs.gids,</div><div class=\"line\">                parsedArgs.debugFlags,</div><div class=\"line\">                null,</div><div class=\"line\">                parsedArgs.permittedCapabilities,</div><div class=\"line\">                parsedArgs.effectiveCapabilities);</div><div class=\"line\">    &#125; catch (IllegalArgumentException ex) &#123;</div><div class=\"line\">        throw new RuntimeException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* For child process */</div><div class=\"line\">    if (pid == 0) &#123;//fork子进程成功</div><div class=\"line\">        if (hasSecondZygote(abiList)) &#123;</div><div class=\"line\">            waitForSecondaryZygote(socketName);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        handleSystemServerProcess(parsedArgs);//运行系统服务，SystemServer拥有了自己的进程</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>创建SystemServer进程，android的所有服务循环框架都建立在SystemServer上</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();// 停止所有守护进程</div><div class=\"line\">    int pid = nativeForkSystemServer( //native函数孵化进程</div><div class=\"line\">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</div><div class=\"line\">    // Enable tracing as soon as we enter the system_server.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon(); // 重新运行各个守护进程</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">native private static int nativeForkSystemServer(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities);</div></pre></td></tr></table></figure>\n<pre><code>调用底层进行fork system server进程。如果创建出的进程pid=0，说明该进程为Zygote的子进程，系统会为其设置uid，gid\n如果pid &gt; 0 ，说明该进程为SystemServer的进程号，Zygote会检查一下该进程有没有died，如果true，重启Zygote进程。\nSystemServer进程创建完成后，就会重新启动垃圾回收后台进程。\n</code></pre><ul>\n<li>运行SystemServer</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Finish remaining work for the newly forked system server process.</div><div class=\"line\"> */</div><div class=\"line\">private static void handleSystemServerProcess(</div><div class=\"line\">        ZygoteConnection.Arguments parsedArgs)</div><div class=\"line\">        throws ZygoteInit.MethodAndArgsCaller &#123;</div><div class=\"line\"></div><div class=\"line\">    closeServerSocket(); //关闭zygote中的socket</div><div class=\"line\"></div><div class=\"line\">    // set umask to 0077 so new files and directories will default to owner-only permissions.</div><div class=\"line\">    Os.umask(S_IRWXG | S_IRWXO);</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.niceName != null) &#123;</div><div class=\"line\">        Process.setArgV0(parsedArgs.niceName);// 设置进程名</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;); // 获取SystemServer的classpath</div><div class=\"line\">    if (systemServerClasspath != null) &#123;</div><div class=\"line\">        performSystemServerDexOpt(systemServerClasspath); //对改路径中的文件做dexopt优化</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (parsedArgs.invokeWith != null) &#123;</div><div class=\"line\">        String[] args = parsedArgs.remainingArgs;</div><div class=\"line\">        // If we have a non-null system server class path, we&apos;ll have to duplicate the</div><div class=\"line\">        // existing arguments and append the classpath to it. ART will handle the classpath</div><div class=\"line\">        // correctly when we exec a new process.</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">            String[] amendedArgs = new String[args.length + 2];</div><div class=\"line\">            amendedArgs[0] = &quot;-cp&quot;;</div><div class=\"line\">            amendedArgs[1] = systemServerClasspath;</div><div class=\"line\">            System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        WrapperInit.execApplication(parsedArgs.invokeWith,</div><div class=\"line\">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</div><div class=\"line\">                VMRuntime.getCurrentInstructionSet(), null, args);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ClassLoader cl = null;</div><div class=\"line\">        if (systemServerClasspath != null) &#123;</div><div class=\"line\">        // 为SystemServer创建ClassLoader，使其可以进入平台的私有本地类库</div><div class=\"line\">            cl = createSystemServerClassLoader(systemServerClasspath,</div><div class=\"line\">                                               parsedArgs.targetSdkVersion);</div><div class=\"line\"></div><div class=\"line\">            Thread.currentThread().setContextClassLoader(cl);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">         * Pass the remaining arguments to SystemServer.</div><div class=\"line\">         * 将剩余的参数传递给SystemServer</div><div class=\"line\">         */</div><div class=\"line\">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /* should never reach here */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SystemServer.main中创建线程注册各种service到servicemanager中。</p>\n<h4 id=\"HOME启动\"><a href=\"#HOME启动\" class=\"headerlink\" title=\"HOME启动\"></a>HOME启动</h4><p>在启动完所有的Android服务后，通知各个服务，系统已经准备就绪。</p>\n<p>startSystemUi 方法启动HOME界面。</p>\n<p>至此，android系统完成了引导过程，这是ACTION_BOOT_COMPLETED开机启动广播就会发出去。</p>\n<h3 id=\"孵化-Application-进程\"><a href=\"#孵化-Application-进程\" class=\"headerlink\" title=\"孵化 Application 进程\"></a>孵化 Application 进程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir) &#123;</div><div class=\"line\">    VM_HOOKS.preFork();</div><div class=\"line\">    int pid = nativeForkAndSpecialize(</div><div class=\"line\">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</div><div class=\"line\">              instructionSet, appDataDir);</div><div class=\"line\">    // Enable tracing as soon as possible for the child process.</div><div class=\"line\">    if (pid == 0) &#123;</div><div class=\"line\">        Trace.setTracingEnabled(true);</div><div class=\"line\"></div><div class=\"line\">        // Note that this event ends at the end of handleChildProc,</div><div class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;PostFork&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    VM_HOOKS.postForkCommon();</div><div class=\"line\">    return pid;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">native private static int nativeForkAndSpecialize(int uid, int gid, int[] gids,int debugFlags,</div><div class=\"line\">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</div><div class=\"line\">      String instructionSet, String appDataDir);</div></pre></td></tr></table></figure>\n<h3 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h3><ul>\n<li>为所有Java程序复刻一个虚拟机实例</li>\n<li>应用程序的入口是<code>ActivityThread$main()</code>，而zygote就是为应用程序创建进程的</li>\n<li><p>大部分应用程序由zygote创建进程，但是系统引导进程、init进程不是</p>\n<h4 id=\"android中的zygote分两块\"><a href=\"#android中的zygote分两块\" class=\"headerlink\" title=\"android中的zygote分两块\"></a>android中的zygote分两块</h4><ol>\n<li>C/C++编写的zygote，主要用来为系统服务和应用程序复刻进程的</li>\n<li>Java编写的zygote接口，负责为系统服务和应用程序调用C/C++ zygote接口执行复刻，创建虚拟机进程</li>\n</ol>\n<h4 id=\"android中的service分两种\"><a href=\"#android中的service分两种\" class=\"headerlink\" title=\"android中的service分两种\"></a>android中的service分两种</h4><ol>\n<li>NativeService</li>\n<li>SystemService，即本project示例集所研究</li>\n</ol>\n</li>\n</ul>\n"},{"title":"Android 内存泄露","date":"2017-11-09T00:00:00.000Z","_content":"\n#### 什么是内存泄露\n\njvm会根据可达性算法,计算每个对象是否可被回收,如果有对象被持有引用,即可达,并且该对象已经无用.此时对象不可被回收但是占用内存的这种状态成为内存泄露.如果内存泄露情况比较多,很有可能引起OOM异常.\n\n#### 原因\n\n* 根源在android组件的生命周期和底层Java对象的生命周期不是直接匹配的\n* 一个应用程序的启动分为三步:\n\t* 复刻受精卵进程\n\t* 系统为该进程添加运行时执行环境\n\t* 运行时执行环境加载可执行文件,即调用onCreate()方法启动应用程序\n* 应用程序的生命周期理想状态下,是在运行时调用onTerminate()方法是结束,但一般情况下都不会如此.应用程序的生命周期是从第一个的组件被创建到最后一个组件被销毁,很有可能在onTerminate()方法还没有调用,当前进程已经被回收掉了.即应用程序的存活时间小于了Java对象的存活时间.\n* 简单来说,就是长生命周期的对象引用了短生命周期的对象\n* 应用程序生命周期内,考虑多线程情况下,线程的存活时间取决于当前任务的长度,任务就是应用程序代码定义的,CPU有序顺序执行的指令,所以线程如果比所在组件生命长,很有可能是这样,往往容易引起内存泄露\n\n#### 常见情况及解决\n\n| 情况 | 解决 |\n|:---:|:---:|\n| Thread + Handler | 优先考虑静态成员类 |\n| 数据库连接,IO,Socket连接,Bitmap | 及时关闭,及时释放 |\n| 静态容器,静态类,持有对短生命周期的对象 | 及时删除对象,使用弱引用,软引用 |\n","source":"_posts/2017-11-09-android-memory-leak.md","raw":"---\ntitle: Android 内存泄露\ndate: 2017-11-09\ntags: android\ncategories: Android\n---\n\n#### 什么是内存泄露\n\njvm会根据可达性算法,计算每个对象是否可被回收,如果有对象被持有引用,即可达,并且该对象已经无用.此时对象不可被回收但是占用内存的这种状态成为内存泄露.如果内存泄露情况比较多,很有可能引起OOM异常.\n\n#### 原因\n\n* 根源在android组件的生命周期和底层Java对象的生命周期不是直接匹配的\n* 一个应用程序的启动分为三步:\n\t* 复刻受精卵进程\n\t* 系统为该进程添加运行时执行环境\n\t* 运行时执行环境加载可执行文件,即调用onCreate()方法启动应用程序\n* 应用程序的生命周期理想状态下,是在运行时调用onTerminate()方法是结束,但一般情况下都不会如此.应用程序的生命周期是从第一个的组件被创建到最后一个组件被销毁,很有可能在onTerminate()方法还没有调用,当前进程已经被回收掉了.即应用程序的存活时间小于了Java对象的存活时间.\n* 简单来说,就是长生命周期的对象引用了短生命周期的对象\n* 应用程序生命周期内,考虑多线程情况下,线程的存活时间取决于当前任务的长度,任务就是应用程序代码定义的,CPU有序顺序执行的指令,所以线程如果比所在组件生命长,很有可能是这样,往往容易引起内存泄露\n\n#### 常见情况及解决\n\n| 情况 | 解决 |\n|:---:|:---:|\n| Thread + Handler | 优先考虑静态成员类 |\n| 数据库连接,IO,Socket连接,Bitmap | 及时关闭,及时释放 |\n| 静态容器,静态类,持有对短生命周期的对象 | 及时删除对象,使用弱引用,软引用 |\n","slug":"android-memory-leak","published":1,"updated":"2017-11-16T09:27:41.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1iq007e2siv3ul89nco","content":"<h4 id=\"什么是内存泄露\"><a href=\"#什么是内存泄露\" class=\"headerlink\" title=\"什么是内存泄露\"></a>什么是内存泄露</h4><p>jvm会根据可达性算法,计算每个对象是否可被回收,如果有对象被持有引用,即可达,并且该对象已经无用.此时对象不可被回收但是占用内存的这种状态成为内存泄露.如果内存泄露情况比较多,很有可能引起OOM异常.</p>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><ul>\n<li>根源在android组件的生命周期和底层Java对象的生命周期不是直接匹配的</li>\n<li>一个应用程序的启动分为三步:<ul>\n<li>复刻受精卵进程</li>\n<li>系统为该进程添加运行时执行环境</li>\n<li>运行时执行环境加载可执行文件,即调用onCreate()方法启动应用程序</li>\n</ul>\n</li>\n<li>应用程序的生命周期理想状态下,是在运行时调用onTerminate()方法是结束,但一般情况下都不会如此.应用程序的生命周期是从第一个的组件被创建到最后一个组件被销毁,很有可能在onTerminate()方法还没有调用,当前进程已经被回收掉了.即应用程序的存活时间小于了Java对象的存活时间.</li>\n<li>简单来说,就是长生命周期的对象引用了短生命周期的对象</li>\n<li>应用程序生命周期内,考虑多线程情况下,线程的存活时间取决于当前任务的长度,任务就是应用程序代码定义的,CPU有序顺序执行的指令,所以线程如果比所在组件生命长,很有可能是这样,往往容易引起内存泄露</li>\n</ul>\n<h4 id=\"常见情况及解决\"><a href=\"#常见情况及解决\" class=\"headerlink\" title=\"常见情况及解决\"></a>常见情况及解决</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">情况</th>\n<th style=\"text-align:center\">解决</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Thread + Handler</td>\n<td style=\"text-align:center\">优先考虑静态成员类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数据库连接,IO,Socket连接,Bitmap</td>\n<td style=\"text-align:center\">及时关闭,及时释放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态容器,静态类,持有对短生命周期的对象</td>\n<td style=\"text-align:center\">及时删除对象,使用弱引用,软引用</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么是内存泄露\"><a href=\"#什么是内存泄露\" class=\"headerlink\" title=\"什么是内存泄露\"></a>什么是内存泄露</h4><p>jvm会根据可达性算法,计算每个对象是否可被回收,如果有对象被持有引用,即可达,并且该对象已经无用.此时对象不可被回收但是占用内存的这种状态成为内存泄露.如果内存泄露情况比较多,很有可能引起OOM异常.</p>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><ul>\n<li>根源在android组件的生命周期和底层Java对象的生命周期不是直接匹配的</li>\n<li>一个应用程序的启动分为三步:<ul>\n<li>复刻受精卵进程</li>\n<li>系统为该进程添加运行时执行环境</li>\n<li>运行时执行环境加载可执行文件,即调用onCreate()方法启动应用程序</li>\n</ul>\n</li>\n<li>应用程序的生命周期理想状态下,是在运行时调用onTerminate()方法是结束,但一般情况下都不会如此.应用程序的生命周期是从第一个的组件被创建到最后一个组件被销毁,很有可能在onTerminate()方法还没有调用,当前进程已经被回收掉了.即应用程序的存活时间小于了Java对象的存活时间.</li>\n<li>简单来说,就是长生命周期的对象引用了短生命周期的对象</li>\n<li>应用程序生命周期内,考虑多线程情况下,线程的存活时间取决于当前任务的长度,任务就是应用程序代码定义的,CPU有序顺序执行的指令,所以线程如果比所在组件生命长,很有可能是这样,往往容易引起内存泄露</li>\n</ul>\n<h4 id=\"常见情况及解决\"><a href=\"#常见情况及解决\" class=\"headerlink\" title=\"常见情况及解决\"></a>常见情况及解决</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">情况</th>\n<th style=\"text-align:center\">解决</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Thread + Handler</td>\n<td style=\"text-align:center\">优先考虑静态成员类</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数据库连接,IO,Socket连接,Bitmap</td>\n<td style=\"text-align:center\">及时关闭,及时释放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态容器,静态类,持有对短生命周期的对象</td>\n<td style=\"text-align:center\">及时删除对象,使用弱引用,软引用</td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"682. Baseball Game","date":"2017-11-21T00:00:00.000Z","_content":" \n\n\n#### 题目 ####\nYou're now a baseball game point recorder.\n\nGiven a list of strings, each string can be one of the 4 following types:\n\n1. Integer (one round's score): Directly represents the number of points you get in this round.\n2. \"+\" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.\n3. \"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.\n4. \"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.\nEach round's operation is permanent and could have an impact on the round before and the round after.\n\nYou need to return the sum of the points you could get in all the rounds.\n\nExample 1:\n\n\tInput: [\"5\",\"2\",\"C\",\"D\",\"+\"]\n\tOutput: 30\n\tExplanation: \n\tRound 1: You could get 5 points. The sum is: 5.\n\tRound 2: You could get 2 points. The sum is: 7.\n\tOperation 1: The round 2's data was invalid. The sum is: 5.  \n\tRound 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.\n\tRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n\nExample 2:\n\n\tInput: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n\tOutput: 27\n\tExplanation: \n\tRound 1: You could get 5 points. The sum is: 5.\n\tRound 2: You could get -2 points. The sum is: 3.\n\tRound 3: You could get 4 points. The sum is: 7.\n\tOperation 1: The round 3's data is invalid. The sum is: 3.  \n\tRound 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.\n\tRound 5: You could get 9 points. The sum is: 8.\n\tRound 6: You could get -4 + 9 = 5 points. The sum is 13.\n\tRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n\nNote:\n\n- The size of the input list will be between 1 and 1000.\n- Every integer represented in the list will be between -30000 and 30000.\n \n#### 解法 ####\n\n##### 7ms #####\n\n```\n   public int calPointsBestTime(String[] ops) {\n    int ans = 0;\n    int index = -1;\n    int[] valid = new int[ops.length];\n    for (int i = 0; i < ops.length; i++) {\n      if (ops[i].equals(\"C\")) {\n        ans -= valid[index--];\n        continue;\n      }\n      if (ops[i].equals(\"D\")) {\n        int d = valid[index] * 2;\n        valid[++index] = d;\n        ans += d;\n        continue;\n      }\n      if (ops[i].equals(\"+\")) {\n        int d = valid[index] + valid[index - 1];\n        valid[++index] = d;\n        ans += d;\n        continue;\n      }\n      index++;\n      valid[index] = Integer.parseInt(ops[i]);\n      ans += Integer.parseInt(ops[i]);\n    }\n    return ans;\n  }\n\n```\n\n","source":"_posts/2017-11-21-baseball-game.md","raw":"---\nlayout: post\ntitle:  682. Baseball Game\ndate:   2017-11-21\ncategories: Algorithm\ntag: [算法,PAT,LeetCode]\n---\n \n\n\n#### 题目 ####\nYou're now a baseball game point recorder.\n\nGiven a list of strings, each string can be one of the 4 following types:\n\n1. Integer (one round's score): Directly represents the number of points you get in this round.\n2. \"+\" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.\n3. \"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.\n4. \"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.\nEach round's operation is permanent and could have an impact on the round before and the round after.\n\nYou need to return the sum of the points you could get in all the rounds.\n\nExample 1:\n\n\tInput: [\"5\",\"2\",\"C\",\"D\",\"+\"]\n\tOutput: 30\n\tExplanation: \n\tRound 1: You could get 5 points. The sum is: 5.\n\tRound 2: You could get 2 points. The sum is: 7.\n\tOperation 1: The round 2's data was invalid. The sum is: 5.  \n\tRound 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.\n\tRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n\nExample 2:\n\n\tInput: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n\tOutput: 27\n\tExplanation: \n\tRound 1: You could get 5 points. The sum is: 5.\n\tRound 2: You could get -2 points. The sum is: 3.\n\tRound 3: You could get 4 points. The sum is: 7.\n\tOperation 1: The round 3's data is invalid. The sum is: 3.  \n\tRound 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.\n\tRound 5: You could get 9 points. The sum is: 8.\n\tRound 6: You could get -4 + 9 = 5 points. The sum is 13.\n\tRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n\nNote:\n\n- The size of the input list will be between 1 and 1000.\n- Every integer represented in the list will be between -30000 and 30000.\n \n#### 解法 ####\n\n##### 7ms #####\n\n```\n   public int calPointsBestTime(String[] ops) {\n    int ans = 0;\n    int index = -1;\n    int[] valid = new int[ops.length];\n    for (int i = 0; i < ops.length; i++) {\n      if (ops[i].equals(\"C\")) {\n        ans -= valid[index--];\n        continue;\n      }\n      if (ops[i].equals(\"D\")) {\n        int d = valid[index] * 2;\n        valid[++index] = d;\n        ans += d;\n        continue;\n      }\n      if (ops[i].equals(\"+\")) {\n        int d = valid[index] + valid[index - 1];\n        valid[++index] = d;\n        ans += d;\n        continue;\n      }\n      index++;\n      valid[index] = Integer.parseInt(ops[i]);\n      ans += Integer.parseInt(ops[i]);\n    }\n    return ans;\n  }\n\n```\n\n","slug":"baseball-game","published":1,"updated":"2018-01-29T07:50:15.608Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1it007h2sivkdyxu621","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>You’re now a baseball game point recorder.</p>\n<p>Given a list of strings, each string can be one of the 4 following types:</p>\n<ol>\n<li>Integer (one round’s score): Directly represents the number of points you get in this round.</li>\n<li>“+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points.</li>\n<li>“D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points.</li>\n<li>“C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed.<br>Each round’s operation is permanent and could have an impact on the round before and the round after.</li>\n</ol>\n<p>You need to return the sum of the points you could get in all the rounds.</p>\n<p>Example 1:</p>\n<pre><code>Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]\nOutput: 30\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get 2 points. The sum is: 7.\nOperation 1: The round 2&apos;s data was invalid. The sum is: 5.  \nRound 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n</code></pre><p>Example 2:</p>\n<pre><code>Input: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]\nOutput: 27\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get -2 points. The sum is: 3.\nRound 3: You could get 4 points. The sum is: 7.\nOperation 1: The round 3&apos;s data is invalid. The sum is: 3.  \nRound 4: You could get -4 points (the round 3&apos;s data has been removed). The sum is: -1.\nRound 5: You could get 9 points. The sum is: 8.\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n</code></pre><p>Note:</p>\n<ul>\n<li>The size of the input list will be between 1 and 1000.</li>\n<li>Every integer represented in the list will be between -30000 and 30000.</li>\n</ul>\n<h4 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h4><h5 id=\"7ms\"><a href=\"#7ms\" class=\"headerlink\" title=\"7ms\"></a>7ms</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public int calPointsBestTime(String[] ops) &#123;</div><div class=\"line\">  int ans = 0;</div><div class=\"line\">  int index = -1;</div><div class=\"line\">  int[] valid = new int[ops.length];</div><div class=\"line\">  for (int i = 0; i &lt; ops.length; i++) &#123;</div><div class=\"line\">    if (ops[i].equals(&quot;C&quot;)) &#123;</div><div class=\"line\">      ans -= valid[index--];</div><div class=\"line\">      continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (ops[i].equals(&quot;D&quot;)) &#123;</div><div class=\"line\">      int d = valid[index] * 2;</div><div class=\"line\">      valid[++index] = d;</div><div class=\"line\">      ans += d;</div><div class=\"line\">      continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (ops[i].equals(&quot;+&quot;)) &#123;</div><div class=\"line\">      int d = valid[index] + valid[index - 1];</div><div class=\"line\">      valid[++index] = d;</div><div class=\"line\">      ans += d;</div><div class=\"line\">      continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    index++;</div><div class=\"line\">    valid[index] = Integer.parseInt(ops[i]);</div><div class=\"line\">    ans += Integer.parseInt(ops[i]);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>You’re now a baseball game point recorder.</p>\n<p>Given a list of strings, each string can be one of the 4 following types:</p>\n<ol>\n<li>Integer (one round’s score): Directly represents the number of points you get in this round.</li>\n<li>“+” (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points.</li>\n<li>“D” (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points.</li>\n<li>“C” (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed.<br>Each round’s operation is permanent and could have an impact on the round before and the round after.</li>\n</ol>\n<p>You need to return the sum of the points you could get in all the rounds.</p>\n<p>Example 1:</p>\n<pre><code>Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]\nOutput: 30\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get 2 points. The sum is: 7.\nOperation 1: The round 2&apos;s data was invalid. The sum is: 5.  \nRound 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n</code></pre><p>Example 2:</p>\n<pre><code>Input: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]\nOutput: 27\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get -2 points. The sum is: 3.\nRound 3: You could get 4 points. The sum is: 7.\nOperation 1: The round 3&apos;s data is invalid. The sum is: 3.  \nRound 4: You could get -4 points (the round 3&apos;s data has been removed). The sum is: -1.\nRound 5: You could get 9 points. The sum is: 8.\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n</code></pre><p>Note:</p>\n<ul>\n<li>The size of the input list will be between 1 and 1000.</li>\n<li>Every integer represented in the list will be between -30000 and 30000.</li>\n</ul>\n<h4 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h4><h5 id=\"7ms\"><a href=\"#7ms\" class=\"headerlink\" title=\"7ms\"></a>7ms</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public int calPointsBestTime(String[] ops) &#123;</div><div class=\"line\">  int ans = 0;</div><div class=\"line\">  int index = -1;</div><div class=\"line\">  int[] valid = new int[ops.length];</div><div class=\"line\">  for (int i = 0; i &lt; ops.length; i++) &#123;</div><div class=\"line\">    if (ops[i].equals(&quot;C&quot;)) &#123;</div><div class=\"line\">      ans -= valid[index--];</div><div class=\"line\">      continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (ops[i].equals(&quot;D&quot;)) &#123;</div><div class=\"line\">      int d = valid[index] * 2;</div><div class=\"line\">      valid[++index] = d;</div><div class=\"line\">      ans += d;</div><div class=\"line\">      continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (ops[i].equals(&quot;+&quot;)) &#123;</div><div class=\"line\">      int d = valid[index] + valid[index - 1];</div><div class=\"line\">      valid[++index] = d;</div><div class=\"line\">      ans += d;</div><div class=\"line\">      continue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    index++;</div><div class=\"line\">    valid[index] = Integer.parseInt(ops[i]);</div><div class=\"line\">    ans += Integer.parseInt(ops[i]);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"乙1001. 害死人不偿命的(3n+1)猜想 (15)","date":"2017-12-21T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t卡拉兹(Callatz)猜想：\n\t\n\t对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n\t\n\t我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？\n\t\n\t输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。\n\t\n\t输出格式：输出从n计算到1需要的步数。\n\t\n\t输入样例：\n\t3\n\t输出样例：\n\t5\n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\tpublic class Main {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = in.nextInt();\n\t\t\tint times = 0;\n\t\t\tnum = getNum(num);\n\t\t\twhile (num != 1) {\n\t\t\t\tnum = getNum(num / 2);\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t\tSystem.out.println(times);\n\t\t}\n\t\n\t\tstatic int getNum(int num) {\n\t\t\twhile (num % 2 != 0 && num != 1) {\n\t\t\t\tnum = 3 * num + 1;\n\t\t\t}\n\t\t\treturn num;\n\t\t}\n\t\n\t}\n\n \n\n\n\n","source":"_posts/2017-12-21-pat-yi-1001.md","raw":"---\nlayout: post\ntitle:  乙1001. 害死人不偿命的(3n+1)猜想 (15)\ndate:   2017-12-21\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t卡拉兹(Callatz)猜想：\n\t\n\t对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n\t\n\t我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？\n\t\n\t输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。\n\t\n\t输出格式：输出从n计算到1需要的步数。\n\t\n\t输入样例：\n\t3\n\t输出样例：\n\t5\n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\tpublic class Main {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = in.nextInt();\n\t\t\tint times = 0;\n\t\t\tnum = getNum(num);\n\t\t\twhile (num != 1) {\n\t\t\t\tnum = getNum(num / 2);\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t\tSystem.out.println(times);\n\t\t}\n\t\n\t\tstatic int getNum(int num) {\n\t\t\twhile (num % 2 != 0 && num != 1) {\n\t\t\t\tnum = 3 * num + 1;\n\t\t\t}\n\t\t\treturn num;\n\t\t}\n\t\n\t}\n\n \n\n\n\n","slug":"pat-yi-1001","published":1,"updated":"2018-01-29T07:45:07.933Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1iw007k2sivup9hku7r","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>卡拉兹(Callatz)猜想：\n\n对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？\n\n输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。\n\n输出格式：输出从n计算到1需要的步数。\n\n输入样例：\n3\n输出样例：\n5\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = in.nextInt();\n        int times = 0;\n        num = getNum(num);\n        while (num != 1) {\n            num = getNum(num / 2);\n            times++;\n        }\n        System.out.println(times);\n    }\n\n    static int getNum(int num) {\n        while (num % 2 != 0 &amp;&amp; num != 1) {\n            num = 3 * num + 1;\n        }\n        return num;\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>卡拉兹(Callatz)猜想：\n\n对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……\n\n我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？\n\n输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。\n\n输出格式：输出从n计算到1需要的步数。\n\n输入样例：\n3\n输出样例：\n5\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = in.nextInt();\n        int times = 0;\n        num = getNum(num);\n        while (num != 1) {\n            num = getNum(num / 2);\n            times++;\n        }\n        System.out.println(times);\n    }\n\n    static int getNum(int num) {\n        while (num % 2 != 0 &amp;&amp; num != 1) {\n            num = 3 * num + 1;\n        }\n        return num;\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"乙1002. 写出这个数 (20)","date":"2017-12-21T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n\n\t输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。\n\t\n\t输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。\n\t\n\t输入样例：\n\t1234567890987654321123456789\n\t输出样例：\n\tyi san wu\n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\t\n\t/**\n\t * NO.1002:写出这个数 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1002 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tString[] com = new String[] { \"ling \", \"yi \", \"er \", \"san \", \"si \", \"wu \", \"liu \", \"qi \", \"ba \", \"jiu \" };\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString num = in.nextLine().trim();\n\t\t\tchar[] nums = num.toCharArray();\n\t\t\tint ans = 0;\n\t\t\tfor (char c : nums) {\n\t\t\t\tans += Integer.parseInt(String.valueOf(c));\n\t\t\t}\n\t\n\t\t\tString res = String.valueOf(ans);\n\t\t\tnums = res.toCharArray();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (char c : nums) {\n\t\t\t\tsb.append(com[Integer.parseInt(String.valueOf(c))]);\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString().trim());\n\t\t}\n\t\n\t}","source":"_posts/2017-12-21-pat-yi-1002.md","raw":"---\nlayout: post\ntitle:  乙1002. 写出这个数 (20)\ndate:   2017-12-21\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n\n\t输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。\n\t\n\t输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。\n\t\n\t输入样例：\n\t1234567890987654321123456789\n\t输出样例：\n\tyi san wu\n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\t\n\t/**\n\t * NO.1002:写出这个数 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1002 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tString[] com = new String[] { \"ling \", \"yi \", \"er \", \"san \", \"si \", \"wu \", \"liu \", \"qi \", \"ba \", \"jiu \" };\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString num = in.nextLine().trim();\n\t\t\tchar[] nums = num.toCharArray();\n\t\t\tint ans = 0;\n\t\t\tfor (char c : nums) {\n\t\t\t\tans += Integer.parseInt(String.valueOf(c));\n\t\t\t}\n\t\n\t\t\tString res = String.valueOf(ans);\n\t\t\tnums = res.toCharArray();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (char c : nums) {\n\t\t\t\tsb.append(com[Integer.parseInt(String.valueOf(c))]);\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString().trim());\n\t\t}\n\t\n\t}","slug":"pat-yi-1002","published":1,"updated":"2018-01-29T07:45:03.707Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1iz007o2sivv37zf8qq","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n\n输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。\n\n输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。\n\n输入样例：\n1234567890987654321123456789\n输出样例：\nyi san wu\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * NO.1002:写出这个数 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1002 {\n\n    public static void main(String[] args) {\n        String[] com = new String[] { &quot;ling &quot;, &quot;yi &quot;, &quot;er &quot;, &quot;san &quot;, &quot;si &quot;, &quot;wu &quot;, &quot;liu &quot;, &quot;qi &quot;, &quot;ba &quot;, &quot;jiu &quot; };\n        Scanner in = new Scanner(System.in);\n        String num = in.nextLine().trim();\n        char[] nums = num.toCharArray();\n        int ans = 0;\n        for (char c : nums) {\n            ans += Integer.parseInt(String.valueOf(c));\n        }\n\n        String res = String.valueOf(ans);\n        nums = res.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for (char c : nums) {\n            sb.append(com[Integer.parseInt(String.valueOf(c))]);\n        }\n        System.out.println(sb.toString().trim());\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。\n\n输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。\n\n输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。\n\n输入样例：\n1234567890987654321123456789\n输出样例：\nyi san wu\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * NO.1002:写出这个数 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1002 {\n\n    public static void main(String[] args) {\n        String[] com = new String[] { &quot;ling &quot;, &quot;yi &quot;, &quot;er &quot;, &quot;san &quot;, &quot;si &quot;, &quot;wu &quot;, &quot;liu &quot;, &quot;qi &quot;, &quot;ba &quot;, &quot;jiu &quot; };\n        Scanner in = new Scanner(System.in);\n        String num = in.nextLine().trim();\n        char[] nums = num.toCharArray();\n        int ans = 0;\n        for (char c : nums) {\n            ans += Integer.parseInt(String.valueOf(c));\n        }\n\n        String res = String.valueOf(ans);\n        nums = res.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for (char c : nums) {\n            sb.append(com[Integer.parseInt(String.valueOf(c))]);\n        }\n        System.out.println(sb.toString().trim());\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"乙1004. 成绩排名 (20)","date":"2017-12-21T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n\t\n\t输入格式：每个测试输入包含1个测试用例，格式为\n\t\n\t  第1行：正整数n\n\t  第2行：第1个学生的姓名 学号 成绩\n\t  第3行：第2个学生的姓名 学号 成绩\n\t  ... ... ...\n\t  第n+1行：第n个学生的姓名 学号 成绩\n\t其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\n\t输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。\n\t\n\t输入样例：\n\t3\n\tJoe Math990112 89\n\tMike CS991301 100\n\tMary EE990830 95\n\t输出样例：\n\tMike CS991301\n\tJoe Math990112\n\n\n#### 解答 ####\n \t\n\n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1004: 成绩排名 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1004 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = Integer.parseInt(in.nextLine());\n\t\t\tString maxStr = \"\";\n\t\t\tString minStr = \"\";\n\t\t\tint max = 0, min = Integer.MAX_VALUE;\n\t\t\twhile (num > 0) {\n\t\t\t\tnum--;\n\t\t\t\tString item = in.nextLine();\n\t\t\t\tString[] split = item.split(\" \");\n\t\t\t\tif (max < Integer.parseInt(split[2])) {\n\t\t\t\t\tmax = Integer.parseInt(split[2]);\n\t\t\t\t\tmaxStr = split[0] + \" \" + split[1];\n\t\t\t\t}\n\t\t\t\tif (min > Integer.parseInt(split[2])) {\n\t\t\t\t\tmin = Integer.parseInt(split[2]);\n\t\t\t\t\tminStr = split[0] + \" \" + split[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxStr);\n\t\t\tSystem.out.println(minStr);\n\t\t}\n\t\n\t}\n\n ","source":"_posts/2017-12-21-pat-yi-1004.md","raw":"---\nlayout: post\ntitle:  乙1004. 成绩排名 (20)\ndate:   2017-12-21\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n\t\n\t输入格式：每个测试输入包含1个测试用例，格式为\n\t\n\t  第1行：正整数n\n\t  第2行：第1个学生的姓名 学号 成绩\n\t  第3行：第2个学生的姓名 学号 成绩\n\t  ... ... ...\n\t  第n+1行：第n个学生的姓名 学号 成绩\n\t其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\n\t输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。\n\t\n\t输入样例：\n\t3\n\tJoe Math990112 89\n\tMike CS991301 100\n\tMary EE990830 95\n\t输出样例：\n\tMike CS991301\n\tJoe Math990112\n\n\n#### 解答 ####\n \t\n\n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1004: 成绩排名 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1004 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = Integer.parseInt(in.nextLine());\n\t\t\tString maxStr = \"\";\n\t\t\tString minStr = \"\";\n\t\t\tint max = 0, min = Integer.MAX_VALUE;\n\t\t\twhile (num > 0) {\n\t\t\t\tnum--;\n\t\t\t\tString item = in.nextLine();\n\t\t\t\tString[] split = item.split(\" \");\n\t\t\t\tif (max < Integer.parseInt(split[2])) {\n\t\t\t\t\tmax = Integer.parseInt(split[2]);\n\t\t\t\t\tmaxStr = split[0] + \" \" + split[1];\n\t\t\t\t}\n\t\t\t\tif (min > Integer.parseInt(split[2])) {\n\t\t\t\t\tmin = Integer.parseInt(split[2]);\n\t\t\t\t\tminStr = split[0] + \" \" + split[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(maxStr);\n\t\t\tSystem.out.println(minStr);\n\t\t}\n\t\n\t}\n\n ","slug":"pat-yi-1004","published":1,"updated":"2018-01-29T07:44:53.540Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1j4007r2sivnqvd7p21","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n\n输入格式：每个测试输入包含1个测试用例，格式为\n\n  第1行：正整数n\n  第2行：第1个学生的姓名 学号 成绩\n  第3行：第2个学生的姓名 学号 成绩\n  ... ... ...\n  第n+1行：第n个学生的姓名 学号 成绩\n其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\n输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。\n\n输入样例：\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n输出样例：\nMike CS991301\nJoe Math990112\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1004: 成绩排名 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1004 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = Integer.parseInt(in.nextLine());\n        String maxStr = &quot;&quot;;\n        String minStr = &quot;&quot;;\n        int max = 0, min = Integer.MAX_VALUE;\n        while (num &gt; 0) {\n            num--;\n            String item = in.nextLine();\n            String[] split = item.split(&quot; &quot;);\n            if (max &lt; Integer.parseInt(split[2])) {\n                max = Integer.parseInt(split[2]);\n                maxStr = split[0] + &quot; &quot; + split[1];\n            }\n            if (min &gt; Integer.parseInt(split[2])) {\n                min = Integer.parseInt(split[2]);\n                minStr = split[0] + &quot; &quot; + split[1];\n            }\n        }\n        System.out.println(maxStr);\n        System.out.println(minStr);\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。\n\n输入格式：每个测试输入包含1个测试用例，格式为\n\n  第1行：正整数n\n  第2行：第1个学生的姓名 学号 成绩\n  第3行：第2个学生的姓名 学号 成绩\n  ... ... ...\n  第n+1行：第n个学生的姓名 学号 成绩\n其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\n输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。\n\n输入样例：\n3\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n输出样例：\nMike CS991301\nJoe Math990112\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1004: 成绩排名 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1004 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = Integer.parseInt(in.nextLine());\n        String maxStr = &quot;&quot;;\n        String minStr = &quot;&quot;;\n        int max = 0, min = Integer.MAX_VALUE;\n        while (num &gt; 0) {\n            num--;\n            String item = in.nextLine();\n            String[] split = item.split(&quot; &quot;);\n            if (max &lt; Integer.parseInt(split[2])) {\n                max = Integer.parseInt(split[2]);\n                maxStr = split[0] + &quot; &quot; + split[1];\n            }\n            if (min &gt; Integer.parseInt(split[2])) {\n                min = Integer.parseInt(split[2]);\n                minStr = split[0] + &quot; &quot; + split[1];\n            }\n        }\n        System.out.println(maxStr);\n        System.out.println(minStr);\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"乙1003. 我要通过！(20)","date":"2017-12-21T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。\n\n\t得到“答案正确”的条件是：\n\t\n\t\t1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；\n\t\t2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；\n\t\t3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。\n\t\n\t现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。\n\t输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。\n\t\n\t输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。\n\t\n\t输入样例：\n\t8\n\tPAT\n\tPAAT\n\tAAPATAA\n\tAAPAATAAAA\n\txPATx\n\tPT\n\tWhatever\n\tAPAAATAA\n\t输出样例：\n\tYES\n\tYES\n\tYES\n\tYES\n\tNO\n\tNO\n\tNO\n\tNO\n\n#### 思路 ####\n\t\n - 这是一道找规律题.发现,最后一个看着应该输出`YES`,为什么样例给出`NO`,从这里结合要求[3]找出A的个数的规律.可得:请拉倒页面底部看.\n - PT,结合要求[1],得出判定条件.\n\n\n\n#### 解答 ####\n \t\n\timport java.util.Scanner;\n\t\n\t/**\n\t * NO.1003: 我要通过！(20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1003 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner scanner = new Scanner(System.in);\n\t\t\tint num = Integer.parseInt(scanner.nextLine());\n\t\t\tboolean[] res = new boolean[num];\n\t\t\tchar chars[];\n\t\t\tint index = 0;\n\t\t\tint pIndex = 0;\n\t\t\tint tIndex = 0;\n\t\t\tout: while (num > 0) {\n\t\t\t\tnum--;\n\t\t\t\tString str = scanner.nextLine();\n\t\t\t\tchars = str.toCharArray();\n\t\t\t\tin: for (char c : chars) {\n\t\t\t\t\tif (c != 'P' && c != 'T' && c != 'A') {\n\t\t\t\t\t\tres[index] = false;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpIndex = str.indexOf('P');\n\t\t\t\ttIndex = str.indexOf('T');\n\t\n\t\t\t\tif (tIndex <= pIndex || str.length() < 3) {\n\t\t\t\t\tres[index] = false;\n\t\t\t\t\tindex++;\n\t\t\t\t\tcontinue out;\n\t\t\t\t}\n\t\t\t\tif (pIndex * (tIndex - pIndex - 1) == str.length() - 1 - tIndex) {\n\t\t\t\t\tres[index] = true;\n\t\t\t\t} else {\n\t\t\t\t\tres[index] = false;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tcontinue out;\n\t\t\t}\n\t\n\t\t\tfor (boolean b : res) {\n\t\t\t\tSystem.out.println(b ? \"YES\" : \"NO\");\n\t\t\t}\n\t\t}\n\t\n\t}\n\n#### 规律 ####\n\n由:`如果 aPbTc 是正确的`,半句可得:b>=1\n由:`那么 aPbATca 也是正确的` 和 样例给出,可以得到: a x (b+1) = c + a (单位为A)\n化简得: a x b = c","source":"_posts/2017-12-21-pat-yi-1003.md","raw":"---\nlayout: post\ntitle:  乙1003. 我要通过！(20)\ndate:   2017-12-21\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。\n\n\t得到“答案正确”的条件是：\n\t\n\t\t1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；\n\t\t2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；\n\t\t3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。\n\t\n\t现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。\n\t输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (<10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。\n\t\n\t输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。\n\t\n\t输入样例：\n\t8\n\tPAT\n\tPAAT\n\tAAPATAA\n\tAAPAATAAAA\n\txPATx\n\tPT\n\tWhatever\n\tAPAAATAA\n\t输出样例：\n\tYES\n\tYES\n\tYES\n\tYES\n\tNO\n\tNO\n\tNO\n\tNO\n\n#### 思路 ####\n\t\n - 这是一道找规律题.发现,最后一个看着应该输出`YES`,为什么样例给出`NO`,从这里结合要求[3]找出A的个数的规律.可得:请拉倒页面底部看.\n - PT,结合要求[1],得出判定条件.\n\n\n\n#### 解答 ####\n \t\n\timport java.util.Scanner;\n\t\n\t/**\n\t * NO.1003: 我要通过！(20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1003 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner scanner = new Scanner(System.in);\n\t\t\tint num = Integer.parseInt(scanner.nextLine());\n\t\t\tboolean[] res = new boolean[num];\n\t\t\tchar chars[];\n\t\t\tint index = 0;\n\t\t\tint pIndex = 0;\n\t\t\tint tIndex = 0;\n\t\t\tout: while (num > 0) {\n\t\t\t\tnum--;\n\t\t\t\tString str = scanner.nextLine();\n\t\t\t\tchars = str.toCharArray();\n\t\t\t\tin: for (char c : chars) {\n\t\t\t\t\tif (c != 'P' && c != 'T' && c != 'A') {\n\t\t\t\t\t\tres[index] = false;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tcontinue out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpIndex = str.indexOf('P');\n\t\t\t\ttIndex = str.indexOf('T');\n\t\n\t\t\t\tif (tIndex <= pIndex || str.length() < 3) {\n\t\t\t\t\tres[index] = false;\n\t\t\t\t\tindex++;\n\t\t\t\t\tcontinue out;\n\t\t\t\t}\n\t\t\t\tif (pIndex * (tIndex - pIndex - 1) == str.length() - 1 - tIndex) {\n\t\t\t\t\tres[index] = true;\n\t\t\t\t} else {\n\t\t\t\t\tres[index] = false;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tcontinue out;\n\t\t\t}\n\t\n\t\t\tfor (boolean b : res) {\n\t\t\t\tSystem.out.println(b ? \"YES\" : \"NO\");\n\t\t\t}\n\t\t}\n\t\n\t}\n\n#### 规律 ####\n\n由:`如果 aPbTc 是正确的`,半句可得:b>=1\n由:`那么 aPbATca 也是正确的` 和 样例给出,可以得到: a x (b+1) = c + a (单位为A)\n化简得: a x b = c","slug":"pat-yi-1003","published":1,"updated":"2018-01-29T07:44:59.492Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1j6007u2sivkwba947c","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。\n\n得到“答案正确”的条件是：\n\n    1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；\n    2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；\n    3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。\n\n现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。\n输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。\n\n输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。\n\n输入样例：\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n输出样例：\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>这是一道找规律题.发现,最后一个看着应该输出<code>YES</code>,为什么样例给出<code>NO</code>,从这里结合要求[3]找出A的个数的规律.可得:请拉倒页面底部看.</li>\n<li>PT,结合要求[1],得出判定条件.</li>\n</ul>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * NO.1003: 我要通过！(20)\n * \n * @author sxx.xu\n *\n */\npublic class No1003 {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int num = Integer.parseInt(scanner.nextLine());\n        boolean[] res = new boolean[num];\n        char chars[];\n        int index = 0;\n        int pIndex = 0;\n        int tIndex = 0;\n        out: while (num &gt; 0) {\n            num--;\n            String str = scanner.nextLine();\n            chars = str.toCharArray();\n            in: for (char c : chars) {\n                if (c != &apos;P&apos; &amp;&amp; c != &apos;T&apos; &amp;&amp; c != &apos;A&apos;) {\n                    res[index] = false;\n                    index++;\n                    continue out;\n                }\n            }\n            pIndex = str.indexOf(&apos;P&apos;);\n            tIndex = str.indexOf(&apos;T&apos;);\n\n            if (tIndex &lt;= pIndex || str.length() &lt; 3) {\n                res[index] = false;\n                index++;\n                continue out;\n            }\n            if (pIndex * (tIndex - pIndex - 1) == str.length() - 1 - tIndex) {\n                res[index] = true;\n            } else {\n                res[index] = false;\n            }\n            index++;\n            continue out;\n        }\n\n        for (boolean b : res) {\n            System.out.println(b ? &quot;YES&quot; : &quot;NO&quot;);\n        }\n    }\n\n}\n</code></pre><h4 id=\"规律\"><a href=\"#规律\" class=\"headerlink\" title=\"规律\"></a>规律</h4><p>由:<code>如果 aPbTc 是正确的</code>,半句可得:b&gt;=1<br>由:<code>那么 aPbATca 也是正确的</code> 和 样例给出,可以得到: a x (b+1) = c + a (单位为A)<br>化简得: a x b = c</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。\n\n得到“答案正确”的条件是：\n\n    1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；\n    2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；\n    3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。\n\n现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。\n输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。\n\n输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。\n\n输入样例：\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n输出样例：\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>这是一道找规律题.发现,最后一个看着应该输出<code>YES</code>,为什么样例给出<code>NO</code>,从这里结合要求[3]找出A的个数的规律.可得:请拉倒页面底部看.</li>\n<li>PT,结合要求[1],得出判定条件.</li>\n</ul>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * NO.1003: 我要通过！(20)\n * \n * @author sxx.xu\n *\n */\npublic class No1003 {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int num = Integer.parseInt(scanner.nextLine());\n        boolean[] res = new boolean[num];\n        char chars[];\n        int index = 0;\n        int pIndex = 0;\n        int tIndex = 0;\n        out: while (num &gt; 0) {\n            num--;\n            String str = scanner.nextLine();\n            chars = str.toCharArray();\n            in: for (char c : chars) {\n                if (c != &apos;P&apos; &amp;&amp; c != &apos;T&apos; &amp;&amp; c != &apos;A&apos;) {\n                    res[index] = false;\n                    index++;\n                    continue out;\n                }\n            }\n            pIndex = str.indexOf(&apos;P&apos;);\n            tIndex = str.indexOf(&apos;T&apos;);\n\n            if (tIndex &lt;= pIndex || str.length() &lt; 3) {\n                res[index] = false;\n                index++;\n                continue out;\n            }\n            if (pIndex * (tIndex - pIndex - 1) == str.length() - 1 - tIndex) {\n                res[index] = true;\n            } else {\n                res[index] = false;\n            }\n            index++;\n            continue out;\n        }\n\n        for (boolean b : res) {\n            System.out.println(b ? &quot;YES&quot; : &quot;NO&quot;);\n        }\n    }\n\n}\n</code></pre><h4 id=\"规律\"><a href=\"#规律\" class=\"headerlink\" title=\"规律\"></a>规律</h4><p>由:<code>如果 aPbTc 是正确的</code>,半句可得:b&gt;=1<br>由:<code>那么 aPbATca 也是正确的</code> 和 样例给出,可以得到: a x (b+1) = c + a (单位为A)<br>化简得: a x b = c</p>\n"},{"layout":"post","title":"乙1005. 继续(3n+1)猜想 (25)","date":"2017-12-22T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n\n\t当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，\n\n\t我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，\n\n\t因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，\n\n\t如果n不能被数列中的其他数字所覆盖。现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，\n\n\t就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n\t\n\t输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(<100)，\n\n\t第2行给出K个互不相同的待验证的正整数n(1<n<=100)的值，数字间用空格隔开。\n\t\n\t输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。\n\t\n\t输入样例：\n\t6\n\t3 5 6 7 8 11\n\t输出样例：\n\t7 6\n\n#### 思路 ####\n\n- 首先要理解覆盖的概念,我的理解是,一个给定的数,在求得最终结果\"1\"的路径上,如果一个数可以被2整除,该数就被给定的数覆盖了.\n- 其次,我们默认输入的那组数,互相都没有覆盖,全部加入最终的输出容器\n- 然后,我们循环记录给定的数的path数,如果该数在结果容器里,那么从结果容器中移除\n- 最后,输入结果容器的记录\n\n#### 解答 ####\n  \n\timport java.util.ArrayList;\n\timport java.util.Collections;\n\timport java.util.List;\n\timport java.util.Scanner;\n\timport java.util.TreeSet;\n\t\n\t/**\n\t * No.1005: 继续(3n+1)猜想 (25)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1005 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tList<Integer> path = new ArrayList<>();\n\t\t\tTreeSet<Integer> ans = new TreeSet<>(Collections.reverseOrder());\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint total = Integer.parseInt(in.nextLine());\n\t\t\tString datas = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] split = datas.split(\" \");\n\t\t\tif (split.length == 1) {\n\t\t\t\tSystem.out.println(split[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tnum = Integer.parseInt(split[i]);\n\t\t\t\tans.add(num);\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tnum = Integer.parseInt(split[i]);\n\t\t\t\twhile (num != 1) {\n\t\t\t\t\tif (num % 2 == 0) {\n\t\t\t\t\t\tnum = num / 2;\n\t\t\t\t\t\tpath.add(num);\n\t\t\t\t\t\tif (ans.contains(num))\n\t\t\t\t\t\t\tans.remove(num);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum = 3 * num + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int j : ans) {\n\t\t\t\tsb.append(j).append(\" \");\n\t\t\t}\n\t\t\tif (sb.toString().trim().isEmpty()) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t}\n","source":"_posts/2017-12-22-pat-yi-1005.md","raw":"---\nlayout: post\ntitle:  乙1005. 继续(3n+1)猜想 (25)\ndate:   2017-12-22\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n\n\t当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，\n\n\t我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，\n\n\t因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，\n\n\t如果n不能被数列中的其他数字所覆盖。现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，\n\n\t就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n\t\n\t输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(<100)，\n\n\t第2行给出K个互不相同的待验证的正整数n(1<n<=100)的值，数字间用空格隔开。\n\t\n\t输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。\n\t\n\t输入样例：\n\t6\n\t3 5 6 7 8 11\n\t输出样例：\n\t7 6\n\n#### 思路 ####\n\n- 首先要理解覆盖的概念,我的理解是,一个给定的数,在求得最终结果\"1\"的路径上,如果一个数可以被2整除,该数就被给定的数覆盖了.\n- 其次,我们默认输入的那组数,互相都没有覆盖,全部加入最终的输出容器\n- 然后,我们循环记录给定的数的path数,如果该数在结果容器里,那么从结果容器中移除\n- 最后,输入结果容器的记录\n\n#### 解答 ####\n  \n\timport java.util.ArrayList;\n\timport java.util.Collections;\n\timport java.util.List;\n\timport java.util.Scanner;\n\timport java.util.TreeSet;\n\t\n\t/**\n\t * No.1005: 继续(3n+1)猜想 (25)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1005 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tList<Integer> path = new ArrayList<>();\n\t\t\tTreeSet<Integer> ans = new TreeSet<>(Collections.reverseOrder());\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint total = Integer.parseInt(in.nextLine());\n\t\t\tString datas = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] split = datas.split(\" \");\n\t\t\tif (split.length == 1) {\n\t\t\t\tSystem.out.println(split[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tnum = Integer.parseInt(split[i]);\n\t\t\t\tans.add(num);\n\t\t\t}\n\t\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tnum = Integer.parseInt(split[i]);\n\t\t\t\twhile (num != 1) {\n\t\t\t\t\tif (num % 2 == 0) {\n\t\t\t\t\t\tnum = num / 2;\n\t\t\t\t\t\tpath.add(num);\n\t\t\t\t\t\tif (ans.contains(num))\n\t\t\t\t\t\t\tans.remove(num);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnum = 3 * num + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int j : ans) {\n\t\t\t\tsb.append(j).append(\" \");\n\t\t\t}\n\t\t\tif (sb.toString().trim().isEmpty()) {\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(sb.toString().trim());\n\t\t\t}\n\t\t}\n\t}\n","slug":"pat-yi-1005","published":1,"updated":"2018-01-29T07:44:48.154Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ja007y2siv9gy1528o","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，\n\n我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，\n\n因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，\n\n如果n不能被数列中的其他数字所覆盖。现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，\n\n就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n\n输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，\n\n第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。\n\n输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。\n\n输入样例：\n6\n3 5 6 7 8 11\n输出样例：\n7 6\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>首先要理解覆盖的概念,我的理解是,一个给定的数,在求得最终结果”1”的路径上,如果一个数可以被2整除,该数就被给定的数覆盖了.</li>\n<li>其次,我们默认输入的那组数,互相都没有覆盖,全部加入最终的输出容器</li>\n<li>然后,我们循环记录给定的数的path数,如果该数在结果容器里,那么从结果容器中移除</li>\n<li>最后,输入结果容器的记录</li>\n</ul>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n/**\n * No.1005: 继续(3n+1)猜想 (25)\n * \n * @author sxx.xu\n *\n */\npublic class No1005 {\n\n    public static void main(String[] args) {\n        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\n        TreeSet&lt;Integer&gt; ans = new TreeSet&lt;&gt;(Collections.reverseOrder());\n        Scanner in = new Scanner(System.in);\n        int total = Integer.parseInt(in.nextLine());\n        String datas = in.nextLine();\n        in.close();\n        String[] split = datas.split(&quot; &quot;);\n        if (split.length == 1) {\n            System.out.println(split[0]);\n            return;\n        }\n        int num = 0;\n        for (int i = 0; i &lt; total; i++) {\n            num = Integer.parseInt(split[i]);\n            ans.add(num);\n        }\n\n        for (int i = 0; i &lt; total; i++) {\n            num = Integer.parseInt(split[i]);\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                    path.add(num);\n                    if (ans.contains(num))\n                        ans.remove(num);\n                } else {\n                    num = 3 * num + 1;\n                }\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int j : ans) {\n            sb.append(j).append(&quot; &quot;);\n        }\n        if (sb.toString().trim().isEmpty()) {\n            System.out.println(&quot;&quot;);\n        } else {\n            System.out.println(sb.toString().trim());\n        }\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。\n\n当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，\n\n我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，\n\n因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，\n\n如果n不能被数列中的其他数字所覆盖。现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，\n\n就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。\n\n输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，\n\n第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。\n\n输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。\n\n输入样例：\n6\n3 5 6 7 8 11\n输出样例：\n7 6\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>首先要理解覆盖的概念,我的理解是,一个给定的数,在求得最终结果”1”的路径上,如果一个数可以被2整除,该数就被给定的数覆盖了.</li>\n<li>其次,我们默认输入的那组数,互相都没有覆盖,全部加入最终的输出容器</li>\n<li>然后,我们循环记录给定的数的path数,如果该数在结果容器里,那么从结果容器中移除</li>\n<li>最后,输入结果容器的记录</li>\n</ul>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n/**\n * No.1005: 继续(3n+1)猜想 (25)\n * \n * @author sxx.xu\n *\n */\npublic class No1005 {\n\n    public static void main(String[] args) {\n        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\n        TreeSet&lt;Integer&gt; ans = new TreeSet&lt;&gt;(Collections.reverseOrder());\n        Scanner in = new Scanner(System.in);\n        int total = Integer.parseInt(in.nextLine());\n        String datas = in.nextLine();\n        in.close();\n        String[] split = datas.split(&quot; &quot;);\n        if (split.length == 1) {\n            System.out.println(split[0]);\n            return;\n        }\n        int num = 0;\n        for (int i = 0; i &lt; total; i++) {\n            num = Integer.parseInt(split[i]);\n            ans.add(num);\n        }\n\n        for (int i = 0; i &lt; total; i++) {\n            num = Integer.parseInt(split[i]);\n            while (num != 1) {\n                if (num % 2 == 0) {\n                    num = num / 2;\n                    path.add(num);\n                    if (ans.contains(num))\n                        ans.remove(num);\n                } else {\n                    num = 3 * num + 1;\n                }\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int j : ans) {\n            sb.append(j).append(&quot; &quot;);\n        }\n        if (sb.toString().trim().isEmpty()) {\n            System.out.println(&quot;&quot;);\n        } else {\n            System.out.println(sb.toString().trim());\n        }\n    }\n}\n</code></pre>"},{"layout":"post","title":"乙1006. 换个格式输出整数 (15)","date":"2017-12-22T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t让我们用字母B来表示“百”、字母S表示“十”，用“12...n”来表示个位数字n（<10），换个格式来输出任一个不超过3位的正整数。\n\n\t例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。\n\t\n\t输入格式：每个测试输入包含1个测试用例，给出正整数n（<1000）。\n\t\n\t输出格式：每个测试用例的输出占一行，用规定的格式输出n。\n\t\n\t输入样例1：\n\t234\n\t输出样例1：\n\tBBSSS1234\n\t输入样例2：\n\t23\n\t输出样例2：\n\tSS123\n \n\n#### 解答 ####\n  \n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1006: 换个格式输出整数 (15)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1006 {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = in.nextInt();\n\t\t\tin.close();\n\t\t\tfinal String bai = \"B\";\n\t\t\tfinal String ten = \"S\";\n\t\t\tfinal String ge = \"123456789\";\n\t\t\tint a = num / 100;\n\t\t\tint b = (num - a * 100) / 10;\n\t\t\tint c = num - a * 100 - b * 10;\n\t\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < a; i++)\n\t\t\t\tsb.append(bai);\n\t\t\tfor (int j = 0; j < b; j++)\n\t\t\t\tsb.append(ten);\n\t\t\tsb.append(ge.substring(0, c));\n\t\t\tSystem.out.println(sb.toString());\n\t\n\t\t}\n\t}\n","source":"_posts/2017-12-22-pat-yi-1006.md","raw":"---\nlayout: post\ntitle:  乙1006. 换个格式输出整数 (15)\ndate:   2017-12-22\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t让我们用字母B来表示“百”、字母S表示“十”，用“12...n”来表示个位数字n（<10），换个格式来输出任一个不超过3位的正整数。\n\n\t例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。\n\t\n\t输入格式：每个测试输入包含1个测试用例，给出正整数n（<1000）。\n\t\n\t输出格式：每个测试用例的输出占一行，用规定的格式输出n。\n\t\n\t输入样例1：\n\t234\n\t输出样例1：\n\tBBSSS1234\n\t输入样例2：\n\t23\n\t输出样例2：\n\tSS123\n \n\n#### 解答 ####\n  \n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1006: 换个格式输出整数 (15)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1006 {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = in.nextInt();\n\t\t\tin.close();\n\t\t\tfinal String bai = \"B\";\n\t\t\tfinal String ten = \"S\";\n\t\t\tfinal String ge = \"123456789\";\n\t\t\tint a = num / 100;\n\t\t\tint b = (num - a * 100) / 10;\n\t\t\tint c = num - a * 100 - b * 10;\n\t\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < a; i++)\n\t\t\t\tsb.append(bai);\n\t\t\tfor (int j = 0; j < b; j++)\n\t\t\t\tsb.append(ten);\n\t\t\tsb.append(ge.substring(0, c));\n\t\t\tSystem.out.println(sb.toString());\n\t\n\t\t}\n\t}\n","slug":"pat-yi-1006","published":1,"updated":"2018-01-29T07:44:42.333Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1jd00812sivonde973l","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>让我们用字母B来表示“百”、字母S表示“十”，用“12...n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。\n\n例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。\n\n输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。\n\n输出格式：每个测试用例的输出占一行，用规定的格式输出n。\n\n输入样例1：\n234\n输出样例1：\nBBSSS1234\n输入样例2：\n23\n输出样例2：\nSS123\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1006: 换个格式输出整数 (15)\n * \n * @author sxx.xu\n *\n */\npublic class No1006 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = in.nextInt();\n        in.close();\n        final String bai = &quot;B&quot;;\n        final String ten = &quot;S&quot;;\n        final String ge = &quot;123456789&quot;;\n        int a = num / 100;\n        int b = (num - a * 100) / 10;\n        int c = num - a * 100 - b * 10;\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; a; i++)\n            sb.append(bai);\n        for (int j = 0; j &lt; b; j++)\n            sb.append(ten);\n        sb.append(ge.substring(0, c));\n        System.out.println(sb.toString());\n\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>让我们用字母B来表示“百”、字母S表示“十”，用“12...n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。\n\n例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。\n\n输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。\n\n输出格式：每个测试用例的输出占一行，用规定的格式输出n。\n\n输入样例1：\n234\n输出样例1：\nBBSSS1234\n输入样例2：\n23\n输出样例2：\nSS123\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1006: 换个格式输出整数 (15)\n * \n * @author sxx.xu\n *\n */\npublic class No1006 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = in.nextInt();\n        in.close();\n        final String bai = &quot;B&quot;;\n        final String ten = &quot;S&quot;;\n        final String ge = &quot;123456789&quot;;\n        int a = num / 100;\n        int b = (num - a * 100) / 10;\n        int c = num - a * 100 - b * 10;\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; a; i++)\n            sb.append(bai);\n        for (int j = 0; j &lt; b; j++)\n            sb.append(ten);\n        sb.append(ge.substring(0, c));\n        System.out.println(sb.toString());\n\n    }\n}\n</code></pre>"},{"title":"代码开源协议","date":"2017-08-22T00:00:00.000Z","_content":"\n#### License ####\n\nLicense是软件的授权许可，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。软件协议可分为开源和商业。\n商业协议，又叫法律声明、许可协议，这由专门的律师撰写。\n开源协议即本文所介绍。\n如果您只想快速确定自己的代码适合哪种协议，那么[Choose an open source license](https://choosealicense.com/)可以帮您快速抉择。\n\n#### 对比表 ####\n\n| 协议 | 描述 | 要求 | 允许 | 禁止 |\n| :-------------: |:-------------:| :-----:|:-----:|:-----:|\n| [Apache](https://choosealicense.com/licenses/apache-2.0/) | 一个较宽松且简明地指出了专利授权的协议 | `协议和版权信息`\t `声明变更` |`商用` `分发` `修改` `专利授权` `私用` `附加协议` | `责任承担` `商标使用` |\n| [GPL](https://choosealicense.com/licenses/gpl-2.0/) | 此协议是应用最为广泛的开源协议，拥有较强的版权自由要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，要求略有不同 | `公开源码` `协议和版权信息` `声明变更` |`商用` `分发` `修改` `专利授权` `私用`  | `责任承担` `附加协议` |\n| [MIT](https://choosealicense.com/licenses/mit/) | 宽松简单且精要的一个协议。在适当表明来源及免责的情况下，它允许你对代码进行任何形式的使用 |  `协议和版权信息`\t  |`商用` `分发` `修改` `私用` `附加协议`  | `责任承担` |\n| [Artistic](https://choosealicense.com/licenses/artistic-2.0/) | Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用 |  `协议和版权信息`\t`声明变更`  |`商用` `分发` `修改` `私用` `附加协议`  | `责任承担` `商标使用` |\n| [BSD](https://choosealicense.com/licenses/bsd-2-clause/) | 较为宽松的协议，包含两个变种[BSD 2-Clause](https://choosealicense.com/licenses/bsd-2-clause/) 和[BSD 3-Clause](https://choosealicense.com/licenses/bsd-3-clause/)，两者都与MIT协议只存在细微差异。 |  `协议和版权信息`  |`商用` `分发` `修改` `私用` `附加协议`  | `责任承担` |\n| [Eclipse](https://choosealicense.com/licenses/epl-1.0/) | 对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议 | `公开源码` `协议和版权信息`  |`商用` `分发` `修改` `专利授权` `私用` `附加协议`  | `责任承担` |\n| [LGPL](https://choosealicense.com/licenses/lgpl-2.1/) | 主要用于一些代码库。衍生代码可以以此协议发布(也可用别的)，但与此协议相关的代码必须遵循此协议 | `公开源码` `库引用` `协议和版权信息`  |`商用` `分发` `修改` `专利授权` `私用` `附加协议`  | `责任承担` |\n| [Mozilla](https://choosealicense.com/licenses/mpl-2.0/) | Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。 | `公开源码` `协议和版权信息`  |`商用` `分发` `修改` `专利授权` `私用` `附加协议`  | `责任承担` `商标使用` |\n| [No license](https://choosealicense.com/no-license/) | 你保留所以权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必须统一别人可以查看和fork你的代码 | `协议和版权信息`  |`商用` `私用`| `分发` `修改` `附加协议` |\n| [Unlicense](https://choosealicense.com/licenses/unlicense/) |在许多国家，默认版权归作者自动拥有，所以该协议提供了一种通用的模版，表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。 | N/A  |`商用` `分发` `修改` `私用`| `责任承担` |","source":"_posts/2017-08-22-license-introduce.md","raw":"---\ntitle: 代码开源协议\ndate: 2017-08-22\ntags: 杂项\ncategories: Others\n---\n\n#### License ####\n\nLicense是软件的授权许可，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。软件协议可分为开源和商业。\n商业协议，又叫法律声明、许可协议，这由专门的律师撰写。\n开源协议即本文所介绍。\n如果您只想快速确定自己的代码适合哪种协议，那么[Choose an open source license](https://choosealicense.com/)可以帮您快速抉择。\n\n#### 对比表 ####\n\n| 协议 | 描述 | 要求 | 允许 | 禁止 |\n| :-------------: |:-------------:| :-----:|:-----:|:-----:|\n| [Apache](https://choosealicense.com/licenses/apache-2.0/) | 一个较宽松且简明地指出了专利授权的协议 | `协议和版权信息`\t `声明变更` |`商用` `分发` `修改` `专利授权` `私用` `附加协议` | `责任承担` `商标使用` |\n| [GPL](https://choosealicense.com/licenses/gpl-2.0/) | 此协议是应用最为广泛的开源协议，拥有较强的版权自由要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，要求略有不同 | `公开源码` `协议和版权信息` `声明变更` |`商用` `分发` `修改` `专利授权` `私用`  | `责任承担` `附加协议` |\n| [MIT](https://choosealicense.com/licenses/mit/) | 宽松简单且精要的一个协议。在适当表明来源及免责的情况下，它允许你对代码进行任何形式的使用 |  `协议和版权信息`\t  |`商用` `分发` `修改` `私用` `附加协议`  | `责任承担` |\n| [Artistic](https://choosealicense.com/licenses/artistic-2.0/) | Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用 |  `协议和版权信息`\t`声明变更`  |`商用` `分发` `修改` `私用` `附加协议`  | `责任承担` `商标使用` |\n| [BSD](https://choosealicense.com/licenses/bsd-2-clause/) | 较为宽松的协议，包含两个变种[BSD 2-Clause](https://choosealicense.com/licenses/bsd-2-clause/) 和[BSD 3-Clause](https://choosealicense.com/licenses/bsd-3-clause/)，两者都与MIT协议只存在细微差异。 |  `协议和版权信息`  |`商用` `分发` `修改` `私用` `附加协议`  | `责任承担` |\n| [Eclipse](https://choosealicense.com/licenses/epl-1.0/) | 对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议 | `公开源码` `协议和版权信息`  |`商用` `分发` `修改` `专利授权` `私用` `附加协议`  | `责任承担` |\n| [LGPL](https://choosealicense.com/licenses/lgpl-2.1/) | 主要用于一些代码库。衍生代码可以以此协议发布(也可用别的)，但与此协议相关的代码必须遵循此协议 | `公开源码` `库引用` `协议和版权信息`  |`商用` `分发` `修改` `专利授权` `私用` `附加协议`  | `责任承担` |\n| [Mozilla](https://choosealicense.com/licenses/mpl-2.0/) | Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。 | `公开源码` `协议和版权信息`  |`商用` `分发` `修改` `专利授权` `私用` `附加协议`  | `责任承担` `商标使用` |\n| [No license](https://choosealicense.com/no-license/) | 你保留所以权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必须统一别人可以查看和fork你的代码 | `协议和版权信息`  |`商用` `私用`| `分发` `修改` `附加协议` |\n| [Unlicense](https://choosealicense.com/licenses/unlicense/) |在许多国家，默认版权归作者自动拥有，所以该协议提供了一种通用的模版，表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。 | N/A  |`商用` `分发` `修改` `私用`| `责任承担` |","slug":"license-introduce","published":1,"updated":"2017-08-23T07:55:29.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdcfv1jh00852siv3ncnue0r","content":"<h4 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h4><p>License是软件的授权许可，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。软件协议可分为开源和商业。<br>商业协议，又叫法律声明、许可协议，这由专门的律师撰写。<br>开源协议即本文所介绍。<br>如果您只想快速确定自己的代码适合哪种协议，那么<a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"external\">Choose an open source license</a>可以帮您快速抉择。</p>\n<h4 id=\"对比表\"><a href=\"#对比表\" class=\"headerlink\" title=\"对比表\"></a>对比表</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">协议</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">要求</th>\n<th style=\"text-align:center\">允许</th>\n<th style=\"text-align:center\">禁止</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/apache-2.0/\" target=\"_blank\" rel=\"external\">Apache</a></td>\n<td style=\"text-align:center\">一个较宽松且简明地指出了专利授权的协议</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code>     <code>声明变更</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>商标使用</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/gpl-2.0/\" target=\"_blank\" rel=\"external\">GPL</a></td>\n<td style=\"text-align:center\">此协议是应用最为广泛的开源协议，拥有较强的版权自由要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，要求略有不同</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>协议和版权信息</code> <code>声明变更</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>附加协议</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/mit/\" target=\"_blank\" rel=\"external\">MIT</a></td>\n<td style=\"text-align:center\">宽松简单且精要的一个协议。在适当表明来源及免责的情况下，它允许你对代码进行任何形式的使用</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/artistic-2.0/\" target=\"_blank\" rel=\"external\">Artistic</a></td>\n<td style=\"text-align:center\">Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code>    <code>声明变更</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>商标使用</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/bsd-2-clause/\" target=\"_blank\" rel=\"external\">BSD</a></td>\n<td style=\"text-align:center\">较为宽松的协议，包含两个变种<a href=\"https://choosealicense.com/licenses/bsd-2-clause/\" target=\"_blank\" rel=\"external\">BSD 2-Clause</a> 和<a href=\"https://choosealicense.com/licenses/bsd-3-clause/\" target=\"_blank\" rel=\"external\">BSD 3-Clause</a>，两者都与MIT协议只存在细微差异。</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/epl-1.0/\" target=\"_blank\" rel=\"external\">Eclipse</a></td>\n<td style=\"text-align:center\">对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/lgpl-2.1/\" target=\"_blank\" rel=\"external\">LGPL</a></td>\n<td style=\"text-align:center\">主要用于一些代码库。衍生代码可以以此协议发布(也可用别的)，但与此协议相关的代码必须遵循此协议</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>库引用</code> <code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/mpl-2.0/\" target=\"_blank\" rel=\"external\">Mozilla</a></td>\n<td style=\"text-align:center\">Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>商标使用</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/no-license/\" target=\"_blank\" rel=\"external\">No license</a></td>\n<td style=\"text-align:center\">你保留所以权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必须统一别人可以查看和fork你的代码</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>私用</code></td>\n<td style=\"text-align:center\"><code>分发</code> <code>修改</code> <code>附加协议</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/unlicense/\" target=\"_blank\" rel=\"external\">Unlicense</a></td>\n<td style=\"text-align:center\">在许多国家，默认版权归作者自动拥有，所以该协议提供了一种通用的模版，表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。</td>\n<td style=\"text-align:center\">N/A</td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h4><p>License是软件的授权许可，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。软件协议可分为开源和商业。<br>商业协议，又叫法律声明、许可协议，这由专门的律师撰写。<br>开源协议即本文所介绍。<br>如果您只想快速确定自己的代码适合哪种协议，那么<a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"external\">Choose an open source license</a>可以帮您快速抉择。</p>\n<h4 id=\"对比表\"><a href=\"#对比表\" class=\"headerlink\" title=\"对比表\"></a>对比表</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">协议</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">要求</th>\n<th style=\"text-align:center\">允许</th>\n<th style=\"text-align:center\">禁止</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/apache-2.0/\" target=\"_blank\" rel=\"external\">Apache</a></td>\n<td style=\"text-align:center\">一个较宽松且简明地指出了专利授权的协议</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code>     <code>声明变更</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>商标使用</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/gpl-2.0/\" target=\"_blank\" rel=\"external\">GPL</a></td>\n<td style=\"text-align:center\">此协议是应用最为广泛的开源协议，拥有较强的版权自由要求。衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，要求略有不同</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>协议和版权信息</code> <code>声明变更</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>附加协议</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/mit/\" target=\"_blank\" rel=\"external\">MIT</a></td>\n<td style=\"text-align:center\">宽松简单且精要的一个协议。在适当表明来源及免责的情况下，它允许你对代码进行任何形式的使用</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/artistic-2.0/\" target=\"_blank\" rel=\"external\">Artistic</a></td>\n<td style=\"text-align:center\">Perl社区尤为钟爱此协议。要求更改后的软件不能影响原软件的使用</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code>    <code>声明变更</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>商标使用</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/bsd-2-clause/\" target=\"_blank\" rel=\"external\">BSD</a></td>\n<td style=\"text-align:center\">较为宽松的协议，包含两个变种<a href=\"https://choosealicense.com/licenses/bsd-2-clause/\" target=\"_blank\" rel=\"external\">BSD 2-Clause</a> 和<a href=\"https://choosealicense.com/licenses/bsd-3-clause/\" target=\"_blank\" rel=\"external\">BSD 3-Clause</a>，两者都与MIT协议只存在细微差异。</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/epl-1.0/\" target=\"_blank\" rel=\"external\">Eclipse</a></td>\n<td style=\"text-align:center\">对商用非常友好的一种协议，可以用于软件的商业授权。包含对专利的优雅授权，并且也可以对相关代码应用商业协议</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/lgpl-2.1/\" target=\"_blank\" rel=\"external\">LGPL</a></td>\n<td style=\"text-align:center\">主要用于一些代码库。衍生代码可以以此协议发布(也可用别的)，但与此协议相关的代码必须遵循此协议</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>库引用</code> <code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/mpl-2.0/\" target=\"_blank\" rel=\"external\">Mozilla</a></td>\n<td style=\"text-align:center\">Mozilla Public License(MPL 2.0)是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点。</td>\n<td style=\"text-align:center\"><code>公开源码</code> <code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>专利授权</code> <code>私用</code> <code>附加协议</code></td>\n<td style=\"text-align:center\"><code>责任承担</code> <code>商标使用</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/no-license/\" target=\"_blank\" rel=\"external\">No license</a></td>\n<td style=\"text-align:center\">你保留所以权利，不允许他人分发，复制或者创造衍生物。当你将代码发表在一些网站上时需要遵守该网站的协议，此协议可能包含了一些对你劳动成果的授权许可。比如你将代码发布到GitHub，那么你就必须统一别人可以查看和fork你的代码</td>\n<td style=\"text-align:center\"><code>协议和版权信息</code></td>\n<td style=\"text-align:center\"><code>商用</code> <code>私用</code></td>\n<td style=\"text-align:center\"><code>分发</code> <code>修改</code> <code>附加协议</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><a href=\"https://choosealicense.com/licenses/unlicense/\" target=\"_blank\" rel=\"external\">Unlicense</a></td>\n<td style=\"text-align:center\">在许多国家，默认版权归作者自动拥有，所以该协议提供了一种通用的模版，表明你放弃版权，将劳动成果无私贡献出来。你将丧失对作品的全部权利，包括在MIT/X11中定义的无担保权利。</td>\n<td style=\"text-align:center\">N/A</td>\n<td style=\"text-align:center\"><code>商用</code> <code>分发</code> <code>修改</code> <code>私用</code></td>\n<td style=\"text-align:center\"><code>责任承担</code></td>\n</tr>\n</tbody>\n</table>\n"},{"layout":"post","title":"乙1007. 素数对猜想 (20)","date":"2017-12-25T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n>1有 dn 是偶数。\n\n\t“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n\n\t现给定任意正整数N (< 105)，请计算不超过N的满足猜想的素数对的个数。\n\t\n\t输入格式：每个测试输入包含1个测试用例，给出正整数N。\n\t\n\t输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。\n\t\n\t输入样例：\n\t20\n\t输出样例：\n\t4\n \n\n#### 解答 ####\n   \n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1007: 素数对猜想 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1007 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint total = in.nextInt();\n\t\t\tint times = 0;\n\t\t\tin.close();\n\t\n\t\t\tfor (int i = 1; i <= total - 2; i++) {\n\t\t\t\tif (isSu(i) && isSu(i + 2)) {\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(times);\n\t\t}\n\t\n\t\tstatic boolean isSu(int a) {\n\t\t\tboolean flag = true;\n\t\t\tif (a < 2) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfor (int i = 2; i <= Math.sqrt(a); i++) {\n\t\t\t\t\tif (a % i == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flag;\n\t\t}\n\t}\n\n\n#### 注意 ####\n\n- Math不需要import语句\n- 求解素数,循环整除的上限是该数的平方根","source":"_posts/2017-12-25-pat-yi-1007.md","raw":"---\nlayout: post\ntitle:  乙1007. 素数对猜想 (20)\ndate:   2017-12-25\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n>1有 dn 是偶数。\n\n\t“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n\n\t现给定任意正整数N (< 105)，请计算不超过N的满足猜想的素数对的个数。\n\t\n\t输入格式：每个测试输入包含1个测试用例，给出正整数N。\n\t\n\t输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。\n\t\n\t输入样例：\n\t20\n\t输出样例：\n\t4\n \n\n#### 解答 ####\n   \n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1007: 素数对猜想 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1007 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint total = in.nextInt();\n\t\t\tint times = 0;\n\t\t\tin.close();\n\t\n\t\t\tfor (int i = 1; i <= total - 2; i++) {\n\t\t\t\tif (isSu(i) && isSu(i + 2)) {\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(times);\n\t\t}\n\t\n\t\tstatic boolean isSu(int a) {\n\t\t\tboolean flag = true;\n\t\t\tif (a < 2) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfor (int i = 2; i <= Math.sqrt(a); i++) {\n\t\t\t\t\tif (a % i == 0) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flag;\n\t\t}\n\t}\n\n\n#### 注意 ####\n\n- Math不需要import语句\n- 求解素数,循环整除的上限是该数的平方根","slug":"pat-yi-1007","published":1,"updated":"2018-01-29T07:44:38.021Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1jj00882sivfpv6e58c","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。\n\n“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n\n现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。\n\n输入格式：每个测试输入包含1个测试用例，给出正整数N。\n\n输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。\n\n输入样例：\n20\n输出样例：\n4\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1007: 素数对猜想 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1007 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int total = in.nextInt();\n        int times = 0;\n        in.close();\n\n        for (int i = 1; i &lt;= total - 2; i++) {\n            if (isSu(i) &amp;&amp; isSu(i + 2)) {\n                times++;\n            }\n        }\n        System.out.println(times);\n    }\n\n    static boolean isSu(int a) {\n        boolean flag = true;\n        if (a &lt; 2) {\n            return false;\n        } else {\n            for (int i = 2; i &lt;= Math.sqrt(a); i++) {\n                if (a % i == 0) {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n        return flag;\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>Math不需要import语句</li>\n<li>求解素数,循环整除的上限是该数的平方根</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。\n\n“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。\n\n现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。\n\n输入格式：每个测试输入包含1个测试用例，给出正整数N。\n\n输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。\n\n输入样例：\n20\n输出样例：\n4\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1007: 素数对猜想 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1007 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int total = in.nextInt();\n        int times = 0;\n        in.close();\n\n        for (int i = 1; i &lt;= total - 2; i++) {\n            if (isSu(i) &amp;&amp; isSu(i + 2)) {\n                times++;\n            }\n        }\n        System.out.println(times);\n    }\n\n    static boolean isSu(int a) {\n        boolean flag = true;\n        if (a &lt; 2) {\n            return false;\n        } else {\n            for (int i = 2; i &lt;= Math.sqrt(a); i++) {\n                if (a % i == 0) {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n        return flag;\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>Math不需要import语句</li>\n<li>求解素数,循环整除的上限是该数的平方根</li>\n</ul>\n"},{"layout":"post","title":"乙1009. 说反话 (20)","date":"2017-12-25T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n\n\t输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。\n\n\t字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，\n\n\t单词之间用1个空格分开，输入保证句子末尾没有多余的空格。\n\t\n\t输出格式：每个测试用例的输出占一行，输出倒序后的句子。\n\t\n\t输入样例：\n\tHello World Here I Come\n\t输出样例：\n\tCome I Here World Hello\n \n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\t/**\n\t * No.1009. 说反话 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1009 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString str = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] datas = str.split(\" \");\n\t\t\tfor (int i = datas.length - 1; i >= 0; i--) {\n\t\t\t\tSystem.out.print(datas[i]);\n\t\t\t\tif (i >= 1) {\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n","source":"_posts/2017-12-25-pat-yi-1009.md","raw":"---\nlayout: post\ntitle:  乙1009. 说反话 (20)\ndate:   2017-12-25\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n\n\t输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。\n\n\t字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，\n\n\t单词之间用1个空格分开，输入保证句子末尾没有多余的空格。\n\t\n\t输出格式：每个测试用例的输出占一行，输出倒序后的句子。\n\t\n\t输入样例：\n\tHello World Here I Come\n\t输出样例：\n\tCome I Here World Hello\n \n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\t/**\n\t * No.1009. 说反话 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1009 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString str = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] datas = str.split(\" \");\n\t\t\tfor (int i = datas.length - 1; i >= 0; i--) {\n\t\t\t\tSystem.out.print(datas[i]);\n\t\t\t\tif (i >= 1) {\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n","slug":"pat-yi-1009","published":1,"updated":"2018-01-29T07:44:26.923Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1jn008c2siv73u4247f","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n\n输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。\n\n字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，\n\n单词之间用1个空格分开，输入保证句子末尾没有多余的空格。\n\n输出格式：每个测试用例的输出占一行，输出倒序后的句子。\n\n输入样例：\nHello World Here I Come\n输出样例：\nCome I Here World Hello\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n/**\n * No.1009. 说反话 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1009 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String str = in.nextLine();\n        in.close();\n        String[] datas = str.split(&quot; &quot;);\n        for (int i = datas.length - 1; i &gt;= 0; i--) {\n            System.out.print(datas[i]);\n            if (i &gt;= 1) {\n                System.out.print(&quot; &quot;);\n            }\n        }\n\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。\n\n输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。\n\n字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，\n\n单词之间用1个空格分开，输入保证句子末尾没有多余的空格。\n\n输出格式：每个测试用例的输出占一行，输出倒序后的句子。\n\n输入样例：\nHello World Here I Come\n输出样例：\nCome I Here World Hello\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n/**\n * No.1009. 说反话 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1009 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String str = in.nextLine();\n        in.close();\n        String[] datas = str.split(&quot; &quot;);\n        for (int i = datas.length - 1; i &gt;= 0; i--) {\n            System.out.print(datas[i]);\n            if (i &gt;= 1) {\n                System.out.print(&quot; &quot;);\n            }\n        }\n\n    }\n\n}\n</code></pre>"},{"layout":"post","title":"乙1008. 数组元素循环右移问题 (20)","date":"2017-12-25T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t一个数组A中存有N（N>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，\n\n\t即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考\n\n\t虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n\t输入格式：每个输入包含一个测试用例，第1行输入N ( 1<=N<=100)、M（M>=0）；第2行输入N个整数，之间用空格分隔。\n\t\n\t输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\t\n\t输入样例：\n\t6 2\n\t1 2 3 4 5 6\n\t输出样例：\n\t5 6 1 2 3 4\n \n\n#### 解答 ####\n   \n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1008: 数组元素循环右移问题 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1008 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint total = in.nextInt();\n\t\t\tint offset = in.nextInt();\n\t\t\tint[] array = new int[total];\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tint temp = in.nextInt();\n\t\t\t\tif (i + offset < total) {\n\t\t\t\t\tarray[i + offset] = temp;\n\t\t\t\t} else {\n\t\t\t\t\tarray[(i + offset) % total] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tSystem.out.print(array[i]);\n\t\t\t\tif (i < total - 1) {\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n\n\n\n#### 注意 ####\n\n- 根据示例,我一开始用的数组截取,然后打印,但是有两个测试用例没有通过.代码如下:\n\n\n\tpublic class No1008 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString firstLine = in.nextLine();\n\t\t\tString secondLine = in.nextLine();\n\t\t\tin.close();\n\t\t\tString datas[] = secondLine.split(\" \");\n\t\t\tint total = Integer.parseInt(firstLine.split(\" \")[0]);\n\t\t\tint offset = Integer.parseInt(firstLine.split(\" \")[1]);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = total - offset; i < datas.length; i++) {\n\t\t\t\tsb.append(datas[i]).append(\" \");\n\t\t\t}\n\t\t\tfor (int i = 0; i < total - offset; i++) {\n\t\t\t\tsb.append(datas[i]).append(\" \");\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString().trim());\n\t\t}\n\t}","source":"_posts/2017-12-25-pat-yi-1008.md","raw":"---\nlayout: post\ntitle:  乙1008. 数组元素循环右移问题 (20)\ndate:   2017-12-25\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t一个数组A中存有N（N>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，\n\n\t即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考\n\n\t虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n\t输入格式：每个输入包含一个测试用例，第1行输入N ( 1<=N<=100)、M（M>=0）；第2行输入N个整数，之间用空格分隔。\n\t\n\t输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\t\n\t输入样例：\n\t6 2\n\t1 2 3 4 5 6\n\t输出样例：\n\t5 6 1 2 3 4\n \n\n#### 解答 ####\n   \n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1008: 数组元素循环右移问题 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1008 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint total = in.nextInt();\n\t\t\tint offset = in.nextInt();\n\t\t\tint[] array = new int[total];\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tint temp = in.nextInt();\n\t\t\t\tif (i + offset < total) {\n\t\t\t\t\tarray[i + offset] = temp;\n\t\t\t\t} else {\n\t\t\t\t\tarray[(i + offset) % total] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\n\t\t\tfor (int i = 0; i < total; i++) {\n\t\t\t\tSystem.out.print(array[i]);\n\t\t\t\tif (i < total - 1) {\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n\n\n\n#### 注意 ####\n\n- 根据示例,我一开始用的数组截取,然后打印,但是有两个测试用例没有通过.代码如下:\n\n\n\tpublic class No1008 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString firstLine = in.nextLine();\n\t\t\tString secondLine = in.nextLine();\n\t\t\tin.close();\n\t\t\tString datas[] = secondLine.split(\" \");\n\t\t\tint total = Integer.parseInt(firstLine.split(\" \")[0]);\n\t\t\tint offset = Integer.parseInt(firstLine.split(\" \")[1]);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = total - offset; i < datas.length; i++) {\n\t\t\t\tsb.append(datas[i]).append(\" \");\n\t\t\t}\n\t\t\tfor (int i = 0; i < total - offset; i++) {\n\t\t\t\tsb.append(datas[i]).append(\" \");\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString().trim());\n\t\t}\n\t}","slug":"pat-yi-1008","published":1,"updated":"2018-01-29T07:44:31.320Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1jr008f2sivekc9j0es","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，\n\n即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考\n\n虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。\n\n输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\n输入样例：\n6 2\n1 2 3 4 5 6\n输出样例：\n5 6 1 2 3 4\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1008: 数组元素循环右移问题 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1008 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int total = in.nextInt();\n        int offset = in.nextInt();\n        int[] array = new int[total];\n        for (int i = 0; i &lt; total; i++) {\n            int temp = in.nextInt();\n            if (i + offset &lt; total) {\n                array[i + offset] = temp;\n            } else {\n                array[(i + offset) % total] = temp;\n            }\n        }\n        in.close();\n\n        for (int i = 0; i &lt; total; i++) {\n            System.out.print(array[i]);\n            if (i &lt; total - 1) {\n                System.out.print(&quot; &quot;);\n            }\n        }\n\n    }\n\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>根据示例,我一开始用的数组截取,然后打印,但是有两个测试用例没有通过.代码如下:</li>\n</ul>\n<pre><code>public class No1008 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String firstLine = in.nextLine();\n        String secondLine = in.nextLine();\n        in.close();\n        String datas[] = secondLine.split(&quot; &quot;);\n        int total = Integer.parseInt(firstLine.split(&quot; &quot;)[0]);\n        int offset = Integer.parseInt(firstLine.split(&quot; &quot;)[1]);\n        StringBuilder sb = new StringBuilder();\n        for (int i = total - offset; i &lt; datas.length; i++) {\n            sb.append(datas[i]).append(&quot; &quot;);\n        }\n        for (int i = 0; i &lt; total - offset; i++) {\n            sb.append(datas[i]).append(&quot; &quot;);\n        }\n        System.out.println(sb.toString().trim());\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，\n\n即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考\n\n虑程序移动数据的次数尽量少，要如何设计移动的方法？\n\n输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。\n\n输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。\n\n输入样例：\n6 2\n1 2 3 4 5 6\n输出样例：\n5 6 1 2 3 4\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1008: 数组元素循环右移问题 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1008 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int total = in.nextInt();\n        int offset = in.nextInt();\n        int[] array = new int[total];\n        for (int i = 0; i &lt; total; i++) {\n            int temp = in.nextInt();\n            if (i + offset &lt; total) {\n                array[i + offset] = temp;\n            } else {\n                array[(i + offset) % total] = temp;\n            }\n        }\n        in.close();\n\n        for (int i = 0; i &lt; total; i++) {\n            System.out.print(array[i]);\n            if (i &lt; total - 1) {\n                System.out.print(&quot; &quot;);\n            }\n        }\n\n    }\n\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>根据示例,我一开始用的数组截取,然后打印,但是有两个测试用例没有通过.代码如下:</li>\n</ul>\n<pre><code>public class No1008 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String firstLine = in.nextLine();\n        String secondLine = in.nextLine();\n        in.close();\n        String datas[] = secondLine.split(&quot; &quot;);\n        int total = Integer.parseInt(firstLine.split(&quot; &quot;)[0]);\n        int offset = Integer.parseInt(firstLine.split(&quot; &quot;)[1]);\n        StringBuilder sb = new StringBuilder();\n        for (int i = total - offset; i &lt; datas.length; i++) {\n            sb.append(datas[i]).append(&quot; &quot;);\n        }\n        for (int i = 0; i &lt; total - offset; i++) {\n            sb.append(datas[i]).append(&quot; &quot;);\n        }\n        System.out.println(sb.toString().trim());\n    }\n}\n</code></pre>"},{"layout":"post","title":"乙1010. 一元多项式求导 (25)","date":"2017-12-25T00:00:00.000Z","_content":" \n\n#### 题目 ####\n \n\t设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）\n\n\t输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n\t\n\t输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。\n\n\t注意“零多项式”的指数和系数都是0，但是表示为“0 0”。\n\t\n\t输入样例：\n\t3 4 -5 2 6 1 -2 0\n\t输出样例：\n\t12 3 -10 1 6 0\n \n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\t\n\tpublic class No1010 {\n\t\n\t\tpublic static void mains(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString str = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] datas = str.split(\" \");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < datas.length; i += 2) {\n\t\t\t\tif (i % 2 == 0 && i < datas.length - 1) {\n\t\t\t\t\tint x = Integer.parseInt(datas[i]) * Integer.parseInt(datas[i + 1]);\n\t\t\t\t\tif (Integer.parseInt(datas[i]) == 0 && Integer.parseInt(datas[i + 1]) == 0) {\n\t\t\t\t\t\tsb.append(\"0 0 \");\n\t\t\t\t\t} else if (x == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(x).append(\" \").append(Integer.parseInt(datas[i + 1]) - 1).append(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString().trim());\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tboolean isHaveOutput = false;\n\t\t\twhile (in.hasNext()) {\n\t\t\t\tint expon = in.nextInt();\n\t\t\t\tint coef = in.nextInt();\n\t\t\t\tif (expon * coef != 0) {\n\t\t\t\t\tif (isHaveOutput) {\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisHaveOutput = true;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.print(expon * coef + \" \" + (coef - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\n\t\t\tSystem.out.println(isHaveOutput);\n\t\t\tif (!isHaveOutput) {\n\t\t\t\tSystem.out.print(\"0 0\");\n\t\t\t}\n\t\t}\n\t}\n\n\n#### 疑惑 ####\n\n- 好多人的解法,如果结果为空,则输出\"0 0\",不知道从何而来\n","source":"_posts/2017-12-25-pat-yi-1010.md","raw":"---\nlayout: post\ntitle:  乙1010. 一元多项式求导 (25)\ndate:   2017-12-25\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n \n\t设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）\n\n\t输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n\t\n\t输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。\n\n\t注意“零多项式”的指数和系数都是0，但是表示为“0 0”。\n\t\n\t输入样例：\n\t3 4 -5 2 6 1 -2 0\n\t输出样例：\n\t12 3 -10 1 6 0\n \n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\t\n\tpublic class No1010 {\n\t\n\t\tpublic static void mains(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString str = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] datas = str.split(\" \");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < datas.length; i += 2) {\n\t\t\t\tif (i % 2 == 0 && i < datas.length - 1) {\n\t\t\t\t\tint x = Integer.parseInt(datas[i]) * Integer.parseInt(datas[i + 1]);\n\t\t\t\t\tif (Integer.parseInt(datas[i]) == 0 && Integer.parseInt(datas[i + 1]) == 0) {\n\t\t\t\t\t\tsb.append(\"0 0 \");\n\t\t\t\t\t} else if (x == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsb.append(x).append(\" \").append(Integer.parseInt(datas[i + 1]) - 1).append(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb.toString().trim());\n\t\t}\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tboolean isHaveOutput = false;\n\t\t\twhile (in.hasNext()) {\n\t\t\t\tint expon = in.nextInt();\n\t\t\t\tint coef = in.nextInt();\n\t\t\t\tif (expon * coef != 0) {\n\t\t\t\t\tif (isHaveOutput) {\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisHaveOutput = true;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.print(expon * coef + \" \" + (coef - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\n\t\t\tSystem.out.println(isHaveOutput);\n\t\t\tif (!isHaveOutput) {\n\t\t\t\tSystem.out.print(\"0 0\");\n\t\t\t}\n\t\t}\n\t}\n\n\n#### 疑惑 ####\n\n- 好多人的解法,如果结果为空,则输出\"0 0\",不知道从何而来\n","slug":"pat-yi-1010","published":1,"updated":"2018-01-29T07:44:21.398Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1jw008i2sivu9grkyk4","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）\n\n输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n\n输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。\n\n注意“零多项式”的指数和系数都是0，但是表示为“0 0”。\n\n输入样例：\n3 4 -5 2 6 1 -2 0\n输出样例：\n12 3 -10 1 6 0\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1010 {\n\n    public static void mains(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String str = in.nextLine();\n        in.close();\n        String[] datas = str.split(&quot; &quot;);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; datas.length; i += 2) {\n            if (i % 2 == 0 &amp;&amp; i &lt; datas.length - 1) {\n                int x = Integer.parseInt(datas[i]) * Integer.parseInt(datas[i + 1]);\n                if (Integer.parseInt(datas[i]) == 0 &amp;&amp; Integer.parseInt(datas[i + 1]) == 0) {\n                    sb.append(&quot;0 0 &quot;);\n                } else if (x == 0) {\n                    continue;\n                } else {\n                    sb.append(x).append(&quot; &quot;).append(Integer.parseInt(datas[i + 1]) - 1).append(&quot; &quot;);\n                }\n            }\n        }\n        System.out.println(sb.toString().trim());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        boolean isHaveOutput = false;\n        while (in.hasNext()) {\n            int expon = in.nextInt();\n            int coef = in.nextInt();\n            if (expon * coef != 0) {\n                if (isHaveOutput) {\n                    System.out.print(&quot; &quot;);\n                } else {\n                    isHaveOutput = true;\n                }\n                System.out.print(expon * coef + &quot; &quot; + (coef - 1));\n            }\n        }\n        in.close();\n\n        System.out.println(isHaveOutput);\n        if (!isHaveOutput) {\n            System.out.print(&quot;0 0&quot;);\n        }\n    }\n}\n</code></pre><h4 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h4><ul>\n<li>好多人的解法,如果结果为空,则输出”0 0”,不知道从何而来</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><pre><code>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）\n\n输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。\n\n输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。\n\n注意“零多项式”的指数和系数都是0，但是表示为“0 0”。\n\n输入样例：\n3 4 -5 2 6 1 -2 0\n输出样例：\n12 3 -10 1 6 0\n</code></pre><h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1010 {\n\n    public static void mains(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String str = in.nextLine();\n        in.close();\n        String[] datas = str.split(&quot; &quot;);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; datas.length; i += 2) {\n            if (i % 2 == 0 &amp;&amp; i &lt; datas.length - 1) {\n                int x = Integer.parseInt(datas[i]) * Integer.parseInt(datas[i + 1]);\n                if (Integer.parseInt(datas[i]) == 0 &amp;&amp; Integer.parseInt(datas[i + 1]) == 0) {\n                    sb.append(&quot;0 0 &quot;);\n                } else if (x == 0) {\n                    continue;\n                } else {\n                    sb.append(x).append(&quot; &quot;).append(Integer.parseInt(datas[i + 1]) - 1).append(&quot; &quot;);\n                }\n            }\n        }\n        System.out.println(sb.toString().trim());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        boolean isHaveOutput = false;\n        while (in.hasNext()) {\n            int expon = in.nextInt();\n            int coef = in.nextInt();\n            if (expon * coef != 0) {\n                if (isHaveOutput) {\n                    System.out.print(&quot; &quot;);\n                } else {\n                    isHaveOutput = true;\n                }\n                System.out.print(expon * coef + &quot; &quot; + (coef - 1));\n            }\n        }\n        in.close();\n\n        System.out.println(isHaveOutput);\n        if (!isHaveOutput) {\n            System.out.print(&quot;0 0&quot;);\n        }\n    }\n}\n</code></pre><h4 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h4><ul>\n<li>好多人的解法,如果结果为空,则输出”0 0”,不知道从何而来</li>\n</ul>\n"},{"layout":"post","title":"kotlin-扩展函数","date":"2017-12-26T00:00:00.000Z","_content":"\n#### 问题引出 ####\n\n在调用一个对象的方法的时候,IDE自动提示了如下的方法:(请看图中白色的方法)\n![1-1](/images/kotlin_extension_fun.png)\n\n#### 追踪 ####\n\n\t文件位置`org\\jetbrains\\kotlin\\kotlin-stdlib\\1.1.51\\kotlin-stdlib-1.1.51.jar!\\kotlin\\NotImplementedError.class`\n\n\t打开方法所在的文件,第一行:\n\n\t@file:kotlin.jvm.JvmMultifileClass // 包名相同,类名也相同,或者有相同的@JvmName注解,会出错,使用此注解\n\t@file:kotlin.jvm.JvmName(\"StandardKt\") // 使用注解,修改生成的Java类的类名\n\n引申:\n\t在Java中,如果需要把kotlin属性作为字段暴露,需要使用@JvmField注解标注.[更多Java和kotlin互相调用](https://www.kotlincn.net/docs/reference/java-to-kotlin-interop.html)\n\n最后发现这几个函数叫做扩展函数.官方api:[链接](https://www.kotlincn.net/docs/reference/extensions.html)\n\n- 能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的设计模式.\n- 扩展函数不能真正的修改他们所扩展的类.通过定义一个扩展,你并没有在一个类中插入新成员,仅仅是可以通过该类型的变量用点表达式去调用该函数\n- 图片上的是官方提供的扩展函数,我们也可以自己扩展,参考链接中的注意事项.\n\n#### 官方扩展函数 ####\n\n###### let函数 #####\n\n\tlet默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return\n\n- 闭包\n\t- 外部变量 + 函数 组成一个闭包\n\t- 通常实现方式为函数内定义另外一个函数\n\t- 内部函数可以引用外部函数的变量和参数\n\t- 参数和变量不会被垃圾回收器回收\n\t- 作用:\n\t\t- 隐藏关键的变量,把一个全局变量写成局部变量\n\t\t- \n- it参数,一个方法如果只有一个参数,可以用it代替 \n \n\n###### apply函数 #####\n\n\t调用某对象的apply函数,在apply里可以调用该对象的任意方法,并返回该对象,如果let指定return it,两个一样的.\n\t\n\t\nbuıxbuıɥs‾\n\n \n ","source":"_posts/2017-12-26-kotlin-extension-function.md","raw":"---\nlayout: post\ntitle:  kotlin-扩展函数\ndate:   2017-12-26\ncategories: JAVA & kotlin\ntag: 杂项\n---\n\n#### 问题引出 ####\n\n在调用一个对象的方法的时候,IDE自动提示了如下的方法:(请看图中白色的方法)\n![1-1](/images/kotlin_extension_fun.png)\n\n#### 追踪 ####\n\n\t文件位置`org\\jetbrains\\kotlin\\kotlin-stdlib\\1.1.51\\kotlin-stdlib-1.1.51.jar!\\kotlin\\NotImplementedError.class`\n\n\t打开方法所在的文件,第一行:\n\n\t@file:kotlin.jvm.JvmMultifileClass // 包名相同,类名也相同,或者有相同的@JvmName注解,会出错,使用此注解\n\t@file:kotlin.jvm.JvmName(\"StandardKt\") // 使用注解,修改生成的Java类的类名\n\n引申:\n\t在Java中,如果需要把kotlin属性作为字段暴露,需要使用@JvmField注解标注.[更多Java和kotlin互相调用](https://www.kotlincn.net/docs/reference/java-to-kotlin-interop.html)\n\n最后发现这几个函数叫做扩展函数.官方api:[链接](https://www.kotlincn.net/docs/reference/extensions.html)\n\n- 能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的设计模式.\n- 扩展函数不能真正的修改他们所扩展的类.通过定义一个扩展,你并没有在一个类中插入新成员,仅仅是可以通过该类型的变量用点表达式去调用该函数\n- 图片上的是官方提供的扩展函数,我们也可以自己扩展,参考链接中的注意事项.\n\n#### 官方扩展函数 ####\n\n###### let函数 #####\n\n\tlet默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return\n\n- 闭包\n\t- 外部变量 + 函数 组成一个闭包\n\t- 通常实现方式为函数内定义另外一个函数\n\t- 内部函数可以引用外部函数的变量和参数\n\t- 参数和变量不会被垃圾回收器回收\n\t- 作用:\n\t\t- 隐藏关键的变量,把一个全局变量写成局部变量\n\t\t- \n- it参数,一个方法如果只有一个参数,可以用it代替 \n \n\n###### apply函数 #####\n\n\t调用某对象的apply函数,在apply里可以调用该对象的任意方法,并返回该对象,如果let指定return it,两个一样的.\n\t\n\t\nbuıxbuıɥs‾\n\n \n ","slug":"kotlin-extension-function","published":1,"updated":"2017-12-27T09:34:49.850Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1k0008l2siv4vq09mtt","content":"<h4 id=\"问题引出\"><a href=\"#问题引出\" class=\"headerlink\" title=\"问题引出\"></a>问题引出</h4><p>在调用一个对象的方法的时候,IDE自动提示了如下的方法:(请看图中白色的方法)<br><img src=\"/images/kotlin_extension_fun.png\" alt=\"1-1\"></p>\n<h4 id=\"追踪\"><a href=\"#追踪\" class=\"headerlink\" title=\"追踪\"></a>追踪</h4><pre><code>文件位置`org\\jetbrains\\kotlin\\kotlin-stdlib\\1.1.51\\kotlin-stdlib-1.1.51.jar!\\kotlin\\NotImplementedError.class`\n\n打开方法所在的文件,第一行:\n\n@file:kotlin.jvm.JvmMultifileClass // 包名相同,类名也相同,或者有相同的@JvmName注解,会出错,使用此注解\n@file:kotlin.jvm.JvmName(&quot;StandardKt&quot;) // 使用注解,修改生成的Java类的类名\n</code></pre><p>引申:<br>    在Java中,如果需要把kotlin属性作为字段暴露,需要使用@JvmField注解标注.<a href=\"https://www.kotlincn.net/docs/reference/java-to-kotlin-interop.html\" target=\"_blank\" rel=\"external\">更多Java和kotlin互相调用</a></p>\n<p>最后发现这几个函数叫做扩展函数.官方api:<a href=\"https://www.kotlincn.net/docs/reference/extensions.html\" target=\"_blank\" rel=\"external\">链接</a></p>\n<ul>\n<li>能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的设计模式.</li>\n<li>扩展函数不能真正的修改他们所扩展的类.通过定义一个扩展,你并没有在一个类中插入新成员,仅仅是可以通过该类型的变量用点表达式去调用该函数</li>\n<li>图片上的是官方提供的扩展函数,我们也可以自己扩展,参考链接中的注意事项.</li>\n</ul>\n<h4 id=\"官方扩展函数\"><a href=\"#官方扩展函数\" class=\"headerlink\" title=\"官方扩展函数\"></a>官方扩展函数</h4><h6 id=\"let函数\"><a href=\"#let函数\" class=\"headerlink\" title=\"let函数\"></a>let函数</h6><pre><code>let默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return\n</code></pre><ul>\n<li>闭包<ul>\n<li>外部变量 + 函数 组成一个闭包</li>\n<li>通常实现方式为函数内定义另外一个函数</li>\n<li>内部函数可以引用外部函数的变量和参数</li>\n<li>参数和变量不会被垃圾回收器回收</li>\n<li>作用:<ul>\n<li>隐藏关键的变量,把一个全局变量写成局部变量</li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>it参数,一个方法如果只有一个参数,可以用it代替 </li>\n</ul>\n<h6 id=\"apply函数\"><a href=\"#apply函数\" class=\"headerlink\" title=\"apply函数\"></a>apply函数</h6><pre><code>调用某对象的apply函数,在apply里可以调用该对象的任意方法,并返回该对象,如果let指定return it,两个一样的.\n</code></pre><p>buıxbuıɥs‾</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"问题引出\"><a href=\"#问题引出\" class=\"headerlink\" title=\"问题引出\"></a>问题引出</h4><p>在调用一个对象的方法的时候,IDE自动提示了如下的方法:(请看图中白色的方法)<br><img src=\"/images/kotlin_extension_fun.png\" alt=\"1-1\"></p>\n<h4 id=\"追踪\"><a href=\"#追踪\" class=\"headerlink\" title=\"追踪\"></a>追踪</h4><pre><code>文件位置`org\\jetbrains\\kotlin\\kotlin-stdlib\\1.1.51\\kotlin-stdlib-1.1.51.jar!\\kotlin\\NotImplementedError.class`\n\n打开方法所在的文件,第一行:\n\n@file:kotlin.jvm.JvmMultifileClass // 包名相同,类名也相同,或者有相同的@JvmName注解,会出错,使用此注解\n@file:kotlin.jvm.JvmName(&quot;StandardKt&quot;) // 使用注解,修改生成的Java类的类名\n</code></pre><p>引申:<br>    在Java中,如果需要把kotlin属性作为字段暴露,需要使用@JvmField注解标注.<a href=\"https://www.kotlincn.net/docs/reference/java-to-kotlin-interop.html\" target=\"_blank\" rel=\"external\">更多Java和kotlin互相调用</a></p>\n<p>最后发现这几个函数叫做扩展函数.官方api:<a href=\"https://www.kotlincn.net/docs/reference/extensions.html\" target=\"_blank\" rel=\"external\">链接</a></p>\n<ul>\n<li>能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的设计模式.</li>\n<li>扩展函数不能真正的修改他们所扩展的类.通过定义一个扩展,你并没有在一个类中插入新成员,仅仅是可以通过该类型的变量用点表达式去调用该函数</li>\n<li>图片上的是官方提供的扩展函数,我们也可以自己扩展,参考链接中的注意事项.</li>\n</ul>\n<h4 id=\"官方扩展函数\"><a href=\"#官方扩展函数\" class=\"headerlink\" title=\"官方扩展函数\"></a>官方扩展函数</h4><h6 id=\"let函数\"><a href=\"#let函数\" class=\"headerlink\" title=\"let函数\"></a>let函数</h6><pre><code>let默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return\n</code></pre><ul>\n<li>闭包<ul>\n<li>外部变量 + 函数 组成一个闭包</li>\n<li>通常实现方式为函数内定义另外一个函数</li>\n<li>内部函数可以引用外部函数的变量和参数</li>\n<li>参数和变量不会被垃圾回收器回收</li>\n<li>作用:<ul>\n<li>隐藏关键的变量,把一个全局变量写成局部变量</li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>it参数,一个方法如果只有一个参数,可以用it代替 </li>\n</ul>\n<h6 id=\"apply函数\"><a href=\"#apply函数\" class=\"headerlink\" title=\"apply函数\"></a>apply函数</h6><pre><code>调用某对象的apply函数,在apply里可以调用该对象的任意方法,并返回该对象,如果let指定return it,两个一样的.\n</code></pre><p>buıxbuıɥs‾</p>\n"},{"layout":"post","title":"关于Android的感想","date":"2017-12-26T00:00:00.000Z","_content":"\n元旦在即.突发一些感悟.Android平台的开发的该何去何从?\n\n我本身从2012年实习就一直开发做Android.因为本身天资并不高,\n\n缺少很多顿悟的灵气,许多感悟都是自己撞破头,才得出来一点点.\n\n到现在突然有了一些感悟,就赶紧记下来.\n\n前一段时间,`Android Studio 3.0` 发布稳定版本,我们去新建一个\n\n示例,得到的都是`kotlin`语言编写的源码.由于我在最近一年多的时间\n\n内都在使用kotlin,对kotlin还算`手熟`.没有感到很多意外.\n\n后半年在`Java虚拟机`,`数据结构`,`算法`,`Android多线程`相关的\n\n知识在补课.后来又接触`Python`,`Go`.发现语言都是在向程序员友好\n\n方面发展.轻量级语言越来越多.\n\nAndroid虽然是一个操作系统,但是如果编写普通的Android应用,\n\n还是和前端差不多的,但是他所使用的语言却是Java这样的庞然大物.\n\n再加上kotlin正式`扶正`,kotlin这种面向对象+脚本的快捷语言,才是\n\n编写Android应用的利器.\n\n我就感到Android的发展方向,要有变化:\n\n\tAndroid应用的未来,要改写了:\n\n\t使用kotlin这种语言开发,然后配合成熟的hybrid框架,涉及核心\n\n\t业务或者安全的代码由c/c++去封装.\n\n这些,都不是什么新东西.尤其是混合应用,从Android诞生,就开始提,\n\n但是到现在也没有成熟的方案.kotlin发布也有几年了,今年才刚刚扶正.\n\n我预测,以后的Android App还会有一个高潮期,kotlin会默默融入并\n\n替换,但不会太震动,真的让大部分普通app纷纷改头换面的,应该是hybrid\n\n成熟的框架诞生.现在应该已经有人在做,但是还没有出世.\n\n现在的app,像支付宝,淘宝,应该是h5显示UI,安全核心模块配以C/C++\n\n像微信,是C/C++的基础支撑库配合Java编写,也有部分h5.\n\n想阿里的这些应用,已经在尝试,可以说很艰难,说得难听一些,就是现在的\n\n混合应用难用的屎一样.\n\n未来一旦成熟的hybrid框架发布,那么许多app就要迎来春天了.\n\n后面:\n\n这些想法,从我入行,就已经听到有人不停的在提,有许多人在做许多的\n\n尝试,这令人敬佩他们的前瞻性.而我今天才想到这个道理,并且描述\n\n的磕磕绊绊,只能露出一个尴尬而不失礼貌的微笑了.\n\n写到这里,昨天还立志做一个算法工程师,今天貌似就要变成开发一个令人\n\n激动的hybrid框架了.这个... ... 还是保持刚才的微笑吧!\n \n\n \n ","source":"_posts/2017-12-26-new-year-about-android.md","raw":"---\nlayout: post\ntitle:  关于Android的感想\ndate:   2017-12-26\ncategories: Others\ntag: 杂项\n---\n\n元旦在即.突发一些感悟.Android平台的开发的该何去何从?\n\n我本身从2012年实习就一直开发做Android.因为本身天资并不高,\n\n缺少很多顿悟的灵气,许多感悟都是自己撞破头,才得出来一点点.\n\n到现在突然有了一些感悟,就赶紧记下来.\n\n前一段时间,`Android Studio 3.0` 发布稳定版本,我们去新建一个\n\n示例,得到的都是`kotlin`语言编写的源码.由于我在最近一年多的时间\n\n内都在使用kotlin,对kotlin还算`手熟`.没有感到很多意外.\n\n后半年在`Java虚拟机`,`数据结构`,`算法`,`Android多线程`相关的\n\n知识在补课.后来又接触`Python`,`Go`.发现语言都是在向程序员友好\n\n方面发展.轻量级语言越来越多.\n\nAndroid虽然是一个操作系统,但是如果编写普通的Android应用,\n\n还是和前端差不多的,但是他所使用的语言却是Java这样的庞然大物.\n\n再加上kotlin正式`扶正`,kotlin这种面向对象+脚本的快捷语言,才是\n\n编写Android应用的利器.\n\n我就感到Android的发展方向,要有变化:\n\n\tAndroid应用的未来,要改写了:\n\n\t使用kotlin这种语言开发,然后配合成熟的hybrid框架,涉及核心\n\n\t业务或者安全的代码由c/c++去封装.\n\n这些,都不是什么新东西.尤其是混合应用,从Android诞生,就开始提,\n\n但是到现在也没有成熟的方案.kotlin发布也有几年了,今年才刚刚扶正.\n\n我预测,以后的Android App还会有一个高潮期,kotlin会默默融入并\n\n替换,但不会太震动,真的让大部分普通app纷纷改头换面的,应该是hybrid\n\n成熟的框架诞生.现在应该已经有人在做,但是还没有出世.\n\n现在的app,像支付宝,淘宝,应该是h5显示UI,安全核心模块配以C/C++\n\n像微信,是C/C++的基础支撑库配合Java编写,也有部分h5.\n\n想阿里的这些应用,已经在尝试,可以说很艰难,说得难听一些,就是现在的\n\n混合应用难用的屎一样.\n\n未来一旦成熟的hybrid框架发布,那么许多app就要迎来春天了.\n\n后面:\n\n这些想法,从我入行,就已经听到有人不停的在提,有许多人在做许多的\n\n尝试,这令人敬佩他们的前瞻性.而我今天才想到这个道理,并且描述\n\n的磕磕绊绊,只能露出一个尴尬而不失礼貌的微笑了.\n\n写到这里,昨天还立志做一个算法工程师,今天貌似就要变成开发一个令人\n\n激动的hybrid框架了.这个... ... 还是保持刚才的微笑吧!\n \n\n \n ","slug":"new-year-about-android","published":1,"updated":"2017-12-26T06:41:43.178Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1k3008o2sivcosap0cf","content":"<p>元旦在即.突发一些感悟.Android平台的开发的该何去何从?</p>\n<p>我本身从2012年实习就一直开发做Android.因为本身天资并不高,</p>\n<p>缺少很多顿悟的灵气,许多感悟都是自己撞破头,才得出来一点点.</p>\n<p>到现在突然有了一些感悟,就赶紧记下来.</p>\n<p>前一段时间,<code>Android Studio 3.0</code> 发布稳定版本,我们去新建一个</p>\n<p>示例,得到的都是<code>kotlin</code>语言编写的源码.由于我在最近一年多的时间</p>\n<p>内都在使用kotlin,对kotlin还算<code>手熟</code>.没有感到很多意外.</p>\n<p>后半年在<code>Java虚拟机</code>,<code>数据结构</code>,<code>算法</code>,<code>Android多线程</code>相关的</p>\n<p>知识在补课.后来又接触<code>Python</code>,<code>Go</code>.发现语言都是在向程序员友好</p>\n<p>方面发展.轻量级语言越来越多.</p>\n<p>Android虽然是一个操作系统,但是如果编写普通的Android应用,</p>\n<p>还是和前端差不多的,但是他所使用的语言却是Java这样的庞然大物.</p>\n<p>再加上kotlin正式<code>扶正</code>,kotlin这种面向对象+脚本的快捷语言,才是</p>\n<p>编写Android应用的利器.</p>\n<p>我就感到Android的发展方向,要有变化:</p>\n<pre><code>Android应用的未来,要改写了:\n\n使用kotlin这种语言开发,然后配合成熟的hybrid框架,涉及核心\n\n业务或者安全的代码由c/c++去封装.\n</code></pre><p>这些,都不是什么新东西.尤其是混合应用,从Android诞生,就开始提,</p>\n<p>但是到现在也没有成熟的方案.kotlin发布也有几年了,今年才刚刚扶正.</p>\n<p>我预测,以后的Android App还会有一个高潮期,kotlin会默默融入并</p>\n<p>替换,但不会太震动,真的让大部分普通app纷纷改头换面的,应该是hybrid</p>\n<p>成熟的框架诞生.现在应该已经有人在做,但是还没有出世.</p>\n<p>现在的app,像支付宝,淘宝,应该是h5显示UI,安全核心模块配以C/C++</p>\n<p>像微信,是C/C++的基础支撑库配合Java编写,也有部分h5.</p>\n<p>想阿里的这些应用,已经在尝试,可以说很艰难,说得难听一些,就是现在的</p>\n<p>混合应用难用的屎一样.</p>\n<p>未来一旦成熟的hybrid框架发布,那么许多app就要迎来春天了.</p>\n<p>后面:</p>\n<p>这些想法,从我入行,就已经听到有人不停的在提,有许多人在做许多的</p>\n<p>尝试,这令人敬佩他们的前瞻性.而我今天才想到这个道理,并且描述</p>\n<p>的磕磕绊绊,只能露出一个尴尬而不失礼貌的微笑了.</p>\n<p>写到这里,昨天还立志做一个算法工程师,今天貌似就要变成开发一个令人</p>\n<p>激动的hybrid框架了.这个… … 还是保持刚才的微笑吧!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>元旦在即.突发一些感悟.Android平台的开发的该何去何从?</p>\n<p>我本身从2012年实习就一直开发做Android.因为本身天资并不高,</p>\n<p>缺少很多顿悟的灵气,许多感悟都是自己撞破头,才得出来一点点.</p>\n<p>到现在突然有了一些感悟,就赶紧记下来.</p>\n<p>前一段时间,<code>Android Studio 3.0</code> 发布稳定版本,我们去新建一个</p>\n<p>示例,得到的都是<code>kotlin</code>语言编写的源码.由于我在最近一年多的时间</p>\n<p>内都在使用kotlin,对kotlin还算<code>手熟</code>.没有感到很多意外.</p>\n<p>后半年在<code>Java虚拟机</code>,<code>数据结构</code>,<code>算法</code>,<code>Android多线程</code>相关的</p>\n<p>知识在补课.后来又接触<code>Python</code>,<code>Go</code>.发现语言都是在向程序员友好</p>\n<p>方面发展.轻量级语言越来越多.</p>\n<p>Android虽然是一个操作系统,但是如果编写普通的Android应用,</p>\n<p>还是和前端差不多的,但是他所使用的语言却是Java这样的庞然大物.</p>\n<p>再加上kotlin正式<code>扶正</code>,kotlin这种面向对象+脚本的快捷语言,才是</p>\n<p>编写Android应用的利器.</p>\n<p>我就感到Android的发展方向,要有变化:</p>\n<pre><code>Android应用的未来,要改写了:\n\n使用kotlin这种语言开发,然后配合成熟的hybrid框架,涉及核心\n\n业务或者安全的代码由c/c++去封装.\n</code></pre><p>这些,都不是什么新东西.尤其是混合应用,从Android诞生,就开始提,</p>\n<p>但是到现在也没有成熟的方案.kotlin发布也有几年了,今年才刚刚扶正.</p>\n<p>我预测,以后的Android App还会有一个高潮期,kotlin会默默融入并</p>\n<p>替换,但不会太震动,真的让大部分普通app纷纷改头换面的,应该是hybrid</p>\n<p>成熟的框架诞生.现在应该已经有人在做,但是还没有出世.</p>\n<p>现在的app,像支付宝,淘宝,应该是h5显示UI,安全核心模块配以C/C++</p>\n<p>像微信,是C/C++的基础支撑库配合Java编写,也有部分h5.</p>\n<p>想阿里的这些应用,已经在尝试,可以说很艰难,说得难听一些,就是现在的</p>\n<p>混合应用难用的屎一样.</p>\n<p>未来一旦成熟的hybrid框架发布,那么许多app就要迎来春天了.</p>\n<p>后面:</p>\n<p>这些想法,从我入行,就已经听到有人不停的在提,有许多人在做许多的</p>\n<p>尝试,这令人敬佩他们的前瞻性.而我今天才想到这个道理,并且描述</p>\n<p>的磕磕绊绊,只能露出一个尴尬而不失礼貌的微笑了.</p>\n<p>写到这里,昨天还立志做一个算法工程师,今天貌似就要变成开发一个令人</p>\n<p>激动的hybrid框架了.这个… … 还是保持刚才的微笑吧!</p>\n"},{"layout":"post","title":"Android电量优化(使用Battery Historian)","date":"2018-01-08T00:00:00.000Z","_content":"\n#### 目录 ####\n\n- 如何收集数据\n- 数据图表的含义\n- 如何分析并优化\n\n#### 收集数据 ####\n\n- 手机连接USB,执行`adb shell dumpsys batterystats --reset`命令,清空电池的历史状态\n- 断开USB,打开目标应用,正常使用5分钟左右\n- 连接USB,执行`adb bugreport bugreport.zip`,可以到处zip文件到当前目录下\n- 浏览器进入`Battery Historian`,上传已生成的zip,然后会自动生成分析图表文件.\n\n\t其实在收集数据时候,我们应该尽量正常使用手机,然后打开几个友商App,大概使用个10分钟左右,导出数据,先看系统电量状态,然后看这几个友商app的耗电情况,然后对比自家产品,看看可以优化的地方在哪里.\n\n关于`Battery Historian`的使用:[传送](http://xusx1024.com/2018/01/04/battery-historian/)\n\n#### 图表导览 ####\n\n* 鉴于网上相关博客过多关于`Historian`的说明,我们的重点是新版`Historian V2`\n\n![File Info](/images/battery_historian_file_info.png)\n\n![Historian](/images/battery_historian_historian.png)\n\n该图各个条目的意思,我们按照各个维度在图片左上右下的顺序来讲述,读者可以对比自己的图表,来查看如下的条目说明:\n\n##### 左 #####\n- CPU running: CPU运行,从开始使用app到转储使用信息,CPU是持续耗电的,与之相似的是`Userspace wakelock`,`Screen`\n- Kernel only uptime: 仅内核运行时间.即:CPU运行,但是屏幕没有唤醒的情况.产生该维度是用来和`CPU running`,`Userspace wakelock`作比较,不会出现在电量日志记录里\n- Userspace wakelock: 一般情况下,设备空闲,屏幕关闭,最后CPU停止运行,wake_lock可以阻止CPU休眠,比如后台持续下载.该维度只记录第一个使用wake_lock的app,如果需要记录所有的,使用`adb shell dumpsys batterystates --enable full-wake-history`\n- **Long Wakelocks**: 如果这个维度出现了记录,说明持有wake_lock已经超过1分钟了,这样是极其不正常的\n- Screen:屏幕维度\n\t- 红色:亮屏\n\t- 白色:息屏\n- **Top app**:耗电最高的应用,如果我们专注于使用测试目标app,那么该维度反而没有用了.其实在正常使用手机下测试,该维度很重要.\n- **Activity Manager Proc**: 活动管理者进程.在我们示例的图中,该进程被两次调起,一次是应用启动,一次是定位服务启动\n- **Crashes(logcat)**:crash耗电信息\n- **JobScheduler**: 任务调度器耗电信息\n- **SyncManager**:同步管理耗电信息.即账户管理器同步相关的.\n- GPS:GPS定位\n\t- 红色:开\n\t- 白色:关\n- **Bluetooth Scan(logcat)**:蓝牙搜索耗电信息\n- BLE scanning:Bluetooth Low Energy,又叫蓝牙4.0,区别于蓝牙3.0和之前的版本.\n\t- 绿色:开\n\t- 白色:关\n- Mobile signal strength: 手机信号强度\n\t- 白色:无信号\n\t- 红色:差\n\t- 橙色:略微好一些\n\t- 黄色:好\n\t- 绿色:棒棒\n- WiFi full lock:和wake lock机制相似,此锁是用于wifi的.\n\t- 绿色:开\n\t- 白色:关\n- WiFi scan: wifi扫描\n- Wifi supplicant:WiFi请求状态\n![wifi-supplicant](/images/wifi-supplicant.png)\n- wifi radio:大概就是wifi是否一直连接.表面含义是wifi 广播.\n\t- 绿色:开\n\t- 白色:关\n- wifi signal strength:wifi信号强度\n\t- 白色:无信号\n\t- 红色:差\n\t- 橙色:略微好一些\n\t- 黄色:好\n\t- 绿色:棒棒\n- wifi multicast: wifi组播\n\t- 绿色:开\n\t- 白色:关\n- wifi running:wifi是否一直运行\n\t- 绿色:开\n\t- 白色:关\n- wifi on:wifi开关是否开启,开启后,如果由于故障,wifi模组不一定运行.\n\t- 绿色:开\n\t- 白色:关\n- Audio:音频.我测试的app中是没有故意加音效的,但是出现了耗电的现象.\n\t- 绿色:开\n\t- 白色:关\n- Foreground process:前台进程.\n- Package active:活动的包,大概指的是运行中的,在前台的包(app)\n- Battery level:统计电量时的耗电量\n- Coulomb charge:库伦是电量单位,难道这是电费??\n- Temperature:温度\n![Temperature](/images/battery_temperature.png)\n- plugged:插电状态,在充电状态为关的这一段时间,是我们的手机的真实耗电时间\n\t- 绿色:开\n\t- 白色:关\n- charging on:充电.如果100电量,就是关闭状态了.\n\t- 绿色:开\n\t- 白色:关\n- Logcat misc:日志杂项.misc. = miscellaneous\n- health:电池?手机健康状态?\n- Plug:插头\n- Voltage:电压\n- charging status:充电状态\n\n\n##### 上 #####\n\n下面几个复选框,可以都试试,控制显示电量条和每个维度的耗电条的\n\n- Add Metrics:增加度量项目\n- show bars\n- show level summaries\n- show line overlay\n- show rate of change\n\n##### 右 #####\n电量余量\n##### 下 #####\n东八区上海时间\n\n\n##### app selection #####\n\n详细数据,都在这个模块里面.读者可以先整体查看`System Stats`里面的数据,然后选定自家的app,看看是不是主因.再根据业务和本文下一个模块的优化建议,斟酌优化.\n该功能虽然称为`Historian`,真正的只能有一个粗略的电量统计,在统计过程中,也要耗电.要综合考虑各种情况,慎重优化.\n\n#### 分析,优化建议 ####\n\n耗电大户:\n\n- 屏幕唤醒\n- CPU唤醒\n- 蜂窝数据\n- 传感器\n\n优化建议:\n\n- 对业务要非常熟悉\n- 传感器的使用,比如gps,如果业务上非频繁使用并且要求精度不高,那么就在业务上优化定位时机和精度.\n- 如果业务上需要有长时间的service,那么要考虑到CPU weak lock,防止后台任务没有完成,但是cpu睡眠,或者任务已经完成,仍然持有weak lock\n- 我们也许会在手机充电时,做一些日志上传操作的定时任务,那么注意重试次数和成功后处理,防止用户一夜充电不到80%,然后手机厂商为我们背锅的情况\n- 已知屏幕唤醒是耗电大户,原因是屏幕渲染,绘制消耗资源,所以我们在自定义视图,布局的时候,要尽量做到Android性能优化里要求\n- 同理,各种优化,平时编码的习惯,都会影响我们脆弱的电量\n- \n\n ","source":"_posts/2018-01-08-battery-historian-2.md","raw":"---\nlayout: post\ntitle:  Android电量优化(使用Battery Historian)\ndate:   2018-01-08\ncategories: Android\ntag: android\n---\n\n#### 目录 ####\n\n- 如何收集数据\n- 数据图表的含义\n- 如何分析并优化\n\n#### 收集数据 ####\n\n- 手机连接USB,执行`adb shell dumpsys batterystats --reset`命令,清空电池的历史状态\n- 断开USB,打开目标应用,正常使用5分钟左右\n- 连接USB,执行`adb bugreport bugreport.zip`,可以到处zip文件到当前目录下\n- 浏览器进入`Battery Historian`,上传已生成的zip,然后会自动生成分析图表文件.\n\n\t其实在收集数据时候,我们应该尽量正常使用手机,然后打开几个友商App,大概使用个10分钟左右,导出数据,先看系统电量状态,然后看这几个友商app的耗电情况,然后对比自家产品,看看可以优化的地方在哪里.\n\n关于`Battery Historian`的使用:[传送](http://xusx1024.com/2018/01/04/battery-historian/)\n\n#### 图表导览 ####\n\n* 鉴于网上相关博客过多关于`Historian`的说明,我们的重点是新版`Historian V2`\n\n![File Info](/images/battery_historian_file_info.png)\n\n![Historian](/images/battery_historian_historian.png)\n\n该图各个条目的意思,我们按照各个维度在图片左上右下的顺序来讲述,读者可以对比自己的图表,来查看如下的条目说明:\n\n##### 左 #####\n- CPU running: CPU运行,从开始使用app到转储使用信息,CPU是持续耗电的,与之相似的是`Userspace wakelock`,`Screen`\n- Kernel only uptime: 仅内核运行时间.即:CPU运行,但是屏幕没有唤醒的情况.产生该维度是用来和`CPU running`,`Userspace wakelock`作比较,不会出现在电量日志记录里\n- Userspace wakelock: 一般情况下,设备空闲,屏幕关闭,最后CPU停止运行,wake_lock可以阻止CPU休眠,比如后台持续下载.该维度只记录第一个使用wake_lock的app,如果需要记录所有的,使用`adb shell dumpsys batterystates --enable full-wake-history`\n- **Long Wakelocks**: 如果这个维度出现了记录,说明持有wake_lock已经超过1分钟了,这样是极其不正常的\n- Screen:屏幕维度\n\t- 红色:亮屏\n\t- 白色:息屏\n- **Top app**:耗电最高的应用,如果我们专注于使用测试目标app,那么该维度反而没有用了.其实在正常使用手机下测试,该维度很重要.\n- **Activity Manager Proc**: 活动管理者进程.在我们示例的图中,该进程被两次调起,一次是应用启动,一次是定位服务启动\n- **Crashes(logcat)**:crash耗电信息\n- **JobScheduler**: 任务调度器耗电信息\n- **SyncManager**:同步管理耗电信息.即账户管理器同步相关的.\n- GPS:GPS定位\n\t- 红色:开\n\t- 白色:关\n- **Bluetooth Scan(logcat)**:蓝牙搜索耗电信息\n- BLE scanning:Bluetooth Low Energy,又叫蓝牙4.0,区别于蓝牙3.0和之前的版本.\n\t- 绿色:开\n\t- 白色:关\n- Mobile signal strength: 手机信号强度\n\t- 白色:无信号\n\t- 红色:差\n\t- 橙色:略微好一些\n\t- 黄色:好\n\t- 绿色:棒棒\n- WiFi full lock:和wake lock机制相似,此锁是用于wifi的.\n\t- 绿色:开\n\t- 白色:关\n- WiFi scan: wifi扫描\n- Wifi supplicant:WiFi请求状态\n![wifi-supplicant](/images/wifi-supplicant.png)\n- wifi radio:大概就是wifi是否一直连接.表面含义是wifi 广播.\n\t- 绿色:开\n\t- 白色:关\n- wifi signal strength:wifi信号强度\n\t- 白色:无信号\n\t- 红色:差\n\t- 橙色:略微好一些\n\t- 黄色:好\n\t- 绿色:棒棒\n- wifi multicast: wifi组播\n\t- 绿色:开\n\t- 白色:关\n- wifi running:wifi是否一直运行\n\t- 绿色:开\n\t- 白色:关\n- wifi on:wifi开关是否开启,开启后,如果由于故障,wifi模组不一定运行.\n\t- 绿色:开\n\t- 白色:关\n- Audio:音频.我测试的app中是没有故意加音效的,但是出现了耗电的现象.\n\t- 绿色:开\n\t- 白色:关\n- Foreground process:前台进程.\n- Package active:活动的包,大概指的是运行中的,在前台的包(app)\n- Battery level:统计电量时的耗电量\n- Coulomb charge:库伦是电量单位,难道这是电费??\n- Temperature:温度\n![Temperature](/images/battery_temperature.png)\n- plugged:插电状态,在充电状态为关的这一段时间,是我们的手机的真实耗电时间\n\t- 绿色:开\n\t- 白色:关\n- charging on:充电.如果100电量,就是关闭状态了.\n\t- 绿色:开\n\t- 白色:关\n- Logcat misc:日志杂项.misc. = miscellaneous\n- health:电池?手机健康状态?\n- Plug:插头\n- Voltage:电压\n- charging status:充电状态\n\n\n##### 上 #####\n\n下面几个复选框,可以都试试,控制显示电量条和每个维度的耗电条的\n\n- Add Metrics:增加度量项目\n- show bars\n- show level summaries\n- show line overlay\n- show rate of change\n\n##### 右 #####\n电量余量\n##### 下 #####\n东八区上海时间\n\n\n##### app selection #####\n\n详细数据,都在这个模块里面.读者可以先整体查看`System Stats`里面的数据,然后选定自家的app,看看是不是主因.再根据业务和本文下一个模块的优化建议,斟酌优化.\n该功能虽然称为`Historian`,真正的只能有一个粗略的电量统计,在统计过程中,也要耗电.要综合考虑各种情况,慎重优化.\n\n#### 分析,优化建议 ####\n\n耗电大户:\n\n- 屏幕唤醒\n- CPU唤醒\n- 蜂窝数据\n- 传感器\n\n优化建议:\n\n- 对业务要非常熟悉\n- 传感器的使用,比如gps,如果业务上非频繁使用并且要求精度不高,那么就在业务上优化定位时机和精度.\n- 如果业务上需要有长时间的service,那么要考虑到CPU weak lock,防止后台任务没有完成,但是cpu睡眠,或者任务已经完成,仍然持有weak lock\n- 我们也许会在手机充电时,做一些日志上传操作的定时任务,那么注意重试次数和成功后处理,防止用户一夜充电不到80%,然后手机厂商为我们背锅的情况\n- 已知屏幕唤醒是耗电大户,原因是屏幕渲染,绘制消耗资源,所以我们在自定义视图,布局的时候,要尽量做到Android性能优化里要求\n- 同理,各种优化,平时编码的习惯,都会影响我们脆弱的电量\n- \n\n ","slug":"battery-historian-2","published":1,"updated":"2018-01-17T00:59:26.312Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1k7008r2siv20xisrlx","content":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><ul>\n<li>如何收集数据</li>\n<li>数据图表的含义</li>\n<li>如何分析并优化</li>\n</ul>\n<h4 id=\"收集数据\"><a href=\"#收集数据\" class=\"headerlink\" title=\"收集数据\"></a>收集数据</h4><ul>\n<li>手机连接USB,执行<code>adb shell dumpsys batterystats --reset</code>命令,清空电池的历史状态</li>\n<li>断开USB,打开目标应用,正常使用5分钟左右</li>\n<li>连接USB,执行<code>adb bugreport bugreport.zip</code>,可以到处zip文件到当前目录下</li>\n<li><p>浏览器进入<code>Battery Historian</code>,上传已生成的zip,然后会自动生成分析图表文件.</p>\n<p>  其实在收集数据时候,我们应该尽量正常使用手机,然后打开几个友商App,大概使用个10分钟左右,导出数据,先看系统电量状态,然后看这几个友商app的耗电情况,然后对比自家产品,看看可以优化的地方在哪里.</p>\n</li>\n</ul>\n<p>关于<code>Battery Historian</code>的使用:<a href=\"http://xusx1024.com/2018/01/04/battery-historian/\" target=\"_blank\" rel=\"external\">传送</a></p>\n<h4 id=\"图表导览\"><a href=\"#图表导览\" class=\"headerlink\" title=\"图表导览\"></a>图表导览</h4><ul>\n<li>鉴于网上相关博客过多关于<code>Historian</code>的说明,我们的重点是新版<code>Historian V2</code></li>\n</ul>\n<p><img src=\"/images/battery_historian_file_info.png\" alt=\"File Info\"></p>\n<p><img src=\"/images/battery_historian_historian.png\" alt=\"Historian\"></p>\n<p>该图各个条目的意思,我们按照各个维度在图片左上右下的顺序来讲述,读者可以对比自己的图表,来查看如下的条目说明:</p>\n<h5 id=\"左\"><a href=\"#左\" class=\"headerlink\" title=\"左\"></a>左</h5><ul>\n<li>CPU running: CPU运行,从开始使用app到转储使用信息,CPU是持续耗电的,与之相似的是<code>Userspace wakelock</code>,<code>Screen</code></li>\n<li>Kernel only uptime: 仅内核运行时间.即:CPU运行,但是屏幕没有唤醒的情况.产生该维度是用来和<code>CPU running</code>,<code>Userspace wakelock</code>作比较,不会出现在电量日志记录里</li>\n<li>Userspace wakelock: 一般情况下,设备空闲,屏幕关闭,最后CPU停止运行,wake_lock可以阻止CPU休眠,比如后台持续下载.该维度只记录第一个使用wake_lock的app,如果需要记录所有的,使用<code>adb shell dumpsys batterystates --enable full-wake-history</code></li>\n<li><strong>Long Wakelocks</strong>: 如果这个维度出现了记录,说明持有wake_lock已经超过1分钟了,这样是极其不正常的</li>\n<li>Screen:屏幕维度<ul>\n<li>红色:亮屏</li>\n<li>白色:息屏</li>\n</ul>\n</li>\n<li><strong>Top app</strong>:耗电最高的应用,如果我们专注于使用测试目标app,那么该维度反而没有用了.其实在正常使用手机下测试,该维度很重要.</li>\n<li><strong>Activity Manager Proc</strong>: 活动管理者进程.在我们示例的图中,该进程被两次调起,一次是应用启动,一次是定位服务启动</li>\n<li><strong>Crashes(logcat)</strong>:crash耗电信息</li>\n<li><strong>JobScheduler</strong>: 任务调度器耗电信息</li>\n<li><strong>SyncManager</strong>:同步管理耗电信息.即账户管理器同步相关的.</li>\n<li>GPS:GPS定位<ul>\n<li>红色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li><strong>Bluetooth Scan(logcat)</strong>:蓝牙搜索耗电信息</li>\n<li>BLE scanning:Bluetooth Low Energy,又叫蓝牙4.0,区别于蓝牙3.0和之前的版本.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Mobile signal strength: 手机信号强度<ul>\n<li>白色:无信号</li>\n<li>红色:差</li>\n<li>橙色:略微好一些</li>\n<li>黄色:好</li>\n<li>绿色:棒棒</li>\n</ul>\n</li>\n<li>WiFi full lock:和wake lock机制相似,此锁是用于wifi的.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>WiFi scan: wifi扫描</li>\n<li>Wifi supplicant:WiFi请求状态<br><img src=\"/images/wifi-supplicant.png\" alt=\"wifi-supplicant\"></li>\n<li>wifi radio:大概就是wifi是否一直连接.表面含义是wifi 广播.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>wifi signal strength:wifi信号强度<ul>\n<li>白色:无信号</li>\n<li>红色:差</li>\n<li>橙色:略微好一些</li>\n<li>黄色:好</li>\n<li>绿色:棒棒</li>\n</ul>\n</li>\n<li>wifi multicast: wifi组播<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>wifi running:wifi是否一直运行<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>wifi on:wifi开关是否开启,开启后,如果由于故障,wifi模组不一定运行.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Audio:音频.我测试的app中是没有故意加音效的,但是出现了耗电的现象.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Foreground process:前台进程.</li>\n<li>Package active:活动的包,大概指的是运行中的,在前台的包(app)</li>\n<li>Battery level:统计电量时的耗电量</li>\n<li>Coulomb charge:库伦是电量单位,难道这是电费??</li>\n<li>Temperature:温度<br><img src=\"/images/battery_temperature.png\" alt=\"Temperature\"></li>\n<li>plugged:插电状态,在充电状态为关的这一段时间,是我们的手机的真实耗电时间<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>charging on:充电.如果100电量,就是关闭状态了.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Logcat misc:日志杂项.misc. = miscellaneous</li>\n<li>health:电池?手机健康状态?</li>\n<li>Plug:插头</li>\n<li>Voltage:电压</li>\n<li>charging status:充电状态</li>\n</ul>\n<h5 id=\"上\"><a href=\"#上\" class=\"headerlink\" title=\"上\"></a>上</h5><p>下面几个复选框,可以都试试,控制显示电量条和每个维度的耗电条的</p>\n<ul>\n<li>Add Metrics:增加度量项目</li>\n<li>show bars</li>\n<li>show level summaries</li>\n<li>show line overlay</li>\n<li>show rate of change</li>\n</ul>\n<h5 id=\"右\"><a href=\"#右\" class=\"headerlink\" title=\"右\"></a>右</h5><p>电量余量</p>\n<h5 id=\"下\"><a href=\"#下\" class=\"headerlink\" title=\"下\"></a>下</h5><p>东八区上海时间</p>\n<h5 id=\"app-selection\"><a href=\"#app-selection\" class=\"headerlink\" title=\"app selection\"></a>app selection</h5><p>详细数据,都在这个模块里面.读者可以先整体查看<code>System Stats</code>里面的数据,然后选定自家的app,看看是不是主因.再根据业务和本文下一个模块的优化建议,斟酌优化.<br>该功能虽然称为<code>Historian</code>,真正的只能有一个粗略的电量统计,在统计过程中,也要耗电.要综合考虑各种情况,慎重优化.</p>\n<h4 id=\"分析-优化建议\"><a href=\"#分析-优化建议\" class=\"headerlink\" title=\"分析,优化建议\"></a>分析,优化建议</h4><p>耗电大户:</p>\n<ul>\n<li>屏幕唤醒</li>\n<li>CPU唤醒</li>\n<li>蜂窝数据</li>\n<li>传感器</li>\n</ul>\n<p>优化建议:</p>\n<ul>\n<li>对业务要非常熟悉</li>\n<li>传感器的使用,比如gps,如果业务上非频繁使用并且要求精度不高,那么就在业务上优化定位时机和精度.</li>\n<li>如果业务上需要有长时间的service,那么要考虑到CPU weak lock,防止后台任务没有完成,但是cpu睡眠,或者任务已经完成,仍然持有weak lock</li>\n<li>我们也许会在手机充电时,做一些日志上传操作的定时任务,那么注意重试次数和成功后处理,防止用户一夜充电不到80%,然后手机厂商为我们背锅的情况</li>\n<li>已知屏幕唤醒是耗电大户,原因是屏幕渲染,绘制消耗资源,所以我们在自定义视图,布局的时候,要尽量做到Android性能优化里要求</li>\n<li>同理,各种优化,平时编码的习惯,都会影响我们脆弱的电量</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><ul>\n<li>如何收集数据</li>\n<li>数据图表的含义</li>\n<li>如何分析并优化</li>\n</ul>\n<h4 id=\"收集数据\"><a href=\"#收集数据\" class=\"headerlink\" title=\"收集数据\"></a>收集数据</h4><ul>\n<li>手机连接USB,执行<code>adb shell dumpsys batterystats --reset</code>命令,清空电池的历史状态</li>\n<li>断开USB,打开目标应用,正常使用5分钟左右</li>\n<li>连接USB,执行<code>adb bugreport bugreport.zip</code>,可以到处zip文件到当前目录下</li>\n<li><p>浏览器进入<code>Battery Historian</code>,上传已生成的zip,然后会自动生成分析图表文件.</p>\n<p>  其实在收集数据时候,我们应该尽量正常使用手机,然后打开几个友商App,大概使用个10分钟左右,导出数据,先看系统电量状态,然后看这几个友商app的耗电情况,然后对比自家产品,看看可以优化的地方在哪里.</p>\n</li>\n</ul>\n<p>关于<code>Battery Historian</code>的使用:<a href=\"http://xusx1024.com/2018/01/04/battery-historian/\" target=\"_blank\" rel=\"external\">传送</a></p>\n<h4 id=\"图表导览\"><a href=\"#图表导览\" class=\"headerlink\" title=\"图表导览\"></a>图表导览</h4><ul>\n<li>鉴于网上相关博客过多关于<code>Historian</code>的说明,我们的重点是新版<code>Historian V2</code></li>\n</ul>\n<p><img src=\"/images/battery_historian_file_info.png\" alt=\"File Info\"></p>\n<p><img src=\"/images/battery_historian_historian.png\" alt=\"Historian\"></p>\n<p>该图各个条目的意思,我们按照各个维度在图片左上右下的顺序来讲述,读者可以对比自己的图表,来查看如下的条目说明:</p>\n<h5 id=\"左\"><a href=\"#左\" class=\"headerlink\" title=\"左\"></a>左</h5><ul>\n<li>CPU running: CPU运行,从开始使用app到转储使用信息,CPU是持续耗电的,与之相似的是<code>Userspace wakelock</code>,<code>Screen</code></li>\n<li>Kernel only uptime: 仅内核运行时间.即:CPU运行,但是屏幕没有唤醒的情况.产生该维度是用来和<code>CPU running</code>,<code>Userspace wakelock</code>作比较,不会出现在电量日志记录里</li>\n<li>Userspace wakelock: 一般情况下,设备空闲,屏幕关闭,最后CPU停止运行,wake_lock可以阻止CPU休眠,比如后台持续下载.该维度只记录第一个使用wake_lock的app,如果需要记录所有的,使用<code>adb shell dumpsys batterystates --enable full-wake-history</code></li>\n<li><strong>Long Wakelocks</strong>: 如果这个维度出现了记录,说明持有wake_lock已经超过1分钟了,这样是极其不正常的</li>\n<li>Screen:屏幕维度<ul>\n<li>红色:亮屏</li>\n<li>白色:息屏</li>\n</ul>\n</li>\n<li><strong>Top app</strong>:耗电最高的应用,如果我们专注于使用测试目标app,那么该维度反而没有用了.其实在正常使用手机下测试,该维度很重要.</li>\n<li><strong>Activity Manager Proc</strong>: 活动管理者进程.在我们示例的图中,该进程被两次调起,一次是应用启动,一次是定位服务启动</li>\n<li><strong>Crashes(logcat)</strong>:crash耗电信息</li>\n<li><strong>JobScheduler</strong>: 任务调度器耗电信息</li>\n<li><strong>SyncManager</strong>:同步管理耗电信息.即账户管理器同步相关的.</li>\n<li>GPS:GPS定位<ul>\n<li>红色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li><strong>Bluetooth Scan(logcat)</strong>:蓝牙搜索耗电信息</li>\n<li>BLE scanning:Bluetooth Low Energy,又叫蓝牙4.0,区别于蓝牙3.0和之前的版本.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Mobile signal strength: 手机信号强度<ul>\n<li>白色:无信号</li>\n<li>红色:差</li>\n<li>橙色:略微好一些</li>\n<li>黄色:好</li>\n<li>绿色:棒棒</li>\n</ul>\n</li>\n<li>WiFi full lock:和wake lock机制相似,此锁是用于wifi的.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>WiFi scan: wifi扫描</li>\n<li>Wifi supplicant:WiFi请求状态<br><img src=\"/images/wifi-supplicant.png\" alt=\"wifi-supplicant\"></li>\n<li>wifi radio:大概就是wifi是否一直连接.表面含义是wifi 广播.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>wifi signal strength:wifi信号强度<ul>\n<li>白色:无信号</li>\n<li>红色:差</li>\n<li>橙色:略微好一些</li>\n<li>黄色:好</li>\n<li>绿色:棒棒</li>\n</ul>\n</li>\n<li>wifi multicast: wifi组播<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>wifi running:wifi是否一直运行<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>wifi on:wifi开关是否开启,开启后,如果由于故障,wifi模组不一定运行.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Audio:音频.我测试的app中是没有故意加音效的,但是出现了耗电的现象.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Foreground process:前台进程.</li>\n<li>Package active:活动的包,大概指的是运行中的,在前台的包(app)</li>\n<li>Battery level:统计电量时的耗电量</li>\n<li>Coulomb charge:库伦是电量单位,难道这是电费??</li>\n<li>Temperature:温度<br><img src=\"/images/battery_temperature.png\" alt=\"Temperature\"></li>\n<li>plugged:插电状态,在充电状态为关的这一段时间,是我们的手机的真实耗电时间<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>charging on:充电.如果100电量,就是关闭状态了.<ul>\n<li>绿色:开</li>\n<li>白色:关</li>\n</ul>\n</li>\n<li>Logcat misc:日志杂项.misc. = miscellaneous</li>\n<li>health:电池?手机健康状态?</li>\n<li>Plug:插头</li>\n<li>Voltage:电压</li>\n<li>charging status:充电状态</li>\n</ul>\n<h5 id=\"上\"><a href=\"#上\" class=\"headerlink\" title=\"上\"></a>上</h5><p>下面几个复选框,可以都试试,控制显示电量条和每个维度的耗电条的</p>\n<ul>\n<li>Add Metrics:增加度量项目</li>\n<li>show bars</li>\n<li>show level summaries</li>\n<li>show line overlay</li>\n<li>show rate of change</li>\n</ul>\n<h5 id=\"右\"><a href=\"#右\" class=\"headerlink\" title=\"右\"></a>右</h5><p>电量余量</p>\n<h5 id=\"下\"><a href=\"#下\" class=\"headerlink\" title=\"下\"></a>下</h5><p>东八区上海时间</p>\n<h5 id=\"app-selection\"><a href=\"#app-selection\" class=\"headerlink\" title=\"app selection\"></a>app selection</h5><p>详细数据,都在这个模块里面.读者可以先整体查看<code>System Stats</code>里面的数据,然后选定自家的app,看看是不是主因.再根据业务和本文下一个模块的优化建议,斟酌优化.<br>该功能虽然称为<code>Historian</code>,真正的只能有一个粗略的电量统计,在统计过程中,也要耗电.要综合考虑各种情况,慎重优化.</p>\n<h4 id=\"分析-优化建议\"><a href=\"#分析-优化建议\" class=\"headerlink\" title=\"分析,优化建议\"></a>分析,优化建议</h4><p>耗电大户:</p>\n<ul>\n<li>屏幕唤醒</li>\n<li>CPU唤醒</li>\n<li>蜂窝数据</li>\n<li>传感器</li>\n</ul>\n<p>优化建议:</p>\n<ul>\n<li>对业务要非常熟悉</li>\n<li>传感器的使用,比如gps,如果业务上非频繁使用并且要求精度不高,那么就在业务上优化定位时机和精度.</li>\n<li>如果业务上需要有长时间的service,那么要考虑到CPU weak lock,防止后台任务没有完成,但是cpu睡眠,或者任务已经完成,仍然持有weak lock</li>\n<li>我们也许会在手机充电时,做一些日志上传操作的定时任务,那么注意重试次数和成功后处理,防止用户一夜充电不到80%,然后手机厂商为我们背锅的情况</li>\n<li>已知屏幕唤醒是耗电大户,原因是屏幕渲染,绘制消耗资源,所以我们在自定义视图,布局的时候,要尽量做到Android性能优化里要求</li>\n<li>同理,各种优化,平时编码的习惯,都会影响我们脆弱的电量</li>\n<li></li>\n</ul>\n"},{"layout":"post","title":"Android电量优化:Battery Historian 使用准备","date":"2018-01-04T00:00:00.000Z","_content":"\n[battery-historian](https://github.com/google/battery-historian) 是google官方提供的,一款优秀的电量分析工具.\n\n在优化电量相关很是有用.\n\n鉴于国内网络条件,和多数开发人员的终端都是win平台,记录自己的研究过程.\n\n好了,废话到此为止.\n\n\n#### docker安装 ####\n\n- 有人说需要翻墙,其实不需要,千万千万不要打开代理,尤其是全局代理\n- 有人说只支持win10和mac,亲测win7可以使用\n- 使用[Docker Toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/)\n\n安装如下图:\n\n![install](/images/setup-docker-toolbox.png)\n- 比如git,VirtualBox,如果有就不要勾选了\n- Docker Compose for windows,kitematic forwindows 最好选用,挺好用的\n\n一路下一步,基本安装成功.\n\n#### 镜像环境 ####\n\n使用battery-historian需要go,Python,Java,git环境,这些在docker里可以获取一个已经配置好的镜像,非常方便.\n\n打开docker quickstart terminal,等待docker初始化成功,并获得一个IP.\n\n注意:\n\n- 不要使用github上的这个命令 `docker -- run -p <port>:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999`\n\t- 命令陈旧,--run,--port都已经没有了\n\t- --run 被run替代\n\t- --port 可以使用 --publish代替\n- 请使用:`docker pull bhaavan/battery-historian`,这是下载该img\n\t- `docker run -d -p 9999:9999 bhaavan/battery-historian --publish 9999` 这是映射端口号\n\n如果一切顺利,到此为止,在浏览器里输入`ip:端口号`应该是可以使用了,如图:\n![upload](/images/battery-historian-upload.png)\n\n#### bugreport ####\n\n在导出bugreport文件时候:\n\n- 高于7.0Android系统 `$ adb bugreport bugreport.zip`\n- 低于6.0Android系统 `$ adb bugreport > bugreport.txt`\n\n#### Kitematic (Alpha) ####\n\n- 可视化统一管理多个镜像\n- 注册登录千万不要用代理\n- 感觉比terminal慢了一点,但是好用\n\n#### 友情提示 ####\n\n有的blog上,有使用[historian.py](https://github.com/google/battery-historian/tree/master/scripts)来可视化bugreport文件的,如下:\n\n\tpython historian.py -a bugreport.txt > battery.html\n\n如果你有Python环境,会优先选择他,看似简单,实际上有些老旧,不建议使用.\n\n理由:\n- Python 2.7写的,和现在的3.6语法大有不同,该文件在3.6环境下,print语句都需要添加`()`,有两个库没法导入(注:我就是在此折戟)\n- Android7.0及其以上没法用,该文件分析的`.txt`,Android7.0导出的是`zip`\n- 安装docker,不止可以使用google的这个分析库,还可以调试源码,模拟别的服务器环境等等,详见:[Docker Hub](https://hub.docker.com/)","source":"_posts/2018-01-04-battery-historian.md","raw":"---\nlayout: post\ntitle:  Android电量优化:Battery Historian 使用准备\ndate:   2018-01-04\ncategories: Android\ntag: android\n---\n\n[battery-historian](https://github.com/google/battery-historian) 是google官方提供的,一款优秀的电量分析工具.\n\n在优化电量相关很是有用.\n\n鉴于国内网络条件,和多数开发人员的终端都是win平台,记录自己的研究过程.\n\n好了,废话到此为止.\n\n\n#### docker安装 ####\n\n- 有人说需要翻墙,其实不需要,千万千万不要打开代理,尤其是全局代理\n- 有人说只支持win10和mac,亲测win7可以使用\n- 使用[Docker Toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/)\n\n安装如下图:\n\n![install](/images/setup-docker-toolbox.png)\n- 比如git,VirtualBox,如果有就不要勾选了\n- Docker Compose for windows,kitematic forwindows 最好选用,挺好用的\n\n一路下一步,基本安装成功.\n\n#### 镜像环境 ####\n\n使用battery-historian需要go,Python,Java,git环境,这些在docker里可以获取一个已经配置好的镜像,非常方便.\n\n打开docker quickstart terminal,等待docker初始化成功,并获得一个IP.\n\n注意:\n\n- 不要使用github上的这个命令 `docker -- run -p <port>:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999`\n\t- 命令陈旧,--run,--port都已经没有了\n\t- --run 被run替代\n\t- --port 可以使用 --publish代替\n- 请使用:`docker pull bhaavan/battery-historian`,这是下载该img\n\t- `docker run -d -p 9999:9999 bhaavan/battery-historian --publish 9999` 这是映射端口号\n\n如果一切顺利,到此为止,在浏览器里输入`ip:端口号`应该是可以使用了,如图:\n![upload](/images/battery-historian-upload.png)\n\n#### bugreport ####\n\n在导出bugreport文件时候:\n\n- 高于7.0Android系统 `$ adb bugreport bugreport.zip`\n- 低于6.0Android系统 `$ adb bugreport > bugreport.txt`\n\n#### Kitematic (Alpha) ####\n\n- 可视化统一管理多个镜像\n- 注册登录千万不要用代理\n- 感觉比terminal慢了一点,但是好用\n\n#### 友情提示 ####\n\n有的blog上,有使用[historian.py](https://github.com/google/battery-historian/tree/master/scripts)来可视化bugreport文件的,如下:\n\n\tpython historian.py -a bugreport.txt > battery.html\n\n如果你有Python环境,会优先选择他,看似简单,实际上有些老旧,不建议使用.\n\n理由:\n- Python 2.7写的,和现在的3.6语法大有不同,该文件在3.6环境下,print语句都需要添加`()`,有两个库没法导入(注:我就是在此折戟)\n- Android7.0及其以上没法用,该文件分析的`.txt`,Android7.0导出的是`zip`\n- 安装docker,不止可以使用google的这个分析库,还可以调试源码,模拟别的服务器环境等等,详见:[Docker Hub](https://hub.docker.com/)","slug":"battery-historian","published":1,"updated":"2018-01-17T00:59:31.254Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ka008u2siv80dkvmnp","content":"<p><a href=\"https://github.com/google/battery-historian\" target=\"_blank\" rel=\"external\">battery-historian</a> 是google官方提供的,一款优秀的电量分析工具.</p>\n<p>在优化电量相关很是有用.</p>\n<p>鉴于国内网络条件,和多数开发人员的终端都是win平台,记录自己的研究过程.</p>\n<p>好了,废话到此为止.</p>\n<h4 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h4><ul>\n<li>有人说需要翻墙,其实不需要,千万千万不要打开代理,尤其是全局代理</li>\n<li>有人说只支持win10和mac,亲测win7可以使用</li>\n<li>使用<a href=\"https://docs.docker.com/toolbox/toolbox_install_windows/\" target=\"_blank\" rel=\"external\">Docker Toolbox</a></li>\n</ul>\n<p>安装如下图:</p>\n<p><img src=\"/images/setup-docker-toolbox.png\" alt=\"install\"></p>\n<ul>\n<li>比如git,VirtualBox,如果有就不要勾选了</li>\n<li>Docker Compose for windows,kitematic forwindows 最好选用,挺好用的</li>\n</ul>\n<p>一路下一步,基本安装成功.</p>\n<h4 id=\"镜像环境\"><a href=\"#镜像环境\" class=\"headerlink\" title=\"镜像环境\"></a>镜像环境</h4><p>使用battery-historian需要go,Python,Java,git环境,这些在docker里可以获取一个已经配置好的镜像,非常方便.</p>\n<p>打开docker quickstart terminal,等待docker初始化成功,并获得一个IP.</p>\n<p>注意:</p>\n<ul>\n<li>不要使用github上的这个命令 <code>docker -- run -p &lt;port&gt;:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999</code><ul>\n<li>命令陈旧,–run,–port都已经没有了</li>\n<li>–run 被run替代</li>\n<li>–port 可以使用 –publish代替</li>\n</ul>\n</li>\n<li>请使用:<code>docker pull bhaavan/battery-historian</code>,这是下载该img<ul>\n<li><code>docker run -d -p 9999:9999 bhaavan/battery-historian --publish 9999</code> 这是映射端口号</li>\n</ul>\n</li>\n</ul>\n<p>如果一切顺利,到此为止,在浏览器里输入<code>ip:端口号</code>应该是可以使用了,如图:<br><img src=\"/images/battery-historian-upload.png\" alt=\"upload\"></p>\n<h4 id=\"bugreport\"><a href=\"#bugreport\" class=\"headerlink\" title=\"bugreport\"></a>bugreport</h4><p>在导出bugreport文件时候:</p>\n<ul>\n<li>高于7.0Android系统 <code>$ adb bugreport bugreport.zip</code></li>\n<li>低于6.0Android系统 <code>$ adb bugreport &gt; bugreport.txt</code></li>\n</ul>\n<h4 id=\"Kitematic-Alpha\"><a href=\"#Kitematic-Alpha\" class=\"headerlink\" title=\"Kitematic (Alpha)\"></a>Kitematic (Alpha)</h4><ul>\n<li>可视化统一管理多个镜像</li>\n<li>注册登录千万不要用代理</li>\n<li>感觉比terminal慢了一点,但是好用</li>\n</ul>\n<h4 id=\"友情提示\"><a href=\"#友情提示\" class=\"headerlink\" title=\"友情提示\"></a>友情提示</h4><p>有的blog上,有使用<a href=\"https://github.com/google/battery-historian/tree/master/scripts\" target=\"_blank\" rel=\"external\">historian.py</a>来可视化bugreport文件的,如下:</p>\n<pre><code>python historian.py -a bugreport.txt &gt; battery.html\n</code></pre><p>如果你有Python环境,会优先选择他,看似简单,实际上有些老旧,不建议使用.</p>\n<p>理由:</p>\n<ul>\n<li>Python 2.7写的,和现在的3.6语法大有不同,该文件在3.6环境下,print语句都需要添加<code>()</code>,有两个库没法导入(注:我就是在此折戟)</li>\n<li>Android7.0及其以上没法用,该文件分析的<code>.txt</code>,Android7.0导出的是<code>zip</code></li>\n<li>安装docker,不止可以使用google的这个分析库,还可以调试源码,模拟别的服务器环境等等,详见:<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"external\">Docker Hub</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/google/battery-historian\" target=\"_blank\" rel=\"external\">battery-historian</a> 是google官方提供的,一款优秀的电量分析工具.</p>\n<p>在优化电量相关很是有用.</p>\n<p>鉴于国内网络条件,和多数开发人员的终端都是win平台,记录自己的研究过程.</p>\n<p>好了,废话到此为止.</p>\n<h4 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h4><ul>\n<li>有人说需要翻墙,其实不需要,千万千万不要打开代理,尤其是全局代理</li>\n<li>有人说只支持win10和mac,亲测win7可以使用</li>\n<li>使用<a href=\"https://docs.docker.com/toolbox/toolbox_install_windows/\" target=\"_blank\" rel=\"external\">Docker Toolbox</a></li>\n</ul>\n<p>安装如下图:</p>\n<p><img src=\"/images/setup-docker-toolbox.png\" alt=\"install\"></p>\n<ul>\n<li>比如git,VirtualBox,如果有就不要勾选了</li>\n<li>Docker Compose for windows,kitematic forwindows 最好选用,挺好用的</li>\n</ul>\n<p>一路下一步,基本安装成功.</p>\n<h4 id=\"镜像环境\"><a href=\"#镜像环境\" class=\"headerlink\" title=\"镜像环境\"></a>镜像环境</h4><p>使用battery-historian需要go,Python,Java,git环境,这些在docker里可以获取一个已经配置好的镜像,非常方便.</p>\n<p>打开docker quickstart terminal,等待docker初始化成功,并获得一个IP.</p>\n<p>注意:</p>\n<ul>\n<li>不要使用github上的这个命令 <code>docker -- run -p &lt;port&gt;:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999</code><ul>\n<li>命令陈旧,–run,–port都已经没有了</li>\n<li>–run 被run替代</li>\n<li>–port 可以使用 –publish代替</li>\n</ul>\n</li>\n<li>请使用:<code>docker pull bhaavan/battery-historian</code>,这是下载该img<ul>\n<li><code>docker run -d -p 9999:9999 bhaavan/battery-historian --publish 9999</code> 这是映射端口号</li>\n</ul>\n</li>\n</ul>\n<p>如果一切顺利,到此为止,在浏览器里输入<code>ip:端口号</code>应该是可以使用了,如图:<br><img src=\"/images/battery-historian-upload.png\" alt=\"upload\"></p>\n<h4 id=\"bugreport\"><a href=\"#bugreport\" class=\"headerlink\" title=\"bugreport\"></a>bugreport</h4><p>在导出bugreport文件时候:</p>\n<ul>\n<li>高于7.0Android系统 <code>$ adb bugreport bugreport.zip</code></li>\n<li>低于6.0Android系统 <code>$ adb bugreport &gt; bugreport.txt</code></li>\n</ul>\n<h4 id=\"Kitematic-Alpha\"><a href=\"#Kitematic-Alpha\" class=\"headerlink\" title=\"Kitematic (Alpha)\"></a>Kitematic (Alpha)</h4><ul>\n<li>可视化统一管理多个镜像</li>\n<li>注册登录千万不要用代理</li>\n<li>感觉比terminal慢了一点,但是好用</li>\n</ul>\n<h4 id=\"友情提示\"><a href=\"#友情提示\" class=\"headerlink\" title=\"友情提示\"></a>友情提示</h4><p>有的blog上,有使用<a href=\"https://github.com/google/battery-historian/tree/master/scripts\" target=\"_blank\" rel=\"external\">historian.py</a>来可视化bugreport文件的,如下:</p>\n<pre><code>python historian.py -a bugreport.txt &gt; battery.html\n</code></pre><p>如果你有Python环境,会优先选择他,看似简单,实际上有些老旧,不建议使用.</p>\n<p>理由:</p>\n<ul>\n<li>Python 2.7写的,和现在的3.6语法大有不同,该文件在3.6环境下,print语句都需要添加<code>()</code>,有两个库没法导入(注:我就是在此折戟)</li>\n<li>Android7.0及其以上没法用,该文件分析的<code>.txt</code>,Android7.0导出的是<code>zip</code></li>\n<li>安装docker,不止可以使用google的这个分析库,还可以调试源码,模拟别的服务器环境等等,详见:<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"external\">Docker Hub</a></li>\n</ul>\n"},{"layout":"post","title":"Android系统服务:知识预备","date":"2018-01-10T00:00:00.000Z","_content":" \n2017,在学习Android系统架构服务的相关知识的阶段,走了一些弯路,成果很是不好,发现自己的知识预备不够充足,导致自己局限于某一个服务的具体实现逻辑里面,而不能以开阔的,或者更加高维的视角去学习.\n\n具体的来说,在学习一个特定的服务的时候,一直在追踪代码,这些代码是Java实现的,我也能够看明白关键的几句话是什么意思,但是该服务为什么这么实现?设计一个服务究竟根据的是什么?里面的思想一点也不明白,被蒙头带着走.然后再碰到本地实现,那就是望洋兴叹了.\n\n上一年,一整年的关于服务的学习的效果,基本可以忽略不计.但是由此得到的一些经验教训,不可以不记录在此,以飨后来.\n\n#### 书单 ####\n\n- 《深入理解Java虚拟机：JVM高级特性与最佳实践》 \n- 《Efficient.Android.Threading 》\n- 《汇编语言_第2版》 王爽\n- 《深入理解计算机系统》\n- 《深入理解Android内核设计思想》\n- 《Java并发编程实战（中文版)》\n- 《Android Dalvik虚拟机结构及机制剖析》\n\n\t这些书我列的很小的一方面,仅仅是我手头上有的.不一定要逐字逐句看完,可以选择自己需要的章节阅读,目的是要有大方向的概念.\n\n#### 知识预备 ####\n\n- binder机制\n- 反编译\n- 类加载机制\n- 进程管理,通信\n- 线程调度\n- 内存管理\n- 反射\n- 注解\n- Android虚拟机\n- 设计模式\n\n\n#### 自我总结的方法 ####\n\n1. 针对某一系统服务,读官方文档,写一个示例\n2. 写示例时思考,这个api这样调用,是出于一种什么样的设计?如果我来设计呢?\n3. 跟踪对应文件的关键源码\n\t1. 读文件注释\n\t2. 根据我们的实例,查看关键api的实现\n\t3. 参考网上资源博客\n4. 对比自己的知识库,那些需要补充,重点补足\n\n### **边研究边学习,而不是先学习上面的准备知识,后研究.** ###\n\n \n ","source":"_posts/2018-01-10-android-system-service-prework.md","raw":"---\nlayout: post\ntitle:  Android系统服务:知识预备\ndate:   2018-01-10\ncategories: Android System Framework\ntag: android\n---\n \n2017,在学习Android系统架构服务的相关知识的阶段,走了一些弯路,成果很是不好,发现自己的知识预备不够充足,导致自己局限于某一个服务的具体实现逻辑里面,而不能以开阔的,或者更加高维的视角去学习.\n\n具体的来说,在学习一个特定的服务的时候,一直在追踪代码,这些代码是Java实现的,我也能够看明白关键的几句话是什么意思,但是该服务为什么这么实现?设计一个服务究竟根据的是什么?里面的思想一点也不明白,被蒙头带着走.然后再碰到本地实现,那就是望洋兴叹了.\n\n上一年,一整年的关于服务的学习的效果,基本可以忽略不计.但是由此得到的一些经验教训,不可以不记录在此,以飨后来.\n\n#### 书单 ####\n\n- 《深入理解Java虚拟机：JVM高级特性与最佳实践》 \n- 《Efficient.Android.Threading 》\n- 《汇编语言_第2版》 王爽\n- 《深入理解计算机系统》\n- 《深入理解Android内核设计思想》\n- 《Java并发编程实战（中文版)》\n- 《Android Dalvik虚拟机结构及机制剖析》\n\n\t这些书我列的很小的一方面,仅仅是我手头上有的.不一定要逐字逐句看完,可以选择自己需要的章节阅读,目的是要有大方向的概念.\n\n#### 知识预备 ####\n\n- binder机制\n- 反编译\n- 类加载机制\n- 进程管理,通信\n- 线程调度\n- 内存管理\n- 反射\n- 注解\n- Android虚拟机\n- 设计模式\n\n\n#### 自我总结的方法 ####\n\n1. 针对某一系统服务,读官方文档,写一个示例\n2. 写示例时思考,这个api这样调用,是出于一种什么样的设计?如果我来设计呢?\n3. 跟踪对应文件的关键源码\n\t1. 读文件注释\n\t2. 根据我们的实例,查看关键api的实现\n\t3. 参考网上资源博客\n4. 对比自己的知识库,那些需要补充,重点补足\n\n### **边研究边学习,而不是先学习上面的准备知识,后研究.** ###\n\n \n ","slug":"android-system-service-prework","published":1,"updated":"2018-01-10T03:04:15.661Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kd008x2sivr69xyrg8","content":"<p>2017,在学习Android系统架构服务的相关知识的阶段,走了一些弯路,成果很是不好,发现自己的知识预备不够充足,导致自己局限于某一个服务的具体实现逻辑里面,而不能以开阔的,或者更加高维的视角去学习.</p>\n<p>具体的来说,在学习一个特定的服务的时候,一直在追踪代码,这些代码是Java实现的,我也能够看明白关键的几句话是什么意思,但是该服务为什么这么实现?设计一个服务究竟根据的是什么?里面的思想一点也不明白,被蒙头带着走.然后再碰到本地实现,那就是望洋兴叹了.</p>\n<p>上一年,一整年的关于服务的学习的效果,基本可以忽略不计.但是由此得到的一些经验教训,不可以不记录在此,以飨后来.</p>\n<h4 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h4><ul>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》 </li>\n<li>《Efficient.Android.Threading 》</li>\n<li>《汇编语言_第2版》 王爽</li>\n<li>《深入理解计算机系统》</li>\n<li>《深入理解Android内核设计思想》</li>\n<li>《Java并发编程实战（中文版)》</li>\n<li><p>《Android Dalvik虚拟机结构及机制剖析》</p>\n<p>  这些书我列的很小的一方面,仅仅是我手头上有的.不一定要逐字逐句看完,可以选择自己需要的章节阅读,目的是要有大方向的概念.</p>\n</li>\n</ul>\n<h4 id=\"知识预备\"><a href=\"#知识预备\" class=\"headerlink\" title=\"知识预备\"></a>知识预备</h4><ul>\n<li>binder机制</li>\n<li>反编译</li>\n<li>类加载机制</li>\n<li>进程管理,通信</li>\n<li>线程调度</li>\n<li>内存管理</li>\n<li>反射</li>\n<li>注解</li>\n<li>Android虚拟机</li>\n<li>设计模式</li>\n</ul>\n<h4 id=\"自我总结的方法\"><a href=\"#自我总结的方法\" class=\"headerlink\" title=\"自我总结的方法\"></a>自我总结的方法</h4><ol>\n<li>针对某一系统服务,读官方文档,写一个示例</li>\n<li>写示例时思考,这个api这样调用,是出于一种什么样的设计?如果我来设计呢?</li>\n<li>跟踪对应文件的关键源码<ol>\n<li>读文件注释</li>\n<li>根据我们的实例,查看关键api的实现</li>\n<li>参考网上资源博客</li>\n</ol>\n</li>\n<li>对比自己的知识库,那些需要补充,重点补足</li>\n</ol>\n<h3 id=\"边研究边学习-而不是先学习上面的准备知识-后研究\"><a href=\"#边研究边学习-而不是先学习上面的准备知识-后研究\" class=\"headerlink\" title=\"边研究边学习,而不是先学习上面的准备知识,后研究.\"></a><strong>边研究边学习,而不是先学习上面的准备知识,后研究.</strong></h3>","site":{"data":{}},"excerpt":"","more":"<p>2017,在学习Android系统架构服务的相关知识的阶段,走了一些弯路,成果很是不好,发现自己的知识预备不够充足,导致自己局限于某一个服务的具体实现逻辑里面,而不能以开阔的,或者更加高维的视角去学习.</p>\n<p>具体的来说,在学习一个特定的服务的时候,一直在追踪代码,这些代码是Java实现的,我也能够看明白关键的几句话是什么意思,但是该服务为什么这么实现?设计一个服务究竟根据的是什么?里面的思想一点也不明白,被蒙头带着走.然后再碰到本地实现,那就是望洋兴叹了.</p>\n<p>上一年,一整年的关于服务的学习的效果,基本可以忽略不计.但是由此得到的一些经验教训,不可以不记录在此,以飨后来.</p>\n<h4 id=\"书单\"><a href=\"#书单\" class=\"headerlink\" title=\"书单\"></a>书单</h4><ul>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》 </li>\n<li>《Efficient.Android.Threading 》</li>\n<li>《汇编语言_第2版》 王爽</li>\n<li>《深入理解计算机系统》</li>\n<li>《深入理解Android内核设计思想》</li>\n<li>《Java并发编程实战（中文版)》</li>\n<li><p>《Android Dalvik虚拟机结构及机制剖析》</p>\n<p>  这些书我列的很小的一方面,仅仅是我手头上有的.不一定要逐字逐句看完,可以选择自己需要的章节阅读,目的是要有大方向的概念.</p>\n</li>\n</ul>\n<h4 id=\"知识预备\"><a href=\"#知识预备\" class=\"headerlink\" title=\"知识预备\"></a>知识预备</h4><ul>\n<li>binder机制</li>\n<li>反编译</li>\n<li>类加载机制</li>\n<li>进程管理,通信</li>\n<li>线程调度</li>\n<li>内存管理</li>\n<li>反射</li>\n<li>注解</li>\n<li>Android虚拟机</li>\n<li>设计模式</li>\n</ul>\n<h4 id=\"自我总结的方法\"><a href=\"#自我总结的方法\" class=\"headerlink\" title=\"自我总结的方法\"></a>自我总结的方法</h4><ol>\n<li>针对某一系统服务,读官方文档,写一个示例</li>\n<li>写示例时思考,这个api这样调用,是出于一种什么样的设计?如果我来设计呢?</li>\n<li>跟踪对应文件的关键源码<ol>\n<li>读文件注释</li>\n<li>根据我们的实例,查看关键api的实现</li>\n<li>参考网上资源博客</li>\n</ol>\n</li>\n<li>对比自己的知识库,那些需要补充,重点补足</li>\n</ol>\n<h3 id=\"边研究边学习-而不是先学习上面的准备知识-后研究\"><a href=\"#边研究边学习-而不是先学习上面的准备知识-后研究\" class=\"headerlink\" title=\"边研究边学习,而不是先学习上面的准备知识,后研究.\"></a><strong>边研究边学习,而不是先学习上面的准备知识,后研究.</strong></h3>"},{"layout":"post","title":"Android系统服务：AudioManager","date":"2018-01-11T00:00:00.000Z","_content":"\n\t小知识点:audi,是一个重要的英语词根.跟hear一个意思.\n\n#### 示例时间 ####\n\n- 阅读[官方文档](https://developer.android.com/guide/topics/media-apps/audio-app/building-an-audio-app.html)\n- 根据指导写出示例\n- 示例地址\n\n##### 重要的类 #####\n\n[android.service.media.MediaBrowserService]()\n\n\t小知识点:final修饰符,不可变,如果赋值,继承,就会报编译错误.final是编译绑定的.final代码是确定的,可以为jvm提供评估标准,提高程序性能.\n\t所以kotlin中,默认声明变量都是val即final的.final和abstract是反义词,所以,一定不会同时出现.final修饰的必须在声明时初始化,\n\t或者在构造里初始化.接口,匿名类中的成员都是final的.\n\n\n\n#### 重要api ####\n\n- first api\n- second api\n\n#### 想法 ####","source":"_posts/2018-01-11-android-system-service-AudioManager.md","raw":"---\nlayout: post\ntitle:  Android系统服务：AudioManager\ndate:   2018-01-11\ncategories: Android System Framework\ntag: android\n---\n\n\t小知识点:audi,是一个重要的英语词根.跟hear一个意思.\n\n#### 示例时间 ####\n\n- 阅读[官方文档](https://developer.android.com/guide/topics/media-apps/audio-app/building-an-audio-app.html)\n- 根据指导写出示例\n- 示例地址\n\n##### 重要的类 #####\n\n[android.service.media.MediaBrowserService]()\n\n\t小知识点:final修饰符,不可变,如果赋值,继承,就会报编译错误.final是编译绑定的.final代码是确定的,可以为jvm提供评估标准,提高程序性能.\n\t所以kotlin中,默认声明变量都是val即final的.final和abstract是反义词,所以,一定不会同时出现.final修饰的必须在声明时初始化,\n\t或者在构造里初始化.接口,匿名类中的成员都是final的.\n\n\n\n#### 重要api ####\n\n- first api\n- second api\n\n#### 想法 ####","slug":"android-system-service-AudioManager","published":1,"updated":"2018-01-10T05:24:17.329Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kf00902sivtqhs4ayp","content":"<pre><code>小知识点:audi,是一个重要的英语词根.跟hear一个意思.\n</code></pre><h4 id=\"示例时间\"><a href=\"#示例时间\" class=\"headerlink\" title=\"示例时间\"></a>示例时间</h4><ul>\n<li>阅读<a href=\"https://developer.android.com/guide/topics/media-apps/audio-app/building-an-audio-app.html\" target=\"_blank\" rel=\"external\">官方文档</a></li>\n<li>根据指导写出示例</li>\n<li>示例地址</li>\n</ul>\n<h5 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h5><p><a href=\"\">android.service.media.MediaBrowserService</a></p>\n<pre><code>小知识点:final修饰符,不可变,如果赋值,继承,就会报编译错误.final是编译绑定的.final代码是确定的,可以为jvm提供评估标准,提高程序性能.\n所以kotlin中,默认声明变量都是val即final的.final和abstract是反义词,所以,一定不会同时出现.final修饰的必须在声明时初始化,\n或者在构造里初始化.接口,匿名类中的成员都是final的.\n</code></pre><h4 id=\"重要api\"><a href=\"#重要api\" class=\"headerlink\" title=\"重要api\"></a>重要api</h4><ul>\n<li>first api</li>\n<li>second api</li>\n</ul>\n<h4 id=\"想法\"><a href=\"#想法\" class=\"headerlink\" title=\"想法\"></a>想法</h4>","site":{"data":{}},"excerpt":"","more":"<pre><code>小知识点:audi,是一个重要的英语词根.跟hear一个意思.\n</code></pre><h4 id=\"示例时间\"><a href=\"#示例时间\" class=\"headerlink\" title=\"示例时间\"></a>示例时间</h4><ul>\n<li>阅读<a href=\"https://developer.android.com/guide/topics/media-apps/audio-app/building-an-audio-app.html\" target=\"_blank\" rel=\"external\">官方文档</a></li>\n<li>根据指导写出示例</li>\n<li>示例地址</li>\n</ul>\n<h5 id=\"重要的类\"><a href=\"#重要的类\" class=\"headerlink\" title=\"重要的类\"></a>重要的类</h5><p><a href=\"\">android.service.media.MediaBrowserService</a></p>\n<pre><code>小知识点:final修饰符,不可变,如果赋值,继承,就会报编译错误.final是编译绑定的.final代码是确定的,可以为jvm提供评估标准,提高程序性能.\n所以kotlin中,默认声明变量都是val即final的.final和abstract是反义词,所以,一定不会同时出现.final修饰的必须在声明时初始化,\n或者在构造里初始化.接口,匿名类中的成员都是final的.\n</code></pre><h4 id=\"重要api\"><a href=\"#重要api\" class=\"headerlink\" title=\"重要api\"></a>重要api</h4><ul>\n<li>first api</li>\n<li>second api</li>\n</ul>\n<h4 id=\"想法\"><a href=\"#想法\" class=\"headerlink\" title=\"想法\"></a>想法</h4>"},{"layout":"post","title":"Android官方示例按字母索引","date":"2018-01-15T00:00:00.000Z","_content":"\n[Google 官方示例](https://developer.android.com/samples/index.html)\n\n\t好东西真多.\n\t因为墙的原因,不可用的也很多.\n\t如果可以,选择国内类似服务,或者自己模拟搭建服务.\n\n### A ###\n\n#### AppShortcuts(快捷方式) ####\n\n- [项目地址](https://github.com/googlesamples/android-AppShortcuts/#readme)\n- 版本: Android 7.1 (API 25)\n- 功能简介:\n\t- 长按图标展示一个意图集合\n\t- 静态创建和动态创建\n\n\n#### AutofillFramework(自动填充) ####\n\n- [kotlin-项目地址](https://github.com/googlesamples/android-AutofillFramework/tree/master/kotlinApp/#readme)\n- [java-项目地址](https://github.com/googlesamples/android-AutofillFramework/#readme)\n- 版本: Android 7.1 (API 25)\n- 功能简介:\n\t- 少数app会开发该功能\n\t- 一般是密码管理器这类的第三方app会开发该服务\n\t- 自动填充服务解析客户端的视图层级,找到可以提供数据的自动填充字段,然后发送推荐\n\t- 客户端使用一些字段,指定拥有自动填充属性的视图\n\t- 示例的数据存在shared preference中,并不安全\n\n#### AAudio ####\n\n- [项目地址](https://github.com/googlesamples/android-audio-high-performance/tree/master/aaudio/#readme)\n- 大概是个录音和播放的功能\n-  API (android-26)\n-  NDK-r15 or above\n\n#### AsymmetricFingerprintDialog ####\n\n- [项目地址](https://github.com/googlesamples/android-AsymmetricFingerprintDialog/#readme)\n- 使用app中已注册的指纹,授权用户做一些例如充值之类的操作\n- Android SDK 26\n\n#### ActionBarCompat-Basic ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-Basic/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActionBarCompat-Styled ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-Styled/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActiveNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-ActiveNotifications/#readme)\n- 通知组和通知管理\n\n#### AccelerometerPlay ####\n\n- [项目地址](https://github.com/googlesamples/android-AccelerometerPlay/#readme)\n- 加速度传感器\n\n#### ActionBarCompat-ListPopupMenu ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActionBarCompat-ShareActionProvider ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActivityInstrumentation  ####\n\n- [项目地址](https://github.com/googlesamples/android-ActivityInstrumentation)\n- 模拟测试数据\n- 不需要进去看了,一个spinner展示了一个写死的list\n\n\n#### ActivitySceneTransitionBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-ActivitySceneTransitionBasic/#readme)\n- Activity之间转场动画\n- 一个场景:新闻列表的图片,进入详情,然后放大,并且带有动画\n\n#### AdMob Banner #### \n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/BannerExample/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### AdMob Native Advanced #### \n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme)\n- app内置广告api调用,国内应该有类似\n \n#### AdMob Native Ads Express ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### AdMob Interstitial ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/InterstitialExample/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### Advanced API Demos ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/advanced/APIDemo/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### AgendaData ####\n\n- [项目地址](https://github.com/googlesamples/android-AgendaData/#readme)\n- 同步日程至可穿戴设备示例\n\n#### AdvancedImmersiveMode #### \n\n- [项目地址](https://github.com/googlesamples/android-AdvancedImmersiveMode/#readme)\n- 沉浸模式\n\n#### AlwaysOn #### \n\n- [项目地址](https://github.com/googlesamples/android-AlwaysOn/#readme)\n- 可穿戴设备的微光模式-保持设备常亮\n\n#### AppRestrictionEnforcer ####\n\n- [项目地址](https://github.com/googlesamples/android-AppRestrictionEnforcer/#readme)\n- 多用户系统中,管理员可以分配不同用户不同的权限\n\n#### AppRestrictionSchema ####\n\n- [项目地址](https://github.com/googlesamples/android-AppRestrictionSchema/#readme)\n- 多用户系统中,管理员可以分配不同用户不同的权限\n\n#### AppRestrictions ####\n\n- [项目地址](https://github.com/googlesamples/android-AppRestrictions/#readme)\n- 多用户系统中,管理员可以分配不同用户不同的权限\n\n#### AppUsageStatistics ####\n\n- [项目地址](https://github.com/googlesamples/android-AppUsageStatistics/#readme)\n- 管理追踪手机及应用使用情况\n\n#### Architecture Components Basic ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample/#readme)\n- 官方MVVM架构\n\n#### Architecture Components Paging ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample/#readme)\n- 官方MVVM架构-分页\n\n#### Audio-Echo ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/audio-echo/#readme)\n- 使用OpenSL ES创建音频播放器和记录器,NDK开发\n\n### B ###\n\n#### BasicNetworking ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicNetworking/#readme)\n- 判断网络状态\n\n#### BeamLargeFiles  ####\n\n- [项目地址](https://github.com/googlesamples/android-BeamLargeFiles/#readme)\n- NFC,通过Android beam 传输大文件\n\n#### BluetoothAdvertisements ####\n\n- [项目地址](https://github.com/googlesamples/android-BluetoothAdvertisements/#readme)\n- 蓝牙,低功耗,传输少量数据\n\n#### BluetoothLeGatt ####\n\n- [项目地址](https://github.com/googlesamples/android-BluetoothLeGatt/#readme)\n- 蓝牙,使用BluetoothLeGatt,传输任意数据\n\n#### BasicAccessibility  ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicAccessibility/#readme)\n- 无障碍-talkback 使用.为盲人或视力不好的提供语音反馈\n\n#### BasicAndroidKeyStore ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicAndroidKeyStore/#readme)\n- 高级示例展示数据完整性的创建和用例\n- 创建和存储密钥,只有你的应用可以访问\n- 理解为公钥私钥那一堆验证即可\n\n#### BasicContactables ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicContactables/#readme)\n- 搜索框文字匹配联系人\n\n#### BasicGestureDetect ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicGestureDetect/#readme)\n- 手势监听\n\n#### BasicImmersiveMode ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicImmersiveMode/#readme)\n- 沉浸式\n\n#### BasicManagedProfile ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicManagedProfile/#readme)\n- [Managed Profile简介](https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html)\n- 企业环境中使用私人设备\n\n#### BasicMediaDecoder ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicManagedProfile/#readme)\n- 配合[TextureView](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1213/2153.html)展示视频流\n\n#### BasicMediaRouter ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicMediaRouter/#readme)\n- 媒体无线投射\n\n#### BasicMultitouch ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicMultitouch/#readme)\n- 多点触控示例\n\n#### BasicNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicNotifications/#readme)\n- 基本的通知事件\n\n#### BasicRenderScript ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicRenderScript/#readme)\n- 基本的图形渲染脚本演示\n\n#### BasicSyncAdapter ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicSyncAdapter/#readme)\n- 基本的异步适配器,后台同步数据\n\n#### BasicTransition ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicTransition/#readme)\n- 基本的transition动画-kitkat\n\n#### BatchStepSensor ####\n\n- [项目地址](https://github.com/googlesamples/android-BatchStepSensor/#readme)\n- 计步传感器\n\n#### Bitmap Plasma ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/bitmap-plasma/#readme)\n- 图片等离子效果\n\n#### Bluetooth GATT Server ####\n\n- [项目地址](https://github.com/androidthings/sample-bluetooth-le-gattserver/#readme)\n- Android Things应用,访问蓝牙GATT服务通信\n\n#### BluetoothChat ####\n\n- [项目地址](https://github.com/googlesamples/android-BluetoothChat/#readme)\n- 两个设备通过蓝牙实现双向文本会话,全部使用的是基础蓝牙api\n\n#### BorderlessButtons ####\n\n- [项目地址](https://github.com/googlesamples/android-BorderlessButtons/#readme)\n- holo风格的无边框按钮\n\n#### Button and LED sample for Android Things ####\n\n- [项目地址](https://github.com/androidthings/sample-button/#readme)\n- Android things 示例,监听按钮,控制led灯的明灭\n \n### C ###\n\n#### CardView ####\n\n- [项目地址](https://github.com/googlesamples/android-CardView/#readme)\n- 理解为圆角layout吧,类似于framelayout,配合recyclerview使用\n\n\n#### CommitContentSampleApp ####\n\n- [项目地址](https://github.com/googlesamples/android-CommitContentSampleApp/#readme)\n- 键盘发送富文本\n\n#### CommitContentSampleIME ####\n\n- [项目地址](https://github.com/googlesamples/android-CommitContentSampleIME/#readme)\n- 键盘发送富文本\n\n#### Camera2Basic ####\n\n- [项目地址](https://github.com/googlesamples/android-Camera2Basic/#readme)\n- Camera2 API基本使用(5.0以后Camera2)\n\n#### Camera2Raw ####\n\n- [项目地址](https://github.com/googlesamples/android-Camera2Raw/#readme)\n- Camera2拍摄RAW格式照片\n\n#### Camera2Video ####\n\n- [项目地址](https://github.com/googlesamples/android-Camera2Video/#readme)\n- Camera2拍摄视频\n\n#### CardEmulation ####\n\n- [项目地址](https://github.com/googlesamples/android-CardEmulation/#readme)\n- 模拟NFC卡\n \n#### CardReader ####\n\n- [项目地址](https://github.com/googlesamples/android-CardReader/#readme)\n- 实现一个低级的NFC读取卡,功能包括是否包含NDEF或Android Beam数据\n \n#### ClippingBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-ClippingBasic/#readme)\n- 使用ViewOutlineProvider 和给定的图形,裁剪已有的view\n \n#### Confirm Credential ####\n\n- [项目地址](https://github.com/googlesamples/android-ConfirmCredential/#readme)\n- 如何使用设备的凭证(PIN码,密码,手势等)认证用户\n \n#### CustomChoiceList ####\n\n- [项目地址](https://github.com/googlesamples/android-CustomChoiceList/#readme)\n- 带有checkbox的listview\n \n#### CustomNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-CustomNotifications/#readme)\n- 展示一个带有内容的通知视图,可以扩展和折叠\n \n#### CustomTransition ####\n\n- [项目地址](https://github.com/googlesamples/android-CustomTransition/#readme)\n- 继承标准的transition类来实现一个自定义动画\n\n### D ###\n\n#### DownloadableFonts ####\n\n- [项目地址](https://github.com/googlesamples/android-DownloadableFonts/#readme)\n- 字体下载,这样字体不需要放入app的资源文件了,国内没法用\n\n#### DownloadableFonts(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-DownloadableFonts/tree/master/kotlinApp#readme)\n- 字体下载,这样字体不需要放入app的资源文件了,国内没法用\n\n#### DirectBoot ####\n\n- [项目地址](https://github.com/googlesamples/android-DirectBoot/#readme)\n- 直接启动模式-当设备已经开机但用户尚未解锁设备时.\n\t- 闹钟,短信,无障碍应用\n\n#### DirectShare ####\n\n- [项目地址](https://github.com/googlesamples/android-DirectShare/#readme)\n- 系统的内置分享\n\n#### DocumentCentricRecents ####\n\n- [项目地址](https://github.com/googlesamples/android-DocumentCentricApps/#readme)\n- `Document Centric Apps`基本用例\n- 可以令你在系统最近任务中,创建一个新的文档,并且手机重启也会保留其状态\n\n#### DataLayer ####\n\n- [项目地址](https://github.com/googlesamples/android-DataLayer/#readme)\n- 使用`WearableListenerService`,`DataLayer`,产生和自定义数据事件和高效的工作.\n\n#### DelayedConfirmation ####\n\n- [项目地址](https://github.com/googlesamples/android-DelayedConfirmation/#readme)\n- 在你的穿戴设备上,创建一个可延迟确定的视图.\n\n#### DeviceOwner ####\n\n- [项目地址](https://github.com/googlesamples/android-DeviceOwner/#readme)\n- 该示例展示如何使用设备所有者的所有功能\n\n#### DirectorySelection ####\n\n- [项目地址](https://github.com/googlesamples/android-DirectorySelection/#readme)\n- 使用目录选择api,可以让用户选择整个目录子树\n\n#### DisplayingBitmaps ####\n\n- [项目地址](https://github.com/googlesamples/android-DisplayingBitmaps/#readme)\n- 非主线程中高效加载大图,缓存图片,管理图片内存,展示图片\n\n#### DocumentCentricRelinquishIdentity ####\n\n- [项目地址](https://github.com/googlesamples/android-DocumentCentricRelinquishIdentity/#readme)\n- 使用`ActivityManager.TaskDescription`修改一个activity的特征\n\n#### DoneBar ####\n\n- [项目地址](https://github.com/googlesamples/android-DoneBar/#readme)\n- 使用2个独立的布局,在ActionBar 上创建自定义已完成按钮\n\n#### DoubleClick Banner ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/doubleclick/BannerExample/#readme)\n- 双击的广告,应该基于Google ad的,国内没法用的.\n\n#### DoubleClick Custom Rendering ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/doubleclick/CustomRenderingExample/#readme)\n- 广告相关的,应该基于Google ad的,国内没法用的.\n\n#### DoubleClick For Publishers Advanced Native Example ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/advanced/NativeListViewExample/#readme)\n- 广告相关的,应该基于Google ad的,国内没法用的.\n\n#### DoubleClick Interstitial Sample ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/doubleclick/InterstitialExample/#readme)\n- 广告相关的,应该基于Google ad的,国内没法用的.\n\n#### DrawableTinting ####\n\n- [项目地址](https://github.com/googlesamples/android-DrawableTinting/#readme)\n- 图片在可用/不可用,获取焦点,按下,选中等等状态时,给其着色.\n \n### E ###\n\n#### EmojiCompat ####\n\n- [项目地址](https://github.com/googlesamples/android-EmojiCompat/#readme)\n- 表情组件,保持最新,防止出现不识别的符号,国内没法用\n\n#### EmojiCompat(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-EmojiCompat/tree/master/kotlinApp/#readme)\n- 表情组件,保持最新,防止出现不识别的符号,国内没法用\n\n#### ElevationBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-ElevationBasic/#readme)\n- 操作视图Z轴属性(阴影)\n\n#### ElevationDrag ####\n\n- [项目地址](https://github.com/googlesamples/android-ElevationDrag/#readme)\n- 拖动时,操作视图Z轴属性(阴影)\n\n#### ElizaChat ####\n\n- [项目地址](https://github.com/googlesamples/android-ElizaChat/#readme)\n- 添加扩展到可穿戴设备的通知上.\n\n#### Endless Tunnel ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/endless-tunnel/#readme)\n- 一个游戏\n- 使用as c++支持\n- 使用Android native glue\n- 实现了joystick 支持\n\n### F ###\n\n#### FingerprintDialog ####\n\n- [项目地址](https://github.com/googlesamples/android-FingerprintDialog/#readme)\n- 使用app中已注册的指纹,授权用户做一些例如充值之类的操作\n- Android SDK 26\n \n#### Firebase Quickstarts ####\n\n- [项目地址](https://github.com/firebase/quickstart-android/#readme)\n- firebase快速开始,国内没法用\n\t- 分析app\n\t- 开发app\n\t- 广告\n\n#### FindMyPhone ####\n\n- [项目地址](https://github.com/googlesamples/android-FindMyPhone/#readme)\n- 可穿戴设备失联了,或者还连接着但你的手机找不到了\n\n#### Flashlight ####\n\n- [项目地址](https://github.com/googlesamples/android-Flashlight/#readme)\n- 可穿戴设备上的一个页面,屏幕展示为一个手电筒(发光)\n\n#### FloatingActionButtonBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-FloatingActionButtonBasic/#readme)\n- 示例展示了两个尺寸的Floating Action Buttons,和他们之间的相互作用.\n\n### G ###\n\n#### Geofencing ####\n\n- [项目地址](https://github.com/googlesamples/android-Geofencing/#readme)\n- 可穿戴设备上一个功能,当你出现在某个地方,一个通知静默出现,当你离开,通知消失,应该用的Googlemap,国内有替代品.\n\n#### Github Browser Sample ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample/#readme)\n- Room,Lifecycle-aware,ViewModels,LiveData,Paging构成,访问github的框架\n\n#### Google Assistant API Sample for Android Things ####\n\n- [项目地址](https://github.com/androidthings/sample-googleassistant/#readme)\n- Android things关于谷歌助手api示例\n\n#### GridViewPager ####\n\n- [项目地址](https://github.com/googlesamples/android-GridViewPager/#readme)\n- 可穿戴设备上的GridViewPager\n\n#### gles3jni ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/gles3jni/#readme)\n- 示例如何JNI调用`OpenGL ES 3.0`\n\n### H ###\n\n#### HdrViewfinder ####\n\n- [项目地址](https://github.com/googlesamples/android-HdrViewfinder/#readme)\n- 实现了一个实时的高动态范围的相机取景器,\n\n#### Hello GL2 ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-gl2/#readme)\n- 使用GLES 2.0画了一个三角形\n\n#### Hello JNI ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-jni/#readme)\n- Java调用C代码示例\n\n#### Hello JNI Callback ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-jniCallback/#readme)\n- Java调用C代码的回调示例\n\n#### HorizontalPaging ####\n\n- [项目地址](https://github.com/googlesamples/android-HorizontalPaging/#readme)\n- viewpager + fragment\n\n#### hello-libs ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-libs/#readme)\n- 示例展示了在AS中,如何管理第三方C/C++库.\n\n### I ###\n\n#### ImmersiveMode ####\n\n- [项目地址](https://github.com/googlesamples/android-ImmersiveMode/#readme)\n- 沉浸模式\n\n#### Instant Apps - Cookie API ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/cookie-api/#readme)\n- 即时App(依赖GooglePlay),8.0及其以上,使用cookie\n\n#### Instant Apps - Configuration APKs ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/configuration-apks/#readme)\n- 即时App(依赖GooglePlay),gradle中配置apk\n\n#### Instant Apps - Feature Module sample ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/hello-feature-module/#readme)\n- 即时App(依赖GooglePlay),功能模块示例\n\n#### Instant Apps - Flavors ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/flavors/#readme)\n- 即时App(依赖GooglePlay),gradle的flavor示例\n\n#### Instant Apps - Google Analytics ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/analytics/#readme)\n- 即时App(依赖GooglePlay),Google 分析示例\n\n#### Instant Apps - Hello World ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/hello-java/#readme)\n- 即时App(依赖GooglePlay),基本示例\n\n#### Instant Apps - Install API ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/install-api/#readme)\n- 即时App(依赖GooglePlay),安装apk到设备示例\n\n#### Instant Apps - Multi feature ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/multi-feature-module/#readme)\n- 即时App(依赖GooglePlay),示例构建了一个可安装的apk和一个即时app.即时app有2个功能,可以单独的在设备上使用.\n\n#### Instant Apps - Service ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/service/#readme)\n- 即时App(依赖GooglePlay),instant app如何start或bind一个服务.\n\n#### Instant Apps - Storage API ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/storage-api/#readme)\n- 即时App(依赖GooglePlay),instant app存储的数据,正式安装后的apk转换存储数据使用该api示例.\n\n#### Interpolator ####\n\n- [项目地址](https://github.com/googlesamples/android-Interpolator/#readme)\n- 材料设计的插值动画和路径动画.\n\n### J ###\n\n#### JobScheduler ####\n\n- [项目地址](https://github.com/googlesamples/android-JobScheduler/#readme)\n- 后台任务示例\n\n#### JumpingJack ####\n\n- [项目地址](https://github.com/googlesamples/android-JumpingJack/#readme)\n- 可穿戴设备上,通过重力传感器,计算你能`开合跳`多少下.\n\n### L ###\n\n#### LNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-LNotifications/#readme)\n- Android 5.0 的新通知.\n\n### M ###\n\n#### MessagingService ####\n\n- [项目地址](https://github.com/googlesamples/android-MessagingService/#readme)\n- 使用gms收发消息,国内没法用\n\n#### MediaBrowserService ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaBrowserService/#readme)\n- 如何实现一个媒体app后台播放,提供媒体库给别的app\n\n#### MediaEffects ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaEffects/#readme)\n- 4.0以后的,应用图片效果,像OpenGL ES2.0的 textures一样.\n\n#### MediaRecorder ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaRecorder/#readme)\n- api14以前,使用surfaceview,现在使用textureview,通过摄像头拍摄.\n\n#### MediaRouter ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaRouter/#readme)\n- 自定义媒体无线投射\n\n#### MidiScope ####\n\n- [项目地址](https://github.com/googlesamples/android-MidiScope/#readme)\n- MIDI(乐器数字接口)api示例,比如:枚举当前可用的MIDI设备,设备的插上和拔下,接收MIDI信号.示例展示了接收到的MIDI信号,但是并没有演奏声音.\n\n#### MidiSynth ####\n\n- [项目地址](https://github.com/googlesamples/android-MidiSynth/#readme)\n- MIDI(乐器数字接口)api示例,接收和演奏MIDI信号.\n\n#### MultiWindowPlayground ####\n\n- [项目地址](https://github.com/googlesamples/android-MultiWindowPlayground/#readme)\n- Android N多窗口示例\n\n### N ###\n\n#### Notifications ####\n\n- [项目地址](https://github.com/googlesamples/android-Notifications/#readme)\n- 手机和可穿戴设备上的通知样式\n\n#### NotificationChannels ####\n\n- [项目地址](https://github.com/googlesamples/android-NotificationChannels/#readme)\n- android o 以后,根据主题,分类通知\n\n#### NotificationChannels(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-NotificationChannels/tree/master/kotlinApp/#readme)\n- android o 以后,根据主题,分类通知\n\n#### Native Activity ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/native-activity/#readme)\n- 本地activity,初始化GLES 2.0上下文,从本地C代码中读取加速度传感器数据.\n\n#### Native Ads Express RecyclerView Sample ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/advanced/NativeExpressRecyclerViewExample/#readme)\n- recyclerview列表展示Google 广告,国内没法用\n\n#### Native Audio ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/native-audio/#readme)\n- 使用JNI,调用C++ OpenSLES API,演奏和记录声音\n\n#### Native Plasma ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/native-plasma/#readme)\n- 使用C代码,在一个图片中渲染等离子效果\n\n#### Navigation Drawer ####\n\n- [项目地址](https://github.com/googlesamples/android-NavigationDrawer/#readme)\n- 侧滑导航普通调用\n\n#### NetworkConnect ####\n\n- [项目地址](https://github.com/googlesamples/android-NetworkConnect/#readme)\n- AsyncTask + HttpsURLConnection\n\n#### NfcProvisioning ####\n\n- [项目地址](https://github.com/googlesamples/android-NfcProvisioning/#readme)\n- 使用NFC和设备拥有者提供诶一个新的设备.\n- 设备拥有者是是特殊的设备管理员,可以控制设备的安全和配置.\n- 示例本身不是一个设备拥有者,但是他发送了NFC消息给未设置对等设备,并且告诉对方知道设备的拥有者.\n\n#### NetworkConnect ####\n\n- [项目地址](https://github.com/googlesamples/android-NetworkConnect/#readme)\n- AsyncTask + HttpsURLConnection\n\n### P ###\n\n#### PictureInPicture ####\n\n- [项目地址](https://github.com/googlesamples/android-PictureInPicture/#readme)\n- android o,画中画\n\n#### PictureInPicture(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-PictureInPicture/tree/master/kotlinApp/#readme)\n- android o,画中画\n\n#### PdfRendererBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-PdfRendererBasic/#readme)\n- android 5.0,显示PDF\n\n#### PermissionRequest ####\n\n- [项目地址](https://github.com/googlesamples/android-PermissionRequest/#readme)\n- webview中权限申请\n \n### Q ###\n\n#### Quiz ####\n\n- [项目地址](https://github.com/googlesamples/android-Quiz/#readme)\n- webview中权限申请\n \n### R ###\n\n#### RecyclerView ####\n\n- [项目地址](https://github.com/googlesamples/android-RecyclerView/#readme)\n- 理解为高级listview\n\n#### RuntimePermissions ####\n\n- [项目地址](https://github.com/googlesamples/android-RuntimePermissions/#readme)\n- android M,运行时权限\n\n#### RecipeAssistant ####\n\n- [项目地址](https://github.com/googlesamples/android-RecipeAssistant/#readme)\n- 加强的通知api,可以发送至可穿戴设备\n\n#### RenderScriptIntrinsic ####\n\n- [项目地址](https://github.com/googlesamples/android-RenderScriptIntrinsic/#readme)\n- `RenderScript intrinsics`使用示例,图片渲染\n\n#### RepeatingAlarm ####\n\n- [项目地址](https://github.com/googlesamples/android-RepeatingAlarm/#readme)\n- 一个重复的提醒\n\n#### RevealEffectBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-RevealEffectBasic/#readme)\n- 圆形揭露动画,用于按钮点击,页面跳转.点击时,页面出现一个渐变的圆圈.\n\n#### Room & RxJava ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample/#readme)\n- Room 和 RxJava搭配示例\n\n#### Room & RxJava(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSampleKotlin/#readme)\n- Room 和 RxJava搭配示例\n\n#### Room with Content Providers ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceContentProviderSample/#readme)\n- Room 和 内容提供者搭配示例\n\n#### RuntimePermissionsBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-RuntimePermissionsBasic/#readme)\n- 基本的运行时权限\n\n#### RuntimePermissionsWear ####\n\n- [项目地址](https://github.com/googlesamples/android-RuntimePermissionsWear/#readme)\n- 可穿戴设备的运行时权限\n\n### S ###\n\n#### Sample Android TV Channel App (TV Input) using TIF ####\n\n- [项目地址](https://github.com/googlesamples/androidtv-sample-inputs/#readme)\n- 一个电视app示例\n\n#### San Angeles ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/san-angeles/#readme)\n- 一个示例使用 GLES C/API来渲染过程场景\n\n#### ScopedDirectoryAccess ####\n\n- [项目地址](https://github.com/googlesamples/android-ScopedDirectoryAccess/#readme)\n- 利用Scoped Directory Access API进入指定的目录,不需要请求权限\n\n#### ScreenCapture ####\n\n- [项目地址](https://github.com/googlesamples/android-ScreenCapture/#readme)\n- 利用Media Projection API,实时截图\n\n#### Sensor-Graph ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/sensor-graph/#readme)\n- 把传感器的变化用图形表示出来.示例读取当前加速度,使用OpenGL画出变化曲线.\n\n#### Simple example of Android Things Native Peripheral I/O APIs ####\n\n- [项目地址](https://github.com/androidthings/sample-nativepio/#readme)\n- C++,使用 Native PIO APIs,示例附加设备的I/O\n\n#### Simple example of Android Things Peripheral I/O APIs ####\n\n- [项目地址](https://github.com/androidthings/sample-simplepio/#readme)\n- 使用 Native PIO APIs,示例附加设备的I/O\n\n#### SkeletonWearableApp ####\n\n- [项目地址](https://github.com/googlesamples/android-SkeletonWearableApp/#readme)\n- 一个大概的app,可用以开始一个可穿戴开发\n\n#### SlidingTabsBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-SlidingTabsBasic/#readme)\n- 基本的左右滑动切换tab页面\n\n#### SlidingTabsColors ####\n\n- [项目地址](https://github.com/googlesamples/android-SlidingTabsColors/#readme)\n- 左右滑动切换tab页面的指示器颜色,文字颜色,分割线颜色\n\n#### SpeedTracker ####\n\n- [项目地址](https://github.com/googlesamples/android-SpeedTracker/#readme)\n- 可穿戴设备记录位置和速度\n\n#### StorageClient ####\n\n- [项目地址](https://github.com/googlesamples/android-StorageClient/#readme)\n- 使用`OPEN_DOCUMENT `意图,一个客户app可以访问设备上的文档提供者的列表,并且从中选择文件.\n\n#### StorageProvider ####\n\n- [项目地址](https://github.com/googlesamples/android-StorageProvider/#readme)\n- 示例实现了一个简单文档提供者\n\n####  SwipeRefreshLayout ####\n\n- [项目地址](https://github.com/googlesamples/android-SwipeRefreshLayoutBasic/#readme)\n- 官方下拉刷新\n\n####  SwipeRefreshListFragment ####\n\n- [项目地址](https://github.com/googlesamples/android-SwipeRefreshListFragment/#readme)\n- 官方下拉刷新fragment\n\n####  SwipeRefreshMultipleViews ####\n\n- [项目地址](https://github.com/googlesamples/android-SwipeRefreshMultipleViews/#readme)\n- 官方下拉刷新多组视图\n\n####  SynchronizedNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-SynchronizedNotifications/#readme)\n- 同步通知.允许手机和手表上同时关闭.\n\n### T ###\n\n####  TV Leanback Support Library sample ####\n\n- [项目地址](https://github.com/googlesamples/androidtv-Leanback/#readme)\n- `Leanback Support library`祝你完成更好的电视app\n\n####  Teapots ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/teapots/#readme)\n- 通过渲染一个茶壶,展示Android NDK平台的功能\n\n####  TextLinkify ####\n\n- [项目地址](https://github.com/googlesamples/android-TextLinkify/#readme)\n- 如何给TextView添加链接\n\n####  TextSwitcher ####\n\n- [项目地址](https://github.com/googlesamples/android-TextSwitcher/#readme)\n- `TextSwitcher`来展示文字改变的动画\n\n####  Things Bluetooth Audio sample ####\n\n- [项目地址](https://github.com/androidthings/sample-bluetooth-audio/#readme)\n- Android things里,和音频有关的蓝牙api示例.\n\n####  Things Cloud IoT Sensor Hub ####\n\n- [项目地址](https://github.com/androidthings/sensorhub-cloud-iot/#readme)\n- Android things里,实现一个传感器中心,收集传感器数据.上传到Google Cloud.该服务国内不能用.\n\n####  Things Doorbell ####\n\n- [项目地址](https://github.com/androidthings/doorbell/#readme)\n- Android things里,看起来是个门铃实现.\n\n####  Things Simple UI ####\n\n- [项目地址](https://github.com/androidthings/sample-simpleui/#readme)\n- Android things里,一个开关UI\n\n####  Things TensorFlow image classifier sample ####\n\n- [项目地址](https://github.com/androidthings/sample-tensorflow-imageclassifier/#readme)\n- Android things里,当按下GPIO按钮,当前画面被添加的相机捕获.该图片被覆盖和传入TensorFlow模式,识别图片里的是啥.如果有屏幕就展示识别后的最多三个标签,如果有扬声器,那么就说出来.使用的Google服务,国内不能用.\n\n####  Things Weather Station ####\n\n- [项目地址](https://github.com/androidthings/weatherstation/#readme)\n- Android things里,外围多个设备组成一个连接地天气站.\n\n####  Things driver ####\n\n- [项目地址](https://github.com/androidthings/drivers-samples/#readme)\n- Android things里,外围驱动\n\n####  Timer ####\n\n- [项目地址](https://github.com/googlesamples/android-Timer/#readme)\n- 定时器,可不依靠手机独立运行在可穿戴设备上.\n\n####  Topeka ####\n\n- [项目地址](https://github.com/googlesamples/android-topeka/#readme)\n- 一个有趣的小测试题展示材料设计\n\n####  Trivial Drive ####\n\n- [项目地址](https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive/#readme)\n- 开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用\n\n####  Trivial Drive2 ####\n\n- [项目地址](https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive_v2/#readme)\n- 开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用\n\n### U ###\n\n#### UART Loopback sample ####\n\n- [项目地址](https://github.com/androidthings/sample-uartloopback/#readme)\n- Android things里,通过异步收发器,读写数据.\n\n#### USB Enumerator ####\n\n- [项目地址](https://github.com/androidthings/sample-usbenum/#readme)\n- 枚举所有USB设备\n\n#### Universal Android Music Player ####\n\n- [项目地址](https://github.com/googlesamples/android-UniversalMusicPlayer/#readme)\n- 一个音乐播放器,可以在手机,平板,手表,电视,Android Auto(汽车),Google Cast devices这些设备上提供一致的用户体验.\n\n### V ###\n\n#### Vulkan ####\n\n- [项目地址](https://github.com/googlesamples/vulkan-basic-samples/#readme)\n- 一个C++实现的库,渲染3D图形\n\n### W ###\n\n#### WatchFace ####\n\n- [项目地址](https://github.com/googlesamples/android-WatchFace/#readme)\n- 为可穿戴设备创建watch face\n \n#### WearDrawers ####\n\n- [项目地址](https://github.com/googlesamples/android-WearDrawers/#readme)\n- 为可穿戴设备创建导航抽屉\n \n#### WearHighBandwidthNetworking ####\n\n- [项目地址](https://github.com/googlesamples/android-WearHighBandwidthNetworking/#readme)\n- 可穿戴设备的带宽处理最佳实践\n \n#### WEBP Samples ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/webp/#readme)\n- webp,一种google建议的图片格式.\n \n#### WatchViewStub ####\n\n- [项目地址](https://github.com/googlesamples/android-WatchViewStub/#readme)\n- 为圆形,方形的手表指定不同的布局\n \n#### WearComplicationProvidersTestSuite  ####\n\n- [项目地址](https://github.com/googlesamples/android-WearComplicationProvidersTestSuite/#readme)\n- 并发测试套装集合,提供了假数据可以用来测试手表的不同类型渲染.\n \n#### WearNotifications  ####\n\n- [项目地址](https://github.com/googlesamples/android-WearNotifications/#readme)\n- 手机和手表的通知最佳实践.\n \n#### WearSpeakerSample  ####\n\n- [项目地址](https://github.com/googlesamples/android-WearSpeakerSample/#readme)\n- 在可穿戴设备上录音,播音.\n \n#### WearVerifyRemoteApp ####\n\n- [项目地址](https://github.com/googlesamples/android-WearVerifyRemoteApp/#readme)\n- 最佳实践:检测已连接的设备是否从周边的可穿戴设备上安装了你的app.(如果安装了就可以传输数据了)\n\n### X ###\n \n#### XYZTouristAttractions ####\n\n- [项目地址](https://github.com/googlesamples/android-XYZTouristAttractions/#readme)\n- 示例打算尽可能的通过手机和可穿戴设备接近真实实践.巴拉巴拉吹牛逼的话...\n- 示例模拟一个景点,当用户靠近时通知用户\n- GridViewPage展示图片和文字介绍\n\n\n\n\n\n","source":"_posts/2018-01-15-android-samples-index.md","raw":"---\nlayout: post\ntitle:  Android官方示例按字母索引\ndate:   2018-01-15\ncategories: Android System Framework\ntag: android\n---\n\n[Google 官方示例](https://developer.android.com/samples/index.html)\n\n\t好东西真多.\n\t因为墙的原因,不可用的也很多.\n\t如果可以,选择国内类似服务,或者自己模拟搭建服务.\n\n### A ###\n\n#### AppShortcuts(快捷方式) ####\n\n- [项目地址](https://github.com/googlesamples/android-AppShortcuts/#readme)\n- 版本: Android 7.1 (API 25)\n- 功能简介:\n\t- 长按图标展示一个意图集合\n\t- 静态创建和动态创建\n\n\n#### AutofillFramework(自动填充) ####\n\n- [kotlin-项目地址](https://github.com/googlesamples/android-AutofillFramework/tree/master/kotlinApp/#readme)\n- [java-项目地址](https://github.com/googlesamples/android-AutofillFramework/#readme)\n- 版本: Android 7.1 (API 25)\n- 功能简介:\n\t- 少数app会开发该功能\n\t- 一般是密码管理器这类的第三方app会开发该服务\n\t- 自动填充服务解析客户端的视图层级,找到可以提供数据的自动填充字段,然后发送推荐\n\t- 客户端使用一些字段,指定拥有自动填充属性的视图\n\t- 示例的数据存在shared preference中,并不安全\n\n#### AAudio ####\n\n- [项目地址](https://github.com/googlesamples/android-audio-high-performance/tree/master/aaudio/#readme)\n- 大概是个录音和播放的功能\n-  API (android-26)\n-  NDK-r15 or above\n\n#### AsymmetricFingerprintDialog ####\n\n- [项目地址](https://github.com/googlesamples/android-AsymmetricFingerprintDialog/#readme)\n- 使用app中已注册的指纹,授权用户做一些例如充值之类的操作\n- Android SDK 26\n\n#### ActionBarCompat-Basic ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-Basic/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActionBarCompat-Styled ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-Styled/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActiveNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-ActiveNotifications/#readme)\n- 通知组和通知管理\n\n#### AccelerometerPlay ####\n\n- [项目地址](https://github.com/googlesamples/android-AccelerometerPlay/#readme)\n- 加速度传感器\n\n#### ActionBarCompat-ListPopupMenu ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActionBarCompat-ShareActionProvider ####\n\n- [项目地址](https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme)\n- ActionBar组件使用,现在应该都开始用toolbar了吧\n\n#### ActivityInstrumentation  ####\n\n- [项目地址](https://github.com/googlesamples/android-ActivityInstrumentation)\n- 模拟测试数据\n- 不需要进去看了,一个spinner展示了一个写死的list\n\n\n#### ActivitySceneTransitionBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-ActivitySceneTransitionBasic/#readme)\n- Activity之间转场动画\n- 一个场景:新闻列表的图片,进入详情,然后放大,并且带有动画\n\n#### AdMob Banner #### \n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/BannerExample/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### AdMob Native Advanced #### \n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme)\n- app内置广告api调用,国内应该有类似\n \n#### AdMob Native Ads Express ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### AdMob Interstitial ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/admob/InterstitialExample/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### Advanced API Demos ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/advanced/APIDemo/#readme)\n- app内置广告api调用,国内应该有类似\n\n#### AgendaData ####\n\n- [项目地址](https://github.com/googlesamples/android-AgendaData/#readme)\n- 同步日程至可穿戴设备示例\n\n#### AdvancedImmersiveMode #### \n\n- [项目地址](https://github.com/googlesamples/android-AdvancedImmersiveMode/#readme)\n- 沉浸模式\n\n#### AlwaysOn #### \n\n- [项目地址](https://github.com/googlesamples/android-AlwaysOn/#readme)\n- 可穿戴设备的微光模式-保持设备常亮\n\n#### AppRestrictionEnforcer ####\n\n- [项目地址](https://github.com/googlesamples/android-AppRestrictionEnforcer/#readme)\n- 多用户系统中,管理员可以分配不同用户不同的权限\n\n#### AppRestrictionSchema ####\n\n- [项目地址](https://github.com/googlesamples/android-AppRestrictionSchema/#readme)\n- 多用户系统中,管理员可以分配不同用户不同的权限\n\n#### AppRestrictions ####\n\n- [项目地址](https://github.com/googlesamples/android-AppRestrictions/#readme)\n- 多用户系统中,管理员可以分配不同用户不同的权限\n\n#### AppUsageStatistics ####\n\n- [项目地址](https://github.com/googlesamples/android-AppUsageStatistics/#readme)\n- 管理追踪手机及应用使用情况\n\n#### Architecture Components Basic ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample/#readme)\n- 官方MVVM架构\n\n#### Architecture Components Paging ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample/#readme)\n- 官方MVVM架构-分页\n\n#### Audio-Echo ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/audio-echo/#readme)\n- 使用OpenSL ES创建音频播放器和记录器,NDK开发\n\n### B ###\n\n#### BasicNetworking ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicNetworking/#readme)\n- 判断网络状态\n\n#### BeamLargeFiles  ####\n\n- [项目地址](https://github.com/googlesamples/android-BeamLargeFiles/#readme)\n- NFC,通过Android beam 传输大文件\n\n#### BluetoothAdvertisements ####\n\n- [项目地址](https://github.com/googlesamples/android-BluetoothAdvertisements/#readme)\n- 蓝牙,低功耗,传输少量数据\n\n#### BluetoothLeGatt ####\n\n- [项目地址](https://github.com/googlesamples/android-BluetoothLeGatt/#readme)\n- 蓝牙,使用BluetoothLeGatt,传输任意数据\n\n#### BasicAccessibility  ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicAccessibility/#readme)\n- 无障碍-talkback 使用.为盲人或视力不好的提供语音反馈\n\n#### BasicAndroidKeyStore ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicAndroidKeyStore/#readme)\n- 高级示例展示数据完整性的创建和用例\n- 创建和存储密钥,只有你的应用可以访问\n- 理解为公钥私钥那一堆验证即可\n\n#### BasicContactables ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicContactables/#readme)\n- 搜索框文字匹配联系人\n\n#### BasicGestureDetect ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicGestureDetect/#readme)\n- 手势监听\n\n#### BasicImmersiveMode ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicImmersiveMode/#readme)\n- 沉浸式\n\n#### BasicManagedProfile ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicManagedProfile/#readme)\n- [Managed Profile简介](https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html)\n- 企业环境中使用私人设备\n\n#### BasicMediaDecoder ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicManagedProfile/#readme)\n- 配合[TextureView](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1213/2153.html)展示视频流\n\n#### BasicMediaRouter ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicMediaRouter/#readme)\n- 媒体无线投射\n\n#### BasicMultitouch ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicMultitouch/#readme)\n- 多点触控示例\n\n#### BasicNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicNotifications/#readme)\n- 基本的通知事件\n\n#### BasicRenderScript ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicRenderScript/#readme)\n- 基本的图形渲染脚本演示\n\n#### BasicSyncAdapter ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicSyncAdapter/#readme)\n- 基本的异步适配器,后台同步数据\n\n#### BasicTransition ####\n\n- [项目地址](https://github.com/googlesamples/android-BasicTransition/#readme)\n- 基本的transition动画-kitkat\n\n#### BatchStepSensor ####\n\n- [项目地址](https://github.com/googlesamples/android-BatchStepSensor/#readme)\n- 计步传感器\n\n#### Bitmap Plasma ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/bitmap-plasma/#readme)\n- 图片等离子效果\n\n#### Bluetooth GATT Server ####\n\n- [项目地址](https://github.com/androidthings/sample-bluetooth-le-gattserver/#readme)\n- Android Things应用,访问蓝牙GATT服务通信\n\n#### BluetoothChat ####\n\n- [项目地址](https://github.com/googlesamples/android-BluetoothChat/#readme)\n- 两个设备通过蓝牙实现双向文本会话,全部使用的是基础蓝牙api\n\n#### BorderlessButtons ####\n\n- [项目地址](https://github.com/googlesamples/android-BorderlessButtons/#readme)\n- holo风格的无边框按钮\n\n#### Button and LED sample for Android Things ####\n\n- [项目地址](https://github.com/androidthings/sample-button/#readme)\n- Android things 示例,监听按钮,控制led灯的明灭\n \n### C ###\n\n#### CardView ####\n\n- [项目地址](https://github.com/googlesamples/android-CardView/#readme)\n- 理解为圆角layout吧,类似于framelayout,配合recyclerview使用\n\n\n#### CommitContentSampleApp ####\n\n- [项目地址](https://github.com/googlesamples/android-CommitContentSampleApp/#readme)\n- 键盘发送富文本\n\n#### CommitContentSampleIME ####\n\n- [项目地址](https://github.com/googlesamples/android-CommitContentSampleIME/#readme)\n- 键盘发送富文本\n\n#### Camera2Basic ####\n\n- [项目地址](https://github.com/googlesamples/android-Camera2Basic/#readme)\n- Camera2 API基本使用(5.0以后Camera2)\n\n#### Camera2Raw ####\n\n- [项目地址](https://github.com/googlesamples/android-Camera2Raw/#readme)\n- Camera2拍摄RAW格式照片\n\n#### Camera2Video ####\n\n- [项目地址](https://github.com/googlesamples/android-Camera2Video/#readme)\n- Camera2拍摄视频\n\n#### CardEmulation ####\n\n- [项目地址](https://github.com/googlesamples/android-CardEmulation/#readme)\n- 模拟NFC卡\n \n#### CardReader ####\n\n- [项目地址](https://github.com/googlesamples/android-CardReader/#readme)\n- 实现一个低级的NFC读取卡,功能包括是否包含NDEF或Android Beam数据\n \n#### ClippingBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-ClippingBasic/#readme)\n- 使用ViewOutlineProvider 和给定的图形,裁剪已有的view\n \n#### Confirm Credential ####\n\n- [项目地址](https://github.com/googlesamples/android-ConfirmCredential/#readme)\n- 如何使用设备的凭证(PIN码,密码,手势等)认证用户\n \n#### CustomChoiceList ####\n\n- [项目地址](https://github.com/googlesamples/android-CustomChoiceList/#readme)\n- 带有checkbox的listview\n \n#### CustomNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-CustomNotifications/#readme)\n- 展示一个带有内容的通知视图,可以扩展和折叠\n \n#### CustomTransition ####\n\n- [项目地址](https://github.com/googlesamples/android-CustomTransition/#readme)\n- 继承标准的transition类来实现一个自定义动画\n\n### D ###\n\n#### DownloadableFonts ####\n\n- [项目地址](https://github.com/googlesamples/android-DownloadableFonts/#readme)\n- 字体下载,这样字体不需要放入app的资源文件了,国内没法用\n\n#### DownloadableFonts(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-DownloadableFonts/tree/master/kotlinApp#readme)\n- 字体下载,这样字体不需要放入app的资源文件了,国内没法用\n\n#### DirectBoot ####\n\n- [项目地址](https://github.com/googlesamples/android-DirectBoot/#readme)\n- 直接启动模式-当设备已经开机但用户尚未解锁设备时.\n\t- 闹钟,短信,无障碍应用\n\n#### DirectShare ####\n\n- [项目地址](https://github.com/googlesamples/android-DirectShare/#readme)\n- 系统的内置分享\n\n#### DocumentCentricRecents ####\n\n- [项目地址](https://github.com/googlesamples/android-DocumentCentricApps/#readme)\n- `Document Centric Apps`基本用例\n- 可以令你在系统最近任务中,创建一个新的文档,并且手机重启也会保留其状态\n\n#### DataLayer ####\n\n- [项目地址](https://github.com/googlesamples/android-DataLayer/#readme)\n- 使用`WearableListenerService`,`DataLayer`,产生和自定义数据事件和高效的工作.\n\n#### DelayedConfirmation ####\n\n- [项目地址](https://github.com/googlesamples/android-DelayedConfirmation/#readme)\n- 在你的穿戴设备上,创建一个可延迟确定的视图.\n\n#### DeviceOwner ####\n\n- [项目地址](https://github.com/googlesamples/android-DeviceOwner/#readme)\n- 该示例展示如何使用设备所有者的所有功能\n\n#### DirectorySelection ####\n\n- [项目地址](https://github.com/googlesamples/android-DirectorySelection/#readme)\n- 使用目录选择api,可以让用户选择整个目录子树\n\n#### DisplayingBitmaps ####\n\n- [项目地址](https://github.com/googlesamples/android-DisplayingBitmaps/#readme)\n- 非主线程中高效加载大图,缓存图片,管理图片内存,展示图片\n\n#### DocumentCentricRelinquishIdentity ####\n\n- [项目地址](https://github.com/googlesamples/android-DocumentCentricRelinquishIdentity/#readme)\n- 使用`ActivityManager.TaskDescription`修改一个activity的特征\n\n#### DoneBar ####\n\n- [项目地址](https://github.com/googlesamples/android-DoneBar/#readme)\n- 使用2个独立的布局,在ActionBar 上创建自定义已完成按钮\n\n#### DoubleClick Banner ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/doubleclick/BannerExample/#readme)\n- 双击的广告,应该基于Google ad的,国内没法用的.\n\n#### DoubleClick Custom Rendering ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/doubleclick/CustomRenderingExample/#readme)\n- 广告相关的,应该基于Google ad的,国内没法用的.\n\n#### DoubleClick For Publishers Advanced Native Example ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/advanced/NativeListViewExample/#readme)\n- 广告相关的,应该基于Google ad的,国内没法用的.\n\n#### DoubleClick Interstitial Sample ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/doubleclick/InterstitialExample/#readme)\n- 广告相关的,应该基于Google ad的,国内没法用的.\n\n#### DrawableTinting ####\n\n- [项目地址](https://github.com/googlesamples/android-DrawableTinting/#readme)\n- 图片在可用/不可用,获取焦点,按下,选中等等状态时,给其着色.\n \n### E ###\n\n#### EmojiCompat ####\n\n- [项目地址](https://github.com/googlesamples/android-EmojiCompat/#readme)\n- 表情组件,保持最新,防止出现不识别的符号,国内没法用\n\n#### EmojiCompat(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-EmojiCompat/tree/master/kotlinApp/#readme)\n- 表情组件,保持最新,防止出现不识别的符号,国内没法用\n\n#### ElevationBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-ElevationBasic/#readme)\n- 操作视图Z轴属性(阴影)\n\n#### ElevationDrag ####\n\n- [项目地址](https://github.com/googlesamples/android-ElevationDrag/#readme)\n- 拖动时,操作视图Z轴属性(阴影)\n\n#### ElizaChat ####\n\n- [项目地址](https://github.com/googlesamples/android-ElizaChat/#readme)\n- 添加扩展到可穿戴设备的通知上.\n\n#### Endless Tunnel ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/endless-tunnel/#readme)\n- 一个游戏\n- 使用as c++支持\n- 使用Android native glue\n- 实现了joystick 支持\n\n### F ###\n\n#### FingerprintDialog ####\n\n- [项目地址](https://github.com/googlesamples/android-FingerprintDialog/#readme)\n- 使用app中已注册的指纹,授权用户做一些例如充值之类的操作\n- Android SDK 26\n \n#### Firebase Quickstarts ####\n\n- [项目地址](https://github.com/firebase/quickstart-android/#readme)\n- firebase快速开始,国内没法用\n\t- 分析app\n\t- 开发app\n\t- 广告\n\n#### FindMyPhone ####\n\n- [项目地址](https://github.com/googlesamples/android-FindMyPhone/#readme)\n- 可穿戴设备失联了,或者还连接着但你的手机找不到了\n\n#### Flashlight ####\n\n- [项目地址](https://github.com/googlesamples/android-Flashlight/#readme)\n- 可穿戴设备上的一个页面,屏幕展示为一个手电筒(发光)\n\n#### FloatingActionButtonBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-FloatingActionButtonBasic/#readme)\n- 示例展示了两个尺寸的Floating Action Buttons,和他们之间的相互作用.\n\n### G ###\n\n#### Geofencing ####\n\n- [项目地址](https://github.com/googlesamples/android-Geofencing/#readme)\n- 可穿戴设备上一个功能,当你出现在某个地方,一个通知静默出现,当你离开,通知消失,应该用的Googlemap,国内有替代品.\n\n#### Github Browser Sample ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample/#readme)\n- Room,Lifecycle-aware,ViewModels,LiveData,Paging构成,访问github的框架\n\n#### Google Assistant API Sample for Android Things ####\n\n- [项目地址](https://github.com/androidthings/sample-googleassistant/#readme)\n- Android things关于谷歌助手api示例\n\n#### GridViewPager ####\n\n- [项目地址](https://github.com/googlesamples/android-GridViewPager/#readme)\n- 可穿戴设备上的GridViewPager\n\n#### gles3jni ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/gles3jni/#readme)\n- 示例如何JNI调用`OpenGL ES 3.0`\n\n### H ###\n\n#### HdrViewfinder ####\n\n- [项目地址](https://github.com/googlesamples/android-HdrViewfinder/#readme)\n- 实现了一个实时的高动态范围的相机取景器,\n\n#### Hello GL2 ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-gl2/#readme)\n- 使用GLES 2.0画了一个三角形\n\n#### Hello JNI ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-jni/#readme)\n- Java调用C代码示例\n\n#### Hello JNI Callback ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-jniCallback/#readme)\n- Java调用C代码的回调示例\n\n#### HorizontalPaging ####\n\n- [项目地址](https://github.com/googlesamples/android-HorizontalPaging/#readme)\n- viewpager + fragment\n\n#### hello-libs ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/hello-libs/#readme)\n- 示例展示了在AS中,如何管理第三方C/C++库.\n\n### I ###\n\n#### ImmersiveMode ####\n\n- [项目地址](https://github.com/googlesamples/android-ImmersiveMode/#readme)\n- 沉浸模式\n\n#### Instant Apps - Cookie API ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/cookie-api/#readme)\n- 即时App(依赖GooglePlay),8.0及其以上,使用cookie\n\n#### Instant Apps - Configuration APKs ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/configuration-apks/#readme)\n- 即时App(依赖GooglePlay),gradle中配置apk\n\n#### Instant Apps - Feature Module sample ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/hello-feature-module/#readme)\n- 即时App(依赖GooglePlay),功能模块示例\n\n#### Instant Apps - Flavors ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/flavors/#readme)\n- 即时App(依赖GooglePlay),gradle的flavor示例\n\n#### Instant Apps - Google Analytics ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/analytics/#readme)\n- 即时App(依赖GooglePlay),Google 分析示例\n\n#### Instant Apps - Hello World ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/hello-java/#readme)\n- 即时App(依赖GooglePlay),基本示例\n\n#### Instant Apps - Install API ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/install-api/#readme)\n- 即时App(依赖GooglePlay),安装apk到设备示例\n\n#### Instant Apps - Multi feature ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/multi-feature-module/#readme)\n- 即时App(依赖GooglePlay),示例构建了一个可安装的apk和一个即时app.即时app有2个功能,可以单独的在设备上使用.\n\n#### Instant Apps - Service ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/service/#readme)\n- 即时App(依赖GooglePlay),instant app如何start或bind一个服务.\n\n#### Instant Apps - Storage API ####\n\n- [项目地址](https://github.com/googlesamples/android-instant-apps/tree/master/storage-api/#readme)\n- 即时App(依赖GooglePlay),instant app存储的数据,正式安装后的apk转换存储数据使用该api示例.\n\n#### Interpolator ####\n\n- [项目地址](https://github.com/googlesamples/android-Interpolator/#readme)\n- 材料设计的插值动画和路径动画.\n\n### J ###\n\n#### JobScheduler ####\n\n- [项目地址](https://github.com/googlesamples/android-JobScheduler/#readme)\n- 后台任务示例\n\n#### JumpingJack ####\n\n- [项目地址](https://github.com/googlesamples/android-JumpingJack/#readme)\n- 可穿戴设备上,通过重力传感器,计算你能`开合跳`多少下.\n\n### L ###\n\n#### LNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-LNotifications/#readme)\n- Android 5.0 的新通知.\n\n### M ###\n\n#### MessagingService ####\n\n- [项目地址](https://github.com/googlesamples/android-MessagingService/#readme)\n- 使用gms收发消息,国内没法用\n\n#### MediaBrowserService ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaBrowserService/#readme)\n- 如何实现一个媒体app后台播放,提供媒体库给别的app\n\n#### MediaEffects ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaEffects/#readme)\n- 4.0以后的,应用图片效果,像OpenGL ES2.0的 textures一样.\n\n#### MediaRecorder ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaRecorder/#readme)\n- api14以前,使用surfaceview,现在使用textureview,通过摄像头拍摄.\n\n#### MediaRouter ####\n\n- [项目地址](https://github.com/googlesamples/android-MediaRouter/#readme)\n- 自定义媒体无线投射\n\n#### MidiScope ####\n\n- [项目地址](https://github.com/googlesamples/android-MidiScope/#readme)\n- MIDI(乐器数字接口)api示例,比如:枚举当前可用的MIDI设备,设备的插上和拔下,接收MIDI信号.示例展示了接收到的MIDI信号,但是并没有演奏声音.\n\n#### MidiSynth ####\n\n- [项目地址](https://github.com/googlesamples/android-MidiSynth/#readme)\n- MIDI(乐器数字接口)api示例,接收和演奏MIDI信号.\n\n#### MultiWindowPlayground ####\n\n- [项目地址](https://github.com/googlesamples/android-MultiWindowPlayground/#readme)\n- Android N多窗口示例\n\n### N ###\n\n#### Notifications ####\n\n- [项目地址](https://github.com/googlesamples/android-Notifications/#readme)\n- 手机和可穿戴设备上的通知样式\n\n#### NotificationChannels ####\n\n- [项目地址](https://github.com/googlesamples/android-NotificationChannels/#readme)\n- android o 以后,根据主题,分类通知\n\n#### NotificationChannels(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-NotificationChannels/tree/master/kotlinApp/#readme)\n- android o 以后,根据主题,分类通知\n\n#### Native Activity ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/native-activity/#readme)\n- 本地activity,初始化GLES 2.0上下文,从本地C代码中读取加速度传感器数据.\n\n#### Native Ads Express RecyclerView Sample ####\n\n- [项目地址](https://github.com/googlesamples/android-ads/tree/master/advanced/NativeExpressRecyclerViewExample/#readme)\n- recyclerview列表展示Google 广告,国内没法用\n\n#### Native Audio ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/native-audio/#readme)\n- 使用JNI,调用C++ OpenSLES API,演奏和记录声音\n\n#### Native Plasma ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/native-plasma/#readme)\n- 使用C代码,在一个图片中渲染等离子效果\n\n#### Navigation Drawer ####\n\n- [项目地址](https://github.com/googlesamples/android-NavigationDrawer/#readme)\n- 侧滑导航普通调用\n\n#### NetworkConnect ####\n\n- [项目地址](https://github.com/googlesamples/android-NetworkConnect/#readme)\n- AsyncTask + HttpsURLConnection\n\n#### NfcProvisioning ####\n\n- [项目地址](https://github.com/googlesamples/android-NfcProvisioning/#readme)\n- 使用NFC和设备拥有者提供诶一个新的设备.\n- 设备拥有者是是特殊的设备管理员,可以控制设备的安全和配置.\n- 示例本身不是一个设备拥有者,但是他发送了NFC消息给未设置对等设备,并且告诉对方知道设备的拥有者.\n\n#### NetworkConnect ####\n\n- [项目地址](https://github.com/googlesamples/android-NetworkConnect/#readme)\n- AsyncTask + HttpsURLConnection\n\n### P ###\n\n#### PictureInPicture ####\n\n- [项目地址](https://github.com/googlesamples/android-PictureInPicture/#readme)\n- android o,画中画\n\n#### PictureInPicture(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-PictureInPicture/tree/master/kotlinApp/#readme)\n- android o,画中画\n\n#### PdfRendererBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-PdfRendererBasic/#readme)\n- android 5.0,显示PDF\n\n#### PermissionRequest ####\n\n- [项目地址](https://github.com/googlesamples/android-PermissionRequest/#readme)\n- webview中权限申请\n \n### Q ###\n\n#### Quiz ####\n\n- [项目地址](https://github.com/googlesamples/android-Quiz/#readme)\n- webview中权限申请\n \n### R ###\n\n#### RecyclerView ####\n\n- [项目地址](https://github.com/googlesamples/android-RecyclerView/#readme)\n- 理解为高级listview\n\n#### RuntimePermissions ####\n\n- [项目地址](https://github.com/googlesamples/android-RuntimePermissions/#readme)\n- android M,运行时权限\n\n#### RecipeAssistant ####\n\n- [项目地址](https://github.com/googlesamples/android-RecipeAssistant/#readme)\n- 加强的通知api,可以发送至可穿戴设备\n\n#### RenderScriptIntrinsic ####\n\n- [项目地址](https://github.com/googlesamples/android-RenderScriptIntrinsic/#readme)\n- `RenderScript intrinsics`使用示例,图片渲染\n\n#### RepeatingAlarm ####\n\n- [项目地址](https://github.com/googlesamples/android-RepeatingAlarm/#readme)\n- 一个重复的提醒\n\n#### RevealEffectBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-RevealEffectBasic/#readme)\n- 圆形揭露动画,用于按钮点击,页面跳转.点击时,页面出现一个渐变的圆圈.\n\n#### Room & RxJava ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample/#readme)\n- Room 和 RxJava搭配示例\n\n#### Room & RxJava(Kotlin) ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSampleKotlin/#readme)\n- Room 和 RxJava搭配示例\n\n#### Room with Content Providers ####\n\n- [项目地址](https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceContentProviderSample/#readme)\n- Room 和 内容提供者搭配示例\n\n#### RuntimePermissionsBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-RuntimePermissionsBasic/#readme)\n- 基本的运行时权限\n\n#### RuntimePermissionsWear ####\n\n- [项目地址](https://github.com/googlesamples/android-RuntimePermissionsWear/#readme)\n- 可穿戴设备的运行时权限\n\n### S ###\n\n#### Sample Android TV Channel App (TV Input) using TIF ####\n\n- [项目地址](https://github.com/googlesamples/androidtv-sample-inputs/#readme)\n- 一个电视app示例\n\n#### San Angeles ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/san-angeles/#readme)\n- 一个示例使用 GLES C/API来渲染过程场景\n\n#### ScopedDirectoryAccess ####\n\n- [项目地址](https://github.com/googlesamples/android-ScopedDirectoryAccess/#readme)\n- 利用Scoped Directory Access API进入指定的目录,不需要请求权限\n\n#### ScreenCapture ####\n\n- [项目地址](https://github.com/googlesamples/android-ScreenCapture/#readme)\n- 利用Media Projection API,实时截图\n\n#### Sensor-Graph ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/sensor-graph/#readme)\n- 把传感器的变化用图形表示出来.示例读取当前加速度,使用OpenGL画出变化曲线.\n\n#### Simple example of Android Things Native Peripheral I/O APIs ####\n\n- [项目地址](https://github.com/androidthings/sample-nativepio/#readme)\n- C++,使用 Native PIO APIs,示例附加设备的I/O\n\n#### Simple example of Android Things Peripheral I/O APIs ####\n\n- [项目地址](https://github.com/androidthings/sample-simplepio/#readme)\n- 使用 Native PIO APIs,示例附加设备的I/O\n\n#### SkeletonWearableApp ####\n\n- [项目地址](https://github.com/googlesamples/android-SkeletonWearableApp/#readme)\n- 一个大概的app,可用以开始一个可穿戴开发\n\n#### SlidingTabsBasic ####\n\n- [项目地址](https://github.com/googlesamples/android-SlidingTabsBasic/#readme)\n- 基本的左右滑动切换tab页面\n\n#### SlidingTabsColors ####\n\n- [项目地址](https://github.com/googlesamples/android-SlidingTabsColors/#readme)\n- 左右滑动切换tab页面的指示器颜色,文字颜色,分割线颜色\n\n#### SpeedTracker ####\n\n- [项目地址](https://github.com/googlesamples/android-SpeedTracker/#readme)\n- 可穿戴设备记录位置和速度\n\n#### StorageClient ####\n\n- [项目地址](https://github.com/googlesamples/android-StorageClient/#readme)\n- 使用`OPEN_DOCUMENT `意图,一个客户app可以访问设备上的文档提供者的列表,并且从中选择文件.\n\n#### StorageProvider ####\n\n- [项目地址](https://github.com/googlesamples/android-StorageProvider/#readme)\n- 示例实现了一个简单文档提供者\n\n####  SwipeRefreshLayout ####\n\n- [项目地址](https://github.com/googlesamples/android-SwipeRefreshLayoutBasic/#readme)\n- 官方下拉刷新\n\n####  SwipeRefreshListFragment ####\n\n- [项目地址](https://github.com/googlesamples/android-SwipeRefreshListFragment/#readme)\n- 官方下拉刷新fragment\n\n####  SwipeRefreshMultipleViews ####\n\n- [项目地址](https://github.com/googlesamples/android-SwipeRefreshMultipleViews/#readme)\n- 官方下拉刷新多组视图\n\n####  SynchronizedNotifications ####\n\n- [项目地址](https://github.com/googlesamples/android-SynchronizedNotifications/#readme)\n- 同步通知.允许手机和手表上同时关闭.\n\n### T ###\n\n####  TV Leanback Support Library sample ####\n\n- [项目地址](https://github.com/googlesamples/androidtv-Leanback/#readme)\n- `Leanback Support library`祝你完成更好的电视app\n\n####  Teapots ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/teapots/#readme)\n- 通过渲染一个茶壶,展示Android NDK平台的功能\n\n####  TextLinkify ####\n\n- [项目地址](https://github.com/googlesamples/android-TextLinkify/#readme)\n- 如何给TextView添加链接\n\n####  TextSwitcher ####\n\n- [项目地址](https://github.com/googlesamples/android-TextSwitcher/#readme)\n- `TextSwitcher`来展示文字改变的动画\n\n####  Things Bluetooth Audio sample ####\n\n- [项目地址](https://github.com/androidthings/sample-bluetooth-audio/#readme)\n- Android things里,和音频有关的蓝牙api示例.\n\n####  Things Cloud IoT Sensor Hub ####\n\n- [项目地址](https://github.com/androidthings/sensorhub-cloud-iot/#readme)\n- Android things里,实现一个传感器中心,收集传感器数据.上传到Google Cloud.该服务国内不能用.\n\n####  Things Doorbell ####\n\n- [项目地址](https://github.com/androidthings/doorbell/#readme)\n- Android things里,看起来是个门铃实现.\n\n####  Things Simple UI ####\n\n- [项目地址](https://github.com/androidthings/sample-simpleui/#readme)\n- Android things里,一个开关UI\n\n####  Things TensorFlow image classifier sample ####\n\n- [项目地址](https://github.com/androidthings/sample-tensorflow-imageclassifier/#readme)\n- Android things里,当按下GPIO按钮,当前画面被添加的相机捕获.该图片被覆盖和传入TensorFlow模式,识别图片里的是啥.如果有屏幕就展示识别后的最多三个标签,如果有扬声器,那么就说出来.使用的Google服务,国内不能用.\n\n####  Things Weather Station ####\n\n- [项目地址](https://github.com/androidthings/weatherstation/#readme)\n- Android things里,外围多个设备组成一个连接地天气站.\n\n####  Things driver ####\n\n- [项目地址](https://github.com/androidthings/drivers-samples/#readme)\n- Android things里,外围驱动\n\n####  Timer ####\n\n- [项目地址](https://github.com/googlesamples/android-Timer/#readme)\n- 定时器,可不依靠手机独立运行在可穿戴设备上.\n\n####  Topeka ####\n\n- [项目地址](https://github.com/googlesamples/android-topeka/#readme)\n- 一个有趣的小测试题展示材料设计\n\n####  Trivial Drive ####\n\n- [项目地址](https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive/#readme)\n- 开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用\n\n####  Trivial Drive2 ####\n\n- [项目地址](https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive_v2/#readme)\n- 开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用\n\n### U ###\n\n#### UART Loopback sample ####\n\n- [项目地址](https://github.com/androidthings/sample-uartloopback/#readme)\n- Android things里,通过异步收发器,读写数据.\n\n#### USB Enumerator ####\n\n- [项目地址](https://github.com/androidthings/sample-usbenum/#readme)\n- 枚举所有USB设备\n\n#### Universal Android Music Player ####\n\n- [项目地址](https://github.com/googlesamples/android-UniversalMusicPlayer/#readme)\n- 一个音乐播放器,可以在手机,平板,手表,电视,Android Auto(汽车),Google Cast devices这些设备上提供一致的用户体验.\n\n### V ###\n\n#### Vulkan ####\n\n- [项目地址](https://github.com/googlesamples/vulkan-basic-samples/#readme)\n- 一个C++实现的库,渲染3D图形\n\n### W ###\n\n#### WatchFace ####\n\n- [项目地址](https://github.com/googlesamples/android-WatchFace/#readme)\n- 为可穿戴设备创建watch face\n \n#### WearDrawers ####\n\n- [项目地址](https://github.com/googlesamples/android-WearDrawers/#readme)\n- 为可穿戴设备创建导航抽屉\n \n#### WearHighBandwidthNetworking ####\n\n- [项目地址](https://github.com/googlesamples/android-WearHighBandwidthNetworking/#readme)\n- 可穿戴设备的带宽处理最佳实践\n \n#### WEBP Samples ####\n\n- [项目地址](https://github.com/googlesamples/android-ndk/tree/master/webp/#readme)\n- webp,一种google建议的图片格式.\n \n#### WatchViewStub ####\n\n- [项目地址](https://github.com/googlesamples/android-WatchViewStub/#readme)\n- 为圆形,方形的手表指定不同的布局\n \n#### WearComplicationProvidersTestSuite  ####\n\n- [项目地址](https://github.com/googlesamples/android-WearComplicationProvidersTestSuite/#readme)\n- 并发测试套装集合,提供了假数据可以用来测试手表的不同类型渲染.\n \n#### WearNotifications  ####\n\n- [项目地址](https://github.com/googlesamples/android-WearNotifications/#readme)\n- 手机和手表的通知最佳实践.\n \n#### WearSpeakerSample  ####\n\n- [项目地址](https://github.com/googlesamples/android-WearSpeakerSample/#readme)\n- 在可穿戴设备上录音,播音.\n \n#### WearVerifyRemoteApp ####\n\n- [项目地址](https://github.com/googlesamples/android-WearVerifyRemoteApp/#readme)\n- 最佳实践:检测已连接的设备是否从周边的可穿戴设备上安装了你的app.(如果安装了就可以传输数据了)\n\n### X ###\n \n#### XYZTouristAttractions ####\n\n- [项目地址](https://github.com/googlesamples/android-XYZTouristAttractions/#readme)\n- 示例打算尽可能的通过手机和可穿戴设备接近真实实践.巴拉巴拉吹牛逼的话...\n- 示例模拟一个景点,当用户靠近时通知用户\n- GridViewPage展示图片和文字介绍\n\n\n\n\n\n","slug":"android-samples-index","published":1,"updated":"2018-01-18T07:39:02.085Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ki00932sivfb4qnp1x","content":"<p><a href=\"https://developer.android.com/samples/index.html\" target=\"_blank\" rel=\"external\">Google 官方示例</a></p>\n<pre><code>好东西真多.\n因为墙的原因,不可用的也很多.\n如果可以,选择国内类似服务,或者自己模拟搭建服务.\n</code></pre><h3 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h3><h4 id=\"AppShortcuts-快捷方式\"><a href=\"#AppShortcuts-快捷方式\" class=\"headerlink\" title=\"AppShortcuts(快捷方式)\"></a>AppShortcuts(快捷方式)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppShortcuts/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>版本: Android 7.1 (API 25)</li>\n<li>功能简介:<ul>\n<li>长按图标展示一个意图集合</li>\n<li>静态创建和动态创建</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AutofillFramework-自动填充\"><a href=\"#AutofillFramework-自动填充\" class=\"headerlink\" title=\"AutofillFramework(自动填充)\"></a>AutofillFramework(自动填充)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AutofillFramework/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">kotlin-项目地址</a></li>\n<li><a href=\"https://github.com/googlesamples/android-AutofillFramework/#readme\" target=\"_blank\" rel=\"external\">java-项目地址</a></li>\n<li>版本: Android 7.1 (API 25)</li>\n<li>功能简介:<ul>\n<li>少数app会开发该功能</li>\n<li>一般是密码管理器这类的第三方app会开发该服务</li>\n<li>自动填充服务解析客户端的视图层级,找到可以提供数据的自动填充字段,然后发送推荐</li>\n<li>客户端使用一些字段,指定拥有自动填充属性的视图</li>\n<li>示例的数据存在shared preference中,并不安全</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AAudio\"><a href=\"#AAudio\" class=\"headerlink\" title=\"AAudio\"></a>AAudio</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-audio-high-performance/tree/master/aaudio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>大概是个录音和播放的功能</li>\n<li>API (android-26)</li>\n<li>NDK-r15 or above</li>\n</ul>\n<h4 id=\"AsymmetricFingerprintDialog\"><a href=\"#AsymmetricFingerprintDialog\" class=\"headerlink\" title=\"AsymmetricFingerprintDialog\"></a>AsymmetricFingerprintDialog</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AsymmetricFingerprintDialog/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用app中已注册的指纹,授权用户做一些例如充值之类的操作</li>\n<li>Android SDK 26</li>\n</ul>\n<h4 id=\"ActionBarCompat-Basic\"><a href=\"#ActionBarCompat-Basic\" class=\"headerlink\" title=\"ActionBarCompat-Basic\"></a>ActionBarCompat-Basic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-Basic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActionBarCompat-Styled\"><a href=\"#ActionBarCompat-Styled\" class=\"headerlink\" title=\"ActionBarCompat-Styled\"></a>ActionBarCompat-Styled</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-Styled/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActiveNotifications\"><a href=\"#ActiveNotifications\" class=\"headerlink\" title=\"ActiveNotifications\"></a>ActiveNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActiveNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>通知组和通知管理</li>\n</ul>\n<h4 id=\"AccelerometerPlay\"><a href=\"#AccelerometerPlay\" class=\"headerlink\" title=\"AccelerometerPlay\"></a>AccelerometerPlay</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AccelerometerPlay/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>加速度传感器</li>\n</ul>\n<h4 id=\"ActionBarCompat-ListPopupMenu\"><a href=\"#ActionBarCompat-ListPopupMenu\" class=\"headerlink\" title=\"ActionBarCompat-ListPopupMenu\"></a>ActionBarCompat-ListPopupMenu</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActionBarCompat-ShareActionProvider\"><a href=\"#ActionBarCompat-ShareActionProvider\" class=\"headerlink\" title=\"ActionBarCompat-ShareActionProvider\"></a>ActionBarCompat-ShareActionProvider</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActivityInstrumentation\"><a href=\"#ActivityInstrumentation\" class=\"headerlink\" title=\"ActivityInstrumentation\"></a>ActivityInstrumentation</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActivityInstrumentation\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>模拟测试数据</li>\n<li>不需要进去看了,一个spinner展示了一个写死的list</li>\n</ul>\n<h4 id=\"ActivitySceneTransitionBasic\"><a href=\"#ActivitySceneTransitionBasic\" class=\"headerlink\" title=\"ActivitySceneTransitionBasic\"></a>ActivitySceneTransitionBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActivitySceneTransitionBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Activity之间转场动画</li>\n<li>一个场景:新闻列表的图片,进入详情,然后放大,并且带有动画</li>\n</ul>\n<h4 id=\"AdMob-Banner\"><a href=\"#AdMob-Banner\" class=\"headerlink\" title=\"AdMob Banner\"></a>AdMob Banner</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/BannerExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AdMob-Native-Advanced\"><a href=\"#AdMob-Native-Advanced\" class=\"headerlink\" title=\"AdMob Native Advanced\"></a>AdMob Native Advanced</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AdMob-Native-Ads-Express\"><a href=\"#AdMob-Native-Ads-Express\" class=\"headerlink\" title=\"AdMob Native Ads Express\"></a>AdMob Native Ads Express</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AdMob-Interstitial\"><a href=\"#AdMob-Interstitial\" class=\"headerlink\" title=\"AdMob Interstitial\"></a>AdMob Interstitial</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/InterstitialExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"Advanced-API-Demos\"><a href=\"#Advanced-API-Demos\" class=\"headerlink\" title=\"Advanced API Demos\"></a>Advanced API Demos</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/advanced/APIDemo/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AgendaData\"><a href=\"#AgendaData\" class=\"headerlink\" title=\"AgendaData\"></a>AgendaData</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AgendaData/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>同步日程至可穿戴设备示例</li>\n</ul>\n<h4 id=\"AdvancedImmersiveMode\"><a href=\"#AdvancedImmersiveMode\" class=\"headerlink\" title=\"AdvancedImmersiveMode\"></a>AdvancedImmersiveMode</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AdvancedImmersiveMode/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>沉浸模式</li>\n</ul>\n<h4 id=\"AlwaysOn\"><a href=\"#AlwaysOn\" class=\"headerlink\" title=\"AlwaysOn\"></a>AlwaysOn</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AlwaysOn/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备的微光模式-保持设备常亮</li>\n</ul>\n<h4 id=\"AppRestrictionEnforcer\"><a href=\"#AppRestrictionEnforcer\" class=\"headerlink\" title=\"AppRestrictionEnforcer\"></a>AppRestrictionEnforcer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppRestrictionEnforcer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多用户系统中,管理员可以分配不同用户不同的权限</li>\n</ul>\n<h4 id=\"AppRestrictionSchema\"><a href=\"#AppRestrictionSchema\" class=\"headerlink\" title=\"AppRestrictionSchema\"></a>AppRestrictionSchema</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppRestrictionSchema/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多用户系统中,管理员可以分配不同用户不同的权限</li>\n</ul>\n<h4 id=\"AppRestrictions\"><a href=\"#AppRestrictions\" class=\"headerlink\" title=\"AppRestrictions\"></a>AppRestrictions</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppRestrictions/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多用户系统中,管理员可以分配不同用户不同的权限</li>\n</ul>\n<h4 id=\"AppUsageStatistics\"><a href=\"#AppUsageStatistics\" class=\"headerlink\" title=\"AppUsageStatistics\"></a>AppUsageStatistics</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppUsageStatistics/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>管理追踪手机及应用使用情况</li>\n</ul>\n<h4 id=\"Architecture-Components-Basic\"><a href=\"#Architecture-Components-Basic\" class=\"headerlink\" title=\"Architecture Components Basic\"></a>Architecture Components Basic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方MVVM架构</li>\n</ul>\n<h4 id=\"Architecture-Components-Paging\"><a href=\"#Architecture-Components-Paging\" class=\"headerlink\" title=\"Architecture Components Paging\"></a>Architecture Components Paging</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方MVVM架构-分页</li>\n</ul>\n<h4 id=\"Audio-Echo\"><a href=\"#Audio-Echo\" class=\"headerlink\" title=\"Audio-Echo\"></a>Audio-Echo</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/audio-echo/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用OpenSL ES创建音频播放器和记录器,NDK开发</li>\n</ul>\n<h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h3><h4 id=\"BasicNetworking\"><a href=\"#BasicNetworking\" class=\"headerlink\" title=\"BasicNetworking\"></a>BasicNetworking</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicNetworking/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>判断网络状态</li>\n</ul>\n<h4 id=\"BeamLargeFiles\"><a href=\"#BeamLargeFiles\" class=\"headerlink\" title=\"BeamLargeFiles\"></a>BeamLargeFiles</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BeamLargeFiles/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>NFC,通过Android beam 传输大文件</li>\n</ul>\n<h4 id=\"BluetoothAdvertisements\"><a href=\"#BluetoothAdvertisements\" class=\"headerlink\" title=\"BluetoothAdvertisements\"></a>BluetoothAdvertisements</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BluetoothAdvertisements/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>蓝牙,低功耗,传输少量数据</li>\n</ul>\n<h4 id=\"BluetoothLeGatt\"><a href=\"#BluetoothLeGatt\" class=\"headerlink\" title=\"BluetoothLeGatt\"></a>BluetoothLeGatt</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BluetoothLeGatt/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>蓝牙,使用BluetoothLeGatt,传输任意数据</li>\n</ul>\n<h4 id=\"BasicAccessibility\"><a href=\"#BasicAccessibility\" class=\"headerlink\" title=\"BasicAccessibility\"></a>BasicAccessibility</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicAccessibility/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>无障碍-talkback 使用.为盲人或视力不好的提供语音反馈</li>\n</ul>\n<h4 id=\"BasicAndroidKeyStore\"><a href=\"#BasicAndroidKeyStore\" class=\"headerlink\" title=\"BasicAndroidKeyStore\"></a>BasicAndroidKeyStore</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicAndroidKeyStore/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>高级示例展示数据完整性的创建和用例</li>\n<li>创建和存储密钥,只有你的应用可以访问</li>\n<li>理解为公钥私钥那一堆验证即可</li>\n</ul>\n<h4 id=\"BasicContactables\"><a href=\"#BasicContactables\" class=\"headerlink\" title=\"BasicContactables\"></a>BasicContactables</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicContactables/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>搜索框文字匹配联系人</li>\n</ul>\n<h4 id=\"BasicGestureDetect\"><a href=\"#BasicGestureDetect\" class=\"headerlink\" title=\"BasicGestureDetect\"></a>BasicGestureDetect</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicGestureDetect/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>手势监听</li>\n</ul>\n<h4 id=\"BasicImmersiveMode\"><a href=\"#BasicImmersiveMode\" class=\"headerlink\" title=\"BasicImmersiveMode\"></a>BasicImmersiveMode</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicImmersiveMode/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>沉浸式</li>\n</ul>\n<h4 id=\"BasicManagedProfile\"><a href=\"#BasicManagedProfile\" class=\"headerlink\" title=\"BasicManagedProfile\"></a>BasicManagedProfile</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicManagedProfile/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><a href=\"https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html\" target=\"_blank\" rel=\"external\">Managed Profile简介</a></li>\n<li>企业环境中使用私人设备</li>\n</ul>\n<h4 id=\"BasicMediaDecoder\"><a href=\"#BasicMediaDecoder\" class=\"headerlink\" title=\"BasicMediaDecoder\"></a>BasicMediaDecoder</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicManagedProfile/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>配合<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1213/2153.html\" target=\"_blank\" rel=\"external\">TextureView</a>展示视频流</li>\n</ul>\n<h4 id=\"BasicMediaRouter\"><a href=\"#BasicMediaRouter\" class=\"headerlink\" title=\"BasicMediaRouter\"></a>BasicMediaRouter</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicMediaRouter/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>媒体无线投射</li>\n</ul>\n<h4 id=\"BasicMultitouch\"><a href=\"#BasicMultitouch\" class=\"headerlink\" title=\"BasicMultitouch\"></a>BasicMultitouch</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicMultitouch/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多点触控示例</li>\n</ul>\n<h4 id=\"BasicNotifications\"><a href=\"#BasicNotifications\" class=\"headerlink\" title=\"BasicNotifications\"></a>BasicNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的通知事件</li>\n</ul>\n<h4 id=\"BasicRenderScript\"><a href=\"#BasicRenderScript\" class=\"headerlink\" title=\"BasicRenderScript\"></a>BasicRenderScript</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicRenderScript/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的图形渲染脚本演示</li>\n</ul>\n<h4 id=\"BasicSyncAdapter\"><a href=\"#BasicSyncAdapter\" class=\"headerlink\" title=\"BasicSyncAdapter\"></a>BasicSyncAdapter</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicSyncAdapter/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的异步适配器,后台同步数据</li>\n</ul>\n<h4 id=\"BasicTransition\"><a href=\"#BasicTransition\" class=\"headerlink\" title=\"BasicTransition\"></a>BasicTransition</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicTransition/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的transition动画-kitkat</li>\n</ul>\n<h4 id=\"BatchStepSensor\"><a href=\"#BatchStepSensor\" class=\"headerlink\" title=\"BatchStepSensor\"></a>BatchStepSensor</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BatchStepSensor/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>计步传感器</li>\n</ul>\n<h4 id=\"Bitmap-Plasma\"><a href=\"#Bitmap-Plasma\" class=\"headerlink\" title=\"Bitmap Plasma\"></a>Bitmap Plasma</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/bitmap-plasma/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>图片等离子效果</li>\n</ul>\n<h4 id=\"Bluetooth-GATT-Server\"><a href=\"#Bluetooth-GATT-Server\" class=\"headerlink\" title=\"Bluetooth GATT Server\"></a>Bluetooth GATT Server</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-bluetooth-le-gattserver/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android Things应用,访问蓝牙GATT服务通信</li>\n</ul>\n<h4 id=\"BluetoothChat\"><a href=\"#BluetoothChat\" class=\"headerlink\" title=\"BluetoothChat\"></a>BluetoothChat</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BluetoothChat/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>两个设备通过蓝牙实现双向文本会话,全部使用的是基础蓝牙api</li>\n</ul>\n<h4 id=\"BorderlessButtons\"><a href=\"#BorderlessButtons\" class=\"headerlink\" title=\"BorderlessButtons\"></a>BorderlessButtons</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BorderlessButtons/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>holo风格的无边框按钮</li>\n</ul>\n<h4 id=\"Button-and-LED-sample-for-Android-Things\"><a href=\"#Button-and-LED-sample-for-Android-Things\" class=\"headerlink\" title=\"Button and LED sample for Android Things\"></a>Button and LED sample for Android Things</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-button/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things 示例,监听按钮,控制led灯的明灭</li>\n</ul>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h3><h4 id=\"CardView\"><a href=\"#CardView\" class=\"headerlink\" title=\"CardView\"></a>CardView</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CardView/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>理解为圆角layout吧,类似于framelayout,配合recyclerview使用</li>\n</ul>\n<h4 id=\"CommitContentSampleApp\"><a href=\"#CommitContentSampleApp\" class=\"headerlink\" title=\"CommitContentSampleApp\"></a>CommitContentSampleApp</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CommitContentSampleApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>键盘发送富文本</li>\n</ul>\n<h4 id=\"CommitContentSampleIME\"><a href=\"#CommitContentSampleIME\" class=\"headerlink\" title=\"CommitContentSampleIME\"></a>CommitContentSampleIME</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CommitContentSampleIME/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>键盘发送富文本</li>\n</ul>\n<h4 id=\"Camera2Basic\"><a href=\"#Camera2Basic\" class=\"headerlink\" title=\"Camera2Basic\"></a>Camera2Basic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Camera2Basic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Camera2 API基本使用(5.0以后Camera2)</li>\n</ul>\n<h4 id=\"Camera2Raw\"><a href=\"#Camera2Raw\" class=\"headerlink\" title=\"Camera2Raw\"></a>Camera2Raw</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Camera2Raw/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Camera2拍摄RAW格式照片</li>\n</ul>\n<h4 id=\"Camera2Video\"><a href=\"#Camera2Video\" class=\"headerlink\" title=\"Camera2Video\"></a>Camera2Video</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Camera2Video/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Camera2拍摄视频</li>\n</ul>\n<h4 id=\"CardEmulation\"><a href=\"#CardEmulation\" class=\"headerlink\" title=\"CardEmulation\"></a>CardEmulation</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CardEmulation/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>模拟NFC卡</li>\n</ul>\n<h4 id=\"CardReader\"><a href=\"#CardReader\" class=\"headerlink\" title=\"CardReader\"></a>CardReader</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CardReader/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>实现一个低级的NFC读取卡,功能包括是否包含NDEF或Android Beam数据</li>\n</ul>\n<h4 id=\"ClippingBasic\"><a href=\"#ClippingBasic\" class=\"headerlink\" title=\"ClippingBasic\"></a>ClippingBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ClippingBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用ViewOutlineProvider 和给定的图形,裁剪已有的view</li>\n</ul>\n<h4 id=\"Confirm-Credential\"><a href=\"#Confirm-Credential\" class=\"headerlink\" title=\"Confirm Credential\"></a>Confirm Credential</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ConfirmCredential/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>如何使用设备的凭证(PIN码,密码,手势等)认证用户</li>\n</ul>\n<h4 id=\"CustomChoiceList\"><a href=\"#CustomChoiceList\" class=\"headerlink\" title=\"CustomChoiceList\"></a>CustomChoiceList</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CustomChoiceList/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>带有checkbox的listview</li>\n</ul>\n<h4 id=\"CustomNotifications\"><a href=\"#CustomNotifications\" class=\"headerlink\" title=\"CustomNotifications\"></a>CustomNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CustomNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>展示一个带有内容的通知视图,可以扩展和折叠</li>\n</ul>\n<h4 id=\"CustomTransition\"><a href=\"#CustomTransition\" class=\"headerlink\" title=\"CustomTransition\"></a>CustomTransition</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CustomTransition/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>继承标准的transition类来实现一个自定义动画</li>\n</ul>\n<h3 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h3><h4 id=\"DownloadableFonts\"><a href=\"#DownloadableFonts\" class=\"headerlink\" title=\"DownloadableFonts\"></a>DownloadableFonts</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DownloadableFonts/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>字体下载,这样字体不需要放入app的资源文件了,国内没法用</li>\n</ul>\n<h4 id=\"DownloadableFonts-Kotlin\"><a href=\"#DownloadableFonts-Kotlin\" class=\"headerlink\" title=\"DownloadableFonts(Kotlin)\"></a>DownloadableFonts(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DownloadableFonts/tree/master/kotlinApp#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>字体下载,这样字体不需要放入app的资源文件了,国内没法用</li>\n</ul>\n<h4 id=\"DirectBoot\"><a href=\"#DirectBoot\" class=\"headerlink\" title=\"DirectBoot\"></a>DirectBoot</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DirectBoot/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>直接启动模式-当设备已经开机但用户尚未解锁设备时.<ul>\n<li>闹钟,短信,无障碍应用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"DirectShare\"><a href=\"#DirectShare\" class=\"headerlink\" title=\"DirectShare\"></a>DirectShare</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DirectShare/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>系统的内置分享</li>\n</ul>\n<h4 id=\"DocumentCentricRecents\"><a href=\"#DocumentCentricRecents\" class=\"headerlink\" title=\"DocumentCentricRecents\"></a>DocumentCentricRecents</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DocumentCentricApps/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>Document Centric Apps</code>基本用例</li>\n<li>可以令你在系统最近任务中,创建一个新的文档,并且手机重启也会保留其状态</li>\n</ul>\n<h4 id=\"DataLayer\"><a href=\"#DataLayer\" class=\"headerlink\" title=\"DataLayer\"></a>DataLayer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DataLayer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用<code>WearableListenerService</code>,<code>DataLayer</code>,产生和自定义数据事件和高效的工作.</li>\n</ul>\n<h4 id=\"DelayedConfirmation\"><a href=\"#DelayedConfirmation\" class=\"headerlink\" title=\"DelayedConfirmation\"></a>DelayedConfirmation</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DelayedConfirmation/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>在你的穿戴设备上,创建一个可延迟确定的视图.</li>\n</ul>\n<h4 id=\"DeviceOwner\"><a href=\"#DeviceOwner\" class=\"headerlink\" title=\"DeviceOwner\"></a>DeviceOwner</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DeviceOwner/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>该示例展示如何使用设备所有者的所有功能</li>\n</ul>\n<h4 id=\"DirectorySelection\"><a href=\"#DirectorySelection\" class=\"headerlink\" title=\"DirectorySelection\"></a>DirectorySelection</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DirectorySelection/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用目录选择api,可以让用户选择整个目录子树</li>\n</ul>\n<h4 id=\"DisplayingBitmaps\"><a href=\"#DisplayingBitmaps\" class=\"headerlink\" title=\"DisplayingBitmaps\"></a>DisplayingBitmaps</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DisplayingBitmaps/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>非主线程中高效加载大图,缓存图片,管理图片内存,展示图片</li>\n</ul>\n<h4 id=\"DocumentCentricRelinquishIdentity\"><a href=\"#DocumentCentricRelinquishIdentity\" class=\"headerlink\" title=\"DocumentCentricRelinquishIdentity\"></a>DocumentCentricRelinquishIdentity</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DocumentCentricRelinquishIdentity/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用<code>ActivityManager.TaskDescription</code>修改一个activity的特征</li>\n</ul>\n<h4 id=\"DoneBar\"><a href=\"#DoneBar\" class=\"headerlink\" title=\"DoneBar\"></a>DoneBar</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DoneBar/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用2个独立的布局,在ActionBar 上创建自定义已完成按钮</li>\n</ul>\n<h4 id=\"DoubleClick-Banner\"><a href=\"#DoubleClick-Banner\" class=\"headerlink\" title=\"DoubleClick Banner\"></a>DoubleClick Banner</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/doubleclick/BannerExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>双击的广告,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DoubleClick-Custom-Rendering\"><a href=\"#DoubleClick-Custom-Rendering\" class=\"headerlink\" title=\"DoubleClick Custom Rendering\"></a>DoubleClick Custom Rendering</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/doubleclick/CustomRenderingExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>广告相关的,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DoubleClick-For-Publishers-Advanced-Native-Example\"><a href=\"#DoubleClick-For-Publishers-Advanced-Native-Example\" class=\"headerlink\" title=\"DoubleClick For Publishers Advanced Native Example\"></a>DoubleClick For Publishers Advanced Native Example</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/advanced/NativeListViewExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>广告相关的,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DoubleClick-Interstitial-Sample\"><a href=\"#DoubleClick-Interstitial-Sample\" class=\"headerlink\" title=\"DoubleClick Interstitial Sample\"></a>DoubleClick Interstitial Sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/doubleclick/InterstitialExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>广告相关的,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DrawableTinting\"><a href=\"#DrawableTinting\" class=\"headerlink\" title=\"DrawableTinting\"></a>DrawableTinting</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DrawableTinting/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>图片在可用/不可用,获取焦点,按下,选中等等状态时,给其着色.</li>\n</ul>\n<h3 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h3><h4 id=\"EmojiCompat\"><a href=\"#EmojiCompat\" class=\"headerlink\" title=\"EmojiCompat\"></a>EmojiCompat</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-EmojiCompat/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>表情组件,保持最新,防止出现不识别的符号,国内没法用</li>\n</ul>\n<h4 id=\"EmojiCompat-Kotlin\"><a href=\"#EmojiCompat-Kotlin\" class=\"headerlink\" title=\"EmojiCompat(Kotlin)\"></a>EmojiCompat(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-EmojiCompat/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>表情组件,保持最新,防止出现不识别的符号,国内没法用</li>\n</ul>\n<h4 id=\"ElevationBasic\"><a href=\"#ElevationBasic\" class=\"headerlink\" title=\"ElevationBasic\"></a>ElevationBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ElevationBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>操作视图Z轴属性(阴影)</li>\n</ul>\n<h4 id=\"ElevationDrag\"><a href=\"#ElevationDrag\" class=\"headerlink\" title=\"ElevationDrag\"></a>ElevationDrag</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ElevationDrag/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>拖动时,操作视图Z轴属性(阴影)</li>\n</ul>\n<h4 id=\"ElizaChat\"><a href=\"#ElizaChat\" class=\"headerlink\" title=\"ElizaChat\"></a>ElizaChat</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ElizaChat/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>添加扩展到可穿戴设备的通知上.</li>\n</ul>\n<h4 id=\"Endless-Tunnel\"><a href=\"#Endless-Tunnel\" class=\"headerlink\" title=\"Endless Tunnel\"></a>Endless Tunnel</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/endless-tunnel/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个游戏</li>\n<li>使用as c++支持</li>\n<li>使用Android native glue</li>\n<li>实现了joystick 支持</li>\n</ul>\n<h3 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h3><h4 id=\"FingerprintDialog\"><a href=\"#FingerprintDialog\" class=\"headerlink\" title=\"FingerprintDialog\"></a>FingerprintDialog</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-FingerprintDialog/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用app中已注册的指纹,授权用户做一些例如充值之类的操作</li>\n<li>Android SDK 26</li>\n</ul>\n<h4 id=\"Firebase-Quickstarts\"><a href=\"#Firebase-Quickstarts\" class=\"headerlink\" title=\"Firebase Quickstarts\"></a>Firebase Quickstarts</h4><ul>\n<li><a href=\"https://github.com/firebase/quickstart-android/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>firebase快速开始,国内没法用<ul>\n<li>分析app</li>\n<li>开发app</li>\n<li>广告</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"FindMyPhone\"><a href=\"#FindMyPhone\" class=\"headerlink\" title=\"FindMyPhone\"></a>FindMyPhone</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-FindMyPhone/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备失联了,或者还连接着但你的手机找不到了</li>\n</ul>\n<h4 id=\"Flashlight\"><a href=\"#Flashlight\" class=\"headerlink\" title=\"Flashlight\"></a>Flashlight</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Flashlight/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上的一个页面,屏幕展示为一个手电筒(发光)</li>\n</ul>\n<h4 id=\"FloatingActionButtonBasic\"><a href=\"#FloatingActionButtonBasic\" class=\"headerlink\" title=\"FloatingActionButtonBasic\"></a>FloatingActionButtonBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-FloatingActionButtonBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例展示了两个尺寸的Floating Action Buttons,和他们之间的相互作用.</li>\n</ul>\n<h3 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h3><h4 id=\"Geofencing\"><a href=\"#Geofencing\" class=\"headerlink\" title=\"Geofencing\"></a>Geofencing</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Geofencing/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上一个功能,当你出现在某个地方,一个通知静默出现,当你离开,通知消失,应该用的Googlemap,国内有替代品.</li>\n</ul>\n<h4 id=\"Github-Browser-Sample\"><a href=\"#Github-Browser-Sample\" class=\"headerlink\" title=\"Github Browser Sample\"></a>Github Browser Sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room,Lifecycle-aware,ViewModels,LiveData,Paging构成,访问github的框架</li>\n</ul>\n<h4 id=\"Google-Assistant-API-Sample-for-Android-Things\"><a href=\"#Google-Assistant-API-Sample-for-Android-Things\" class=\"headerlink\" title=\"Google Assistant API Sample for Android Things\"></a>Google Assistant API Sample for Android Things</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-googleassistant/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things关于谷歌助手api示例</li>\n</ul>\n<h4 id=\"GridViewPager\"><a href=\"#GridViewPager\" class=\"headerlink\" title=\"GridViewPager\"></a>GridViewPager</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-GridViewPager/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上的GridViewPager</li>\n</ul>\n<h4 id=\"gles3jni\"><a href=\"#gles3jni\" class=\"headerlink\" title=\"gles3jni\"></a>gles3jni</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/gles3jni/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例如何JNI调用<code>OpenGL ES 3.0</code></li>\n</ul>\n<h3 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h3><h4 id=\"HdrViewfinder\"><a href=\"#HdrViewfinder\" class=\"headerlink\" title=\"HdrViewfinder\"></a>HdrViewfinder</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-HdrViewfinder/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>实现了一个实时的高动态范围的相机取景器,</li>\n</ul>\n<h4 id=\"Hello-GL2\"><a href=\"#Hello-GL2\" class=\"headerlink\" title=\"Hello GL2\"></a>Hello GL2</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-gl2/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用GLES 2.0画了一个三角形</li>\n</ul>\n<h4 id=\"Hello-JNI\"><a href=\"#Hello-JNI\" class=\"headerlink\" title=\"Hello JNI\"></a>Hello JNI</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-jni/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Java调用C代码示例</li>\n</ul>\n<h4 id=\"Hello-JNI-Callback\"><a href=\"#Hello-JNI-Callback\" class=\"headerlink\" title=\"Hello JNI Callback\"></a>Hello JNI Callback</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-jniCallback/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Java调用C代码的回调示例</li>\n</ul>\n<h4 id=\"HorizontalPaging\"><a href=\"#HorizontalPaging\" class=\"headerlink\" title=\"HorizontalPaging\"></a>HorizontalPaging</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-HorizontalPaging/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>viewpager + fragment</li>\n</ul>\n<h4 id=\"hello-libs\"><a href=\"#hello-libs\" class=\"headerlink\" title=\"hello-libs\"></a>hello-libs</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-libs/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例展示了在AS中,如何管理第三方C/C++库.</li>\n</ul>\n<h3 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h3><h4 id=\"ImmersiveMode\"><a href=\"#ImmersiveMode\" class=\"headerlink\" title=\"ImmersiveMode\"></a>ImmersiveMode</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ImmersiveMode/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>沉浸模式</li>\n</ul>\n<h4 id=\"Instant-Apps-Cookie-API\"><a href=\"#Instant-Apps-Cookie-API\" class=\"headerlink\" title=\"Instant Apps - Cookie API\"></a>Instant Apps - Cookie API</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/cookie-api/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),8.0及其以上,使用cookie</li>\n</ul>\n<h4 id=\"Instant-Apps-Configuration-APKs\"><a href=\"#Instant-Apps-Configuration-APKs\" class=\"headerlink\" title=\"Instant Apps - Configuration APKs\"></a>Instant Apps - Configuration APKs</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/configuration-apks/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),gradle中配置apk</li>\n</ul>\n<h4 id=\"Instant-Apps-Feature-Module-sample\"><a href=\"#Instant-Apps-Feature-Module-sample\" class=\"headerlink\" title=\"Instant Apps - Feature Module sample\"></a>Instant Apps - Feature Module sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/hello-feature-module/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),功能模块示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Flavors\"><a href=\"#Instant-Apps-Flavors\" class=\"headerlink\" title=\"Instant Apps - Flavors\"></a>Instant Apps - Flavors</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/flavors/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),gradle的flavor示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Google-Analytics\"><a href=\"#Instant-Apps-Google-Analytics\" class=\"headerlink\" title=\"Instant Apps - Google Analytics\"></a>Instant Apps - Google Analytics</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/analytics/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),Google 分析示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Hello-World\"><a href=\"#Instant-Apps-Hello-World\" class=\"headerlink\" title=\"Instant Apps - Hello World\"></a>Instant Apps - Hello World</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/hello-java/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),基本示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Install-API\"><a href=\"#Instant-Apps-Install-API\" class=\"headerlink\" title=\"Instant Apps - Install API\"></a>Instant Apps - Install API</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/install-api/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),安装apk到设备示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Multi-feature\"><a href=\"#Instant-Apps-Multi-feature\" class=\"headerlink\" title=\"Instant Apps - Multi feature\"></a>Instant Apps - Multi feature</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/multi-feature-module/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),示例构建了一个可安装的apk和一个即时app.即时app有2个功能,可以单独的在设备上使用.</li>\n</ul>\n<h4 id=\"Instant-Apps-Service\"><a href=\"#Instant-Apps-Service\" class=\"headerlink\" title=\"Instant Apps - Service\"></a>Instant Apps - Service</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/service/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),instant app如何start或bind一个服务.</li>\n</ul>\n<h4 id=\"Instant-Apps-Storage-API\"><a href=\"#Instant-Apps-Storage-API\" class=\"headerlink\" title=\"Instant Apps - Storage API\"></a>Instant Apps - Storage API</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/storage-api/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),instant app存储的数据,正式安装后的apk转换存储数据使用该api示例.</li>\n</ul>\n<h4 id=\"Interpolator\"><a href=\"#Interpolator\" class=\"headerlink\" title=\"Interpolator\"></a>Interpolator</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Interpolator/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>材料设计的插值动画和路径动画.</li>\n</ul>\n<h3 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h3><h4 id=\"JobScheduler\"><a href=\"#JobScheduler\" class=\"headerlink\" title=\"JobScheduler\"></a>JobScheduler</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-JobScheduler/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>后台任务示例</li>\n</ul>\n<h4 id=\"JumpingJack\"><a href=\"#JumpingJack\" class=\"headerlink\" title=\"JumpingJack\"></a>JumpingJack</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-JumpingJack/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上,通过重力传感器,计算你能<code>开合跳</code>多少下.</li>\n</ul>\n<h3 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h3><h4 id=\"LNotifications\"><a href=\"#LNotifications\" class=\"headerlink\" title=\"LNotifications\"></a>LNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-LNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android 5.0 的新通知.</li>\n</ul>\n<h3 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h3><h4 id=\"MessagingService\"><a href=\"#MessagingService\" class=\"headerlink\" title=\"MessagingService\"></a>MessagingService</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MessagingService/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用gms收发消息,国内没法用</li>\n</ul>\n<h4 id=\"MediaBrowserService\"><a href=\"#MediaBrowserService\" class=\"headerlink\" title=\"MediaBrowserService\"></a>MediaBrowserService</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaBrowserService/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>如何实现一个媒体app后台播放,提供媒体库给别的app</li>\n</ul>\n<h4 id=\"MediaEffects\"><a href=\"#MediaEffects\" class=\"headerlink\" title=\"MediaEffects\"></a>MediaEffects</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaEffects/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>4.0以后的,应用图片效果,像OpenGL ES2.0的 textures一样.</li>\n</ul>\n<h4 id=\"MediaRecorder\"><a href=\"#MediaRecorder\" class=\"headerlink\" title=\"MediaRecorder\"></a>MediaRecorder</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaRecorder/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>api14以前,使用surfaceview,现在使用textureview,通过摄像头拍摄.</li>\n</ul>\n<h4 id=\"MediaRouter\"><a href=\"#MediaRouter\" class=\"headerlink\" title=\"MediaRouter\"></a>MediaRouter</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaRouter/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>自定义媒体无线投射</li>\n</ul>\n<h4 id=\"MidiScope\"><a href=\"#MidiScope\" class=\"headerlink\" title=\"MidiScope\"></a>MidiScope</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MidiScope/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>MIDI(乐器数字接口)api示例,比如:枚举当前可用的MIDI设备,设备的插上和拔下,接收MIDI信号.示例展示了接收到的MIDI信号,但是并没有演奏声音.</li>\n</ul>\n<h4 id=\"MidiSynth\"><a href=\"#MidiSynth\" class=\"headerlink\" title=\"MidiSynth\"></a>MidiSynth</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MidiSynth/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>MIDI(乐器数字接口)api示例,接收和演奏MIDI信号.</li>\n</ul>\n<h4 id=\"MultiWindowPlayground\"><a href=\"#MultiWindowPlayground\" class=\"headerlink\" title=\"MultiWindowPlayground\"></a>MultiWindowPlayground</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MultiWindowPlayground/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android N多窗口示例</li>\n</ul>\n<h3 id=\"N\"><a href=\"#N\" class=\"headerlink\" title=\"N\"></a>N</h3><h4 id=\"Notifications\"><a href=\"#Notifications\" class=\"headerlink\" title=\"Notifications\"></a>Notifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Notifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>手机和可穿戴设备上的通知样式</li>\n</ul>\n<h4 id=\"NotificationChannels\"><a href=\"#NotificationChannels\" class=\"headerlink\" title=\"NotificationChannels\"></a>NotificationChannels</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NotificationChannels/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o 以后,根据主题,分类通知</li>\n</ul>\n<h4 id=\"NotificationChannels-Kotlin\"><a href=\"#NotificationChannels-Kotlin\" class=\"headerlink\" title=\"NotificationChannels(Kotlin)\"></a>NotificationChannels(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NotificationChannels/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o 以后,根据主题,分类通知</li>\n</ul>\n<h4 id=\"Native-Activity\"><a href=\"#Native-Activity\" class=\"headerlink\" title=\"Native Activity\"></a>Native Activity</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/native-activity/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>本地activity,初始化GLES 2.0上下文,从本地C代码中读取加速度传感器数据.</li>\n</ul>\n<h4 id=\"Native-Ads-Express-RecyclerView-Sample\"><a href=\"#Native-Ads-Express-RecyclerView-Sample\" class=\"headerlink\" title=\"Native Ads Express RecyclerView Sample\"></a>Native Ads Express RecyclerView Sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/advanced/NativeExpressRecyclerViewExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>recyclerview列表展示Google 广告,国内没法用</li>\n</ul>\n<h4 id=\"Native-Audio\"><a href=\"#Native-Audio\" class=\"headerlink\" title=\"Native Audio\"></a>Native Audio</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/native-audio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用JNI,调用C++ OpenSLES API,演奏和记录声音</li>\n</ul>\n<h4 id=\"Native-Plasma\"><a href=\"#Native-Plasma\" class=\"headerlink\" title=\"Native Plasma\"></a>Native Plasma</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/native-plasma/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用C代码,在一个图片中渲染等离子效果</li>\n</ul>\n<h4 id=\"Navigation-Drawer\"><a href=\"#Navigation-Drawer\" class=\"headerlink\" title=\"Navigation Drawer\"></a>Navigation Drawer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NavigationDrawer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>侧滑导航普通调用</li>\n</ul>\n<h4 id=\"NetworkConnect\"><a href=\"#NetworkConnect\" class=\"headerlink\" title=\"NetworkConnect\"></a>NetworkConnect</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NetworkConnect/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>AsyncTask + HttpsURLConnection</li>\n</ul>\n<h4 id=\"NfcProvisioning\"><a href=\"#NfcProvisioning\" class=\"headerlink\" title=\"NfcProvisioning\"></a>NfcProvisioning</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NfcProvisioning/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用NFC和设备拥有者提供诶一个新的设备.</li>\n<li>设备拥有者是是特殊的设备管理员,可以控制设备的安全和配置.</li>\n<li>示例本身不是一个设备拥有者,但是他发送了NFC消息给未设置对等设备,并且告诉对方知道设备的拥有者.</li>\n</ul>\n<h4 id=\"NetworkConnect-1\"><a href=\"#NetworkConnect-1\" class=\"headerlink\" title=\"NetworkConnect\"></a>NetworkConnect</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NetworkConnect/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>AsyncTask + HttpsURLConnection</li>\n</ul>\n<h3 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h3><h4 id=\"PictureInPicture\"><a href=\"#PictureInPicture\" class=\"headerlink\" title=\"PictureInPicture\"></a>PictureInPicture</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PictureInPicture/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o,画中画</li>\n</ul>\n<h4 id=\"PictureInPicture-Kotlin\"><a href=\"#PictureInPicture-Kotlin\" class=\"headerlink\" title=\"PictureInPicture(Kotlin)\"></a>PictureInPicture(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PictureInPicture/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o,画中画</li>\n</ul>\n<h4 id=\"PdfRendererBasic\"><a href=\"#PdfRendererBasic\" class=\"headerlink\" title=\"PdfRendererBasic\"></a>PdfRendererBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PdfRendererBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android 5.0,显示PDF</li>\n</ul>\n<h4 id=\"PermissionRequest\"><a href=\"#PermissionRequest\" class=\"headerlink\" title=\"PermissionRequest\"></a>PermissionRequest</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PermissionRequest/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>webview中权限申请</li>\n</ul>\n<h3 id=\"Q\"><a href=\"#Q\" class=\"headerlink\" title=\"Q\"></a>Q</h3><h4 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Quiz/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>webview中权限申请</li>\n</ul>\n<h3 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h3><h4 id=\"RecyclerView\"><a href=\"#RecyclerView\" class=\"headerlink\" title=\"RecyclerView\"></a>RecyclerView</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RecyclerView/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>理解为高级listview</li>\n</ul>\n<h4 id=\"RuntimePermissions\"><a href=\"#RuntimePermissions\" class=\"headerlink\" title=\"RuntimePermissions\"></a>RuntimePermissions</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RuntimePermissions/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android M,运行时权限</li>\n</ul>\n<h4 id=\"RecipeAssistant\"><a href=\"#RecipeAssistant\" class=\"headerlink\" title=\"RecipeAssistant\"></a>RecipeAssistant</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RecipeAssistant/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>加强的通知api,可以发送至可穿戴设备</li>\n</ul>\n<h4 id=\"RenderScriptIntrinsic\"><a href=\"#RenderScriptIntrinsic\" class=\"headerlink\" title=\"RenderScriptIntrinsic\"></a>RenderScriptIntrinsic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RenderScriptIntrinsic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>RenderScript intrinsics</code>使用示例,图片渲染</li>\n</ul>\n<h4 id=\"RepeatingAlarm\"><a href=\"#RepeatingAlarm\" class=\"headerlink\" title=\"RepeatingAlarm\"></a>RepeatingAlarm</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RepeatingAlarm/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个重复的提醒</li>\n</ul>\n<h4 id=\"RevealEffectBasic\"><a href=\"#RevealEffectBasic\" class=\"headerlink\" title=\"RevealEffectBasic\"></a>RevealEffectBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RevealEffectBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>圆形揭露动画,用于按钮点击,页面跳转.点击时,页面出现一个渐变的圆圈.</li>\n</ul>\n<h4 id=\"Room-amp-RxJava\"><a href=\"#Room-amp-RxJava\" class=\"headerlink\" title=\"Room &amp; RxJava\"></a>Room &amp; RxJava</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room 和 RxJava搭配示例</li>\n</ul>\n<h4 id=\"Room-amp-RxJava-Kotlin\"><a href=\"#Room-amp-RxJava-Kotlin\" class=\"headerlink\" title=\"Room &amp; RxJava(Kotlin)\"></a>Room &amp; RxJava(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSampleKotlin/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room 和 RxJava搭配示例</li>\n</ul>\n<h4 id=\"Room-with-Content-Providers\"><a href=\"#Room-with-Content-Providers\" class=\"headerlink\" title=\"Room with Content Providers\"></a>Room with Content Providers</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceContentProviderSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room 和 内容提供者搭配示例</li>\n</ul>\n<h4 id=\"RuntimePermissionsBasic\"><a href=\"#RuntimePermissionsBasic\" class=\"headerlink\" title=\"RuntimePermissionsBasic\"></a>RuntimePermissionsBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RuntimePermissionsBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的运行时权限</li>\n</ul>\n<h4 id=\"RuntimePermissionsWear\"><a href=\"#RuntimePermissionsWear\" class=\"headerlink\" title=\"RuntimePermissionsWear\"></a>RuntimePermissionsWear</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RuntimePermissionsWear/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备的运行时权限</li>\n</ul>\n<h3 id=\"S\"><a href=\"#S\" class=\"headerlink\" title=\"S\"></a>S</h3><h4 id=\"Sample-Android-TV-Channel-App-TV-Input-using-TIF\"><a href=\"#Sample-Android-TV-Channel-App-TV-Input-using-TIF\" class=\"headerlink\" title=\"Sample Android TV Channel App (TV Input) using TIF\"></a>Sample Android TV Channel App (TV Input) using TIF</h4><ul>\n<li><a href=\"https://github.com/googlesamples/androidtv-sample-inputs/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个电视app示例</li>\n</ul>\n<h4 id=\"San-Angeles\"><a href=\"#San-Angeles\" class=\"headerlink\" title=\"San Angeles\"></a>San Angeles</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/san-angeles/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个示例使用 GLES C/API来渲染过程场景</li>\n</ul>\n<h4 id=\"ScopedDirectoryAccess\"><a href=\"#ScopedDirectoryAccess\" class=\"headerlink\" title=\"ScopedDirectoryAccess\"></a>ScopedDirectoryAccess</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ScopedDirectoryAccess/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>利用Scoped Directory Access API进入指定的目录,不需要请求权限</li>\n</ul>\n<h4 id=\"ScreenCapture\"><a href=\"#ScreenCapture\" class=\"headerlink\" title=\"ScreenCapture\"></a>ScreenCapture</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ScreenCapture/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>利用Media Projection API,实时截图</li>\n</ul>\n<h4 id=\"Sensor-Graph\"><a href=\"#Sensor-Graph\" class=\"headerlink\" title=\"Sensor-Graph\"></a>Sensor-Graph</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/sensor-graph/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>把传感器的变化用图形表示出来.示例读取当前加速度,使用OpenGL画出变化曲线.</li>\n</ul>\n<h4 id=\"Simple-example-of-Android-Things-Native-Peripheral-I-O-APIs\"><a href=\"#Simple-example-of-Android-Things-Native-Peripheral-I-O-APIs\" class=\"headerlink\" title=\"Simple example of Android Things Native Peripheral I/O APIs\"></a>Simple example of Android Things Native Peripheral I/O APIs</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-nativepio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>C++,使用 Native PIO APIs,示例附加设备的I/O</li>\n</ul>\n<h4 id=\"Simple-example-of-Android-Things-Peripheral-I-O-APIs\"><a href=\"#Simple-example-of-Android-Things-Peripheral-I-O-APIs\" class=\"headerlink\" title=\"Simple example of Android Things Peripheral I/O APIs\"></a>Simple example of Android Things Peripheral I/O APIs</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-simplepio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用 Native PIO APIs,示例附加设备的I/O</li>\n</ul>\n<h4 id=\"SkeletonWearableApp\"><a href=\"#SkeletonWearableApp\" class=\"headerlink\" title=\"SkeletonWearableApp\"></a>SkeletonWearableApp</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SkeletonWearableApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个大概的app,可用以开始一个可穿戴开发</li>\n</ul>\n<h4 id=\"SlidingTabsBasic\"><a href=\"#SlidingTabsBasic\" class=\"headerlink\" title=\"SlidingTabsBasic\"></a>SlidingTabsBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SlidingTabsBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的左右滑动切换tab页面</li>\n</ul>\n<h4 id=\"SlidingTabsColors\"><a href=\"#SlidingTabsColors\" class=\"headerlink\" title=\"SlidingTabsColors\"></a>SlidingTabsColors</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SlidingTabsColors/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>左右滑动切换tab页面的指示器颜色,文字颜色,分割线颜色</li>\n</ul>\n<h4 id=\"SpeedTracker\"><a href=\"#SpeedTracker\" class=\"headerlink\" title=\"SpeedTracker\"></a>SpeedTracker</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SpeedTracker/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备记录位置和速度</li>\n</ul>\n<h4 id=\"StorageClient\"><a href=\"#StorageClient\" class=\"headerlink\" title=\"StorageClient\"></a>StorageClient</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-StorageClient/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用<code>OPEN_DOCUMENT</code>意图,一个客户app可以访问设备上的文档提供者的列表,并且从中选择文件.</li>\n</ul>\n<h4 id=\"StorageProvider\"><a href=\"#StorageProvider\" class=\"headerlink\" title=\"StorageProvider\"></a>StorageProvider</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-StorageProvider/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例实现了一个简单文档提供者</li>\n</ul>\n<h4 id=\"SwipeRefreshLayout\"><a href=\"#SwipeRefreshLayout\" class=\"headerlink\" title=\"SwipeRefreshLayout\"></a>SwipeRefreshLayout</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SwipeRefreshLayoutBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方下拉刷新</li>\n</ul>\n<h4 id=\"SwipeRefreshListFragment\"><a href=\"#SwipeRefreshListFragment\" class=\"headerlink\" title=\"SwipeRefreshListFragment\"></a>SwipeRefreshListFragment</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SwipeRefreshListFragment/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方下拉刷新fragment</li>\n</ul>\n<h4 id=\"SwipeRefreshMultipleViews\"><a href=\"#SwipeRefreshMultipleViews\" class=\"headerlink\" title=\"SwipeRefreshMultipleViews\"></a>SwipeRefreshMultipleViews</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SwipeRefreshMultipleViews/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方下拉刷新多组视图</li>\n</ul>\n<h4 id=\"SynchronizedNotifications\"><a href=\"#SynchronizedNotifications\" class=\"headerlink\" title=\"SynchronizedNotifications\"></a>SynchronizedNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SynchronizedNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>同步通知.允许手机和手表上同时关闭.</li>\n</ul>\n<h3 id=\"T\"><a href=\"#T\" class=\"headerlink\" title=\"T\"></a>T</h3><h4 id=\"TV-Leanback-Support-Library-sample\"><a href=\"#TV-Leanback-Support-Library-sample\" class=\"headerlink\" title=\"TV Leanback Support Library sample\"></a>TV Leanback Support Library sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/androidtv-Leanback/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>Leanback Support library</code>祝你完成更好的电视app</li>\n</ul>\n<h4 id=\"Teapots\"><a href=\"#Teapots\" class=\"headerlink\" title=\"Teapots\"></a>Teapots</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/teapots/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>通过渲染一个茶壶,展示Android NDK平台的功能</li>\n</ul>\n<h4 id=\"TextLinkify\"><a href=\"#TextLinkify\" class=\"headerlink\" title=\"TextLinkify\"></a>TextLinkify</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-TextLinkify/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>如何给TextView添加链接</li>\n</ul>\n<h4 id=\"TextSwitcher\"><a href=\"#TextSwitcher\" class=\"headerlink\" title=\"TextSwitcher\"></a>TextSwitcher</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-TextSwitcher/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>TextSwitcher</code>来展示文字改变的动画</li>\n</ul>\n<h4 id=\"Things-Bluetooth-Audio-sample\"><a href=\"#Things-Bluetooth-Audio-sample\" class=\"headerlink\" title=\"Things Bluetooth Audio sample\"></a>Things Bluetooth Audio sample</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-bluetooth-audio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,和音频有关的蓝牙api示例.</li>\n</ul>\n<h4 id=\"Things-Cloud-IoT-Sensor-Hub\"><a href=\"#Things-Cloud-IoT-Sensor-Hub\" class=\"headerlink\" title=\"Things Cloud IoT Sensor Hub\"></a>Things Cloud IoT Sensor Hub</h4><ul>\n<li><a href=\"https://github.com/androidthings/sensorhub-cloud-iot/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,实现一个传感器中心,收集传感器数据.上传到Google Cloud.该服务国内不能用.</li>\n</ul>\n<h4 id=\"Things-Doorbell\"><a href=\"#Things-Doorbell\" class=\"headerlink\" title=\"Things Doorbell\"></a>Things Doorbell</h4><ul>\n<li><a href=\"https://github.com/androidthings/doorbell/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,看起来是个门铃实现.</li>\n</ul>\n<h4 id=\"Things-Simple-UI\"><a href=\"#Things-Simple-UI\" class=\"headerlink\" title=\"Things Simple UI\"></a>Things Simple UI</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-simpleui/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,一个开关UI</li>\n</ul>\n<h4 id=\"Things-TensorFlow-image-classifier-sample\"><a href=\"#Things-TensorFlow-image-classifier-sample\" class=\"headerlink\" title=\"Things TensorFlow image classifier sample\"></a>Things TensorFlow image classifier sample</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-tensorflow-imageclassifier/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,当按下GPIO按钮,当前画面被添加的相机捕获.该图片被覆盖和传入TensorFlow模式,识别图片里的是啥.如果有屏幕就展示识别后的最多三个标签,如果有扬声器,那么就说出来.使用的Google服务,国内不能用.</li>\n</ul>\n<h4 id=\"Things-Weather-Station\"><a href=\"#Things-Weather-Station\" class=\"headerlink\" title=\"Things Weather Station\"></a>Things Weather Station</h4><ul>\n<li><a href=\"https://github.com/androidthings/weatherstation/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,外围多个设备组成一个连接地天气站.</li>\n</ul>\n<h4 id=\"Things-driver\"><a href=\"#Things-driver\" class=\"headerlink\" title=\"Things driver\"></a>Things driver</h4><ul>\n<li><a href=\"https://github.com/androidthings/drivers-samples/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,外围驱动</li>\n</ul>\n<h4 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Timer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>定时器,可不依靠手机独立运行在可穿戴设备上.</li>\n</ul>\n<h4 id=\"Topeka\"><a href=\"#Topeka\" class=\"headerlink\" title=\"Topeka\"></a>Topeka</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-topeka/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个有趣的小测试题展示材料设计</li>\n</ul>\n<h4 id=\"Trivial-Drive\"><a href=\"#Trivial-Drive\" class=\"headerlink\" title=\"Trivial Drive\"></a>Trivial Drive</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用</li>\n</ul>\n<h4 id=\"Trivial-Drive2\"><a href=\"#Trivial-Drive2\" class=\"headerlink\" title=\"Trivial Drive2\"></a>Trivial Drive2</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive_v2/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用</li>\n</ul>\n<h3 id=\"U\"><a href=\"#U\" class=\"headerlink\" title=\"U\"></a>U</h3><h4 id=\"UART-Loopback-sample\"><a href=\"#UART-Loopback-sample\" class=\"headerlink\" title=\"UART Loopback sample\"></a>UART Loopback sample</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-uartloopback/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,通过异步收发器,读写数据.</li>\n</ul>\n<h4 id=\"USB-Enumerator\"><a href=\"#USB-Enumerator\" class=\"headerlink\" title=\"USB Enumerator\"></a>USB Enumerator</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-usbenum/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>枚举所有USB设备</li>\n</ul>\n<h4 id=\"Universal-Android-Music-Player\"><a href=\"#Universal-Android-Music-Player\" class=\"headerlink\" title=\"Universal Android Music Player\"></a>Universal Android Music Player</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-UniversalMusicPlayer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个音乐播放器,可以在手机,平板,手表,电视,Android Auto(汽车),Google Cast devices这些设备上提供一致的用户体验.</li>\n</ul>\n<h3 id=\"V\"><a href=\"#V\" class=\"headerlink\" title=\"V\"></a>V</h3><h4 id=\"Vulkan\"><a href=\"#Vulkan\" class=\"headerlink\" title=\"Vulkan\"></a>Vulkan</h4><ul>\n<li><a href=\"https://github.com/googlesamples/vulkan-basic-samples/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个C++实现的库,渲染3D图形</li>\n</ul>\n<h3 id=\"W\"><a href=\"#W\" class=\"headerlink\" title=\"W\"></a>W</h3><h4 id=\"WatchFace\"><a href=\"#WatchFace\" class=\"headerlink\" title=\"WatchFace\"></a>WatchFace</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WatchFace/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>为可穿戴设备创建watch face</li>\n</ul>\n<h4 id=\"WearDrawers\"><a href=\"#WearDrawers\" class=\"headerlink\" title=\"WearDrawers\"></a>WearDrawers</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearDrawers/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>为可穿戴设备创建导航抽屉</li>\n</ul>\n<h4 id=\"WearHighBandwidthNetworking\"><a href=\"#WearHighBandwidthNetworking\" class=\"headerlink\" title=\"WearHighBandwidthNetworking\"></a>WearHighBandwidthNetworking</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearHighBandwidthNetworking/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备的带宽处理最佳实践</li>\n</ul>\n<h4 id=\"WEBP-Samples\"><a href=\"#WEBP-Samples\" class=\"headerlink\" title=\"WEBP Samples\"></a>WEBP Samples</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/webp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>webp,一种google建议的图片格式.</li>\n</ul>\n<h4 id=\"WatchViewStub\"><a href=\"#WatchViewStub\" class=\"headerlink\" title=\"WatchViewStub\"></a>WatchViewStub</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WatchViewStub/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>为圆形,方形的手表指定不同的布局</li>\n</ul>\n<h4 id=\"WearComplicationProvidersTestSuite\"><a href=\"#WearComplicationProvidersTestSuite\" class=\"headerlink\" title=\"WearComplicationProvidersTestSuite\"></a>WearComplicationProvidersTestSuite</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearComplicationProvidersTestSuite/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>并发测试套装集合,提供了假数据可以用来测试手表的不同类型渲染.</li>\n</ul>\n<h4 id=\"WearNotifications\"><a href=\"#WearNotifications\" class=\"headerlink\" title=\"WearNotifications\"></a>WearNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>手机和手表的通知最佳实践.</li>\n</ul>\n<h4 id=\"WearSpeakerSample\"><a href=\"#WearSpeakerSample\" class=\"headerlink\" title=\"WearSpeakerSample\"></a>WearSpeakerSample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearSpeakerSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>在可穿戴设备上录音,播音.</li>\n</ul>\n<h4 id=\"WearVerifyRemoteApp\"><a href=\"#WearVerifyRemoteApp\" class=\"headerlink\" title=\"WearVerifyRemoteApp\"></a>WearVerifyRemoteApp</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearVerifyRemoteApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>最佳实践:检测已连接的设备是否从周边的可穿戴设备上安装了你的app.(如果安装了就可以传输数据了)</li>\n</ul>\n<h3 id=\"X\"><a href=\"#X\" class=\"headerlink\" title=\"X\"></a>X</h3><h4 id=\"XYZTouristAttractions\"><a href=\"#XYZTouristAttractions\" class=\"headerlink\" title=\"XYZTouristAttractions\"></a>XYZTouristAttractions</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-XYZTouristAttractions/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例打算尽可能的通过手机和可穿戴设备接近真实实践.巴拉巴拉吹牛逼的话…</li>\n<li>示例模拟一个景点,当用户靠近时通知用户</li>\n<li>GridViewPage展示图片和文字介绍</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://developer.android.com/samples/index.html\" target=\"_blank\" rel=\"external\">Google 官方示例</a></p>\n<pre><code>好东西真多.\n因为墙的原因,不可用的也很多.\n如果可以,选择国内类似服务,或者自己模拟搭建服务.\n</code></pre><h3 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A\"></a>A</h3><h4 id=\"AppShortcuts-快捷方式\"><a href=\"#AppShortcuts-快捷方式\" class=\"headerlink\" title=\"AppShortcuts(快捷方式)\"></a>AppShortcuts(快捷方式)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppShortcuts/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>版本: Android 7.1 (API 25)</li>\n<li>功能简介:<ul>\n<li>长按图标展示一个意图集合</li>\n<li>静态创建和动态创建</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AutofillFramework-自动填充\"><a href=\"#AutofillFramework-自动填充\" class=\"headerlink\" title=\"AutofillFramework(自动填充)\"></a>AutofillFramework(自动填充)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AutofillFramework/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">kotlin-项目地址</a></li>\n<li><a href=\"https://github.com/googlesamples/android-AutofillFramework/#readme\" target=\"_blank\" rel=\"external\">java-项目地址</a></li>\n<li>版本: Android 7.1 (API 25)</li>\n<li>功能简介:<ul>\n<li>少数app会开发该功能</li>\n<li>一般是密码管理器这类的第三方app会开发该服务</li>\n<li>自动填充服务解析客户端的视图层级,找到可以提供数据的自动填充字段,然后发送推荐</li>\n<li>客户端使用一些字段,指定拥有自动填充属性的视图</li>\n<li>示例的数据存在shared preference中,并不安全</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"AAudio\"><a href=\"#AAudio\" class=\"headerlink\" title=\"AAudio\"></a>AAudio</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-audio-high-performance/tree/master/aaudio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>大概是个录音和播放的功能</li>\n<li>API (android-26)</li>\n<li>NDK-r15 or above</li>\n</ul>\n<h4 id=\"AsymmetricFingerprintDialog\"><a href=\"#AsymmetricFingerprintDialog\" class=\"headerlink\" title=\"AsymmetricFingerprintDialog\"></a>AsymmetricFingerprintDialog</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AsymmetricFingerprintDialog/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用app中已注册的指纹,授权用户做一些例如充值之类的操作</li>\n<li>Android SDK 26</li>\n</ul>\n<h4 id=\"ActionBarCompat-Basic\"><a href=\"#ActionBarCompat-Basic\" class=\"headerlink\" title=\"ActionBarCompat-Basic\"></a>ActionBarCompat-Basic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-Basic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActionBarCompat-Styled\"><a href=\"#ActionBarCompat-Styled\" class=\"headerlink\" title=\"ActionBarCompat-Styled\"></a>ActionBarCompat-Styled</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-Styled/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActiveNotifications\"><a href=\"#ActiveNotifications\" class=\"headerlink\" title=\"ActiveNotifications\"></a>ActiveNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActiveNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>通知组和通知管理</li>\n</ul>\n<h4 id=\"AccelerometerPlay\"><a href=\"#AccelerometerPlay\" class=\"headerlink\" title=\"AccelerometerPlay\"></a>AccelerometerPlay</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AccelerometerPlay/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>加速度传感器</li>\n</ul>\n<h4 id=\"ActionBarCompat-ListPopupMenu\"><a href=\"#ActionBarCompat-ListPopupMenu\" class=\"headerlink\" title=\"ActionBarCompat-ListPopupMenu\"></a>ActionBarCompat-ListPopupMenu</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActionBarCompat-ShareActionProvider\"><a href=\"#ActionBarCompat-ShareActionProvider\" class=\"headerlink\" title=\"ActionBarCompat-ShareActionProvider\"></a>ActionBarCompat-ShareActionProvider</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActionBarCompat-ListPopupMenu/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>ActionBar组件使用,现在应该都开始用toolbar了吧</li>\n</ul>\n<h4 id=\"ActivityInstrumentation\"><a href=\"#ActivityInstrumentation\" class=\"headerlink\" title=\"ActivityInstrumentation\"></a>ActivityInstrumentation</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActivityInstrumentation\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>模拟测试数据</li>\n<li>不需要进去看了,一个spinner展示了一个写死的list</li>\n</ul>\n<h4 id=\"ActivitySceneTransitionBasic\"><a href=\"#ActivitySceneTransitionBasic\" class=\"headerlink\" title=\"ActivitySceneTransitionBasic\"></a>ActivitySceneTransitionBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ActivitySceneTransitionBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Activity之间转场动画</li>\n<li>一个场景:新闻列表的图片,进入详情,然后放大,并且带有动画</li>\n</ul>\n<h4 id=\"AdMob-Banner\"><a href=\"#AdMob-Banner\" class=\"headerlink\" title=\"AdMob Banner\"></a>AdMob Banner</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/BannerExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AdMob-Native-Advanced\"><a href=\"#AdMob-Native-Advanced\" class=\"headerlink\" title=\"AdMob Native Advanced\"></a>AdMob Native Advanced</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AdMob-Native-Ads-Express\"><a href=\"#AdMob-Native-Ads-Express\" class=\"headerlink\" title=\"AdMob Native Ads Express\"></a>AdMob Native Ads Express</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/NativeAdvancedExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AdMob-Interstitial\"><a href=\"#AdMob-Interstitial\" class=\"headerlink\" title=\"AdMob Interstitial\"></a>AdMob Interstitial</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/admob/InterstitialExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"Advanced-API-Demos\"><a href=\"#Advanced-API-Demos\" class=\"headerlink\" title=\"Advanced API Demos\"></a>Advanced API Demos</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/advanced/APIDemo/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>app内置广告api调用,国内应该有类似</li>\n</ul>\n<h4 id=\"AgendaData\"><a href=\"#AgendaData\" class=\"headerlink\" title=\"AgendaData\"></a>AgendaData</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AgendaData/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>同步日程至可穿戴设备示例</li>\n</ul>\n<h4 id=\"AdvancedImmersiveMode\"><a href=\"#AdvancedImmersiveMode\" class=\"headerlink\" title=\"AdvancedImmersiveMode\"></a>AdvancedImmersiveMode</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AdvancedImmersiveMode/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>沉浸模式</li>\n</ul>\n<h4 id=\"AlwaysOn\"><a href=\"#AlwaysOn\" class=\"headerlink\" title=\"AlwaysOn\"></a>AlwaysOn</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AlwaysOn/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备的微光模式-保持设备常亮</li>\n</ul>\n<h4 id=\"AppRestrictionEnforcer\"><a href=\"#AppRestrictionEnforcer\" class=\"headerlink\" title=\"AppRestrictionEnforcer\"></a>AppRestrictionEnforcer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppRestrictionEnforcer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多用户系统中,管理员可以分配不同用户不同的权限</li>\n</ul>\n<h4 id=\"AppRestrictionSchema\"><a href=\"#AppRestrictionSchema\" class=\"headerlink\" title=\"AppRestrictionSchema\"></a>AppRestrictionSchema</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppRestrictionSchema/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多用户系统中,管理员可以分配不同用户不同的权限</li>\n</ul>\n<h4 id=\"AppRestrictions\"><a href=\"#AppRestrictions\" class=\"headerlink\" title=\"AppRestrictions\"></a>AppRestrictions</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppRestrictions/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多用户系统中,管理员可以分配不同用户不同的权限</li>\n</ul>\n<h4 id=\"AppUsageStatistics\"><a href=\"#AppUsageStatistics\" class=\"headerlink\" title=\"AppUsageStatistics\"></a>AppUsageStatistics</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-AppUsageStatistics/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>管理追踪手机及应用使用情况</li>\n</ul>\n<h4 id=\"Architecture-Components-Basic\"><a href=\"#Architecture-Components-Basic\" class=\"headerlink\" title=\"Architecture Components Basic\"></a>Architecture Components Basic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方MVVM架构</li>\n</ul>\n<h4 id=\"Architecture-Components-Paging\"><a href=\"#Architecture-Components-Paging\" class=\"headerlink\" title=\"Architecture Components Paging\"></a>Architecture Components Paging</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方MVVM架构-分页</li>\n</ul>\n<h4 id=\"Audio-Echo\"><a href=\"#Audio-Echo\" class=\"headerlink\" title=\"Audio-Echo\"></a>Audio-Echo</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/audio-echo/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用OpenSL ES创建音频播放器和记录器,NDK开发</li>\n</ul>\n<h3 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h3><h4 id=\"BasicNetworking\"><a href=\"#BasicNetworking\" class=\"headerlink\" title=\"BasicNetworking\"></a>BasicNetworking</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicNetworking/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>判断网络状态</li>\n</ul>\n<h4 id=\"BeamLargeFiles\"><a href=\"#BeamLargeFiles\" class=\"headerlink\" title=\"BeamLargeFiles\"></a>BeamLargeFiles</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BeamLargeFiles/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>NFC,通过Android beam 传输大文件</li>\n</ul>\n<h4 id=\"BluetoothAdvertisements\"><a href=\"#BluetoothAdvertisements\" class=\"headerlink\" title=\"BluetoothAdvertisements\"></a>BluetoothAdvertisements</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BluetoothAdvertisements/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>蓝牙,低功耗,传输少量数据</li>\n</ul>\n<h4 id=\"BluetoothLeGatt\"><a href=\"#BluetoothLeGatt\" class=\"headerlink\" title=\"BluetoothLeGatt\"></a>BluetoothLeGatt</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BluetoothLeGatt/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>蓝牙,使用BluetoothLeGatt,传输任意数据</li>\n</ul>\n<h4 id=\"BasicAccessibility\"><a href=\"#BasicAccessibility\" class=\"headerlink\" title=\"BasicAccessibility\"></a>BasicAccessibility</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicAccessibility/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>无障碍-talkback 使用.为盲人或视力不好的提供语音反馈</li>\n</ul>\n<h4 id=\"BasicAndroidKeyStore\"><a href=\"#BasicAndroidKeyStore\" class=\"headerlink\" title=\"BasicAndroidKeyStore\"></a>BasicAndroidKeyStore</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicAndroidKeyStore/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>高级示例展示数据完整性的创建和用例</li>\n<li>创建和存储密钥,只有你的应用可以访问</li>\n<li>理解为公钥私钥那一堆验证即可</li>\n</ul>\n<h4 id=\"BasicContactables\"><a href=\"#BasicContactables\" class=\"headerlink\" title=\"BasicContactables\"></a>BasicContactables</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicContactables/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>搜索框文字匹配联系人</li>\n</ul>\n<h4 id=\"BasicGestureDetect\"><a href=\"#BasicGestureDetect\" class=\"headerlink\" title=\"BasicGestureDetect\"></a>BasicGestureDetect</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicGestureDetect/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>手势监听</li>\n</ul>\n<h4 id=\"BasicImmersiveMode\"><a href=\"#BasicImmersiveMode\" class=\"headerlink\" title=\"BasicImmersiveMode\"></a>BasicImmersiveMode</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicImmersiveMode/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>沉浸式</li>\n</ul>\n<h4 id=\"BasicManagedProfile\"><a href=\"#BasicManagedProfile\" class=\"headerlink\" title=\"BasicManagedProfile\"></a>BasicManagedProfile</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicManagedProfile/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><a href=\"https://www.w3cschool.cn/android_training_course/android_training_course-t3xv27in.html\" target=\"_blank\" rel=\"external\">Managed Profile简介</a></li>\n<li>企业环境中使用私人设备</li>\n</ul>\n<h4 id=\"BasicMediaDecoder\"><a href=\"#BasicMediaDecoder\" class=\"headerlink\" title=\"BasicMediaDecoder\"></a>BasicMediaDecoder</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicManagedProfile/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>配合<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1213/2153.html\" target=\"_blank\" rel=\"external\">TextureView</a>展示视频流</li>\n</ul>\n<h4 id=\"BasicMediaRouter\"><a href=\"#BasicMediaRouter\" class=\"headerlink\" title=\"BasicMediaRouter\"></a>BasicMediaRouter</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicMediaRouter/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>媒体无线投射</li>\n</ul>\n<h4 id=\"BasicMultitouch\"><a href=\"#BasicMultitouch\" class=\"headerlink\" title=\"BasicMultitouch\"></a>BasicMultitouch</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicMultitouch/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>多点触控示例</li>\n</ul>\n<h4 id=\"BasicNotifications\"><a href=\"#BasicNotifications\" class=\"headerlink\" title=\"BasicNotifications\"></a>BasicNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的通知事件</li>\n</ul>\n<h4 id=\"BasicRenderScript\"><a href=\"#BasicRenderScript\" class=\"headerlink\" title=\"BasicRenderScript\"></a>BasicRenderScript</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicRenderScript/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的图形渲染脚本演示</li>\n</ul>\n<h4 id=\"BasicSyncAdapter\"><a href=\"#BasicSyncAdapter\" class=\"headerlink\" title=\"BasicSyncAdapter\"></a>BasicSyncAdapter</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicSyncAdapter/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的异步适配器,后台同步数据</li>\n</ul>\n<h4 id=\"BasicTransition\"><a href=\"#BasicTransition\" class=\"headerlink\" title=\"BasicTransition\"></a>BasicTransition</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BasicTransition/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的transition动画-kitkat</li>\n</ul>\n<h4 id=\"BatchStepSensor\"><a href=\"#BatchStepSensor\" class=\"headerlink\" title=\"BatchStepSensor\"></a>BatchStepSensor</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BatchStepSensor/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>计步传感器</li>\n</ul>\n<h4 id=\"Bitmap-Plasma\"><a href=\"#Bitmap-Plasma\" class=\"headerlink\" title=\"Bitmap Plasma\"></a>Bitmap Plasma</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/bitmap-plasma/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>图片等离子效果</li>\n</ul>\n<h4 id=\"Bluetooth-GATT-Server\"><a href=\"#Bluetooth-GATT-Server\" class=\"headerlink\" title=\"Bluetooth GATT Server\"></a>Bluetooth GATT Server</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-bluetooth-le-gattserver/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android Things应用,访问蓝牙GATT服务通信</li>\n</ul>\n<h4 id=\"BluetoothChat\"><a href=\"#BluetoothChat\" class=\"headerlink\" title=\"BluetoothChat\"></a>BluetoothChat</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BluetoothChat/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>两个设备通过蓝牙实现双向文本会话,全部使用的是基础蓝牙api</li>\n</ul>\n<h4 id=\"BorderlessButtons\"><a href=\"#BorderlessButtons\" class=\"headerlink\" title=\"BorderlessButtons\"></a>BorderlessButtons</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-BorderlessButtons/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>holo风格的无边框按钮</li>\n</ul>\n<h4 id=\"Button-and-LED-sample-for-Android-Things\"><a href=\"#Button-and-LED-sample-for-Android-Things\" class=\"headerlink\" title=\"Button and LED sample for Android Things\"></a>Button and LED sample for Android Things</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-button/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things 示例,监听按钮,控制led灯的明灭</li>\n</ul>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h3><h4 id=\"CardView\"><a href=\"#CardView\" class=\"headerlink\" title=\"CardView\"></a>CardView</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CardView/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>理解为圆角layout吧,类似于framelayout,配合recyclerview使用</li>\n</ul>\n<h4 id=\"CommitContentSampleApp\"><a href=\"#CommitContentSampleApp\" class=\"headerlink\" title=\"CommitContentSampleApp\"></a>CommitContentSampleApp</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CommitContentSampleApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>键盘发送富文本</li>\n</ul>\n<h4 id=\"CommitContentSampleIME\"><a href=\"#CommitContentSampleIME\" class=\"headerlink\" title=\"CommitContentSampleIME\"></a>CommitContentSampleIME</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CommitContentSampleIME/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>键盘发送富文本</li>\n</ul>\n<h4 id=\"Camera2Basic\"><a href=\"#Camera2Basic\" class=\"headerlink\" title=\"Camera2Basic\"></a>Camera2Basic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Camera2Basic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Camera2 API基本使用(5.0以后Camera2)</li>\n</ul>\n<h4 id=\"Camera2Raw\"><a href=\"#Camera2Raw\" class=\"headerlink\" title=\"Camera2Raw\"></a>Camera2Raw</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Camera2Raw/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Camera2拍摄RAW格式照片</li>\n</ul>\n<h4 id=\"Camera2Video\"><a href=\"#Camera2Video\" class=\"headerlink\" title=\"Camera2Video\"></a>Camera2Video</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Camera2Video/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Camera2拍摄视频</li>\n</ul>\n<h4 id=\"CardEmulation\"><a href=\"#CardEmulation\" class=\"headerlink\" title=\"CardEmulation\"></a>CardEmulation</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CardEmulation/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>模拟NFC卡</li>\n</ul>\n<h4 id=\"CardReader\"><a href=\"#CardReader\" class=\"headerlink\" title=\"CardReader\"></a>CardReader</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CardReader/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>实现一个低级的NFC读取卡,功能包括是否包含NDEF或Android Beam数据</li>\n</ul>\n<h4 id=\"ClippingBasic\"><a href=\"#ClippingBasic\" class=\"headerlink\" title=\"ClippingBasic\"></a>ClippingBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ClippingBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用ViewOutlineProvider 和给定的图形,裁剪已有的view</li>\n</ul>\n<h4 id=\"Confirm-Credential\"><a href=\"#Confirm-Credential\" class=\"headerlink\" title=\"Confirm Credential\"></a>Confirm Credential</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ConfirmCredential/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>如何使用设备的凭证(PIN码,密码,手势等)认证用户</li>\n</ul>\n<h4 id=\"CustomChoiceList\"><a href=\"#CustomChoiceList\" class=\"headerlink\" title=\"CustomChoiceList\"></a>CustomChoiceList</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CustomChoiceList/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>带有checkbox的listview</li>\n</ul>\n<h4 id=\"CustomNotifications\"><a href=\"#CustomNotifications\" class=\"headerlink\" title=\"CustomNotifications\"></a>CustomNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CustomNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>展示一个带有内容的通知视图,可以扩展和折叠</li>\n</ul>\n<h4 id=\"CustomTransition\"><a href=\"#CustomTransition\" class=\"headerlink\" title=\"CustomTransition\"></a>CustomTransition</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-CustomTransition/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>继承标准的transition类来实现一个自定义动画</li>\n</ul>\n<h3 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h3><h4 id=\"DownloadableFonts\"><a href=\"#DownloadableFonts\" class=\"headerlink\" title=\"DownloadableFonts\"></a>DownloadableFonts</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DownloadableFonts/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>字体下载,这样字体不需要放入app的资源文件了,国内没法用</li>\n</ul>\n<h4 id=\"DownloadableFonts-Kotlin\"><a href=\"#DownloadableFonts-Kotlin\" class=\"headerlink\" title=\"DownloadableFonts(Kotlin)\"></a>DownloadableFonts(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DownloadableFonts/tree/master/kotlinApp#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>字体下载,这样字体不需要放入app的资源文件了,国内没法用</li>\n</ul>\n<h4 id=\"DirectBoot\"><a href=\"#DirectBoot\" class=\"headerlink\" title=\"DirectBoot\"></a>DirectBoot</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DirectBoot/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>直接启动模式-当设备已经开机但用户尚未解锁设备时.<ul>\n<li>闹钟,短信,无障碍应用</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"DirectShare\"><a href=\"#DirectShare\" class=\"headerlink\" title=\"DirectShare\"></a>DirectShare</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DirectShare/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>系统的内置分享</li>\n</ul>\n<h4 id=\"DocumentCentricRecents\"><a href=\"#DocumentCentricRecents\" class=\"headerlink\" title=\"DocumentCentricRecents\"></a>DocumentCentricRecents</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DocumentCentricApps/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>Document Centric Apps</code>基本用例</li>\n<li>可以令你在系统最近任务中,创建一个新的文档,并且手机重启也会保留其状态</li>\n</ul>\n<h4 id=\"DataLayer\"><a href=\"#DataLayer\" class=\"headerlink\" title=\"DataLayer\"></a>DataLayer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DataLayer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用<code>WearableListenerService</code>,<code>DataLayer</code>,产生和自定义数据事件和高效的工作.</li>\n</ul>\n<h4 id=\"DelayedConfirmation\"><a href=\"#DelayedConfirmation\" class=\"headerlink\" title=\"DelayedConfirmation\"></a>DelayedConfirmation</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DelayedConfirmation/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>在你的穿戴设备上,创建一个可延迟确定的视图.</li>\n</ul>\n<h4 id=\"DeviceOwner\"><a href=\"#DeviceOwner\" class=\"headerlink\" title=\"DeviceOwner\"></a>DeviceOwner</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DeviceOwner/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>该示例展示如何使用设备所有者的所有功能</li>\n</ul>\n<h4 id=\"DirectorySelection\"><a href=\"#DirectorySelection\" class=\"headerlink\" title=\"DirectorySelection\"></a>DirectorySelection</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DirectorySelection/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用目录选择api,可以让用户选择整个目录子树</li>\n</ul>\n<h4 id=\"DisplayingBitmaps\"><a href=\"#DisplayingBitmaps\" class=\"headerlink\" title=\"DisplayingBitmaps\"></a>DisplayingBitmaps</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DisplayingBitmaps/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>非主线程中高效加载大图,缓存图片,管理图片内存,展示图片</li>\n</ul>\n<h4 id=\"DocumentCentricRelinquishIdentity\"><a href=\"#DocumentCentricRelinquishIdentity\" class=\"headerlink\" title=\"DocumentCentricRelinquishIdentity\"></a>DocumentCentricRelinquishIdentity</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DocumentCentricRelinquishIdentity/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用<code>ActivityManager.TaskDescription</code>修改一个activity的特征</li>\n</ul>\n<h4 id=\"DoneBar\"><a href=\"#DoneBar\" class=\"headerlink\" title=\"DoneBar\"></a>DoneBar</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DoneBar/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用2个独立的布局,在ActionBar 上创建自定义已完成按钮</li>\n</ul>\n<h4 id=\"DoubleClick-Banner\"><a href=\"#DoubleClick-Banner\" class=\"headerlink\" title=\"DoubleClick Banner\"></a>DoubleClick Banner</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/doubleclick/BannerExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>双击的广告,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DoubleClick-Custom-Rendering\"><a href=\"#DoubleClick-Custom-Rendering\" class=\"headerlink\" title=\"DoubleClick Custom Rendering\"></a>DoubleClick Custom Rendering</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/doubleclick/CustomRenderingExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>广告相关的,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DoubleClick-For-Publishers-Advanced-Native-Example\"><a href=\"#DoubleClick-For-Publishers-Advanced-Native-Example\" class=\"headerlink\" title=\"DoubleClick For Publishers Advanced Native Example\"></a>DoubleClick For Publishers Advanced Native Example</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/advanced/NativeListViewExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>广告相关的,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DoubleClick-Interstitial-Sample\"><a href=\"#DoubleClick-Interstitial-Sample\" class=\"headerlink\" title=\"DoubleClick Interstitial Sample\"></a>DoubleClick Interstitial Sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/doubleclick/InterstitialExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>广告相关的,应该基于Google ad的,国内没法用的.</li>\n</ul>\n<h4 id=\"DrawableTinting\"><a href=\"#DrawableTinting\" class=\"headerlink\" title=\"DrawableTinting\"></a>DrawableTinting</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-DrawableTinting/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>图片在可用/不可用,获取焦点,按下,选中等等状态时,给其着色.</li>\n</ul>\n<h3 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h3><h4 id=\"EmojiCompat\"><a href=\"#EmojiCompat\" class=\"headerlink\" title=\"EmojiCompat\"></a>EmojiCompat</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-EmojiCompat/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>表情组件,保持最新,防止出现不识别的符号,国内没法用</li>\n</ul>\n<h4 id=\"EmojiCompat-Kotlin\"><a href=\"#EmojiCompat-Kotlin\" class=\"headerlink\" title=\"EmojiCompat(Kotlin)\"></a>EmojiCompat(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-EmojiCompat/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>表情组件,保持最新,防止出现不识别的符号,国内没法用</li>\n</ul>\n<h4 id=\"ElevationBasic\"><a href=\"#ElevationBasic\" class=\"headerlink\" title=\"ElevationBasic\"></a>ElevationBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ElevationBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>操作视图Z轴属性(阴影)</li>\n</ul>\n<h4 id=\"ElevationDrag\"><a href=\"#ElevationDrag\" class=\"headerlink\" title=\"ElevationDrag\"></a>ElevationDrag</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ElevationDrag/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>拖动时,操作视图Z轴属性(阴影)</li>\n</ul>\n<h4 id=\"ElizaChat\"><a href=\"#ElizaChat\" class=\"headerlink\" title=\"ElizaChat\"></a>ElizaChat</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ElizaChat/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>添加扩展到可穿戴设备的通知上.</li>\n</ul>\n<h4 id=\"Endless-Tunnel\"><a href=\"#Endless-Tunnel\" class=\"headerlink\" title=\"Endless Tunnel\"></a>Endless Tunnel</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/endless-tunnel/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个游戏</li>\n<li>使用as c++支持</li>\n<li>使用Android native glue</li>\n<li>实现了joystick 支持</li>\n</ul>\n<h3 id=\"F\"><a href=\"#F\" class=\"headerlink\" title=\"F\"></a>F</h3><h4 id=\"FingerprintDialog\"><a href=\"#FingerprintDialog\" class=\"headerlink\" title=\"FingerprintDialog\"></a>FingerprintDialog</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-FingerprintDialog/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用app中已注册的指纹,授权用户做一些例如充值之类的操作</li>\n<li>Android SDK 26</li>\n</ul>\n<h4 id=\"Firebase-Quickstarts\"><a href=\"#Firebase-Quickstarts\" class=\"headerlink\" title=\"Firebase Quickstarts\"></a>Firebase Quickstarts</h4><ul>\n<li><a href=\"https://github.com/firebase/quickstart-android/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>firebase快速开始,国内没法用<ul>\n<li>分析app</li>\n<li>开发app</li>\n<li>广告</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"FindMyPhone\"><a href=\"#FindMyPhone\" class=\"headerlink\" title=\"FindMyPhone\"></a>FindMyPhone</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-FindMyPhone/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备失联了,或者还连接着但你的手机找不到了</li>\n</ul>\n<h4 id=\"Flashlight\"><a href=\"#Flashlight\" class=\"headerlink\" title=\"Flashlight\"></a>Flashlight</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Flashlight/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上的一个页面,屏幕展示为一个手电筒(发光)</li>\n</ul>\n<h4 id=\"FloatingActionButtonBasic\"><a href=\"#FloatingActionButtonBasic\" class=\"headerlink\" title=\"FloatingActionButtonBasic\"></a>FloatingActionButtonBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-FloatingActionButtonBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例展示了两个尺寸的Floating Action Buttons,和他们之间的相互作用.</li>\n</ul>\n<h3 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h3><h4 id=\"Geofencing\"><a href=\"#Geofencing\" class=\"headerlink\" title=\"Geofencing\"></a>Geofencing</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Geofencing/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上一个功能,当你出现在某个地方,一个通知静默出现,当你离开,通知消失,应该用的Googlemap,国内有替代品.</li>\n</ul>\n<h4 id=\"Github-Browser-Sample\"><a href=\"#Github-Browser-Sample\" class=\"headerlink\" title=\"Github Browser Sample\"></a>Github Browser Sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room,Lifecycle-aware,ViewModels,LiveData,Paging构成,访问github的框架</li>\n</ul>\n<h4 id=\"Google-Assistant-API-Sample-for-Android-Things\"><a href=\"#Google-Assistant-API-Sample-for-Android-Things\" class=\"headerlink\" title=\"Google Assistant API Sample for Android Things\"></a>Google Assistant API Sample for Android Things</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-googleassistant/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things关于谷歌助手api示例</li>\n</ul>\n<h4 id=\"GridViewPager\"><a href=\"#GridViewPager\" class=\"headerlink\" title=\"GridViewPager\"></a>GridViewPager</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-GridViewPager/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上的GridViewPager</li>\n</ul>\n<h4 id=\"gles3jni\"><a href=\"#gles3jni\" class=\"headerlink\" title=\"gles3jni\"></a>gles3jni</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/gles3jni/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例如何JNI调用<code>OpenGL ES 3.0</code></li>\n</ul>\n<h3 id=\"H\"><a href=\"#H\" class=\"headerlink\" title=\"H\"></a>H</h3><h4 id=\"HdrViewfinder\"><a href=\"#HdrViewfinder\" class=\"headerlink\" title=\"HdrViewfinder\"></a>HdrViewfinder</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-HdrViewfinder/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>实现了一个实时的高动态范围的相机取景器,</li>\n</ul>\n<h4 id=\"Hello-GL2\"><a href=\"#Hello-GL2\" class=\"headerlink\" title=\"Hello GL2\"></a>Hello GL2</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-gl2/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用GLES 2.0画了一个三角形</li>\n</ul>\n<h4 id=\"Hello-JNI\"><a href=\"#Hello-JNI\" class=\"headerlink\" title=\"Hello JNI\"></a>Hello JNI</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-jni/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Java调用C代码示例</li>\n</ul>\n<h4 id=\"Hello-JNI-Callback\"><a href=\"#Hello-JNI-Callback\" class=\"headerlink\" title=\"Hello JNI Callback\"></a>Hello JNI Callback</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-jniCallback/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Java调用C代码的回调示例</li>\n</ul>\n<h4 id=\"HorizontalPaging\"><a href=\"#HorizontalPaging\" class=\"headerlink\" title=\"HorizontalPaging\"></a>HorizontalPaging</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-HorizontalPaging/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>viewpager + fragment</li>\n</ul>\n<h4 id=\"hello-libs\"><a href=\"#hello-libs\" class=\"headerlink\" title=\"hello-libs\"></a>hello-libs</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/hello-libs/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例展示了在AS中,如何管理第三方C/C++库.</li>\n</ul>\n<h3 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a>I</h3><h4 id=\"ImmersiveMode\"><a href=\"#ImmersiveMode\" class=\"headerlink\" title=\"ImmersiveMode\"></a>ImmersiveMode</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ImmersiveMode/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>沉浸模式</li>\n</ul>\n<h4 id=\"Instant-Apps-Cookie-API\"><a href=\"#Instant-Apps-Cookie-API\" class=\"headerlink\" title=\"Instant Apps - Cookie API\"></a>Instant Apps - Cookie API</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/cookie-api/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),8.0及其以上,使用cookie</li>\n</ul>\n<h4 id=\"Instant-Apps-Configuration-APKs\"><a href=\"#Instant-Apps-Configuration-APKs\" class=\"headerlink\" title=\"Instant Apps - Configuration APKs\"></a>Instant Apps - Configuration APKs</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/configuration-apks/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),gradle中配置apk</li>\n</ul>\n<h4 id=\"Instant-Apps-Feature-Module-sample\"><a href=\"#Instant-Apps-Feature-Module-sample\" class=\"headerlink\" title=\"Instant Apps - Feature Module sample\"></a>Instant Apps - Feature Module sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/hello-feature-module/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),功能模块示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Flavors\"><a href=\"#Instant-Apps-Flavors\" class=\"headerlink\" title=\"Instant Apps - Flavors\"></a>Instant Apps - Flavors</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/flavors/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),gradle的flavor示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Google-Analytics\"><a href=\"#Instant-Apps-Google-Analytics\" class=\"headerlink\" title=\"Instant Apps - Google Analytics\"></a>Instant Apps - Google Analytics</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/analytics/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),Google 分析示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Hello-World\"><a href=\"#Instant-Apps-Hello-World\" class=\"headerlink\" title=\"Instant Apps - Hello World\"></a>Instant Apps - Hello World</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/hello-java/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),基本示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Install-API\"><a href=\"#Instant-Apps-Install-API\" class=\"headerlink\" title=\"Instant Apps - Install API\"></a>Instant Apps - Install API</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/install-api/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),安装apk到设备示例</li>\n</ul>\n<h4 id=\"Instant-Apps-Multi-feature\"><a href=\"#Instant-Apps-Multi-feature\" class=\"headerlink\" title=\"Instant Apps - Multi feature\"></a>Instant Apps - Multi feature</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/multi-feature-module/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),示例构建了一个可安装的apk和一个即时app.即时app有2个功能,可以单独的在设备上使用.</li>\n</ul>\n<h4 id=\"Instant-Apps-Service\"><a href=\"#Instant-Apps-Service\" class=\"headerlink\" title=\"Instant Apps - Service\"></a>Instant Apps - Service</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/service/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),instant app如何start或bind一个服务.</li>\n</ul>\n<h4 id=\"Instant-Apps-Storage-API\"><a href=\"#Instant-Apps-Storage-API\" class=\"headerlink\" title=\"Instant Apps - Storage API\"></a>Instant Apps - Storage API</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-instant-apps/tree/master/storage-api/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>即时App(依赖GooglePlay),instant app存储的数据,正式安装后的apk转换存储数据使用该api示例.</li>\n</ul>\n<h4 id=\"Interpolator\"><a href=\"#Interpolator\" class=\"headerlink\" title=\"Interpolator\"></a>Interpolator</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Interpolator/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>材料设计的插值动画和路径动画.</li>\n</ul>\n<h3 id=\"J\"><a href=\"#J\" class=\"headerlink\" title=\"J\"></a>J</h3><h4 id=\"JobScheduler\"><a href=\"#JobScheduler\" class=\"headerlink\" title=\"JobScheduler\"></a>JobScheduler</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-JobScheduler/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>后台任务示例</li>\n</ul>\n<h4 id=\"JumpingJack\"><a href=\"#JumpingJack\" class=\"headerlink\" title=\"JumpingJack\"></a>JumpingJack</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-JumpingJack/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备上,通过重力传感器,计算你能<code>开合跳</code>多少下.</li>\n</ul>\n<h3 id=\"L\"><a href=\"#L\" class=\"headerlink\" title=\"L\"></a>L</h3><h4 id=\"LNotifications\"><a href=\"#LNotifications\" class=\"headerlink\" title=\"LNotifications\"></a>LNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-LNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android 5.0 的新通知.</li>\n</ul>\n<h3 id=\"M\"><a href=\"#M\" class=\"headerlink\" title=\"M\"></a>M</h3><h4 id=\"MessagingService\"><a href=\"#MessagingService\" class=\"headerlink\" title=\"MessagingService\"></a>MessagingService</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MessagingService/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用gms收发消息,国内没法用</li>\n</ul>\n<h4 id=\"MediaBrowserService\"><a href=\"#MediaBrowserService\" class=\"headerlink\" title=\"MediaBrowserService\"></a>MediaBrowserService</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaBrowserService/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>如何实现一个媒体app后台播放,提供媒体库给别的app</li>\n</ul>\n<h4 id=\"MediaEffects\"><a href=\"#MediaEffects\" class=\"headerlink\" title=\"MediaEffects\"></a>MediaEffects</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaEffects/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>4.0以后的,应用图片效果,像OpenGL ES2.0的 textures一样.</li>\n</ul>\n<h4 id=\"MediaRecorder\"><a href=\"#MediaRecorder\" class=\"headerlink\" title=\"MediaRecorder\"></a>MediaRecorder</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaRecorder/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>api14以前,使用surfaceview,现在使用textureview,通过摄像头拍摄.</li>\n</ul>\n<h4 id=\"MediaRouter\"><a href=\"#MediaRouter\" class=\"headerlink\" title=\"MediaRouter\"></a>MediaRouter</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MediaRouter/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>自定义媒体无线投射</li>\n</ul>\n<h4 id=\"MidiScope\"><a href=\"#MidiScope\" class=\"headerlink\" title=\"MidiScope\"></a>MidiScope</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MidiScope/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>MIDI(乐器数字接口)api示例,比如:枚举当前可用的MIDI设备,设备的插上和拔下,接收MIDI信号.示例展示了接收到的MIDI信号,但是并没有演奏声音.</li>\n</ul>\n<h4 id=\"MidiSynth\"><a href=\"#MidiSynth\" class=\"headerlink\" title=\"MidiSynth\"></a>MidiSynth</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MidiSynth/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>MIDI(乐器数字接口)api示例,接收和演奏MIDI信号.</li>\n</ul>\n<h4 id=\"MultiWindowPlayground\"><a href=\"#MultiWindowPlayground\" class=\"headerlink\" title=\"MultiWindowPlayground\"></a>MultiWindowPlayground</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-MultiWindowPlayground/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android N多窗口示例</li>\n</ul>\n<h3 id=\"N\"><a href=\"#N\" class=\"headerlink\" title=\"N\"></a>N</h3><h4 id=\"Notifications\"><a href=\"#Notifications\" class=\"headerlink\" title=\"Notifications\"></a>Notifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Notifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>手机和可穿戴设备上的通知样式</li>\n</ul>\n<h4 id=\"NotificationChannels\"><a href=\"#NotificationChannels\" class=\"headerlink\" title=\"NotificationChannels\"></a>NotificationChannels</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NotificationChannels/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o 以后,根据主题,分类通知</li>\n</ul>\n<h4 id=\"NotificationChannels-Kotlin\"><a href=\"#NotificationChannels-Kotlin\" class=\"headerlink\" title=\"NotificationChannels(Kotlin)\"></a>NotificationChannels(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NotificationChannels/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o 以后,根据主题,分类通知</li>\n</ul>\n<h4 id=\"Native-Activity\"><a href=\"#Native-Activity\" class=\"headerlink\" title=\"Native Activity\"></a>Native Activity</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/native-activity/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>本地activity,初始化GLES 2.0上下文,从本地C代码中读取加速度传感器数据.</li>\n</ul>\n<h4 id=\"Native-Ads-Express-RecyclerView-Sample\"><a href=\"#Native-Ads-Express-RecyclerView-Sample\" class=\"headerlink\" title=\"Native Ads Express RecyclerView Sample\"></a>Native Ads Express RecyclerView Sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ads/tree/master/advanced/NativeExpressRecyclerViewExample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>recyclerview列表展示Google 广告,国内没法用</li>\n</ul>\n<h4 id=\"Native-Audio\"><a href=\"#Native-Audio\" class=\"headerlink\" title=\"Native Audio\"></a>Native Audio</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/native-audio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用JNI,调用C++ OpenSLES API,演奏和记录声音</li>\n</ul>\n<h4 id=\"Native-Plasma\"><a href=\"#Native-Plasma\" class=\"headerlink\" title=\"Native Plasma\"></a>Native Plasma</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/native-plasma/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用C代码,在一个图片中渲染等离子效果</li>\n</ul>\n<h4 id=\"Navigation-Drawer\"><a href=\"#Navigation-Drawer\" class=\"headerlink\" title=\"Navigation Drawer\"></a>Navigation Drawer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NavigationDrawer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>侧滑导航普通调用</li>\n</ul>\n<h4 id=\"NetworkConnect\"><a href=\"#NetworkConnect\" class=\"headerlink\" title=\"NetworkConnect\"></a>NetworkConnect</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NetworkConnect/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>AsyncTask + HttpsURLConnection</li>\n</ul>\n<h4 id=\"NfcProvisioning\"><a href=\"#NfcProvisioning\" class=\"headerlink\" title=\"NfcProvisioning\"></a>NfcProvisioning</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NfcProvisioning/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用NFC和设备拥有者提供诶一个新的设备.</li>\n<li>设备拥有者是是特殊的设备管理员,可以控制设备的安全和配置.</li>\n<li>示例本身不是一个设备拥有者,但是他发送了NFC消息给未设置对等设备,并且告诉对方知道设备的拥有者.</li>\n</ul>\n<h4 id=\"NetworkConnect-1\"><a href=\"#NetworkConnect-1\" class=\"headerlink\" title=\"NetworkConnect\"></a>NetworkConnect</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-NetworkConnect/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>AsyncTask + HttpsURLConnection</li>\n</ul>\n<h3 id=\"P\"><a href=\"#P\" class=\"headerlink\" title=\"P\"></a>P</h3><h4 id=\"PictureInPicture\"><a href=\"#PictureInPicture\" class=\"headerlink\" title=\"PictureInPicture\"></a>PictureInPicture</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PictureInPicture/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o,画中画</li>\n</ul>\n<h4 id=\"PictureInPicture-Kotlin\"><a href=\"#PictureInPicture-Kotlin\" class=\"headerlink\" title=\"PictureInPicture(Kotlin)\"></a>PictureInPicture(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PictureInPicture/tree/master/kotlinApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android o,画中画</li>\n</ul>\n<h4 id=\"PdfRendererBasic\"><a href=\"#PdfRendererBasic\" class=\"headerlink\" title=\"PdfRendererBasic\"></a>PdfRendererBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PdfRendererBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android 5.0,显示PDF</li>\n</ul>\n<h4 id=\"PermissionRequest\"><a href=\"#PermissionRequest\" class=\"headerlink\" title=\"PermissionRequest\"></a>PermissionRequest</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-PermissionRequest/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>webview中权限申请</li>\n</ul>\n<h3 id=\"Q\"><a href=\"#Q\" class=\"headerlink\" title=\"Q\"></a>Q</h3><h4 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Quiz/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>webview中权限申请</li>\n</ul>\n<h3 id=\"R\"><a href=\"#R\" class=\"headerlink\" title=\"R\"></a>R</h3><h4 id=\"RecyclerView\"><a href=\"#RecyclerView\" class=\"headerlink\" title=\"RecyclerView\"></a>RecyclerView</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RecyclerView/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>理解为高级listview</li>\n</ul>\n<h4 id=\"RuntimePermissions\"><a href=\"#RuntimePermissions\" class=\"headerlink\" title=\"RuntimePermissions\"></a>RuntimePermissions</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RuntimePermissions/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>android M,运行时权限</li>\n</ul>\n<h4 id=\"RecipeAssistant\"><a href=\"#RecipeAssistant\" class=\"headerlink\" title=\"RecipeAssistant\"></a>RecipeAssistant</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RecipeAssistant/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>加强的通知api,可以发送至可穿戴设备</li>\n</ul>\n<h4 id=\"RenderScriptIntrinsic\"><a href=\"#RenderScriptIntrinsic\" class=\"headerlink\" title=\"RenderScriptIntrinsic\"></a>RenderScriptIntrinsic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RenderScriptIntrinsic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>RenderScript intrinsics</code>使用示例,图片渲染</li>\n</ul>\n<h4 id=\"RepeatingAlarm\"><a href=\"#RepeatingAlarm\" class=\"headerlink\" title=\"RepeatingAlarm\"></a>RepeatingAlarm</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RepeatingAlarm/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个重复的提醒</li>\n</ul>\n<h4 id=\"RevealEffectBasic\"><a href=\"#RevealEffectBasic\" class=\"headerlink\" title=\"RevealEffectBasic\"></a>RevealEffectBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RevealEffectBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>圆形揭露动画,用于按钮点击,页面跳转.点击时,页面出现一个渐变的圆圈.</li>\n</ul>\n<h4 id=\"Room-amp-RxJava\"><a href=\"#Room-amp-RxJava\" class=\"headerlink\" title=\"Room &amp; RxJava\"></a>Room &amp; RxJava</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room 和 RxJava搭配示例</li>\n</ul>\n<h4 id=\"Room-amp-RxJava-Kotlin\"><a href=\"#Room-amp-RxJava-Kotlin\" class=\"headerlink\" title=\"Room &amp; RxJava(Kotlin)\"></a>Room &amp; RxJava(Kotlin)</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/BasicRxJavaSampleKotlin/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room 和 RxJava搭配示例</li>\n</ul>\n<h4 id=\"Room-with-Content-Providers\"><a href=\"#Room-with-Content-Providers\" class=\"headerlink\" title=\"Room with Content Providers\"></a>Room with Content Providers</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceContentProviderSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Room 和 内容提供者搭配示例</li>\n</ul>\n<h4 id=\"RuntimePermissionsBasic\"><a href=\"#RuntimePermissionsBasic\" class=\"headerlink\" title=\"RuntimePermissionsBasic\"></a>RuntimePermissionsBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RuntimePermissionsBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的运行时权限</li>\n</ul>\n<h4 id=\"RuntimePermissionsWear\"><a href=\"#RuntimePermissionsWear\" class=\"headerlink\" title=\"RuntimePermissionsWear\"></a>RuntimePermissionsWear</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-RuntimePermissionsWear/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备的运行时权限</li>\n</ul>\n<h3 id=\"S\"><a href=\"#S\" class=\"headerlink\" title=\"S\"></a>S</h3><h4 id=\"Sample-Android-TV-Channel-App-TV-Input-using-TIF\"><a href=\"#Sample-Android-TV-Channel-App-TV-Input-using-TIF\" class=\"headerlink\" title=\"Sample Android TV Channel App (TV Input) using TIF\"></a>Sample Android TV Channel App (TV Input) using TIF</h4><ul>\n<li><a href=\"https://github.com/googlesamples/androidtv-sample-inputs/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个电视app示例</li>\n</ul>\n<h4 id=\"San-Angeles\"><a href=\"#San-Angeles\" class=\"headerlink\" title=\"San Angeles\"></a>San Angeles</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/san-angeles/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个示例使用 GLES C/API来渲染过程场景</li>\n</ul>\n<h4 id=\"ScopedDirectoryAccess\"><a href=\"#ScopedDirectoryAccess\" class=\"headerlink\" title=\"ScopedDirectoryAccess\"></a>ScopedDirectoryAccess</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ScopedDirectoryAccess/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>利用Scoped Directory Access API进入指定的目录,不需要请求权限</li>\n</ul>\n<h4 id=\"ScreenCapture\"><a href=\"#ScreenCapture\" class=\"headerlink\" title=\"ScreenCapture\"></a>ScreenCapture</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ScreenCapture/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>利用Media Projection API,实时截图</li>\n</ul>\n<h4 id=\"Sensor-Graph\"><a href=\"#Sensor-Graph\" class=\"headerlink\" title=\"Sensor-Graph\"></a>Sensor-Graph</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/sensor-graph/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>把传感器的变化用图形表示出来.示例读取当前加速度,使用OpenGL画出变化曲线.</li>\n</ul>\n<h4 id=\"Simple-example-of-Android-Things-Native-Peripheral-I-O-APIs\"><a href=\"#Simple-example-of-Android-Things-Native-Peripheral-I-O-APIs\" class=\"headerlink\" title=\"Simple example of Android Things Native Peripheral I/O APIs\"></a>Simple example of Android Things Native Peripheral I/O APIs</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-nativepio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>C++,使用 Native PIO APIs,示例附加设备的I/O</li>\n</ul>\n<h4 id=\"Simple-example-of-Android-Things-Peripheral-I-O-APIs\"><a href=\"#Simple-example-of-Android-Things-Peripheral-I-O-APIs\" class=\"headerlink\" title=\"Simple example of Android Things Peripheral I/O APIs\"></a>Simple example of Android Things Peripheral I/O APIs</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-simplepio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用 Native PIO APIs,示例附加设备的I/O</li>\n</ul>\n<h4 id=\"SkeletonWearableApp\"><a href=\"#SkeletonWearableApp\" class=\"headerlink\" title=\"SkeletonWearableApp\"></a>SkeletonWearableApp</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SkeletonWearableApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个大概的app,可用以开始一个可穿戴开发</li>\n</ul>\n<h4 id=\"SlidingTabsBasic\"><a href=\"#SlidingTabsBasic\" class=\"headerlink\" title=\"SlidingTabsBasic\"></a>SlidingTabsBasic</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SlidingTabsBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>基本的左右滑动切换tab页面</li>\n</ul>\n<h4 id=\"SlidingTabsColors\"><a href=\"#SlidingTabsColors\" class=\"headerlink\" title=\"SlidingTabsColors\"></a>SlidingTabsColors</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SlidingTabsColors/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>左右滑动切换tab页面的指示器颜色,文字颜色,分割线颜色</li>\n</ul>\n<h4 id=\"SpeedTracker\"><a href=\"#SpeedTracker\" class=\"headerlink\" title=\"SpeedTracker\"></a>SpeedTracker</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SpeedTracker/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备记录位置和速度</li>\n</ul>\n<h4 id=\"StorageClient\"><a href=\"#StorageClient\" class=\"headerlink\" title=\"StorageClient\"></a>StorageClient</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-StorageClient/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>使用<code>OPEN_DOCUMENT</code>意图,一个客户app可以访问设备上的文档提供者的列表,并且从中选择文件.</li>\n</ul>\n<h4 id=\"StorageProvider\"><a href=\"#StorageProvider\" class=\"headerlink\" title=\"StorageProvider\"></a>StorageProvider</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-StorageProvider/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例实现了一个简单文档提供者</li>\n</ul>\n<h4 id=\"SwipeRefreshLayout\"><a href=\"#SwipeRefreshLayout\" class=\"headerlink\" title=\"SwipeRefreshLayout\"></a>SwipeRefreshLayout</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SwipeRefreshLayoutBasic/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方下拉刷新</li>\n</ul>\n<h4 id=\"SwipeRefreshListFragment\"><a href=\"#SwipeRefreshListFragment\" class=\"headerlink\" title=\"SwipeRefreshListFragment\"></a>SwipeRefreshListFragment</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SwipeRefreshListFragment/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方下拉刷新fragment</li>\n</ul>\n<h4 id=\"SwipeRefreshMultipleViews\"><a href=\"#SwipeRefreshMultipleViews\" class=\"headerlink\" title=\"SwipeRefreshMultipleViews\"></a>SwipeRefreshMultipleViews</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SwipeRefreshMultipleViews/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>官方下拉刷新多组视图</li>\n</ul>\n<h4 id=\"SynchronizedNotifications\"><a href=\"#SynchronizedNotifications\" class=\"headerlink\" title=\"SynchronizedNotifications\"></a>SynchronizedNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-SynchronizedNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>同步通知.允许手机和手表上同时关闭.</li>\n</ul>\n<h3 id=\"T\"><a href=\"#T\" class=\"headerlink\" title=\"T\"></a>T</h3><h4 id=\"TV-Leanback-Support-Library-sample\"><a href=\"#TV-Leanback-Support-Library-sample\" class=\"headerlink\" title=\"TV Leanback Support Library sample\"></a>TV Leanback Support Library sample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/androidtv-Leanback/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>Leanback Support library</code>祝你完成更好的电视app</li>\n</ul>\n<h4 id=\"Teapots\"><a href=\"#Teapots\" class=\"headerlink\" title=\"Teapots\"></a>Teapots</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/teapots/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>通过渲染一个茶壶,展示Android NDK平台的功能</li>\n</ul>\n<h4 id=\"TextLinkify\"><a href=\"#TextLinkify\" class=\"headerlink\" title=\"TextLinkify\"></a>TextLinkify</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-TextLinkify/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>如何给TextView添加链接</li>\n</ul>\n<h4 id=\"TextSwitcher\"><a href=\"#TextSwitcher\" class=\"headerlink\" title=\"TextSwitcher\"></a>TextSwitcher</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-TextSwitcher/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li><code>TextSwitcher</code>来展示文字改变的动画</li>\n</ul>\n<h4 id=\"Things-Bluetooth-Audio-sample\"><a href=\"#Things-Bluetooth-Audio-sample\" class=\"headerlink\" title=\"Things Bluetooth Audio sample\"></a>Things Bluetooth Audio sample</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-bluetooth-audio/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,和音频有关的蓝牙api示例.</li>\n</ul>\n<h4 id=\"Things-Cloud-IoT-Sensor-Hub\"><a href=\"#Things-Cloud-IoT-Sensor-Hub\" class=\"headerlink\" title=\"Things Cloud IoT Sensor Hub\"></a>Things Cloud IoT Sensor Hub</h4><ul>\n<li><a href=\"https://github.com/androidthings/sensorhub-cloud-iot/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,实现一个传感器中心,收集传感器数据.上传到Google Cloud.该服务国内不能用.</li>\n</ul>\n<h4 id=\"Things-Doorbell\"><a href=\"#Things-Doorbell\" class=\"headerlink\" title=\"Things Doorbell\"></a>Things Doorbell</h4><ul>\n<li><a href=\"https://github.com/androidthings/doorbell/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,看起来是个门铃实现.</li>\n</ul>\n<h4 id=\"Things-Simple-UI\"><a href=\"#Things-Simple-UI\" class=\"headerlink\" title=\"Things Simple UI\"></a>Things Simple UI</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-simpleui/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,一个开关UI</li>\n</ul>\n<h4 id=\"Things-TensorFlow-image-classifier-sample\"><a href=\"#Things-TensorFlow-image-classifier-sample\" class=\"headerlink\" title=\"Things TensorFlow image classifier sample\"></a>Things TensorFlow image classifier sample</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-tensorflow-imageclassifier/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,当按下GPIO按钮,当前画面被添加的相机捕获.该图片被覆盖和传入TensorFlow模式,识别图片里的是啥.如果有屏幕就展示识别后的最多三个标签,如果有扬声器,那么就说出来.使用的Google服务,国内不能用.</li>\n</ul>\n<h4 id=\"Things-Weather-Station\"><a href=\"#Things-Weather-Station\" class=\"headerlink\" title=\"Things Weather Station\"></a>Things Weather Station</h4><ul>\n<li><a href=\"https://github.com/androidthings/weatherstation/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,外围多个设备组成一个连接地天气站.</li>\n</ul>\n<h4 id=\"Things-driver\"><a href=\"#Things-driver\" class=\"headerlink\" title=\"Things driver\"></a>Things driver</h4><ul>\n<li><a href=\"https://github.com/androidthings/drivers-samples/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,外围驱动</li>\n</ul>\n<h4 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-Timer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>定时器,可不依靠手机独立运行在可穿戴设备上.</li>\n</ul>\n<h4 id=\"Topeka\"><a href=\"#Topeka\" class=\"headerlink\" title=\"Topeka\"></a>Topeka</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-topeka/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个有趣的小测试题展示材料设计</li>\n</ul>\n<h4 id=\"Trivial-Drive\"><a href=\"#Trivial-Drive\" class=\"headerlink\" title=\"Trivial Drive\"></a>Trivial Drive</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用</li>\n</ul>\n<h4 id=\"Trivial-Drive2\"><a href=\"#Trivial-Drive2\" class=\"headerlink\" title=\"Trivial Drive2\"></a>Trivial Drive2</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-play-billing/tree/master/TrivialDrive_v2/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>开车小游戏,展示app内付费,应该是通过Google Play的,国内不能用</li>\n</ul>\n<h3 id=\"U\"><a href=\"#U\" class=\"headerlink\" title=\"U\"></a>U</h3><h4 id=\"UART-Loopback-sample\"><a href=\"#UART-Loopback-sample\" class=\"headerlink\" title=\"UART Loopback sample\"></a>UART Loopback sample</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-uartloopback/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>Android things里,通过异步收发器,读写数据.</li>\n</ul>\n<h4 id=\"USB-Enumerator\"><a href=\"#USB-Enumerator\" class=\"headerlink\" title=\"USB Enumerator\"></a>USB Enumerator</h4><ul>\n<li><a href=\"https://github.com/androidthings/sample-usbenum/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>枚举所有USB设备</li>\n</ul>\n<h4 id=\"Universal-Android-Music-Player\"><a href=\"#Universal-Android-Music-Player\" class=\"headerlink\" title=\"Universal Android Music Player\"></a>Universal Android Music Player</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-UniversalMusicPlayer/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个音乐播放器,可以在手机,平板,手表,电视,Android Auto(汽车),Google Cast devices这些设备上提供一致的用户体验.</li>\n</ul>\n<h3 id=\"V\"><a href=\"#V\" class=\"headerlink\" title=\"V\"></a>V</h3><h4 id=\"Vulkan\"><a href=\"#Vulkan\" class=\"headerlink\" title=\"Vulkan\"></a>Vulkan</h4><ul>\n<li><a href=\"https://github.com/googlesamples/vulkan-basic-samples/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>一个C++实现的库,渲染3D图形</li>\n</ul>\n<h3 id=\"W\"><a href=\"#W\" class=\"headerlink\" title=\"W\"></a>W</h3><h4 id=\"WatchFace\"><a href=\"#WatchFace\" class=\"headerlink\" title=\"WatchFace\"></a>WatchFace</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WatchFace/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>为可穿戴设备创建watch face</li>\n</ul>\n<h4 id=\"WearDrawers\"><a href=\"#WearDrawers\" class=\"headerlink\" title=\"WearDrawers\"></a>WearDrawers</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearDrawers/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>为可穿戴设备创建导航抽屉</li>\n</ul>\n<h4 id=\"WearHighBandwidthNetworking\"><a href=\"#WearHighBandwidthNetworking\" class=\"headerlink\" title=\"WearHighBandwidthNetworking\"></a>WearHighBandwidthNetworking</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearHighBandwidthNetworking/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>可穿戴设备的带宽处理最佳实践</li>\n</ul>\n<h4 id=\"WEBP-Samples\"><a href=\"#WEBP-Samples\" class=\"headerlink\" title=\"WEBP Samples\"></a>WEBP Samples</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-ndk/tree/master/webp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>webp,一种google建议的图片格式.</li>\n</ul>\n<h4 id=\"WatchViewStub\"><a href=\"#WatchViewStub\" class=\"headerlink\" title=\"WatchViewStub\"></a>WatchViewStub</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WatchViewStub/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>为圆形,方形的手表指定不同的布局</li>\n</ul>\n<h4 id=\"WearComplicationProvidersTestSuite\"><a href=\"#WearComplicationProvidersTestSuite\" class=\"headerlink\" title=\"WearComplicationProvidersTestSuite\"></a>WearComplicationProvidersTestSuite</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearComplicationProvidersTestSuite/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>并发测试套装集合,提供了假数据可以用来测试手表的不同类型渲染.</li>\n</ul>\n<h4 id=\"WearNotifications\"><a href=\"#WearNotifications\" class=\"headerlink\" title=\"WearNotifications\"></a>WearNotifications</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearNotifications/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>手机和手表的通知最佳实践.</li>\n</ul>\n<h4 id=\"WearSpeakerSample\"><a href=\"#WearSpeakerSample\" class=\"headerlink\" title=\"WearSpeakerSample\"></a>WearSpeakerSample</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearSpeakerSample/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>在可穿戴设备上录音,播音.</li>\n</ul>\n<h4 id=\"WearVerifyRemoteApp\"><a href=\"#WearVerifyRemoteApp\" class=\"headerlink\" title=\"WearVerifyRemoteApp\"></a>WearVerifyRemoteApp</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-WearVerifyRemoteApp/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>最佳实践:检测已连接的设备是否从周边的可穿戴设备上安装了你的app.(如果安装了就可以传输数据了)</li>\n</ul>\n<h3 id=\"X\"><a href=\"#X\" class=\"headerlink\" title=\"X\"></a>X</h3><h4 id=\"XYZTouristAttractions\"><a href=\"#XYZTouristAttractions\" class=\"headerlink\" title=\"XYZTouristAttractions\"></a>XYZTouristAttractions</h4><ul>\n<li><a href=\"https://github.com/googlesamples/android-XYZTouristAttractions/#readme\" target=\"_blank\" rel=\"external\">项目地址</a></li>\n<li>示例打算尽可能的通过手机和可穿戴设备接近真实实践.巴拉巴拉吹牛逼的话…</li>\n<li>示例模拟一个景点,当用户靠近时通知用户</li>\n<li>GridViewPage展示图片和文字介绍</li>\n</ul>\n"},{"layout":"post","title":"乙1011. A+B和C (15)","date":"2018-01-22T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\t\n给定区间[-2<sup>31</sup>, 2<sup>31</sup>]内的3个整数A、B和C，请判断A+B是否大于C。\n\n输入格式：\n\n输入第1行给出正整数T(<=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。\n\n输出格式：\n\n对每组测试用例，在一行中输出“Case #X: true”如果A+B>C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。\n\n输入样例：\n4\n1 2 3\n2 3 4\n2147483647 0 2147483646\n0 -2147483648 -2147483647\n输出样例：\nCase #1: false\nCase #2: true\nCase #3: true\nCase #4: false\t\n \n\n#### 解答 ####\n\t\n\timport java.math.BigDecimal;\n\timport java.util.Scanner;\n\t \n\tpublic class No1011 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = Integer.parseInt(in.nextLine());\n\t\t\tString originStr;\n\t\t\tString[] split;\n\t\t\tBigDecimal a;\n\t\t\tBigDecimal b;\n\t\t\tBigDecimal c;\n\t\t\tboolean[] res = new boolean[num];\n\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\toriginStr = in.nextLine();\n\t\t\t\tsplit = originStr.split(\" \");\n\t\t\t\ta = new BigDecimal(split[0]);\n\t\t\t\tb = new BigDecimal(split[1]);\n\t\t\t\tc = new BigDecimal(split[2]);\n\t\t\t\tres[i] = (a.add(b).compareTo(c) == 1);\n\t\t\t}\n\t\t\tin.close();\n\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\tSystem.out.println(\"Case #\" + (i+1) + \": \" + res[i]);\n\t\t\t}\n\t\t}\n\t}\n\n#### 注意 ####\n\n- 整型可能会越界\n- 输出是从\"1\"开始\n","source":"_posts/2018-01-22-pat-yi-1011.md","raw":"---\nlayout: post\ntitle:  乙1011. A+B和C (15)\ndate:   2018-01-22\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\t\n给定区间[-2<sup>31</sup>, 2<sup>31</sup>]内的3个整数A、B和C，请判断A+B是否大于C。\n\n输入格式：\n\n输入第1行给出正整数T(<=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。\n\n输出格式：\n\n对每组测试用例，在一行中输出“Case #X: true”如果A+B>C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。\n\n输入样例：\n4\n1 2 3\n2 3 4\n2147483647 0 2147483646\n0 -2147483648 -2147483647\n输出样例：\nCase #1: false\nCase #2: true\nCase #3: true\nCase #4: false\t\n \n\n#### 解答 ####\n\t\n\timport java.math.BigDecimal;\n\timport java.util.Scanner;\n\t \n\tpublic class No1011 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint num = Integer.parseInt(in.nextLine());\n\t\t\tString originStr;\n\t\t\tString[] split;\n\t\t\tBigDecimal a;\n\t\t\tBigDecimal b;\n\t\t\tBigDecimal c;\n\t\t\tboolean[] res = new boolean[num];\n\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\toriginStr = in.nextLine();\n\t\t\t\tsplit = originStr.split(\" \");\n\t\t\t\ta = new BigDecimal(split[0]);\n\t\t\t\tb = new BigDecimal(split[1]);\n\t\t\t\tc = new BigDecimal(split[2]);\n\t\t\t\tres[i] = (a.add(b).compareTo(c) == 1);\n\t\t\t}\n\t\t\tin.close();\n\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\tSystem.out.println(\"Case #\" + (i+1) + \": \" + res[i]);\n\t\t\t}\n\t\t}\n\t}\n\n#### 注意 ####\n\n- 整型可能会越界\n- 输出是从\"1\"开始\n","slug":"pat-yi-1011","published":1,"updated":"2018-01-29T07:43:52.709Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kk00962siv77a4kkuu","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定区间[-2<sup>31</sup>, 2<sup>31</sup>]内的3个整数A、B和C，请判断A+B是否大于C。</p>\n<p>输入格式：</p>\n<p>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p>\n<p>输出格式：</p>\n<p>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p>\n<p>输入样例：<br>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br>输出样例：<br>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false    </p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.math.BigDecimal;\nimport java.util.Scanner;\n\npublic class No1011 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = Integer.parseInt(in.nextLine());\n        String originStr;\n        String[] split;\n        BigDecimal a;\n        BigDecimal b;\n        BigDecimal c;\n        boolean[] res = new boolean[num];\n        for (int i = 0; i &lt; num; i++) {\n            originStr = in.nextLine();\n            split = originStr.split(&quot; &quot;);\n            a = new BigDecimal(split[0]);\n            b = new BigDecimal(split[1]);\n            c = new BigDecimal(split[2]);\n            res[i] = (a.add(b).compareTo(c) == 1);\n        }\n        in.close();\n        for (int i = 0; i &lt; num; i++) {\n            System.out.println(&quot;Case #&quot; + (i+1) + &quot;: &quot; + res[i]);\n        }\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>整型可能会越界</li>\n<li>输出是从”1”开始</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定区间[-2<sup>31</sup>, 2<sup>31</sup>]内的3个整数A、B和C，请判断A+B是否大于C。</p>\n<p>输入格式：</p>\n<p>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p>\n<p>输出格式：</p>\n<p>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p>\n<p>输入样例：<br>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br>输出样例：<br>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false    </p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.math.BigDecimal;\nimport java.util.Scanner;\n\npublic class No1011 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int num = Integer.parseInt(in.nextLine());\n        String originStr;\n        String[] split;\n        BigDecimal a;\n        BigDecimal b;\n        BigDecimal c;\n        boolean[] res = new boolean[num];\n        for (int i = 0; i &lt; num; i++) {\n            originStr = in.nextLine();\n            split = originStr.split(&quot; &quot;);\n            a = new BigDecimal(split[0]);\n            b = new BigDecimal(split[1]);\n            c = new BigDecimal(split[2]);\n            res[i] = (a.add(b).compareTo(c) == 1);\n        }\n        in.close();\n        for (int i = 0; i &lt; num; i++) {\n            System.out.println(&quot;Case #&quot; + (i+1) + &quot;: &quot; + res[i]);\n        }\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>整型可能会越界</li>\n<li>输出是从”1”开始</li>\n</ul>\n"},{"layout":"post","title":"乙1012. 数字分类 (20)","date":"2018-01-22T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：\n\n- A1 = 能被5整除的数字中所有偶数的和；\n- A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；\n- A3 = 被5除后余2的数字的个数；\n- A4 = 被5除后余3的数字的平均数，精确到小数点后1位；\n- A5 = 被5除后余4的数字中最大数字。\n- \n输入格式：\n\n每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。\n\n输出格式：\n\n对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。\n\n若其中某一类数字不存在，则在相应位置输出“N”。\n\n输入样例1：\n\t13 1 2 3 4 5 6 7 8 9 10 20 16 18\n输出样例1：\n\t30 11 2 9.7 9\n输入样例2：\n\t8 1 2 4 5 6 7 9 16\n输出样例2：\n\tN 11 2 N 9\n \n\n#### 解答 ####\n\n\timport java.text.DecimalFormat;\n\timport java.util.Scanner;\n\t\n\tpublic class No1012 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t// long start = System.currentTimeMillis();\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString input = in.nextLine();\n\t\t\tString[] numbers = input.split(\" \");\n\t\t\tint len = numbers.length;\n\t\t\tint median, A1 = -1, A2 = Integer.MAX_VALUE, A3 = -1, A4 = -1, A5 = -1, A2Nums = 0, A4Nums = 0;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tmedian = Integer.parseInt(numbers[i]);\n\t\t\t\tif (median % 5 == 0 && median % 2 == 0) {\n\t\t\t\t\tif (A1 == -1) {\n\t\t\t\t\t\tA1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tA1 += median;\n\t\t\t\t} else if (median % 5 == 1) {\n\t\t\t\t\tA2Nums++;\n\t\t\t\t\tif (A2 == Integer.MAX_VALUE) {\n\t\t\t\t\t\tA2 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (A2Nums % 2 == 0) {\n\t\t\t\t\t\tA2 -= median;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tA2 += median;\n\t\t\t\t\t}\n\t\t\t\t} else if (median % 5 == 2) {\n\t\t\t\t\tif (A3 == -1)\n\t\t\t\t\t\tA3 = 0;\n\t\t\t\t\tA3++;\n\t\t\t\t} else if (median % 5 == 3) {\n\t\t\t\t\tA4Nums++;\n\t\t\t\t\tif (A4 == -1) {\n\t\t\t\t\t\tA4 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tA4 += median;\n\t\t\t\t\tSystem.out.println(A4 + \"/\" + A4Nums);\n\t\t\t\t} else if (median % 5 == 4) {\n\t\t\t\t\tif (A5 == -1)\n\t\t\t\t\t\tA5 = median;\n\t\t\t\t\telse\n\t\t\t\t\t\tA5 = A5 - median > 0 ? A5 : median;\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\t\tdouble A4Res;\n\t\t\tString s4;\n\t\t\tif (A4 != -1) {\n\t\t\t\tDecimalFormat df = new DecimalFormat(\"0.0\");\n\t\t\t\tA4Res = (float) A4 / A4Nums;\n\t\t\t\ts4 = df.format(A4Res);\n\t\t\t} else {\n\t\t\t\ts4 = String.valueOf(A4);\n\t\t\t}\n\t\t\tString[] res = { String.valueOf(A1), String.valueOf(A2), String.valueOf(A3), s4, String.valueOf(A5) };\n\t\t\tfor (int j = 0; j < res.length; j++) {\n\t\t\t\tif (res[j].equals(\"-1\") || res[j].equals(\"2147483647\")) {\n\t\t\t\t\tSystem.out.print(\"N\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(res[j]);\n\t\t\t\t}\n\t\t\t\tif (j != res.length - 1)\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\t// System.out.println((System.currentTimeMillis() - start));\n\t\t}\n\t}\n\n\n#### 注意 ####\n\nPAT的编译器有些抽风,你可能会遇到`运行超时`的问题,解决步骤如下:\n- 去牛客网,找到该题,查看运行结果和时间\n- 返回PAT再次尝试提交,看是否可以成功\n- 如果第二步没有成功,小睡片刻,睡醒后再次提交,应该就可以了(开玩笑的,PAT用的JDK6,然后的确是有些问题的.多提交几次就好了.)\n","source":"_posts/2018-01-22-pat-yi-1012.md","raw":"---\nlayout: post\ntitle:  乙1012. 数字分类 (20)\ndate:   2018-01-22\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：\n\n- A1 = 能被5整除的数字中所有偶数的和；\n- A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...；\n- A3 = 被5除后余2的数字的个数；\n- A4 = 被5除后余3的数字的平均数，精确到小数点后1位；\n- A5 = 被5除后余4的数字中最大数字。\n- \n输入格式：\n\n每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。\n\n输出格式：\n\n对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。\n\n若其中某一类数字不存在，则在相应位置输出“N”。\n\n输入样例1：\n\t13 1 2 3 4 5 6 7 8 9 10 20 16 18\n输出样例1：\n\t30 11 2 9.7 9\n输入样例2：\n\t8 1 2 4 5 6 7 9 16\n输出样例2：\n\tN 11 2 N 9\n \n\n#### 解答 ####\n\n\timport java.text.DecimalFormat;\n\timport java.util.Scanner;\n\t\n\tpublic class No1012 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\t// long start = System.currentTimeMillis();\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString input = in.nextLine();\n\t\t\tString[] numbers = input.split(\" \");\n\t\t\tint len = numbers.length;\n\t\t\tint median, A1 = -1, A2 = Integer.MAX_VALUE, A3 = -1, A4 = -1, A5 = -1, A2Nums = 0, A4Nums = 0;\n\t\t\tfor (int i = 1; i < len; i++) {\n\t\t\t\tmedian = Integer.parseInt(numbers[i]);\n\t\t\t\tif (median % 5 == 0 && median % 2 == 0) {\n\t\t\t\t\tif (A1 == -1) {\n\t\t\t\t\t\tA1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tA1 += median;\n\t\t\t\t} else if (median % 5 == 1) {\n\t\t\t\t\tA2Nums++;\n\t\t\t\t\tif (A2 == Integer.MAX_VALUE) {\n\t\t\t\t\t\tA2 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (A2Nums % 2 == 0) {\n\t\t\t\t\t\tA2 -= median;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tA2 += median;\n\t\t\t\t\t}\n\t\t\t\t} else if (median % 5 == 2) {\n\t\t\t\t\tif (A3 == -1)\n\t\t\t\t\t\tA3 = 0;\n\t\t\t\t\tA3++;\n\t\t\t\t} else if (median % 5 == 3) {\n\t\t\t\t\tA4Nums++;\n\t\t\t\t\tif (A4 == -1) {\n\t\t\t\t\t\tA4 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tA4 += median;\n\t\t\t\t\tSystem.out.println(A4 + \"/\" + A4Nums);\n\t\t\t\t} else if (median % 5 == 4) {\n\t\t\t\t\tif (A5 == -1)\n\t\t\t\t\t\tA5 = median;\n\t\t\t\t\telse\n\t\t\t\t\t\tA5 = A5 - median > 0 ? A5 : median;\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\t\tdouble A4Res;\n\t\t\tString s4;\n\t\t\tif (A4 != -1) {\n\t\t\t\tDecimalFormat df = new DecimalFormat(\"0.0\");\n\t\t\t\tA4Res = (float) A4 / A4Nums;\n\t\t\t\ts4 = df.format(A4Res);\n\t\t\t} else {\n\t\t\t\ts4 = String.valueOf(A4);\n\t\t\t}\n\t\t\tString[] res = { String.valueOf(A1), String.valueOf(A2), String.valueOf(A3), s4, String.valueOf(A5) };\n\t\t\tfor (int j = 0; j < res.length; j++) {\n\t\t\t\tif (res[j].equals(\"-1\") || res[j].equals(\"2147483647\")) {\n\t\t\t\t\tSystem.out.print(\"N\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(res[j]);\n\t\t\t\t}\n\t\t\t\tif (j != res.length - 1)\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\t// System.out.println((System.currentTimeMillis() - start));\n\t\t}\n\t}\n\n\n#### 注意 ####\n\nPAT的编译器有些抽风,你可能会遇到`运行超时`的问题,解决步骤如下:\n- 去牛客网,找到该题,查看运行结果和时间\n- 返回PAT再次尝试提交,看是否可以成功\n- 如果第二步没有成功,小睡片刻,睡醒后再次提交,应该就可以了(开玩笑的,PAT用的JDK6,然后的确是有些问题的.多提交几次就好了.)\n","slug":"pat-yi-1012","published":1,"updated":"2018-01-29T07:43:56.902Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kn00992sivtlkgx62p","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：</p>\n<ul>\n<li>A1 = 能被5整除的数字中所有偶数的和；</li>\n<li>A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；</li>\n<li>A3 = 被5除后余2的数字的个数；</li>\n<li>A4 = 被5除后余3的数字的平均数，精确到小数点后1位；</li>\n<li>A5 = 被5除后余4的数字中最大数字。</li>\n<li>输入格式：</li>\n</ul>\n<p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p>\n<p>输出格式：</p>\n<p>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>\n<p>若其中某一类数字不存在，则在相应位置输出“N”。</p>\n<p>输入样例1：<br>    13 1 2 3 4 5 6 7 8 9 10 20 16 18<br>输出样例1：<br>    30 11 2 9.7 9<br>输入样例2：<br>    8 1 2 4 5 6 7 9 16<br>输出样例2：<br>    N 11 2 N 9</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.text.DecimalFormat;\nimport java.util.Scanner;\n\npublic class No1012 {\n\n    public static void main(String[] args) {\n        // long start = System.currentTimeMillis();\n        Scanner in = new Scanner(System.in);\n        String input = in.nextLine();\n        String[] numbers = input.split(&quot; &quot;);\n        int len = numbers.length;\n        int median, A1 = -1, A2 = Integer.MAX_VALUE, A3 = -1, A4 = -1, A5 = -1, A2Nums = 0, A4Nums = 0;\n        for (int i = 1; i &lt; len; i++) {\n            median = Integer.parseInt(numbers[i]);\n            if (median % 5 == 0 &amp;&amp; median % 2 == 0) {\n                if (A1 == -1) {\n                    A1 = 0;\n                }\n                A1 += median;\n            } else if (median % 5 == 1) {\n                A2Nums++;\n                if (A2 == Integer.MAX_VALUE) {\n                    A2 = 0;\n                }\n                if (A2Nums % 2 == 0) {\n                    A2 -= median;\n                } else {\n                    A2 += median;\n                }\n            } else if (median % 5 == 2) {\n                if (A3 == -1)\n                    A3 = 0;\n                A3++;\n            } else if (median % 5 == 3) {\n                A4Nums++;\n                if (A4 == -1) {\n                    A4 = 0;\n                }\n                A4 += median;\n                System.out.println(A4 + &quot;/&quot; + A4Nums);\n            } else if (median % 5 == 4) {\n                if (A5 == -1)\n                    A5 = median;\n                else\n                    A5 = A5 - median &gt; 0 ? A5 : median;\n            }\n        }\n        in.close();\n        double A4Res;\n        String s4;\n        if (A4 != -1) {\n            DecimalFormat df = new DecimalFormat(&quot;0.0&quot;);\n            A4Res = (float) A4 / A4Nums;\n            s4 = df.format(A4Res);\n        } else {\n            s4 = String.valueOf(A4);\n        }\n        String[] res = { String.valueOf(A1), String.valueOf(A2), String.valueOf(A3), s4, String.valueOf(A5) };\n        for (int j = 0; j &lt; res.length; j++) {\n            if (res[j].equals(&quot;-1&quot;) || res[j].equals(&quot;2147483647&quot;)) {\n                System.out.print(&quot;N&quot;);\n            } else {\n                System.out.print(res[j]);\n            }\n            if (j != res.length - 1)\n                System.out.print(&quot; &quot;);\n        }\n        // System.out.println((System.currentTimeMillis() - start));\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>PAT的编译器有些抽风,你可能会遇到<code>运行超时</code>的问题,解决步骤如下:</p>\n<ul>\n<li>去牛客网,找到该题,查看运行结果和时间</li>\n<li>返回PAT再次尝试提交,看是否可以成功</li>\n<li>如果第二步没有成功,小睡片刻,睡醒后再次提交,应该就可以了(开玩笑的,PAT用的JDK6,然后的确是有些问题的.多提交几次就好了.)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：</p>\n<ul>\n<li>A1 = 能被5整除的数字中所有偶数的和；</li>\n<li>A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；</li>\n<li>A3 = 被5除后余2的数字的个数；</li>\n<li>A4 = 被5除后余3的数字的平均数，精确到小数点后1位；</li>\n<li>A5 = 被5除后余4的数字中最大数字。</li>\n<li>输入格式：</li>\n</ul>\n<p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p>\n<p>输出格式：</p>\n<p>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>\n<p>若其中某一类数字不存在，则在相应位置输出“N”。</p>\n<p>输入样例1：<br>    13 1 2 3 4 5 6 7 8 9 10 20 16 18<br>输出样例1：<br>    30 11 2 9.7 9<br>输入样例2：<br>    8 1 2 4 5 6 7 9 16<br>输出样例2：<br>    N 11 2 N 9</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.text.DecimalFormat;\nimport java.util.Scanner;\n\npublic class No1012 {\n\n    public static void main(String[] args) {\n        // long start = System.currentTimeMillis();\n        Scanner in = new Scanner(System.in);\n        String input = in.nextLine();\n        String[] numbers = input.split(&quot; &quot;);\n        int len = numbers.length;\n        int median, A1 = -1, A2 = Integer.MAX_VALUE, A3 = -1, A4 = -1, A5 = -1, A2Nums = 0, A4Nums = 0;\n        for (int i = 1; i &lt; len; i++) {\n            median = Integer.parseInt(numbers[i]);\n            if (median % 5 == 0 &amp;&amp; median % 2 == 0) {\n                if (A1 == -1) {\n                    A1 = 0;\n                }\n                A1 += median;\n            } else if (median % 5 == 1) {\n                A2Nums++;\n                if (A2 == Integer.MAX_VALUE) {\n                    A2 = 0;\n                }\n                if (A2Nums % 2 == 0) {\n                    A2 -= median;\n                } else {\n                    A2 += median;\n                }\n            } else if (median % 5 == 2) {\n                if (A3 == -1)\n                    A3 = 0;\n                A3++;\n            } else if (median % 5 == 3) {\n                A4Nums++;\n                if (A4 == -1) {\n                    A4 = 0;\n                }\n                A4 += median;\n                System.out.println(A4 + &quot;/&quot; + A4Nums);\n            } else if (median % 5 == 4) {\n                if (A5 == -1)\n                    A5 = median;\n                else\n                    A5 = A5 - median &gt; 0 ? A5 : median;\n            }\n        }\n        in.close();\n        double A4Res;\n        String s4;\n        if (A4 != -1) {\n            DecimalFormat df = new DecimalFormat(&quot;0.0&quot;);\n            A4Res = (float) A4 / A4Nums;\n            s4 = df.format(A4Res);\n        } else {\n            s4 = String.valueOf(A4);\n        }\n        String[] res = { String.valueOf(A1), String.valueOf(A2), String.valueOf(A3), s4, String.valueOf(A5) };\n        for (int j = 0; j &lt; res.length; j++) {\n            if (res[j].equals(&quot;-1&quot;) || res[j].equals(&quot;2147483647&quot;)) {\n                System.out.print(&quot;N&quot;);\n            } else {\n                System.out.print(res[j]);\n            }\n            if (j != res.length - 1)\n                System.out.print(&quot; &quot;);\n        }\n        // System.out.println((System.currentTimeMillis() - start));\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>PAT的编译器有些抽风,你可能会遇到<code>运行超时</code>的问题,解决步骤如下:</p>\n<ul>\n<li>去牛客网,找到该题,查看运行结果和时间</li>\n<li>返回PAT再次尝试提交,看是否可以成功</li>\n<li>如果第二步没有成功,小睡片刻,睡醒后再次提交,应该就可以了(开玩笑的,PAT用的JDK6,然后的确是有些问题的.多提交几次就好了.)</li>\n</ul>\n"},{"layout":"post","title":"乙1013. 数素数 (20)","date":"2018-01-22T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n令Pi表示第i个素数。现任给两个正整数M <= N <= 104，请输出PM到PN的所有素数。\n\n输入格式：\n\n输入在一行中给出M和N，其间以空格分隔。\n\n输出格式：\n\n输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。\n\n输入样例：\n\t5 27\n输出样例：\n\t11 13 17 19 23 29 31 37 41 43\n\t47 53 59 61 67 71 73 79 83 89\n\t97 101 103\n\n#### 解答 ####\n\t\n\timport java.util.Scanner;\n\n\tpublic class No1013 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint M = in.nextInt();\n\t\t\tint N = in.nextInt();\n\t\t\tin.close();\n\t\t\tint current = 0;\n\t\t\tint[] res = new int[N];\n\t\t\tfor (int i = 2; current < N; i++) {\n\t\t\t\tif (isSu(i)) {\n\t\t\t\t\tres[current++] = i;\n\t\t\t\t\tif (current >= M) {\n\t\t\t\t\t\tSystem.out.print(i);\n\t\t\t\t\t\tif (current - M + 1 >= 10 && (current - M + 1) % 10 == 0) {\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (current != N)\n\t\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tstatic boolean isSu(int a) {\n\t\t\tboolean flag = true;\n\t\t\tfor (int i = 2; i <= Math.sqrt(a); i++) {\n\t\t\t\tif (a % i == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flag;\n\t\t}\n\t}\n\n\n#### 注意 ####\n\n- 列出从0-N的素数,然后截取M-N个\n- 需要加强白板写代码的能力,尤其是在输出的时候,角标什么的老爱弄错,大脑一锅粥.\n- IDE是个好东西,在此处,让人发懒了.\n","source":"_posts/2018-01-22-pat-yi-1013.md","raw":"---\nlayout: post\ntitle:  乙1013. 数素数 (20)\ndate:   2018-01-22\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n令Pi表示第i个素数。现任给两个正整数M <= N <= 104，请输出PM到PN的所有素数。\n\n输入格式：\n\n输入在一行中给出M和N，其间以空格分隔。\n\n输出格式：\n\n输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。\n\n输入样例：\n\t5 27\n输出样例：\n\t11 13 17 19 23 29 31 37 41 43\n\t47 53 59 61 67 71 73 79 83 89\n\t97 101 103\n\n#### 解答 ####\n\t\n\timport java.util.Scanner;\n\n\tpublic class No1013 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint M = in.nextInt();\n\t\t\tint N = in.nextInt();\n\t\t\tin.close();\n\t\t\tint current = 0;\n\t\t\tint[] res = new int[N];\n\t\t\tfor (int i = 2; current < N; i++) {\n\t\t\t\tif (isSu(i)) {\n\t\t\t\t\tres[current++] = i;\n\t\t\t\t\tif (current >= M) {\n\t\t\t\t\t\tSystem.out.print(i);\n\t\t\t\t\t\tif (current - M + 1 >= 10 && (current - M + 1) % 10 == 0) {\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (current != N)\n\t\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tstatic boolean isSu(int a) {\n\t\t\tboolean flag = true;\n\t\t\tfor (int i = 2; i <= Math.sqrt(a); i++) {\n\t\t\t\tif (a % i == 0) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flag;\n\t\t}\n\t}\n\n\n#### 注意 ####\n\n- 列出从0-N的素数,然后截取M-N个\n- 需要加强白板写代码的能力,尤其是在输出的时候,角标什么的老爱弄错,大脑一锅粥.\n- IDE是个好东西,在此处,让人发懒了.\n","slug":"pat-yi-1013","published":1,"updated":"2018-01-29T07:44:01.606Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kp009c2sivyt8qslwf","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 104，请输出PM到PN的所有素数。</p>\n<p>输入格式：</p>\n<p>输入在一行中给出M和N，其间以空格分隔。</p>\n<p>输出格式：</p>\n<p>输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。</p>\n<p>输入样例：<br>    5 27<br>输出样例：<br>    11 13 17 19 23 29 31 37 41 43<br>    47 53 59 61 67 71 73 79 83 89<br>    97 101 103</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1013 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int M = in.nextInt();\n        int N = in.nextInt();\n        in.close();\n        int current = 0;\n        int[] res = new int[N];\n        for (int i = 2; current &lt; N; i++) {\n            if (isSu(i)) {\n                res[current++] = i;\n                if (current &gt;= M) {\n                    System.out.print(i);\n                    if (current - M + 1 &gt;= 10 &amp;&amp; (current - M + 1) % 10 == 0) {\n                        System.out.println();\n                    } else {\n                        if (current != N)\n                            System.out.print(&quot; &quot;);\n                    }\n                }\n            }\n        }\n    }\n\n    static boolean isSu(int a) {\n        boolean flag = true;\n        for (int i = 2; i &lt;= Math.sqrt(a); i++) {\n            if (a % i == 0) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>列出从0-N的素数,然后截取M-N个</li>\n<li>需要加强白板写代码的能力,尤其是在输出的时候,角标什么的老爱弄错,大脑一锅粥.</li>\n<li>IDE是个好东西,在此处,让人发懒了.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 104，请输出PM到PN的所有素数。</p>\n<p>输入格式：</p>\n<p>输入在一行中给出M和N，其间以空格分隔。</p>\n<p>输出格式：</p>\n<p>输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。</p>\n<p>输入样例：<br>    5 27<br>输出样例：<br>    11 13 17 19 23 29 31 37 41 43<br>    47 53 59 61 67 71 73 79 83 89<br>    97 101 103</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1013 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int M = in.nextInt();\n        int N = in.nextInt();\n        in.close();\n        int current = 0;\n        int[] res = new int[N];\n        for (int i = 2; current &lt; N; i++) {\n            if (isSu(i)) {\n                res[current++] = i;\n                if (current &gt;= M) {\n                    System.out.print(i);\n                    if (current - M + 1 &gt;= 10 &amp;&amp; (current - M + 1) % 10 == 0) {\n                        System.out.println();\n                    } else {\n                        if (current != N)\n                            System.out.print(&quot; &quot;);\n                    }\n                }\n            }\n        }\n    }\n\n    static boolean isSu(int a) {\n        boolean flag = true;\n        for (int i = 2; i &lt;= Math.sqrt(a); i++) {\n            if (a % i == 0) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>列出从0-N的素数,然后截取M-N个</li>\n<li>需要加强白板写代码的能力,尤其是在输出的时候,角标什么的老爱弄错,大脑一锅粥.</li>\n<li>IDE是个好东西,在此处,让人发懒了.</li>\n</ul>\n"},{"layout":"post","title":"乙1015. 德才论 (25)","date":"2018-01-29T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n\n输入格式：\n\n输入第1行给出3个正整数，分别为：N（<=105），即考生总数；L（>=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。\n\n随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。\n\n输出格式：\n\n输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n\n输入样例：\n\t14 60 80\n\t10000001 64 90\n\t10000002 90 60\n\t10000011 85 80\n\t10000003 85 80\n\t10000004 80 85\n\t10000005 82 77\n\t10000006 83 76\n\t10000007 90 78\n\t10000008 75 79\n\t10000009 59 90\n\t10000010 88 45\n\t10000012 80 100\n\t10000013 90 99\n\t10000014 66 60\n输出样例：\n\t12\n\t10000013 90 99\n\t10000012 80 100\n\t10000003 85 80\n\t10000011 85 80\n\t10000004 80 85\n\t10000007 90 78\n\t10000006 83 76\n\t10000005 82 77\n\t10000002 90 60\n\t10000014 66 60\n\t10000008 75 79\n\t10000001 64 90\n\n#### 解答 ####\n \n\timport java.util.Scanner;\n\timport java.util.Set;\n\timport java.util.TreeSet;\n\t \n\tpublic class No1015 {\n\t\n\t\t// 才德全尽谓之圣人\n\t\t// 才德兼亡谓之愚人\n\t\t// 德胜才谓之君子\n\t\t// 才胜德谓之小人\n\t\t// 苟不得圣人，君子而与之\n\t\t// 与其得小人，不若得愚人\n\t\n\t\t// 圣人 > 君子 > 愚人 > 小人\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSet<Stu> best = new TreeSet<>();\n\t\t\tSet<Stu> better = new TreeSet<>();\n\t\t\tSet<Stu> good = new TreeSet<>();\n\t\t\tSet<Stu> normal = new TreeSet<>();\n\t\t\tString standard = in.nextLine();\n\t\t\tString[] split = standard.split(\" \");\n\t\t\tint total = Integer.valueOf(split[0]);\n\t\t\tint normal_score = Integer.valueOf(split[1]);\n\t\t\tint good_score = Integer.valueOf(split[2]);\n\t\n\t\t\tint de, cai;\n\t\n\t\t\twhile (total > 0) {\n\t\t\t\ttotal--;\n\t\t\t\tstandard = in.nextLine();\n\t\t\t\tsplit = standard.split(\" \");\n\t\t\t\tde = Integer.parseInt(split[1]);\n\t\t\t\tcai = Integer.parseInt(split[2]);\n\t\t\t\tif (de >= normal_score && cai >= normal_score) {\n\t\t\t\t\tStu s = new Stu(split[0], split[1], split[2]);\n\t\t\t\t\tif (de >= good_score && cai >= good_score) {\n\t\t\t\t\t\tbest.add(s);\n\t\t\t\t\t} else if (de >= good_score && cai < good_score) {\n\t\t\t\t\t\tbetter.add(s);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (de >= cai) {\n\t\t\t\t\t\t\tgood.add(s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnormal.add(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tin.close();\n\t\t\tSystem.out.println(best.size() + better.size() + good.size() + normal.size());\n\t\t\tfor (Stu stu : best) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\t\tfor (Stu stu : better) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\t\tfor (Stu stu : good) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\t\tfor (Stu stu : normal) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n\t\n\tclass Stu implements Comparable<Stu> {\n\t\tprivate int id;\n\t\tprivate int de, cai;\n\t\t\n\t\tpublic Stu(String id, String de, String cai) {\n\t\t\tsuper();\n\t\t\tthis.id = Integer.valueOf(id);\n\t\t\tthis.de = Integer.valueOf(de);\n\t\t\tthis.cai = Integer.valueOf(cai);\n\t\t}\n\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn id + \" \" + de + \" \" + cai;\n\t\t}\n\t\n\t\t@Override\n\t\tpublic int compareTo(Stu o2) {\n\t\t\tint i = (this.de + this.cai);\n\t\t\tint j = (o2.de + o2.cai);\n\t\t\tif (i == j) {\n\t\t\t\tif (this.de == o2.de) {\n\t\t\t\t\treturn (this.id - o2.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn (o2.de - this.de);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn j - i;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n#### 思路 ####\n\n- 四个层级之间,按优先级排序\n- 层级之内,按分数排序\n\n#### 注意 ####\n\n- 牛客网全测试通过\n- PAT有两个一直超时\n\n#### 结论 ####\n\n如果去PAT考试,那么请选用C语言,多么痛的领悟!\n","source":"_posts/2018-01-29-pat-yi-1015.md","raw":"---\nlayout: post\ntitle:  乙1015. 德才论 (25)\ndate:   2018-01-29\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”\n\n现给出一批考生的德才分数，请根据司马光的理论给出录取排名。\n\n输入格式：\n\n输入第1行给出3个正整数，分别为：N（<=105），即考生总数；L（>=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。\n\n随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。\n\n输出格式：\n\n输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。\n\n输入样例：\n\t14 60 80\n\t10000001 64 90\n\t10000002 90 60\n\t10000011 85 80\n\t10000003 85 80\n\t10000004 80 85\n\t10000005 82 77\n\t10000006 83 76\n\t10000007 90 78\n\t10000008 75 79\n\t10000009 59 90\n\t10000010 88 45\n\t10000012 80 100\n\t10000013 90 99\n\t10000014 66 60\n输出样例：\n\t12\n\t10000013 90 99\n\t10000012 80 100\n\t10000003 85 80\n\t10000011 85 80\n\t10000004 80 85\n\t10000007 90 78\n\t10000006 83 76\n\t10000005 82 77\n\t10000002 90 60\n\t10000014 66 60\n\t10000008 75 79\n\t10000001 64 90\n\n#### 解答 ####\n \n\timport java.util.Scanner;\n\timport java.util.Set;\n\timport java.util.TreeSet;\n\t \n\tpublic class No1015 {\n\t\n\t\t// 才德全尽谓之圣人\n\t\t// 才德兼亡谓之愚人\n\t\t// 德胜才谓之君子\n\t\t// 才胜德谓之小人\n\t\t// 苟不得圣人，君子而与之\n\t\t// 与其得小人，不若得愚人\n\t\n\t\t// 圣人 > 君子 > 愚人 > 小人\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSet<Stu> best = new TreeSet<>();\n\t\t\tSet<Stu> better = new TreeSet<>();\n\t\t\tSet<Stu> good = new TreeSet<>();\n\t\t\tSet<Stu> normal = new TreeSet<>();\n\t\t\tString standard = in.nextLine();\n\t\t\tString[] split = standard.split(\" \");\n\t\t\tint total = Integer.valueOf(split[0]);\n\t\t\tint normal_score = Integer.valueOf(split[1]);\n\t\t\tint good_score = Integer.valueOf(split[2]);\n\t\n\t\t\tint de, cai;\n\t\n\t\t\twhile (total > 0) {\n\t\t\t\ttotal--;\n\t\t\t\tstandard = in.nextLine();\n\t\t\t\tsplit = standard.split(\" \");\n\t\t\t\tde = Integer.parseInt(split[1]);\n\t\t\t\tcai = Integer.parseInt(split[2]);\n\t\t\t\tif (de >= normal_score && cai >= normal_score) {\n\t\t\t\t\tStu s = new Stu(split[0], split[1], split[2]);\n\t\t\t\t\tif (de >= good_score && cai >= good_score) {\n\t\t\t\t\t\tbest.add(s);\n\t\t\t\t\t} else if (de >= good_score && cai < good_score) {\n\t\t\t\t\t\tbetter.add(s);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (de >= cai) {\n\t\t\t\t\t\t\tgood.add(s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnormal.add(s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tin.close();\n\t\t\tSystem.out.println(best.size() + better.size() + good.size() + normal.size());\n\t\t\tfor (Stu stu : best) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\t\tfor (Stu stu : better) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\t\tfor (Stu stu : good) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\t\tfor (Stu stu : normal) {\n\t\t\t\tSystem.out.println(stu.toString());\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n\t\n\tclass Stu implements Comparable<Stu> {\n\t\tprivate int id;\n\t\tprivate int de, cai;\n\t\t\n\t\tpublic Stu(String id, String de, String cai) {\n\t\t\tsuper();\n\t\t\tthis.id = Integer.valueOf(id);\n\t\t\tthis.de = Integer.valueOf(de);\n\t\t\tthis.cai = Integer.valueOf(cai);\n\t\t}\n\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn id + \" \" + de + \" \" + cai;\n\t\t}\n\t\n\t\t@Override\n\t\tpublic int compareTo(Stu o2) {\n\t\t\tint i = (this.de + this.cai);\n\t\t\tint j = (o2.de + o2.cai);\n\t\t\tif (i == j) {\n\t\t\t\tif (this.de == o2.de) {\n\t\t\t\t\treturn (this.id - o2.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn (o2.de - this.de);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn j - i;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n#### 思路 ####\n\n- 四个层级之间,按优先级排序\n- 层级之内,按分数排序\n\n#### 注意 ####\n\n- 牛客网全测试通过\n- PAT有两个一直超时\n\n#### 结论 ####\n\n如果去PAT考试,那么请选用C语言,多么痛的领悟!\n","slug":"pat-yi-1015","published":1,"updated":"2018-01-29T07:43:45.184Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kr009f2sivhk8cgqms","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p>\n<p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>\n<p>输入格式：</p>\n<p>输入第1行给出3个正整数，分别为：N（&lt;=105），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。</p>\n<p>随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。</p>\n<p>输出格式：</p>\n<p>输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>\n<p>输入样例：<br>    14 60 80<br>    10000001 64 90<br>    10000002 90 60<br>    10000011 85 80<br>    10000003 85 80<br>    10000004 80 85<br>    10000005 82 77<br>    10000006 83 76<br>    10000007 90 78<br>    10000008 75 79<br>    10000009 59 90<br>    10000010 88 45<br>    10000012 80 100<br>    10000013 90 99<br>    10000014 66 60<br>输出样例：<br>    12<br>    10000013 90 99<br>    10000012 80 100<br>    10000003 85 80<br>    10000011 85 80<br>    10000004 80 85<br>    10000007 90 78<br>    10000006 83 76<br>    10000005 82 77<br>    10000002 90 60<br>    10000014 66 60<br>    10000008 75 79<br>    10000001 64 90</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class No1015 {\n\n    // 才德全尽谓之圣人\n    // 才德兼亡谓之愚人\n    // 德胜才谓之君子\n    // 才胜德谓之小人\n    // 苟不得圣人，君子而与之\n    // 与其得小人，不若得愚人\n\n    // 圣人 &gt; 君子 &gt; 愚人 &gt; 小人\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        Set&lt;Stu&gt; best = new TreeSet&lt;&gt;();\n        Set&lt;Stu&gt; better = new TreeSet&lt;&gt;();\n        Set&lt;Stu&gt; good = new TreeSet&lt;&gt;();\n        Set&lt;Stu&gt; normal = new TreeSet&lt;&gt;();\n        String standard = in.nextLine();\n        String[] split = standard.split(&quot; &quot;);\n        int total = Integer.valueOf(split[0]);\n        int normal_score = Integer.valueOf(split[1]);\n        int good_score = Integer.valueOf(split[2]);\n\n        int de, cai;\n\n        while (total &gt; 0) {\n            total--;\n            standard = in.nextLine();\n            split = standard.split(&quot; &quot;);\n            de = Integer.parseInt(split[1]);\n            cai = Integer.parseInt(split[2]);\n            if (de &gt;= normal_score &amp;&amp; cai &gt;= normal_score) {\n                Stu s = new Stu(split[0], split[1], split[2]);\n                if (de &gt;= good_score &amp;&amp; cai &gt;= good_score) {\n                    best.add(s);\n                } else if (de &gt;= good_score &amp;&amp; cai &lt; good_score) {\n                    better.add(s);\n                } else {\n                    if (de &gt;= cai) {\n                        good.add(s);\n                    } else {\n                        normal.add(s);\n                    }\n                }\n            } else {\n                continue;\n            }\n        }\n\n        in.close();\n        System.out.println(best.size() + better.size() + good.size() + normal.size());\n        for (Stu stu : best) {\n            System.out.println(stu.toString());\n        }\n        for (Stu stu : better) {\n            System.out.println(stu.toString());\n        }\n        for (Stu stu : good) {\n            System.out.println(stu.toString());\n        }\n        for (Stu stu : normal) {\n            System.out.println(stu.toString());\n        }\n\n    }\n\n}\n\nclass Stu implements Comparable&lt;Stu&gt; {\n    private int id;\n    private int de, cai;\n\n    public Stu(String id, String de, String cai) {\n        super();\n        this.id = Integer.valueOf(id);\n        this.de = Integer.valueOf(de);\n        this.cai = Integer.valueOf(cai);\n    }\n\n    @Override\n    public String toString() {\n        return id + &quot; &quot; + de + &quot; &quot; + cai;\n    }\n\n    @Override\n    public int compareTo(Stu o2) {\n        int i = (this.de + this.cai);\n        int j = (o2.de + o2.cai);\n        if (i == j) {\n            if (this.de == o2.de) {\n                return (this.id - o2.id);\n            } else {\n                return (o2.de - this.de);\n            }\n        } else {\n            return j - i;\n        }\n    }\n}\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>四个层级之间,按优先级排序</li>\n<li>层级之内,按分数排序</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>牛客网全测试通过</li>\n<li>PAT有两个一直超时</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>如果去PAT考试,那么请选用C语言,多么痛的领悟!</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p>\n<p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>\n<p>输入格式：</p>\n<p>输入第1行给出3个正整数，分别为：N（&lt;=105），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。</p>\n<p>随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。</p>\n<p>输出格式：</p>\n<p>输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>\n<p>输入样例：<br>    14 60 80<br>    10000001 64 90<br>    10000002 90 60<br>    10000011 85 80<br>    10000003 85 80<br>    10000004 80 85<br>    10000005 82 77<br>    10000006 83 76<br>    10000007 90 78<br>    10000008 75 79<br>    10000009 59 90<br>    10000010 88 45<br>    10000012 80 100<br>    10000013 90 99<br>    10000014 66 60<br>输出样例：<br>    12<br>    10000013 90 99<br>    10000012 80 100<br>    10000003 85 80<br>    10000011 85 80<br>    10000004 80 85<br>    10000007 90 78<br>    10000006 83 76<br>    10000005 82 77<br>    10000002 90 60<br>    10000014 66 60<br>    10000008 75 79<br>    10000001 64 90</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class No1015 {\n\n    // 才德全尽谓之圣人\n    // 才德兼亡谓之愚人\n    // 德胜才谓之君子\n    // 才胜德谓之小人\n    // 苟不得圣人，君子而与之\n    // 与其得小人，不若得愚人\n\n    // 圣人 &gt; 君子 &gt; 愚人 &gt; 小人\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        Set&lt;Stu&gt; best = new TreeSet&lt;&gt;();\n        Set&lt;Stu&gt; better = new TreeSet&lt;&gt;();\n        Set&lt;Stu&gt; good = new TreeSet&lt;&gt;();\n        Set&lt;Stu&gt; normal = new TreeSet&lt;&gt;();\n        String standard = in.nextLine();\n        String[] split = standard.split(&quot; &quot;);\n        int total = Integer.valueOf(split[0]);\n        int normal_score = Integer.valueOf(split[1]);\n        int good_score = Integer.valueOf(split[2]);\n\n        int de, cai;\n\n        while (total &gt; 0) {\n            total--;\n            standard = in.nextLine();\n            split = standard.split(&quot; &quot;);\n            de = Integer.parseInt(split[1]);\n            cai = Integer.parseInt(split[2]);\n            if (de &gt;= normal_score &amp;&amp; cai &gt;= normal_score) {\n                Stu s = new Stu(split[0], split[1], split[2]);\n                if (de &gt;= good_score &amp;&amp; cai &gt;= good_score) {\n                    best.add(s);\n                } else if (de &gt;= good_score &amp;&amp; cai &lt; good_score) {\n                    better.add(s);\n                } else {\n                    if (de &gt;= cai) {\n                        good.add(s);\n                    } else {\n                        normal.add(s);\n                    }\n                }\n            } else {\n                continue;\n            }\n        }\n\n        in.close();\n        System.out.println(best.size() + better.size() + good.size() + normal.size());\n        for (Stu stu : best) {\n            System.out.println(stu.toString());\n        }\n        for (Stu stu : better) {\n            System.out.println(stu.toString());\n        }\n        for (Stu stu : good) {\n            System.out.println(stu.toString());\n        }\n        for (Stu stu : normal) {\n            System.out.println(stu.toString());\n        }\n\n    }\n\n}\n\nclass Stu implements Comparable&lt;Stu&gt; {\n    private int id;\n    private int de, cai;\n\n    public Stu(String id, String de, String cai) {\n        super();\n        this.id = Integer.valueOf(id);\n        this.de = Integer.valueOf(de);\n        this.cai = Integer.valueOf(cai);\n    }\n\n    @Override\n    public String toString() {\n        return id + &quot; &quot; + de + &quot; &quot; + cai;\n    }\n\n    @Override\n    public int compareTo(Stu o2) {\n        int i = (this.de + this.cai);\n        int j = (o2.de + o2.cai);\n        if (i == j) {\n            if (this.de == o2.de) {\n                return (this.id - o2.id);\n            } else {\n                return (o2.de - this.de);\n            }\n        } else {\n            return j - i;\n        }\n    }\n}\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>四个层级之间,按优先级排序</li>\n<li>层级之内,按分数排序</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>牛客网全测试通过</li>\n<li>PAT有两个一直超时</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>如果去PAT考试,那么请选用C语言,多么痛的领悟!</p>\n"},{"layout":"post","title":"乙1014. 福尔摩斯的约会 (20)","date":"2018-01-22T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母'D'，代表星期四；第2对相同的字符是'E'，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母's'出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。\n\n输入格式：\n\n输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。\n\n输出格式：\n\n在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。\n\n输入样例：\n\t3485djDkxh4hhGE \n\t2984akDfkkkkggEdsb \n\ts&hgsfdk \n\td&Hyscvnm\n输出样例：\n\tTHU 14:04\n#### 解答 ####\n\t\n\timport java.util.Scanner;\n\n\tpublic class No1014 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString weekStr1 = in.nextLine();\n\t\t\tString weekStr2 = in.nextLine();\n\t\t\tString timeStr1 = in.nextLine();\n\t\t\tString timeStr2 = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] week = { \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\" };\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tchar week_c1, week_c2;\n\t\t\tint counts = 0;\n\t\t\tfor (int i = 0; i < Math.min(weekStr1.length(), weekStr2.length()); i++) {\n\t\t\t\tweek_c1 = weekStr1.charAt(i);\n\t\t\t\tweek_c2 = weekStr2.charAt(i);\n\t\n\t\t\t\tif (week_c1 == week_c2) {\n\t\t\t\t\tif (counts == 0 && week_c1 >= 'A' && week_c1 <= 'G') {\n\t\t\t\t\t\tcounts++;\n\t\t\t\t\t\tsb.append(week[week_c1 - 'A']).append(\" \");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (counts == 1) {\n\t\t\t\t\t\tif (week_c1 >= 'A' && week_c1 <= 'N') {\n\t\t\t\t\t\t\tsb.append(week_c1 - 'A' + 10).append(\":\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (Character.isDigit(week_c1)) {\n\t\t\t\t\t\t\tsb.append(\"0\").append(week_c1).append(\":\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < Math.min(timeStr1.length(), timeStr2.length()); i++) {\n\t\t\t\tif (timeStr1.charAt(i) == timeStr2.charAt(i) && (timeStr1.charAt(i) >= 'a' && timeStr1.charAt(i) <= 'z'\n\t\t\t\t\t\t|| timeStr1.charAt(i) >= 'A' && timeStr1.charAt(i) <= 'Z')) {\n\t\t\t\t\tif (i < 10)\n\t\t\t\t\t\tsb.append(\"0\");\n\t\t\t\t\tsb.append(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb.toString());\n\t\t}\n\t\n\t}\n\n\n#### 思路 ####\n\n- 前两行字符串,第一对相同的A-G之间的大写字母,确定星期\n- 前两行字符串,第二对相同的0-9,A-N之间的字符,确定24小时\n- 后两行字符串,第一对相同的a-z,A-Z之间的字母,所在字符串的序号,确定分钟\n- 小时分钟的输出为:HH:MM\n\n#### 注意 ####\n\n- 牛客网全测试通过\n- PAT有两个一直答案错误,经过我深思熟虑一番修改,错误答案,嘎巴一下~增加到了三个!!\n\n","source":"_posts/2018-01-22-pat-yi-1014.md","raw":"---\nlayout: post\ntitle:  乙1014. 福尔摩斯的约会 (20)\ndate:   2018-01-22\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母'D'，代表星期四；第2对相同的字符是'E'，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母's'出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。\n\n输入格式：\n\n输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。\n\n输出格式：\n\n在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。\n\n输入样例：\n\t3485djDkxh4hhGE \n\t2984akDfkkkkggEdsb \n\ts&hgsfdk \n\td&Hyscvnm\n输出样例：\n\tTHU 14:04\n#### 解答 ####\n\t\n\timport java.util.Scanner;\n\n\tpublic class No1014 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString weekStr1 = in.nextLine();\n\t\t\tString weekStr2 = in.nextLine();\n\t\t\tString timeStr1 = in.nextLine();\n\t\t\tString timeStr2 = in.nextLine();\n\t\t\tin.close();\n\t\t\tString[] week = { \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\", \"SUN\" };\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tchar week_c1, week_c2;\n\t\t\tint counts = 0;\n\t\t\tfor (int i = 0; i < Math.min(weekStr1.length(), weekStr2.length()); i++) {\n\t\t\t\tweek_c1 = weekStr1.charAt(i);\n\t\t\t\tweek_c2 = weekStr2.charAt(i);\n\t\n\t\t\t\tif (week_c1 == week_c2) {\n\t\t\t\t\tif (counts == 0 && week_c1 >= 'A' && week_c1 <= 'G') {\n\t\t\t\t\t\tcounts++;\n\t\t\t\t\t\tsb.append(week[week_c1 - 'A']).append(\" \");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (counts == 1) {\n\t\t\t\t\t\tif (week_c1 >= 'A' && week_c1 <= 'N') {\n\t\t\t\t\t\t\tsb.append(week_c1 - 'A' + 10).append(\":\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (Character.isDigit(week_c1)) {\n\t\t\t\t\t\t\tsb.append(\"0\").append(week_c1).append(\":\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < Math.min(timeStr1.length(), timeStr2.length()); i++) {\n\t\t\t\tif (timeStr1.charAt(i) == timeStr2.charAt(i) && (timeStr1.charAt(i) >= 'a' && timeStr1.charAt(i) <= 'z'\n\t\t\t\t\t\t|| timeStr1.charAt(i) >= 'A' && timeStr1.charAt(i) <= 'Z')) {\n\t\t\t\t\tif (i < 10)\n\t\t\t\t\t\tsb.append(\"0\");\n\t\t\t\t\tsb.append(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(sb.toString());\n\t\t}\n\t\n\t}\n\n\n#### 思路 ####\n\n- 前两行字符串,第一对相同的A-G之间的大写字母,确定星期\n- 前两行字符串,第二对相同的0-9,A-N之间的字符,确定24小时\n- 后两行字符串,第一对相同的a-z,A-Z之间的字母,所在字符串的序号,确定分钟\n- 小时分钟的输出为:HH:MM\n\n#### 注意 ####\n\n- 牛客网全测试通过\n- PAT有两个一直答案错误,经过我深思熟虑一番修改,错误答案,嘎巴一下~增加到了三个!!\n\n","slug":"pat-yi-1014","published":1,"updated":"2018-01-29T07:43:40.142Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1ku009i2sivrxztr3ze","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>\n<p>输入格式：</p>\n<p>输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p>\n<p>输出格式：</p>\n<p>在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p>\n<p>输入样例：<br>    3485djDkxh4hhGE<br>    2984akDfkkkkggEdsb<br>    s&amp;hgsfdk<br>    d&amp;Hyscvnm<br>输出样例：<br>    THU 14:04</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1014 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String weekStr1 = in.nextLine();\n        String weekStr2 = in.nextLine();\n        String timeStr1 = in.nextLine();\n        String timeStr2 = in.nextLine();\n        in.close();\n        String[] week = { &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot; };\n        StringBuilder sb = new StringBuilder();\n        char week_c1, week_c2;\n        int counts = 0;\n        for (int i = 0; i &lt; Math.min(weekStr1.length(), weekStr2.length()); i++) {\n            week_c1 = weekStr1.charAt(i);\n            week_c2 = weekStr2.charAt(i);\n\n            if (week_c1 == week_c2) {\n                if (counts == 0 &amp;&amp; week_c1 &gt;= &apos;A&apos; &amp;&amp; week_c1 &lt;= &apos;G&apos;) {\n                    counts++;\n                    sb.append(week[week_c1 - &apos;A&apos;]).append(&quot; &quot;);\n                    continue;\n                }\n\n                if (counts == 1) {\n                    if (week_c1 &gt;= &apos;A&apos; &amp;&amp; week_c1 &lt;= &apos;N&apos;) {\n                        sb.append(week_c1 - &apos;A&apos; + 10).append(&quot;:&quot;);\n                        break;\n                    } else if (Character.isDigit(week_c1)) {\n                        sb.append(&quot;0&quot;).append(week_c1).append(&quot;:&quot;);\n                        break;\n                    } else {\n                        continue;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i &lt; Math.min(timeStr1.length(), timeStr2.length()); i++) {\n            if (timeStr1.charAt(i) == timeStr2.charAt(i) &amp;&amp; (timeStr1.charAt(i) &gt;= &apos;a&apos; &amp;&amp; timeStr1.charAt(i) &lt;= &apos;z&apos;\n                    || timeStr1.charAt(i) &gt;= &apos;A&apos; &amp;&amp; timeStr1.charAt(i) &lt;= &apos;Z&apos;)) {\n                if (i &lt; 10)\n                    sb.append(&quot;0&quot;);\n                sb.append(i);\n                break;\n            }\n        }\n        System.out.print(sb.toString());\n    }\n\n}\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>前两行字符串,第一对相同的A-G之间的大写字母,确定星期</li>\n<li>前两行字符串,第二对相同的0-9,A-N之间的字符,确定24小时</li>\n<li>后两行字符串,第一对相同的a-z,A-Z之间的字母,所在字符串的序号,确定分钟</li>\n<li>小时分钟的输出为:HH:MM</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>牛客网全测试通过</li>\n<li>PAT有两个一直答案错误,经过我深思熟虑一番修改,错误答案,嘎巴一下~增加到了三个!!</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>\n<p>输入格式：</p>\n<p>输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p>\n<p>输出格式：</p>\n<p>在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p>\n<p>输入样例：<br>    3485djDkxh4hhGE<br>    2984akDfkkkkggEdsb<br>    s&amp;hgsfdk<br>    d&amp;Hyscvnm<br>输出样例：<br>    THU 14:04</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1014 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String weekStr1 = in.nextLine();\n        String weekStr2 = in.nextLine();\n        String timeStr1 = in.nextLine();\n        String timeStr2 = in.nextLine();\n        in.close();\n        String[] week = { &quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot; };\n        StringBuilder sb = new StringBuilder();\n        char week_c1, week_c2;\n        int counts = 0;\n        for (int i = 0; i &lt; Math.min(weekStr1.length(), weekStr2.length()); i++) {\n            week_c1 = weekStr1.charAt(i);\n            week_c2 = weekStr2.charAt(i);\n\n            if (week_c1 == week_c2) {\n                if (counts == 0 &amp;&amp; week_c1 &gt;= &apos;A&apos; &amp;&amp; week_c1 &lt;= &apos;G&apos;) {\n                    counts++;\n                    sb.append(week[week_c1 - &apos;A&apos;]).append(&quot; &quot;);\n                    continue;\n                }\n\n                if (counts == 1) {\n                    if (week_c1 &gt;= &apos;A&apos; &amp;&amp; week_c1 &lt;= &apos;N&apos;) {\n                        sb.append(week_c1 - &apos;A&apos; + 10).append(&quot;:&quot;);\n                        break;\n                    } else if (Character.isDigit(week_c1)) {\n                        sb.append(&quot;0&quot;).append(week_c1).append(&quot;:&quot;);\n                        break;\n                    } else {\n                        continue;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i &lt; Math.min(timeStr1.length(), timeStr2.length()); i++) {\n            if (timeStr1.charAt(i) == timeStr2.charAt(i) &amp;&amp; (timeStr1.charAt(i) &gt;= &apos;a&apos; &amp;&amp; timeStr1.charAt(i) &lt;= &apos;z&apos;\n                    || timeStr1.charAt(i) &gt;= &apos;A&apos; &amp;&amp; timeStr1.charAt(i) &lt;= &apos;Z&apos;)) {\n                if (i &lt; 10)\n                    sb.append(&quot;0&quot;);\n                sb.append(i);\n                break;\n            }\n        }\n        System.out.print(sb.toString());\n    }\n\n}\n</code></pre><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>前两行字符串,第一对相同的A-G之间的大写字母,确定星期</li>\n<li>前两行字符串,第二对相同的0-9,A-N之间的字符,确定24小时</li>\n<li>后两行字符串,第一对相同的a-z,A-Z之间的字母,所在字符串的序号,确定分钟</li>\n<li>小时分钟的输出为:HH:MM</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>牛客网全测试通过</li>\n<li>PAT有两个一直答案错误,经过我深思熟虑一番修改,错误答案,嘎巴一下~增加到了三个!!</li>\n</ul>\n"},{"layout":"post","title":"乙1016. 部分A+B (15)","date":"2018-01-29T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。\n\n现给定A、DA、B、DB，请编写程序计算PA + PB。\n\n输入格式：\n\n输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 < A, B < 1010。\n\n输出格式：\n\n在一行中输出PA + PB的值。\n\n输入样例1：\n\t3862767 6 13530293 3\n输出样例1：\n\t399\n输入样例2：\n\t3862767 1 13530293 8\n输出样例2：\n\t0\n\n\n#### 解答 ####\n \nimport java.math.BigDecimal;\nimport java.util.Scanner;\n\n/**\n * No.1016. 部分A+B (15)\n * \n * @author sxx.xu\n *\n */\n\tpublic class No1016 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString source = in.nextLine();\n\t\t\tin.close();\n\t\n\t\t\tString[] split = source.split(\" \");\n\t\t\tString A = split[0];\n\t\t\tString B = split[2];\n\t\t\tStringBuilder PA = new StringBuilder();\n\t\t\tStringBuilder PB = new StringBuilder();\n\t\t\tint i = Integer.valueOf(split[1]);\n\t\t\tint j = Integer.valueOf(split[3]);\n\t\t\tfor (char c : A.toCharArray()) {\n\t\t\t\tif (Integer.valueOf(String.valueOf(c)) == i) {\n\t\t\t\t\tPA.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (char c : B.toCharArray()) {\n\t\t\t\tif (Integer.valueOf(String.valueOf(c)) == j) {\n\t\t\t\t\tPB.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (PA.length() == 0) {\n\t\t\t\tPA.append(\"0\");\n\t\t\t}\n\t\t\tif (PB.length() == 0) {\n\t\t\t\tPB.append(\"0\");\n\t\t\t}\n\t\n\t\t\tBigDecimal res1 = BigDecimal.valueOf(Long.valueOf(PA.toString()));\n\t\t\tBigDecimal res2 = BigDecimal.valueOf(Long.valueOf(PB.toString()));\n\t\n\t\t\tSystem.out.println(res1.add(res2));\n\t\n\t\t}\n\n\t}\n \n\n#### 注意 ####\n\n- int不要溢出了\n\n\n","source":"_posts/2018-01-29-pat-yi-1016.md","raw":"---\nlayout: post\ntitle:  乙1016. 部分A+B (15)\ndate:   2018-01-29\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。\n\n现给定A、DA、B、DB，请编写程序计算PA + PB。\n\n输入格式：\n\n输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 < A, B < 1010。\n\n输出格式：\n\n在一行中输出PA + PB的值。\n\n输入样例1：\n\t3862767 6 13530293 3\n输出样例1：\n\t399\n输入样例2：\n\t3862767 1 13530293 8\n输出样例2：\n\t0\n\n\n#### 解答 ####\n \nimport java.math.BigDecimal;\nimport java.util.Scanner;\n\n/**\n * No.1016. 部分A+B (15)\n * \n * @author sxx.xu\n *\n */\n\tpublic class No1016 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString source = in.nextLine();\n\t\t\tin.close();\n\t\n\t\t\tString[] split = source.split(\" \");\n\t\t\tString A = split[0];\n\t\t\tString B = split[2];\n\t\t\tStringBuilder PA = new StringBuilder();\n\t\t\tStringBuilder PB = new StringBuilder();\n\t\t\tint i = Integer.valueOf(split[1]);\n\t\t\tint j = Integer.valueOf(split[3]);\n\t\t\tfor (char c : A.toCharArray()) {\n\t\t\t\tif (Integer.valueOf(String.valueOf(c)) == i) {\n\t\t\t\t\tPA.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (char c : B.toCharArray()) {\n\t\t\t\tif (Integer.valueOf(String.valueOf(c)) == j) {\n\t\t\t\t\tPB.append(c);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (PA.length() == 0) {\n\t\t\t\tPA.append(\"0\");\n\t\t\t}\n\t\t\tif (PB.length() == 0) {\n\t\t\t\tPB.append(\"0\");\n\t\t\t}\n\t\n\t\t\tBigDecimal res1 = BigDecimal.valueOf(Long.valueOf(PA.toString()));\n\t\t\tBigDecimal res2 = BigDecimal.valueOf(Long.valueOf(PB.toString()));\n\t\n\t\t\tSystem.out.println(res1.add(res2));\n\t\n\t\t}\n\n\t}\n \n\n#### 注意 ####\n\n- int不要溢出了\n\n\n","slug":"pat-yi-1016","published":1,"updated":"2018-01-29T07:43:34.990Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kw009l2sivrb95zxtx","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。</p>\n<p>现给定A、DA、B、DB，请编写程序计算PA + PB。</p>\n<p>输入格式：</p>\n<p>输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 1010。</p>\n<p>输出格式：</p>\n<p>在一行中输出PA + PB的值。</p>\n<p>输入样例1：<br>    3862767 6 13530293 3<br>输出样例1：<br>    399<br>输入样例2：<br>    3862767 1 13530293 8<br>输出样例2：<br>    0</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><p>import java.math.BigDecimal;<br>import java.util.Scanner;</p>\n<p>/**</p>\n<ul>\n<li>No.1016. 部分A+B (15)</li>\n<li></li>\n<li><p>@author sxx.xu<br><em>\n</em>/<br> public class No1016 {</p>\n<pre><code>public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    String source = in.nextLine();\n    in.close();\n\n    String[] split = source.split(&quot; &quot;);\n    String A = split[0];\n    String B = split[2];\n    StringBuilder PA = new StringBuilder();\n    StringBuilder PB = new StringBuilder();\n    int i = Integer.valueOf(split[1]);\n    int j = Integer.valueOf(split[3]);\n    for (char c : A.toCharArray()) {\n        if (Integer.valueOf(String.valueOf(c)) == i) {\n            PA.append(c);\n        }\n    }\n    for (char c : B.toCharArray()) {\n        if (Integer.valueOf(String.valueOf(c)) == j) {\n            PB.append(c);\n        }\n    }\n\n    if (PA.length() == 0) {\n        PA.append(&quot;0&quot;);\n    }\n    if (PB.length() == 0) {\n        PB.append(&quot;0&quot;);\n    }\n\n    BigDecimal res1 = BigDecimal.valueOf(Long.valueOf(PA.toString()));\n    BigDecimal res2 = BigDecimal.valueOf(Long.valueOf(PB.toString()));\n\n    System.out.println(res1.add(res2));\n\n}\n</code></pre><p> }</p>\n</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>int不要溢出了</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。</p>\n<p>现给定A、DA、B、DB，请编写程序计算PA + PB。</p>\n<p>输入格式：</p>\n<p>输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 1010。</p>\n<p>输出格式：</p>\n<p>在一行中输出PA + PB的值。</p>\n<p>输入样例1：<br>    3862767 6 13530293 3<br>输出样例1：<br>    399<br>输入样例2：<br>    3862767 1 13530293 8<br>输出样例2：<br>    0</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><p>import java.math.BigDecimal;<br>import java.util.Scanner;</p>\n<p>/**</p>\n<ul>\n<li>No.1016. 部分A+B (15)</li>\n<li></li>\n<li><p>@author sxx.xu<br><em>\n</em>/<br> public class No1016 {</p>\n<pre><code>public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    String source = in.nextLine();\n    in.close();\n\n    String[] split = source.split(&quot; &quot;);\n    String A = split[0];\n    String B = split[2];\n    StringBuilder PA = new StringBuilder();\n    StringBuilder PB = new StringBuilder();\n    int i = Integer.valueOf(split[1]);\n    int j = Integer.valueOf(split[3]);\n    for (char c : A.toCharArray()) {\n        if (Integer.valueOf(String.valueOf(c)) == i) {\n            PA.append(c);\n        }\n    }\n    for (char c : B.toCharArray()) {\n        if (Integer.valueOf(String.valueOf(c)) == j) {\n            PB.append(c);\n        }\n    }\n\n    if (PA.length() == 0) {\n        PA.append(&quot;0&quot;);\n    }\n    if (PB.length() == 0) {\n        PB.append(&quot;0&quot;);\n    }\n\n    BigDecimal res1 = BigDecimal.valueOf(Long.valueOf(PA.toString()));\n    BigDecimal res2 = BigDecimal.valueOf(Long.valueOf(PB.toString()));\n\n    System.out.println(res1.add(res2));\n\n}\n</code></pre><p> }</p>\n</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>int不要溢出了</li>\n</ul>\n"},{"layout":"post","title":"乙1018. 锤子剪刀布 (20)","date":"2018-01-30T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：\n\n![图示](/images/7r_muvaqb4myb9.jpg)\n\n现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n\n输入格式：\n\n输入第1行给出正整数N（<=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。\n\n输出格式：\n\n输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。\n\n输入样例：\n\t10\n\tC J\n\tJ B\n\tC B\n\tB B\n\tB C\n\tC C\n\tC B\n\tJ B\n\tB C\n\tJ J\n输出样例：\n\t5 3 2\n\t2 3 5\n\tB B\n\n#### 解答 ####\n\t\n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1018. 锤子剪刀布 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1018 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint nums = Integer.valueOf(in.nextLine());\n\t\t\tString source;\n\t\t\tString[] split;\n\t\t\tint[] res = { 0, 0, 0 };\n\t\t\tint[] resA = { 0, 0, 0 };\n\t\t\tint[] resB = { 0, 0, 0 };\n\t\t\twhile (nums > 0) {\n\t\t\t\tnums--;\n\t\t\t\tsource = in.nextLine();\n\t\t\t\tsplit = source.split(\" \");\n\t\t\t\tif (split[0].equals(split[1])) {\n\t\t\t\t\tres[1]++;\n\t\t\t\t} else {\n\t\t\t\t\tif (judge(split[0], split[1])) {\n\t\t\t\t\t\tres[0]++;\n\t\t\t\t\t\tif (split[0].equals(\"B\")) {\n\t\t\t\t\t\t\tresA[0]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[0].equals(\"C\")) {\n\t\t\t\t\t\t\tresA[1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[0].equals(\"J\")) {\n\t\t\t\t\t\t\tresA[2]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres[2]++;\n\t\t\t\t\t\tif (split[1].equals(\"B\")) {\n\t\t\t\t\t\t\tresB[0]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[1].equals(\"C\")) {\n\t\t\t\t\t\t\tresB[1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[1].equals(\"J\")) {\n\t\t\t\t\t\t\tresB[2]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\t\tSystem.out.println(res[0] + \" \" + res[1] + \" \" + res[2]);\n\t\t\tSystem.out.println(res[2] + \" \" + res[1] + \" \" + res[0]);\n\t\t\tSystem.out.print(getMax(resA) + \" \" + getMax(resB));\n\t\t}\n\t\n\t\tstatic String getMax(int[] res) {\n\t\t\tString[] ans = { \"B\", \"C\", \"J\" };\n\t\t\tint max = res[0];\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (res[i] > max) {\n\t\t\t\t\tmax = res[i];\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans[index];\n\t\t}\n\t\n\t\t/**\n\t\t * \n\t\t * @param s1\n\t\t * @param s2\n\t\t * @return true if s1 > s2\n\t\t */\n\t\tstatic boolean judge(String s1, String s2) {\n\t\t\tboolean flag = false;\n\t\t\tif (s1.equals(\"C\")) {\n\t\t\t\tif (s2.equals(\"J\"))\n\t\t\t\t\tflag = true;\n\t\t\t\tif (s2.equals(\"B\"))\n\t\t\t\t\tflag = false;\n\t\t\t} else if (s1.equals(\"J\")) {\n\t\t\t\tif (s2.equals(\"B\"))\n\t\t\t\t\tflag = true;\n\t\t\t\tif (s2.equals(\"J\"))\n\t\t\t\t\tflag = false;\n\t\t\t} else if (s1.equals(\"B\")) {\n\t\t\t\tif (s2.equals(\"J\"))\n\t\t\t\t\tflag = false;\n\t\t\t\tif (s2.equals(\"C\"))\n\t\t\t\t\tflag = true;\n\t\t\t}\n\t\t\treturn flag;\n\t\t}\n\t}\n\n\n \n\n\n","source":"_posts/2018-01-30-pat-yi-1018.md","raw":"---\nlayout: post\ntitle:  乙1018. 锤子剪刀布 (20)\ndate:   2018-01-30\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：\n\n![图示](/images/7r_muvaqb4myb9.jpg)\n\n现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。\n\n输入格式：\n\n输入第1行给出正整数N（<=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。\n\n输出格式：\n\n输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。\n\n输入样例：\n\t10\n\tC J\n\tJ B\n\tC B\n\tB B\n\tB C\n\tC C\n\tC B\n\tJ B\n\tB C\n\tJ J\n输出样例：\n\t5 3 2\n\t2 3 5\n\tB B\n\n#### 解答 ####\n\t\n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1018. 锤子剪刀布 (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1018 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint nums = Integer.valueOf(in.nextLine());\n\t\t\tString source;\n\t\t\tString[] split;\n\t\t\tint[] res = { 0, 0, 0 };\n\t\t\tint[] resA = { 0, 0, 0 };\n\t\t\tint[] resB = { 0, 0, 0 };\n\t\t\twhile (nums > 0) {\n\t\t\t\tnums--;\n\t\t\t\tsource = in.nextLine();\n\t\t\t\tsplit = source.split(\" \");\n\t\t\t\tif (split[0].equals(split[1])) {\n\t\t\t\t\tres[1]++;\n\t\t\t\t} else {\n\t\t\t\t\tif (judge(split[0], split[1])) {\n\t\t\t\t\t\tres[0]++;\n\t\t\t\t\t\tif (split[0].equals(\"B\")) {\n\t\t\t\t\t\t\tresA[0]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[0].equals(\"C\")) {\n\t\t\t\t\t\t\tresA[1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[0].equals(\"J\")) {\n\t\t\t\t\t\t\tresA[2]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres[2]++;\n\t\t\t\t\t\tif (split[1].equals(\"B\")) {\n\t\t\t\t\t\t\tresB[0]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[1].equals(\"C\")) {\n\t\t\t\t\t\t\tresB[1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (split[1].equals(\"J\")) {\n\t\t\t\t\t\t\tresB[2]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.close();\n\t\t\tSystem.out.println(res[0] + \" \" + res[1] + \" \" + res[2]);\n\t\t\tSystem.out.println(res[2] + \" \" + res[1] + \" \" + res[0]);\n\t\t\tSystem.out.print(getMax(resA) + \" \" + getMax(resB));\n\t\t}\n\t\n\t\tstatic String getMax(int[] res) {\n\t\t\tString[] ans = { \"B\", \"C\", \"J\" };\n\t\t\tint max = res[0];\n\t\t\tint index = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (res[i] > max) {\n\t\t\t\t\tmax = res[i];\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans[index];\n\t\t}\n\t\n\t\t/**\n\t\t * \n\t\t * @param s1\n\t\t * @param s2\n\t\t * @return true if s1 > s2\n\t\t */\n\t\tstatic boolean judge(String s1, String s2) {\n\t\t\tboolean flag = false;\n\t\t\tif (s1.equals(\"C\")) {\n\t\t\t\tif (s2.equals(\"J\"))\n\t\t\t\t\tflag = true;\n\t\t\t\tif (s2.equals(\"B\"))\n\t\t\t\t\tflag = false;\n\t\t\t} else if (s1.equals(\"J\")) {\n\t\t\t\tif (s2.equals(\"B\"))\n\t\t\t\t\tflag = true;\n\t\t\t\tif (s2.equals(\"J\"))\n\t\t\t\t\tflag = false;\n\t\t\t} else if (s1.equals(\"B\")) {\n\t\t\t\tif (s2.equals(\"J\"))\n\t\t\t\t\tflag = false;\n\t\t\t\tif (s2.equals(\"C\"))\n\t\t\t\t\tflag = true;\n\t\t\t}\n\t\t\treturn flag;\n\t\t}\n\t}\n\n\n \n\n\n","slug":"pat-yi-1018","published":1,"updated":"2018-01-31T09:46:20.872Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1kz009o2siv8fqkytzh","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p>\n<p><img src=\"/images/7r_muvaqb4myb9.jpg\" alt=\"图示\"></p>\n<p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>\n<p>输入格式：</p>\n<p>输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。</p>\n<p>输出格式：</p>\n<p>输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。</p>\n<p>输入样例：<br>    10<br>    C J<br>    J B<br>    C B<br>    B B<br>    B C<br>    C C<br>    C B<br>    J B<br>    B C<br>    J J<br>输出样例：<br>    5 3 2<br>    2 3 5<br>    B B</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1018. 锤子剪刀布 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1018 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int nums = Integer.valueOf(in.nextLine());\n        String source;\n        String[] split;\n        int[] res = { 0, 0, 0 };\n        int[] resA = { 0, 0, 0 };\n        int[] resB = { 0, 0, 0 };\n        while (nums &gt; 0) {\n            nums--;\n            source = in.nextLine();\n            split = source.split(&quot; &quot;);\n            if (split[0].equals(split[1])) {\n                res[1]++;\n            } else {\n                if (judge(split[0], split[1])) {\n                    res[0]++;\n                    if (split[0].equals(&quot;B&quot;)) {\n                        resA[0]++;\n                    }\n                    if (split[0].equals(&quot;C&quot;)) {\n                        resA[1]++;\n                    }\n                    if (split[0].equals(&quot;J&quot;)) {\n                        resA[2]++;\n                    }\n                } else {\n                    res[2]++;\n                    if (split[1].equals(&quot;B&quot;)) {\n                        resB[0]++;\n                    }\n                    if (split[1].equals(&quot;C&quot;)) {\n                        resB[1]++;\n                    }\n                    if (split[1].equals(&quot;J&quot;)) {\n                        resB[2]++;\n                    }\n                }\n            }\n        }\n        in.close();\n        System.out.println(res[0] + &quot; &quot; + res[1] + &quot; &quot; + res[2]);\n        System.out.println(res[2] + &quot; &quot; + res[1] + &quot; &quot; + res[0]);\n        System.out.print(getMax(resA) + &quot; &quot; + getMax(resB));\n    }\n\n    static String getMax(int[] res) {\n        String[] ans = { &quot;B&quot;, &quot;C&quot;, &quot;J&quot; };\n        int max = res[0];\n        int index = 0;\n        for (int i = 0; i &lt; 3; i++) {\n            if (res[i] &gt; max) {\n                max = res[i];\n                index = i;\n            }\n        }\n        return ans[index];\n    }\n\n    /**\n     * \n     * @param s1\n     * @param s2\n     * @return true if s1 &gt; s2\n     */\n    static boolean judge(String s1, String s2) {\n        boolean flag = false;\n        if (s1.equals(&quot;C&quot;)) {\n            if (s2.equals(&quot;J&quot;))\n                flag = true;\n            if (s2.equals(&quot;B&quot;))\n                flag = false;\n        } else if (s1.equals(&quot;J&quot;)) {\n            if (s2.equals(&quot;B&quot;))\n                flag = true;\n            if (s2.equals(&quot;J&quot;))\n                flag = false;\n        } else if (s1.equals(&quot;B&quot;)) {\n            if (s2.equals(&quot;J&quot;))\n                flag = false;\n            if (s2.equals(&quot;C&quot;))\n                flag = true;\n        }\n        return flag;\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p>\n<p><img src=\"/images/7r_muvaqb4myb9.jpg\" alt=\"图示\"></p>\n<p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>\n<p>输入格式：</p>\n<p>输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。</p>\n<p>输出格式：</p>\n<p>输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。</p>\n<p>输入样例：<br>    10<br>    C J<br>    J B<br>    C B<br>    B B<br>    B C<br>    C C<br>    C B<br>    J B<br>    B C<br>    J J<br>输出样例：<br>    5 3 2<br>    2 3 5<br>    B B</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\n/**\n * No.1018. 锤子剪刀布 (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1018 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int nums = Integer.valueOf(in.nextLine());\n        String source;\n        String[] split;\n        int[] res = { 0, 0, 0 };\n        int[] resA = { 0, 0, 0 };\n        int[] resB = { 0, 0, 0 };\n        while (nums &gt; 0) {\n            nums--;\n            source = in.nextLine();\n            split = source.split(&quot; &quot;);\n            if (split[0].equals(split[1])) {\n                res[1]++;\n            } else {\n                if (judge(split[0], split[1])) {\n                    res[0]++;\n                    if (split[0].equals(&quot;B&quot;)) {\n                        resA[0]++;\n                    }\n                    if (split[0].equals(&quot;C&quot;)) {\n                        resA[1]++;\n                    }\n                    if (split[0].equals(&quot;J&quot;)) {\n                        resA[2]++;\n                    }\n                } else {\n                    res[2]++;\n                    if (split[1].equals(&quot;B&quot;)) {\n                        resB[0]++;\n                    }\n                    if (split[1].equals(&quot;C&quot;)) {\n                        resB[1]++;\n                    }\n                    if (split[1].equals(&quot;J&quot;)) {\n                        resB[2]++;\n                    }\n                }\n            }\n        }\n        in.close();\n        System.out.println(res[0] + &quot; &quot; + res[1] + &quot; &quot; + res[2]);\n        System.out.println(res[2] + &quot; &quot; + res[1] + &quot; &quot; + res[0]);\n        System.out.print(getMax(resA) + &quot; &quot; + getMax(resB));\n    }\n\n    static String getMax(int[] res) {\n        String[] ans = { &quot;B&quot;, &quot;C&quot;, &quot;J&quot; };\n        int max = res[0];\n        int index = 0;\n        for (int i = 0; i &lt; 3; i++) {\n            if (res[i] &gt; max) {\n                max = res[i];\n                index = i;\n            }\n        }\n        return ans[index];\n    }\n\n    /**\n     * \n     * @param s1\n     * @param s2\n     * @return true if s1 &gt; s2\n     */\n    static boolean judge(String s1, String s2) {\n        boolean flag = false;\n        if (s1.equals(&quot;C&quot;)) {\n            if (s2.equals(&quot;J&quot;))\n                flag = true;\n            if (s2.equals(&quot;B&quot;))\n                flag = false;\n        } else if (s1.equals(&quot;J&quot;)) {\n            if (s2.equals(&quot;B&quot;))\n                flag = true;\n            if (s2.equals(&quot;J&quot;))\n                flag = false;\n        } else if (s1.equals(&quot;B&quot;)) {\n            if (s2.equals(&quot;J&quot;))\n                flag = false;\n            if (s2.equals(&quot;C&quot;))\n                flag = true;\n        }\n        return flag;\n    }\n}\n</code></pre>"},{"layout":"post","title":"乙1017. A除以B (20)","date":"2018-01-29T00:00:00.000Z","_content":" \n\n#### 题目 ####\n\n本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。\n\n输入格式：\n\n输入在1行中依次给出A和B，中间以1空格分隔。\n\n输出格式：\n\n在1行中依次输出Q和R，中间以1空格分隔。\n\n输入样例：\n\t123456789050987654321 7\n输出样例：\n\t17636684150141093474 3\n\n#### 解答 ####\n\t \n\timport java.math.BigDecimal;\n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1017. A除以B (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1017 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString source = in.nextLine();\n\t\t\tin.close();\n\t\n\t\t\tString[] split = source.split(\" \");\n\t\t\tBigDecimal A = new BigDecimal(split[0]);\n\t\t\tBigDecimal B = new BigDecimal(split[1]);\n\t\n\t\t\tBigDecimal[] results = A.divideAndRemainder(B);\n\t\t\tSystem.out.print(results[0] + \" \" + results[1]);\n\t\t}\n\t}\n\n\n#### 注意 ####\n\n- 参考Effective Java 第48条:如果需要精确的答案,避免使用float和double\n\n\n","source":"_posts/2018-01-29-pat-yi-1017.md","raw":"---\nlayout: post\ntitle:  乙1017. A除以B (20)\ndate:   2018-01-29\ncategories: Algorithm\ntag: [算法,PAT]\n---\n \n\n#### 题目 ####\n\n本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。\n\n输入格式：\n\n输入在1行中依次给出A和B，中间以1空格分隔。\n\n输出格式：\n\n在1行中依次输出Q和R，中间以1空格分隔。\n\n输入样例：\n\t123456789050987654321 7\n输出样例：\n\t17636684150141093474 3\n\n#### 解答 ####\n\t \n\timport java.math.BigDecimal;\n\timport java.util.Scanner;\n\t\n\t/**\n\t * No.1017. A除以B (20)\n\t * \n\t * @author sxx.xu\n\t *\n\t */\n\tpublic class No1017 {\n\t\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tString source = in.nextLine();\n\t\t\tin.close();\n\t\n\t\t\tString[] split = source.split(\" \");\n\t\t\tBigDecimal A = new BigDecimal(split[0]);\n\t\t\tBigDecimal B = new BigDecimal(split[1]);\n\t\n\t\t\tBigDecimal[] results = A.divideAndRemainder(B);\n\t\t\tSystem.out.print(results[0] + \" \" + results[1]);\n\t\t}\n\t}\n\n\n#### 注意 ####\n\n- 参考Effective Java 第48条:如果需要精确的答案,避免使用float和double\n\n\n","slug":"pat-yi-1017","published":1,"updated":"2018-01-29T07:43:12.137Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1l1009r2sivil83j4dj","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。</p>\n<p>输入格式：</p>\n<p>输入在1行中依次给出A和B，中间以1空格分隔。</p>\n<p>输出格式：</p>\n<p>在1行中依次输出Q和R，中间以1空格分隔。</p>\n<p>输入样例：<br>    123456789050987654321 7<br>输出样例：<br>    17636684150141093474 3</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.math.BigDecimal;\nimport java.util.Scanner;\n\n/**\n * No.1017. A除以B (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1017 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String source = in.nextLine();\n        in.close();\n\n        String[] split = source.split(&quot; &quot;);\n        BigDecimal A = new BigDecimal(split[0]);\n        BigDecimal B = new BigDecimal(split[1]);\n\n        BigDecimal[] results = A.divideAndRemainder(B);\n        System.out.print(results[0] + &quot; &quot; + results[1]);\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>参考Effective Java 第48条:如果需要精确的答案,避免使用float和double</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。</p>\n<p>输入格式：</p>\n<p>输入在1行中依次给出A和B，中间以1空格分隔。</p>\n<p>输出格式：</p>\n<p>在1行中依次输出Q和R，中间以1空格分隔。</p>\n<p>输入样例：<br>    123456789050987654321 7<br>输出样例：<br>    17636684150141093474 3</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.math.BigDecimal;\nimport java.util.Scanner;\n\n/**\n * No.1017. A除以B (20)\n * \n * @author sxx.xu\n *\n */\npublic class No1017 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String source = in.nextLine();\n        in.close();\n\n        String[] split = source.split(&quot; &quot;);\n        BigDecimal A = new BigDecimal(split[0]);\n        BigDecimal B = new BigDecimal(split[1]);\n\n        BigDecimal[] results = A.divideAndRemainder(B);\n        System.out.print(results[0] + &quot; &quot; + results[1]);\n    }\n}\n</code></pre><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>参考Effective Java 第48条:如果需要精确的答案,避免使用float和double</li>\n</ul>\n"},{"layout":"post","title":"JVM中的final","date":"2018-01-31T00:00:00.000Z","_content":"\n最近用`kotlin`,配合`anko`,写Android非常舒服了.每次申请变量的时候,如果该变量在后续没有被重新赋值,而只是引用,`kotlin`此时会建议把变量标记为`val`的,即`final`的. \n\n#### 基础知识 ####\n\n\tfinal可以修饰类,属性和方法.\n- 表示类不可继承\n- 对于基本类型,值和引用都不可变;对于引用类型,引用不可变,引用指向的对象是可变的\n- 对于方法,表示该方法不允许重写\n\n#### final的使用场景 ####\n\n一:工具类\n\t\n\tpublic final class Tools {\n\t\tprivate Tools() {\n\t\t}\n\t\n\t\tpublic static final void fun() {\n\t\t}\n\t}\n\n同时在类和方法上使用了final,禁止此类的扩展,防止同事手误继承,防止反射回调.\n\n二:同步相关\n\t\n\tpublic class Test {\n\t\tpublic static int VAL = 1;\n\t}\n\n\n\tpublic class Demo {\n\t\tvoid fun() {\n\t\t\tfinal int temp = Test.VAL;\n\t\t}\n\t}\n\nDemo类中的方法,引用了Test中的静态变量.多线程环境下,使用final修饰局部变量,保证同一个方法中,拿到的值是一致的.\n\n三:避免修改\n\n一个局部变量,如果不希望被修改,把他定义为final的.可以借助编译器的帮助,检测被修改(误改)的状态.\n\n\n#### final在JVM中 ####\n\n在能够通过编译的前提下,无论局部变量声明时带不带final关键字修饰,对其访问的效率都一样.\n重复访问一个局部变量比重复访问一个成员或静态变量快,即便将其final修饰符去掉,效果也一样.\n\t\n如下代码:\n\n\tclass Fish{\n\t\tstatic int foo() {\n\t  \tfinal int a = someValueA();\n\t \tfinal int b = someValueB();\n\t  \treturn a + b;  \n\t}\n\tstatic int someValueA(){return 1;}\n\tstatic int someValueB(){return 2;}\n\t}\n\njavac编译该类,使用`javap -c Fish`,查看其字节码文件,发现是一样的.\n\t\n\t\t Code:\n\t    0: invokestatic  #2\n\t    3: istore_0\n\t    4: invokestatic  #3\n\t    7: istore_1\n\t    8: iload_0\n\t    9: iload_1\n\t   10: iadd\n\t   11: ireturn\n\n所以,在局部变量需要计算得到结果的情况下,final的作用在编译阶段很小.\n\n\n考虑另一种情况,局部变量指向常量的情况:\n\n\tclass fish{\n\t\tstatic int foo() {\n\t    int a =1;\n\t    int b = 2;\n\t  \treturn a + b;  \n\t\t}\n\t}\n\t\n\n字节码:\n\n\tstatic int foo();\n    Code:\n       0: iconst_1\n       1: istore_0\n       2: iconst_2\n       3: istore_1\n       4: iload_0\n       5: iload_1\n       6: iadd\n       7: ireturn\n\n--------------\n\n\tclass fish{\n\t\tstatic int foo() {\n  \t\tfinal int a =1;\n\t   \tfinal  int b = 2;\n\t  \treturn a + b;  \n\t\t}\n\t}\n\n字节码:\n\t static int foo();\n\t   Code:\n\t      0: iconst_3\n\t      1: ireturn\n\n带有final的局部变量指向常量时,编译出的字节码,相当于如下代码的编译:\n\t\n\tstatic int foo3() {\n\t  return 5;\n\t}\n\n在Java语言规范里,称为常量折叠.[详情](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.4).","source":"_posts/2018-01-31-final_in_JVM.md","raw":"---\nlayout: post\ntitle:  JVM中的final\ndate:   2018-01-31\ncategories: JAVA & kotlin\ntag: [JVM]\n---\n\n最近用`kotlin`,配合`anko`,写Android非常舒服了.每次申请变量的时候,如果该变量在后续没有被重新赋值,而只是引用,`kotlin`此时会建议把变量标记为`val`的,即`final`的. \n\n#### 基础知识 ####\n\n\tfinal可以修饰类,属性和方法.\n- 表示类不可继承\n- 对于基本类型,值和引用都不可变;对于引用类型,引用不可变,引用指向的对象是可变的\n- 对于方法,表示该方法不允许重写\n\n#### final的使用场景 ####\n\n一:工具类\n\t\n\tpublic final class Tools {\n\t\tprivate Tools() {\n\t\t}\n\t\n\t\tpublic static final void fun() {\n\t\t}\n\t}\n\n同时在类和方法上使用了final,禁止此类的扩展,防止同事手误继承,防止反射回调.\n\n二:同步相关\n\t\n\tpublic class Test {\n\t\tpublic static int VAL = 1;\n\t}\n\n\n\tpublic class Demo {\n\t\tvoid fun() {\n\t\t\tfinal int temp = Test.VAL;\n\t\t}\n\t}\n\nDemo类中的方法,引用了Test中的静态变量.多线程环境下,使用final修饰局部变量,保证同一个方法中,拿到的值是一致的.\n\n三:避免修改\n\n一个局部变量,如果不希望被修改,把他定义为final的.可以借助编译器的帮助,检测被修改(误改)的状态.\n\n\n#### final在JVM中 ####\n\n在能够通过编译的前提下,无论局部变量声明时带不带final关键字修饰,对其访问的效率都一样.\n重复访问一个局部变量比重复访问一个成员或静态变量快,即便将其final修饰符去掉,效果也一样.\n\t\n如下代码:\n\n\tclass Fish{\n\t\tstatic int foo() {\n\t  \tfinal int a = someValueA();\n\t \tfinal int b = someValueB();\n\t  \treturn a + b;  \n\t}\n\tstatic int someValueA(){return 1;}\n\tstatic int someValueB(){return 2;}\n\t}\n\njavac编译该类,使用`javap -c Fish`,查看其字节码文件,发现是一样的.\n\t\n\t\t Code:\n\t    0: invokestatic  #2\n\t    3: istore_0\n\t    4: invokestatic  #3\n\t    7: istore_1\n\t    8: iload_0\n\t    9: iload_1\n\t   10: iadd\n\t   11: ireturn\n\n所以,在局部变量需要计算得到结果的情况下,final的作用在编译阶段很小.\n\n\n考虑另一种情况,局部变量指向常量的情况:\n\n\tclass fish{\n\t\tstatic int foo() {\n\t    int a =1;\n\t    int b = 2;\n\t  \treturn a + b;  \n\t\t}\n\t}\n\t\n\n字节码:\n\n\tstatic int foo();\n    Code:\n       0: iconst_1\n       1: istore_0\n       2: iconst_2\n       3: istore_1\n       4: iload_0\n       5: iload_1\n       6: iadd\n       7: ireturn\n\n--------------\n\n\tclass fish{\n\t\tstatic int foo() {\n  \t\tfinal int a =1;\n\t   \tfinal  int b = 2;\n\t  \treturn a + b;  \n\t\t}\n\t}\n\n字节码:\n\t static int foo();\n\t   Code:\n\t      0: iconst_3\n\t      1: ireturn\n\n带有final的局部变量指向常量时,编译出的字节码,相当于如下代码的编译:\n\t\n\tstatic int foo3() {\n\t  return 5;\n\t}\n\n在Java语言规范里,称为常量折叠.[详情](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.4).","slug":"final_in_JVM","published":1,"updated":"2018-01-31T08:30:49.864Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1l3009u2sivebyp3gij","content":"<p>最近用<code>kotlin</code>,配合<code>anko</code>,写Android非常舒服了.每次申请变量的时候,如果该变量在后续没有被重新赋值,而只是引用,<code>kotlin</code>此时会建议把变量标记为<code>val</code>的,即<code>final</code>的. </p>\n<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><pre><code>final可以修饰类,属性和方法.\n</code></pre><ul>\n<li>表示类不可继承</li>\n<li>对于基本类型,值和引用都不可变;对于引用类型,引用不可变,引用指向的对象是可变的</li>\n<li>对于方法,表示该方法不允许重写</li>\n</ul>\n<h4 id=\"final的使用场景\"><a href=\"#final的使用场景\" class=\"headerlink\" title=\"final的使用场景\"></a>final的使用场景</h4><p>一:工具类</p>\n<pre><code>public final class Tools {\n    private Tools() {\n    }\n\n    public static final void fun() {\n    }\n}\n</code></pre><p>同时在类和方法上使用了final,禁止此类的扩展,防止同事手误继承,防止反射回调.</p>\n<p>二:同步相关</p>\n<pre><code>public class Test {\n    public static int VAL = 1;\n}\n\n\npublic class Demo {\n    void fun() {\n        final int temp = Test.VAL;\n    }\n}\n</code></pre><p>Demo类中的方法,引用了Test中的静态变量.多线程环境下,使用final修饰局部变量,保证同一个方法中,拿到的值是一致的.</p>\n<p>三:避免修改</p>\n<p>一个局部变量,如果不希望被修改,把他定义为final的.可以借助编译器的帮助,检测被修改(误改)的状态.</p>\n<h4 id=\"final在JVM中\"><a href=\"#final在JVM中\" class=\"headerlink\" title=\"final在JVM中\"></a>final在JVM中</h4><p>在能够通过编译的前提下,无论局部变量声明时带不带final关键字修饰,对其访问的效率都一样.<br>重复访问一个局部变量比重复访问一个成员或静态变量快,即便将其final修饰符去掉,效果也一样.</p>\n<p>如下代码:</p>\n<pre><code>class Fish{\n    static int foo() {\n      final int a = someValueA();\n     final int b = someValueB();\n      return a + b;  \n}\nstatic int someValueA(){return 1;}\nstatic int someValueB(){return 2;}\n}\n</code></pre><p>javac编译该类,使用<code>javap -c Fish</code>,查看其字节码文件,发现是一样的.</p>\n<pre><code>  Code:\n 0: invokestatic  #2\n 3: istore_0\n 4: invokestatic  #3\n 7: istore_1\n 8: iload_0\n 9: iload_1\n10: iadd\n11: ireturn\n</code></pre><p>所以,在局部变量需要计算得到结果的情况下,final的作用在编译阶段很小.</p>\n<p>考虑另一种情况,局部变量指向常量的情况:</p>\n<pre><code>class fish{\n    static int foo() {\n    int a =1;\n    int b = 2;\n      return a + b;  \n    }\n}\n</code></pre><p>字节码:</p>\n<pre><code>static int foo();\nCode:\n   0: iconst_1\n   1: istore_0\n   2: iconst_2\n   3: istore_1\n   4: iload_0\n   5: iload_1\n   6: iadd\n   7: ireturn\n</code></pre><hr>\n<pre><code>class fish{\n    static int foo() {\n      final int a =1;\n       final  int b = 2;\n      return a + b;  \n    }\n}\n</code></pre><p>字节码:<br>     static int foo();<br>       Code:<br>          0: iconst_3<br>          1: ireturn</p>\n<p>带有final的局部变量指向常量时,编译出的字节码,相当于如下代码的编译:</p>\n<pre><code>static int foo3() {\n  return 5;\n}\n</code></pre><p>在Java语言规范里,称为常量折叠.<a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.4\" target=\"_blank\" rel=\"external\">详情</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近用<code>kotlin</code>,配合<code>anko</code>,写Android非常舒服了.每次申请变量的时候,如果该变量在后续没有被重新赋值,而只是引用,<code>kotlin</code>此时会建议把变量标记为<code>val</code>的,即<code>final</code>的. </p>\n<h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><pre><code>final可以修饰类,属性和方法.\n</code></pre><ul>\n<li>表示类不可继承</li>\n<li>对于基本类型,值和引用都不可变;对于引用类型,引用不可变,引用指向的对象是可变的</li>\n<li>对于方法,表示该方法不允许重写</li>\n</ul>\n<h4 id=\"final的使用场景\"><a href=\"#final的使用场景\" class=\"headerlink\" title=\"final的使用场景\"></a>final的使用场景</h4><p>一:工具类</p>\n<pre><code>public final class Tools {\n    private Tools() {\n    }\n\n    public static final void fun() {\n    }\n}\n</code></pre><p>同时在类和方法上使用了final,禁止此类的扩展,防止同事手误继承,防止反射回调.</p>\n<p>二:同步相关</p>\n<pre><code>public class Test {\n    public static int VAL = 1;\n}\n\n\npublic class Demo {\n    void fun() {\n        final int temp = Test.VAL;\n    }\n}\n</code></pre><p>Demo类中的方法,引用了Test中的静态变量.多线程环境下,使用final修饰局部变量,保证同一个方法中,拿到的值是一致的.</p>\n<p>三:避免修改</p>\n<p>一个局部变量,如果不希望被修改,把他定义为final的.可以借助编译器的帮助,检测被修改(误改)的状态.</p>\n<h4 id=\"final在JVM中\"><a href=\"#final在JVM中\" class=\"headerlink\" title=\"final在JVM中\"></a>final在JVM中</h4><p>在能够通过编译的前提下,无论局部变量声明时带不带final关键字修饰,对其访问的效率都一样.<br>重复访问一个局部变量比重复访问一个成员或静态变量快,即便将其final修饰符去掉,效果也一样.</p>\n<p>如下代码:</p>\n<pre><code>class Fish{\n    static int foo() {\n      final int a = someValueA();\n     final int b = someValueB();\n      return a + b;  \n}\nstatic int someValueA(){return 1;}\nstatic int someValueB(){return 2;}\n}\n</code></pre><p>javac编译该类,使用<code>javap -c Fish</code>,查看其字节码文件,发现是一样的.</p>\n<pre><code>  Code:\n 0: invokestatic  #2\n 3: istore_0\n 4: invokestatic  #3\n 7: istore_1\n 8: iload_0\n 9: iload_1\n10: iadd\n11: ireturn\n</code></pre><p>所以,在局部变量需要计算得到结果的情况下,final的作用在编译阶段很小.</p>\n<p>考虑另一种情况,局部变量指向常量的情况:</p>\n<pre><code>class fish{\n    static int foo() {\n    int a =1;\n    int b = 2;\n      return a + b;  \n    }\n}\n</code></pre><p>字节码:</p>\n<pre><code>static int foo();\nCode:\n   0: iconst_1\n   1: istore_0\n   2: iconst_2\n   3: istore_1\n   4: iload_0\n   5: iload_1\n   6: iadd\n   7: ireturn\n</code></pre><hr>\n<pre><code>class fish{\n    static int foo() {\n      final int a =1;\n       final  int b = 2;\n      return a + b;  \n    }\n}\n</code></pre><p>字节码:<br>     static int foo();<br>       Code:<br>          0: iconst_3<br>          1: ireturn</p>\n<p>带有final的局部变量指向常量时,编译出的字节码,相当于如下代码的编译:</p>\n<pre><code>static int foo3() {\n  return 5;\n}\n</code></pre><p>在Java语言规范里,称为常量折叠.<a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.4\" target=\"_blank\" rel=\"external\">详情</a>.</p>\n"},{"layout":"post","title":"乙1019. 数字黑洞 (20)","date":"2018-01-31T00:00:00.000Z","_content":"\n\n#### 题目 ####\n\n给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。\n\n例如，我们从6767开始，将得到\n\n\t7766 - 6677 = 1089\n\t9810 - 0189 = 9621\n\t9621 - 1269 = 8352\n\t8532 - 2358 = 6174\n\t7641 - 1467 = 6174\n\t... ...\n\n现给定任意4位正整数，请编写程序演示到达黑洞的过程。\n\n输入格式：\n\n输入给出一个(0, 10000)区间内的正整数N。\n\n输出格式：\n\n如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。\n\n输入样例1：\n\t6767\n输出样例1：\n\t7766 - 6677 = 1089\n\t9810 - 0189 = 9621\n\t9621 - 1269 = 8352\n\t8532 - 2358 = 6174\n输入样例2：\n\t2222\n输出样例2：\n\t2222 - 2222 = 0000\n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\n\tpublic class No1019 {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint source = in.nextInt();\n\t\t\tin.close();\n\t\t\tif(source == 6174){\n\t\t\t\tSystem.out.println(\"7641 - 1467 = 6174\");\n\t\t\t}\n\t\t\twhile (source != 6174) {\n\t\t\t\tsource = output(source);\n\t\t\t}\n\t\t}\n\n\t\tstatic int output(int source) {\n\t\t\tint[] val = { source % 10, (source / 10) % 10, (source / 100) % 10, (source / 1000) % 10 };\n\t\t\tif (val[0] == val[1] && val[1] == val[2] && val[0] == val[3]) {\n\t\t\t\tSystem.out.println(\"\" + val[0] + val[1] + val[2] + val[3] + \" - \" + val[0] + val[1] + val[2] + val[3]\n\t\t\t\t\t\t+ \" = \" + \"0000\");\n\t\t\t\treturn 6174;\n\t\t\t}\n\t\t\tval = incriseSort(val);\n\t\t\tint max = val[0] * 1000 + val[1] * 100 + val[2] * 10 + val[3];\n\t\t\tint min = val[3] * 1000 + val[2] * 100 + val[1] * 10 + val[0];\n\t\t\tfinal int ans = max - min;\n\t\t\tString minStr = min + \"\";\n\t\t\tString ansStr = ans + \"\";\n\n\t\t\tif (min < 1000)\n\t\t\t\tminStr = \"0\" + min;\n\t\t\tif (min < 100)\n\t\t\t\tminStr = \"00\" + min;\n\t\t\tif (min < 10)\n\t\t\t\tminStr = \"000\" + min;\n\n\t\t\tif (ans < 1000)\n\t\t\t\tansStr = \"0\" + ans;\n\t\t\tif (ans < 100)\n\t\t\t\tansStr = \"00\" + ans;\n\t\t\tif (ans < 10)\n\t\t\t\tansStr = \"000\" + ans;\n\n\t\t\tSystem.out.println(max + \" - \" + minStr + \" = \" + ansStr);\n\t\t\treturn ans;\n\t\t}\n\n\t\tstatic int[] incriseSort(int[] val) {\n\t\t\tint temp = val[0];\n\t\t\tfor (int i = 0; i < val.length; i++) {\n\t\t\t\tfor (int j = i + 1; j < val.length; j++) {\n\t\t\t\t\tif (val[i] < val[j]) {\n\t\t\t\t\t\ttemp = val[i];\n\t\t\t\t\t\tval[i] = val[j];\n\t\t\t\t\t\tval[j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t}\n","source":"_posts/2018-01-31-pat-yi-1019.md","raw":"---\nlayout: post\ntitle:  乙1019. 数字黑洞 (20)\ndate:   2018-01-31\ncategories: Algorithm\ntag: [算法,PAT]\n---\n\n\n#### 题目 ####\n\n给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。\n\n例如，我们从6767开始，将得到\n\n\t7766 - 6677 = 1089\n\t9810 - 0189 = 9621\n\t9621 - 1269 = 8352\n\t8532 - 2358 = 6174\n\t7641 - 1467 = 6174\n\t... ...\n\n现给定任意4位正整数，请编写程序演示到达黑洞的过程。\n\n输入格式：\n\n输入给出一个(0, 10000)区间内的正整数N。\n\n输出格式：\n\n如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。\n\n输入样例1：\n\t6767\n输出样例1：\n\t7766 - 6677 = 1089\n\t9810 - 0189 = 9621\n\t9621 - 1269 = 8352\n\t8532 - 2358 = 6174\n输入样例2：\n\t2222\n输出样例2：\n\t2222 - 2222 = 0000\n\n#### 解答 ####\n\n\timport java.util.Scanner;\n\n\tpublic class No1019 {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tint source = in.nextInt();\n\t\t\tin.close();\n\t\t\tif(source == 6174){\n\t\t\t\tSystem.out.println(\"7641 - 1467 = 6174\");\n\t\t\t}\n\t\t\twhile (source != 6174) {\n\t\t\t\tsource = output(source);\n\t\t\t}\n\t\t}\n\n\t\tstatic int output(int source) {\n\t\t\tint[] val = { source % 10, (source / 10) % 10, (source / 100) % 10, (source / 1000) % 10 };\n\t\t\tif (val[0] == val[1] && val[1] == val[2] && val[0] == val[3]) {\n\t\t\t\tSystem.out.println(\"\" + val[0] + val[1] + val[2] + val[3] + \" - \" + val[0] + val[1] + val[2] + val[3]\n\t\t\t\t\t\t+ \" = \" + \"0000\");\n\t\t\t\treturn 6174;\n\t\t\t}\n\t\t\tval = incriseSort(val);\n\t\t\tint max = val[0] * 1000 + val[1] * 100 + val[2] * 10 + val[3];\n\t\t\tint min = val[3] * 1000 + val[2] * 100 + val[1] * 10 + val[0];\n\t\t\tfinal int ans = max - min;\n\t\t\tString minStr = min + \"\";\n\t\t\tString ansStr = ans + \"\";\n\n\t\t\tif (min < 1000)\n\t\t\t\tminStr = \"0\" + min;\n\t\t\tif (min < 100)\n\t\t\t\tminStr = \"00\" + min;\n\t\t\tif (min < 10)\n\t\t\t\tminStr = \"000\" + min;\n\n\t\t\tif (ans < 1000)\n\t\t\t\tansStr = \"0\" + ans;\n\t\t\tif (ans < 100)\n\t\t\t\tansStr = \"00\" + ans;\n\t\t\tif (ans < 10)\n\t\t\t\tansStr = \"000\" + ans;\n\n\t\t\tSystem.out.println(max + \" - \" + minStr + \" = \" + ansStr);\n\t\t\treturn ans;\n\t\t}\n\n\t\tstatic int[] incriseSort(int[] val) {\n\t\t\tint temp = val[0];\n\t\t\tfor (int i = 0; i < val.length; i++) {\n\t\t\t\tfor (int j = i + 1; j < val.length; j++) {\n\t\t\t\t\tif (val[i] < val[j]) {\n\t\t\t\t\t\ttemp = val[i];\n\t\t\t\t\t\tval[i] = val[j];\n\t\t\t\t\t\tval[j] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t}\n","slug":"pat-yi-1019","published":1,"updated":"2018-02-05T02:21:31.802Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1l6009x2siv294gobdc","content":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。</p>\n<p>例如，我们从6767开始，将得到</p>\n<pre><code>7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n7641 - 1467 = 6174\n... ...\n</code></pre><p>现给定任意4位正整数，请编写程序演示到达黑洞的过程。</p>\n<p>输入格式：</p>\n<p>输入给出一个(0, 10000)区间内的正整数N。</p>\n<p>输出格式：</p>\n<p>如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。</p>\n<p>输入样例1：<br>    6767<br>输出样例1：<br>    7766 - 6677 = 1089<br>    9810 - 0189 = 9621<br>    9621 - 1269 = 8352<br>    8532 - 2358 = 6174<br>输入样例2：<br>    2222<br>输出样例2：<br>    2222 - 2222 = 0000</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1019 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int source = in.nextInt();\n        in.close();\n        if(source == 6174){\n            System.out.println(&quot;7641 - 1467 = 6174&quot;);\n        }\n        while (source != 6174) {\n            source = output(source);\n        }\n    }\n\n    static int output(int source) {\n        int[] val = { source % 10, (source / 10) % 10, (source / 100) % 10, (source / 1000) % 10 };\n        if (val[0] == val[1] &amp;&amp; val[1] == val[2] &amp;&amp; val[0] == val[3]) {\n            System.out.println(&quot;&quot; + val[0] + val[1] + val[2] + val[3] + &quot; - &quot; + val[0] + val[1] + val[2] + val[3]\n                    + &quot; = &quot; + &quot;0000&quot;);\n            return 6174;\n        }\n        val = incriseSort(val);\n        int max = val[0] * 1000 + val[1] * 100 + val[2] * 10 + val[3];\n        int min = val[3] * 1000 + val[2] * 100 + val[1] * 10 + val[0];\n        final int ans = max - min;\n        String minStr = min + &quot;&quot;;\n        String ansStr = ans + &quot;&quot;;\n\n        if (min &lt; 1000)\n            minStr = &quot;0&quot; + min;\n        if (min &lt; 100)\n            minStr = &quot;00&quot; + min;\n        if (min &lt; 10)\n            minStr = &quot;000&quot; + min;\n\n        if (ans &lt; 1000)\n            ansStr = &quot;0&quot; + ans;\n        if (ans &lt; 100)\n            ansStr = &quot;00&quot; + ans;\n        if (ans &lt; 10)\n            ansStr = &quot;000&quot; + ans;\n\n        System.out.println(max + &quot; - &quot; + minStr + &quot; = &quot; + ansStr);\n        return ans;\n    }\n\n    static int[] incriseSort(int[] val) {\n        int temp = val[0];\n        for (int i = 0; i &lt; val.length; i++) {\n            for (int j = i + 1; j &lt; val.length; j++) {\n                if (val[i] &lt; val[j]) {\n                    temp = val[i];\n                    val[i] = val[j];\n                    val[j] = temp;\n                }\n            }\n        }\n        return val;\n    }\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h4><p>给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。</p>\n<p>例如，我们从6767开始，将得到</p>\n<pre><code>7766 - 6677 = 1089\n9810 - 0189 = 9621\n9621 - 1269 = 8352\n8532 - 2358 = 6174\n7641 - 1467 = 6174\n... ...\n</code></pre><p>现给定任意4位正整数，请编写程序演示到达黑洞的过程。</p>\n<p>输入格式：</p>\n<p>输入给出一个(0, 10000)区间内的正整数N。</p>\n<p>输出格式：</p>\n<p>如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。</p>\n<p>输入样例1：<br>    6767<br>输出样例1：<br>    7766 - 6677 = 1089<br>    9810 - 0189 = 9621<br>    9621 - 1269 = 8352<br>    8532 - 2358 = 6174<br>输入样例2：<br>    2222<br>输出样例2：<br>    2222 - 2222 = 0000</p>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><pre><code>import java.util.Scanner;\n\npublic class No1019 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int source = in.nextInt();\n        in.close();\n        if(source == 6174){\n            System.out.println(&quot;7641 - 1467 = 6174&quot;);\n        }\n        while (source != 6174) {\n            source = output(source);\n        }\n    }\n\n    static int output(int source) {\n        int[] val = { source % 10, (source / 10) % 10, (source / 100) % 10, (source / 1000) % 10 };\n        if (val[0] == val[1] &amp;&amp; val[1] == val[2] &amp;&amp; val[0] == val[3]) {\n            System.out.println(&quot;&quot; + val[0] + val[1] + val[2] + val[3] + &quot; - &quot; + val[0] + val[1] + val[2] + val[3]\n                    + &quot; = &quot; + &quot;0000&quot;);\n            return 6174;\n        }\n        val = incriseSort(val);\n        int max = val[0] * 1000 + val[1] * 100 + val[2] * 10 + val[3];\n        int min = val[3] * 1000 + val[2] * 100 + val[1] * 10 + val[0];\n        final int ans = max - min;\n        String minStr = min + &quot;&quot;;\n        String ansStr = ans + &quot;&quot;;\n\n        if (min &lt; 1000)\n            minStr = &quot;0&quot; + min;\n        if (min &lt; 100)\n            minStr = &quot;00&quot; + min;\n        if (min &lt; 10)\n            minStr = &quot;000&quot; + min;\n\n        if (ans &lt; 1000)\n            ansStr = &quot;0&quot; + ans;\n        if (ans &lt; 100)\n            ansStr = &quot;00&quot; + ans;\n        if (ans &lt; 10)\n            ansStr = &quot;000&quot; + ans;\n\n        System.out.println(max + &quot; - &quot; + minStr + &quot; = &quot; + ansStr);\n        return ans;\n    }\n\n    static int[] incriseSort(int[] val) {\n        int temp = val[0];\n        for (int i = 0; i &lt; val.length; i++) {\n            for (int j = i + 1; j &lt; val.length; j++) {\n                if (val[i] &lt; val[j]) {\n                    temp = val[i];\n                    val[i] = val[j];\n                    val[j] = temp;\n                }\n            }\n        }\n        return val;\n    }\n}\n</code></pre>"},{"layout":"post","title":"Hybrid预研","date":"2018-02-05T00:00:00.000Z","_content":"\n\n#### 目录 ####\n\n* [HybridApp简介](#Hybrid简介)\n* [Hybrid方案](#Hybrid方案)\n* [react native](#react-native)\n* [weex](#weex)\n* [VasSonic](#VasSonic)\n* [android友好度]()\n* [业务分析]()\n\n#### HybridApp简介 ####\n\n混合模式移动应用.指介于web-app,native-app之间,并且兼具二者优势的app.\n\n如果native-view和web-view交替展示,此时app主题是native,web为补充,该归类于native.\n\n如果同一view内,同时包括native-view和web-view,互相之间层叠,该归类于Hybrid.\n\n如果是以web-view 为主,穿插native功能,归类于web-app.\n\n|           |Native App|Web App|Hybrid App|\n| :---      | :--- | :--- |:---|\n|原生功能体验 |优|差|良|\n|渲染性能     |快|慢|快|\n|访问底层    |支持|不支持|支持|\n|更新复杂度       |高|低|低|\n|社区       |成熟|成熟|有局限|\n|上手难度|难|易|易|\n|开发成本|高|低|低|\n|开发周期|长|短|短|\n|跨平台|否|是|是|\n\n#### Hybrid方案 ####\n\n说起来选方案,紧跟大厂app,错不了!\n\n |公司|框架|\n |:---|:---|\n |Facebook|react native|\n |阿里巴巴|weex|\n |腾讯|VasSonic|\n\n最火的是rn啦,但是at两大国内巨头,也不能不考虑.\n\nrn和weex的资源和社区现在都比较丰富了.VasSonic是我在搜集资料是看到,以前从未有过耳闻,不知道\n\n其社区建设的如何.同时,考虑at巨头里面的不少开源项目都是kpi压力之下的大作,不知道其支持程度如\n\n何.再加上Facebook自带国外光环,让我等还未站起来的程序员不得不仰视.\n\n这样一个单方面考虑,就不由得往rn靠拢了呢.\n\n其实这只是一个单方面原因,最重要的是哪个的易上手,漏洞少,资源丰富了.\n\n##### react native #####\n\n[React Native 中文网](https://reactnative.cn/)\n\n##### weex #####\n\n[weex](https://github.com/apache/incubator-weex)\n\n##### VasSonic #####\n\n[VasSonic](https://github.com/Tencent/VasSonic)\n","source":"_posts/2018-02-05-reactive-native-pre.md","raw":"---\nlayout: post\ntitle:  Hybrid预研\ndate:   2018-02-05\ncategories: Android\ntag: [android,杂项]\n---\n\n\n#### 目录 ####\n\n* [HybridApp简介](#Hybrid简介)\n* [Hybrid方案](#Hybrid方案)\n* [react native](#react-native)\n* [weex](#weex)\n* [VasSonic](#VasSonic)\n* [android友好度]()\n* [业务分析]()\n\n#### HybridApp简介 ####\n\n混合模式移动应用.指介于web-app,native-app之间,并且兼具二者优势的app.\n\n如果native-view和web-view交替展示,此时app主题是native,web为补充,该归类于native.\n\n如果同一view内,同时包括native-view和web-view,互相之间层叠,该归类于Hybrid.\n\n如果是以web-view 为主,穿插native功能,归类于web-app.\n\n|           |Native App|Web App|Hybrid App|\n| :---      | :--- | :--- |:---|\n|原生功能体验 |优|差|良|\n|渲染性能     |快|慢|快|\n|访问底层    |支持|不支持|支持|\n|更新复杂度       |高|低|低|\n|社区       |成熟|成熟|有局限|\n|上手难度|难|易|易|\n|开发成本|高|低|低|\n|开发周期|长|短|短|\n|跨平台|否|是|是|\n\n#### Hybrid方案 ####\n\n说起来选方案,紧跟大厂app,错不了!\n\n |公司|框架|\n |:---|:---|\n |Facebook|react native|\n |阿里巴巴|weex|\n |腾讯|VasSonic|\n\n最火的是rn啦,但是at两大国内巨头,也不能不考虑.\n\nrn和weex的资源和社区现在都比较丰富了.VasSonic是我在搜集资料是看到,以前从未有过耳闻,不知道\n\n其社区建设的如何.同时,考虑at巨头里面的不少开源项目都是kpi压力之下的大作,不知道其支持程度如\n\n何.再加上Facebook自带国外光环,让我等还未站起来的程序员不得不仰视.\n\n这样一个单方面考虑,就不由得往rn靠拢了呢.\n\n其实这只是一个单方面原因,最重要的是哪个的易上手,漏洞少,资源丰富了.\n\n##### react native #####\n\n[React Native 中文网](https://reactnative.cn/)\n\n##### weex #####\n\n[weex](https://github.com/apache/incubator-weex)\n\n##### VasSonic #####\n\n[VasSonic](https://github.com/Tencent/VasSonic)\n","slug":"reactive-native-pre","published":1,"updated":"2018-02-06T07:28:10.179Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1l900a12siv9mqu27v1","content":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><ul>\n<li><a href=\"#Hybrid简介\">HybridApp简介</a></li>\n<li><a href=\"#Hybrid方案\">Hybrid方案</a></li>\n<li><a href=\"#react-native\">react native</a></li>\n<li><a href=\"#weex\">weex</a></li>\n<li><a href=\"#VasSonic\">VasSonic</a></li>\n<li><a href=\"\">android友好度</a></li>\n<li><a href=\"\">业务分析</a></li>\n</ul>\n<h4 id=\"HybridApp简介\"><a href=\"#HybridApp简介\" class=\"headerlink\" title=\"HybridApp简介\"></a>HybridApp简介</h4><p>混合模式移动应用.指介于web-app,native-app之间,并且兼具二者优势的app.</p>\n<p>如果native-view和web-view交替展示,此时app主题是native,web为补充,该归类于native.</p>\n<p>如果同一view内,同时包括native-view和web-view,互相之间层叠,该归类于Hybrid.</p>\n<p>如果是以web-view 为主,穿插native功能,归类于web-app.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">Native App</th>\n<th style=\"text-align:left\">Web App</th>\n<th style=\"text-align:left\">Hybrid App</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">原生功能体验</td>\n<td style=\"text-align:left\">优</td>\n<td style=\"text-align:left\">差</td>\n<td style=\"text-align:left\">良</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">渲染性能</td>\n<td style=\"text-align:left\">快</td>\n<td style=\"text-align:left\">慢</td>\n<td style=\"text-align:left\">快</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问底层</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新复杂度</td>\n<td style=\"text-align:left\">高</td>\n<td style=\"text-align:left\">低</td>\n<td style=\"text-align:left\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">社区</td>\n<td style=\"text-align:left\">成熟</td>\n<td style=\"text-align:left\">成熟</td>\n<td style=\"text-align:left\">有局限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上手难度</td>\n<td style=\"text-align:left\">难</td>\n<td style=\"text-align:left\">易</td>\n<td style=\"text-align:left\">易</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开发成本</td>\n<td style=\"text-align:left\">高</td>\n<td style=\"text-align:left\">低</td>\n<td style=\"text-align:left\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开发周期</td>\n<td style=\"text-align:left\">长</td>\n<td style=\"text-align:left\">短</td>\n<td style=\"text-align:left\">短</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跨平台</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Hybrid方案\"><a href=\"#Hybrid方案\" class=\"headerlink\" title=\"Hybrid方案\"></a>Hybrid方案</h4><p>说起来选方案,紧跟大厂app,错不了!</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">公司</th>\n<th style=\"text-align:left\">框架</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Facebook</td>\n<td style=\"text-align:left\">react native</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">阿里巴巴</td>\n<td style=\"text-align:left\">weex</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">腾讯</td>\n<td style=\"text-align:left\">VasSonic</td>\n</tr>\n</tbody>\n</table>\n<p>最火的是rn啦,但是at两大国内巨头,也不能不考虑.</p>\n<p>rn和weex的资源和社区现在都比较丰富了.VasSonic是我在搜集资料是看到,以前从未有过耳闻,不知道</p>\n<p>其社区建设的如何.同时,考虑at巨头里面的不少开源项目都是kpi压力之下的大作,不知道其支持程度如</p>\n<p>何.再加上Facebook自带国外光环,让我等还未站起来的程序员不得不仰视.</p>\n<p>这样一个单方面考虑,就不由得往rn靠拢了呢.</p>\n<p>其实这只是一个单方面原因,最重要的是哪个的易上手,漏洞少,资源丰富了.</p>\n<h5 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react native\"></a>react native</h5><p><a href=\"https://reactnative.cn/\" target=\"_blank\" rel=\"external\">React Native 中文网</a></p>\n<h5 id=\"weex\"><a href=\"#weex\" class=\"headerlink\" title=\"weex\"></a>weex</h5><p><a href=\"https://github.com/apache/incubator-weex\" target=\"_blank\" rel=\"external\">weex</a></p>\n<h5 id=\"VasSonic\"><a href=\"#VasSonic\" class=\"headerlink\" title=\"VasSonic\"></a>VasSonic</h5><p><a href=\"https://github.com/Tencent/VasSonic\" target=\"_blank\" rel=\"external\">VasSonic</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><ul>\n<li><a href=\"#Hybrid简介\">HybridApp简介</a></li>\n<li><a href=\"#Hybrid方案\">Hybrid方案</a></li>\n<li><a href=\"#react-native\">react native</a></li>\n<li><a href=\"#weex\">weex</a></li>\n<li><a href=\"#VasSonic\">VasSonic</a></li>\n<li><a href=\"\">android友好度</a></li>\n<li><a href=\"\">业务分析</a></li>\n</ul>\n<h4 id=\"HybridApp简介\"><a href=\"#HybridApp简介\" class=\"headerlink\" title=\"HybridApp简介\"></a>HybridApp简介</h4><p>混合模式移动应用.指介于web-app,native-app之间,并且兼具二者优势的app.</p>\n<p>如果native-view和web-view交替展示,此时app主题是native,web为补充,该归类于native.</p>\n<p>如果同一view内,同时包括native-view和web-view,互相之间层叠,该归类于Hybrid.</p>\n<p>如果是以web-view 为主,穿插native功能,归类于web-app.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">Native App</th>\n<th style=\"text-align:left\">Web App</th>\n<th style=\"text-align:left\">Hybrid App</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">原生功能体验</td>\n<td style=\"text-align:left\">优</td>\n<td style=\"text-align:left\">差</td>\n<td style=\"text-align:left\">良</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">渲染性能</td>\n<td style=\"text-align:left\">快</td>\n<td style=\"text-align:left\">慢</td>\n<td style=\"text-align:left\">快</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问底层</td>\n<td style=\"text-align:left\">支持</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新复杂度</td>\n<td style=\"text-align:left\">高</td>\n<td style=\"text-align:left\">低</td>\n<td style=\"text-align:left\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">社区</td>\n<td style=\"text-align:left\">成熟</td>\n<td style=\"text-align:left\">成熟</td>\n<td style=\"text-align:left\">有局限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">上手难度</td>\n<td style=\"text-align:left\">难</td>\n<td style=\"text-align:left\">易</td>\n<td style=\"text-align:left\">易</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开发成本</td>\n<td style=\"text-align:left\">高</td>\n<td style=\"text-align:left\">低</td>\n<td style=\"text-align:left\">低</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">开发周期</td>\n<td style=\"text-align:left\">长</td>\n<td style=\"text-align:left\">短</td>\n<td style=\"text-align:left\">短</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跨平台</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">是</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Hybrid方案\"><a href=\"#Hybrid方案\" class=\"headerlink\" title=\"Hybrid方案\"></a>Hybrid方案</h4><p>说起来选方案,紧跟大厂app,错不了!</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">公司</th>\n<th style=\"text-align:left\">框架</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Facebook</td>\n<td style=\"text-align:left\">react native</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">阿里巴巴</td>\n<td style=\"text-align:left\">weex</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">腾讯</td>\n<td style=\"text-align:left\">VasSonic</td>\n</tr>\n</tbody>\n</table>\n<p>最火的是rn啦,但是at两大国内巨头,也不能不考虑.</p>\n<p>rn和weex的资源和社区现在都比较丰富了.VasSonic是我在搜集资料是看到,以前从未有过耳闻,不知道</p>\n<p>其社区建设的如何.同时,考虑at巨头里面的不少开源项目都是kpi压力之下的大作,不知道其支持程度如</p>\n<p>何.再加上Facebook自带国外光环,让我等还未站起来的程序员不得不仰视.</p>\n<p>这样一个单方面考虑,就不由得往rn靠拢了呢.</p>\n<p>其实这只是一个单方面原因,最重要的是哪个的易上手,漏洞少,资源丰富了.</p>\n<h5 id=\"react-native\"><a href=\"#react-native\" class=\"headerlink\" title=\"react native\"></a>react native</h5><p><a href=\"https://reactnative.cn/\" target=\"_blank\" rel=\"external\">React Native 中文网</a></p>\n<h5 id=\"weex\"><a href=\"#weex\" class=\"headerlink\" title=\"weex\"></a>weex</h5><p><a href=\"https://github.com/apache/incubator-weex\" target=\"_blank\" rel=\"external\">weex</a></p>\n<h5 id=\"VasSonic\"><a href=\"#VasSonic\" class=\"headerlink\" title=\"VasSonic\"></a>VasSonic</h5><p><a href=\"https://github.com/Tencent/VasSonic\" target=\"_blank\" rel=\"external\">VasSonic</a></p>\n"},{"layout":"post","title":"设计模式开篇","date":"2017-03-18T00:00:00.000Z","_content":" \n\n#### 设计模式 ####\n\n设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br/>\n\n软件模式包括：\n\n- 设计模式\n- 架构模式\n- 分析模式\n- 过程模式\n\n\n#### 学习设计模式的层次 ####\n\n- 能在白纸上画出所有的模式结构和时序图\n- 能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用\n- 灵活运用至项目中\n\n在线画图工具安利：[https://www.processon.com/diagrams](https://www.processon.com/diagrams)\nwinPC画图工具安利：[http://astah.net/](http://astah.net/)\n\n#### 面向对象设计原则 ####\n\n  | 名称 | 定 义 |使用频率|\n |:-------------:|:-----:|:-----:|\n|单一职责原则 (Single Responsibility Principle, SRP)\t|一个类只负责一个功能领域中的相应职责|\t★★★★☆|\n|开闭原则 (Open-Closed Principle, OCP)\t|软件实体应对扩展开放，而对修改关闭\t|★★★★★|\n|里氏代换原则 (Liskov Substitution Principle, LSP)|\t所有引用基类对象的地方能够透明地使用其子类的对象\t|★★★★★|\n|依赖倒转原则 (Dependence Inversion Principle, DIP)|\t抽象不应该依赖于细节，细节应该依赖于抽象\t|★★★★★|\n|接口隔离原则 (Interface Segregation Principle, ISP)\t|使用多个专门的接口，而不使用单一的总接口\t|★★☆☆☆|\n|合成复用原则 (Composite Reuse Principle, CRP)\t|尽量使用对象组合，而不是继承来达到复用的目的\t|★★★★☆|\n|迪米特法则 (Law of Demeter, LoD)|\t一个软件实体应当尽可能少地与其他实体发生相互作用\t|★★★☆☆|\n\n#### 设计模式分类 ####\n\n##### 创建型模式(5) #####\n\n创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道他们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n- [单例模式](http://xusx1024.com/2017/02/11/design-patterns-singleton-1/)\n- [建造者模式](http://xusx1024.com/2017/03/03/design-patterns-builder-1/)\n- [原型模式](http://xusx1024.com/2017/03/18/design-patterns-prototype-1/)\n- [工厂方法模式](http://xusx1024.com/2017/05/24/design-patterns-factory-method/)\n- [抽象工厂模式](http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/)\n \t\n##### 行为型模式(11) #####\n\n行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用。\n\n- [策略模式](http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/)\n- [模版方法模式](http://xusx1024.com/2017/06/19/design-patterns-template-method/)\n- [观察者模式](http://xusx1024.com/2017/06/09/design-patterns-observer/)\n- [迭代器模式](http://xusx1024.com/2017/06/15/design-patterns-iterator/)\n- [责任链模式](http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/)\n- [命令模式](http://xusx1024.com/2017/06/14/design-patterns-command/)\n- [备忘录模式](http://xusx1024.com/2017/06/16/design-patterns-memento/)\n- [状态模式](http://xusx1024.com/2017/05/26/design-patterns-state-pattern/)\n- [访问者模式](http://xusx1024.com/2017/06/20/design-patterns-visitor/)\n- [中介者模式](http://xusx1024.com/2017/06/13/design-patterns-mediator/)\n- [解释器模式](http://xusx1024.com/2017/06/02/design-patterns-interpreter/)\n\n##### 结构型模式(7) #####\n\n描述如何将类或对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，一般只存在继承和实现。对象结构型模式关系类与对象的组合，通过关联关系使一个类中定义另一个类的实例对象。\n根据“合成复用”原则，在系统中尽量使用关联关系来替代继承关系。\n\n- [适配器模式](http://xusx1024.com/2017/06/21/design-patterns-adapter/)\n- [桥接模式](http://xusx1024.com/2017/06/22/design-patterns-bridge/)\n- [装饰模式](http://xusx1024.com/2017/06/23/design-patterns-decorator/)\n- [外观模式](http://xusx1024.com/2017/06/26/design-patterns-facade/)\n- [享元模式](http://xusx1024.com/2017/06/27/design-patterns-flyweight/)\n- [代理模式](http://xusx1024.com/2017/06/28/design-patterns-proxy/)\n- [组合模式](http://xusx1024.com/2017/06/26/design-patterns-composite/)\n \n#### 参考 ####\n\n- [图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/)\n- [设计模式](https://quanke.gitbooks.io/design-pattern-java/)\n- 《Android源码设计模式解析与实战》\n- [工匠若水](http://blog.csdn.net/yanbober/article/category/3148699)\n- [卡奴达摩](http://blog.csdn.net/zhengzhb/article/category/926691)\n- [特种兵—AK47](http://blog.csdn.net/column/details/loveyun.html)","source":"_posts/2017-03-18-design-patterns-start.md","raw":"---\nlayout: post\ntitle:  设计模式开篇\ndate:   2017-03-18\ncategories: Design Pattern\ntag: 设计模式\n---\n \n\n#### 设计模式 ####\n\n设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br/>\n\n软件模式包括：\n\n- 设计模式\n- 架构模式\n- 分析模式\n- 过程模式\n\n\n#### 学习设计模式的层次 ####\n\n- 能在白纸上画出所有的模式结构和时序图\n- 能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用\n- 灵活运用至项目中\n\n在线画图工具安利：[https://www.processon.com/diagrams](https://www.processon.com/diagrams)\nwinPC画图工具安利：[http://astah.net/](http://astah.net/)\n\n#### 面向对象设计原则 ####\n\n  | 名称 | 定 义 |使用频率|\n |:-------------:|:-----:|:-----:|\n|单一职责原则 (Single Responsibility Principle, SRP)\t|一个类只负责一个功能领域中的相应职责|\t★★★★☆|\n|开闭原则 (Open-Closed Principle, OCP)\t|软件实体应对扩展开放，而对修改关闭\t|★★★★★|\n|里氏代换原则 (Liskov Substitution Principle, LSP)|\t所有引用基类对象的地方能够透明地使用其子类的对象\t|★★★★★|\n|依赖倒转原则 (Dependence Inversion Principle, DIP)|\t抽象不应该依赖于细节，细节应该依赖于抽象\t|★★★★★|\n|接口隔离原则 (Interface Segregation Principle, ISP)\t|使用多个专门的接口，而不使用单一的总接口\t|★★☆☆☆|\n|合成复用原则 (Composite Reuse Principle, CRP)\t|尽量使用对象组合，而不是继承来达到复用的目的\t|★★★★☆|\n|迪米特法则 (Law of Demeter, LoD)|\t一个软件实体应当尽可能少地与其他实体发生相互作用\t|★★★☆☆|\n\n#### 设计模式分类 ####\n\n##### 创建型模式(5) #####\n\n创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道他们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n\n- [单例模式](http://xusx1024.com/2017/02/11/design-patterns-singleton-1/)\n- [建造者模式](http://xusx1024.com/2017/03/03/design-patterns-builder-1/)\n- [原型模式](http://xusx1024.com/2017/03/18/design-patterns-prototype-1/)\n- [工厂方法模式](http://xusx1024.com/2017/05/24/design-patterns-factory-method/)\n- [抽象工厂模式](http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/)\n \t\n##### 行为型模式(11) #####\n\n行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用。\n\n- [策略模式](http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/)\n- [模版方法模式](http://xusx1024.com/2017/06/19/design-patterns-template-method/)\n- [观察者模式](http://xusx1024.com/2017/06/09/design-patterns-observer/)\n- [迭代器模式](http://xusx1024.com/2017/06/15/design-patterns-iterator/)\n- [责任链模式](http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/)\n- [命令模式](http://xusx1024.com/2017/06/14/design-patterns-command/)\n- [备忘录模式](http://xusx1024.com/2017/06/16/design-patterns-memento/)\n- [状态模式](http://xusx1024.com/2017/05/26/design-patterns-state-pattern/)\n- [访问者模式](http://xusx1024.com/2017/06/20/design-patterns-visitor/)\n- [中介者模式](http://xusx1024.com/2017/06/13/design-patterns-mediator/)\n- [解释器模式](http://xusx1024.com/2017/06/02/design-patterns-interpreter/)\n\n##### 结构型模式(7) #####\n\n描述如何将类或对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，一般只存在继承和实现。对象结构型模式关系类与对象的组合，通过关联关系使一个类中定义另一个类的实例对象。\n根据“合成复用”原则，在系统中尽量使用关联关系来替代继承关系。\n\n- [适配器模式](http://xusx1024.com/2017/06/21/design-patterns-adapter/)\n- [桥接模式](http://xusx1024.com/2017/06/22/design-patterns-bridge/)\n- [装饰模式](http://xusx1024.com/2017/06/23/design-patterns-decorator/)\n- [外观模式](http://xusx1024.com/2017/06/26/design-patterns-facade/)\n- [享元模式](http://xusx1024.com/2017/06/27/design-patterns-flyweight/)\n- [代理模式](http://xusx1024.com/2017/06/28/design-patterns-proxy/)\n- [组合模式](http://xusx1024.com/2017/06/26/design-patterns-composite/)\n \n#### 参考 ####\n\n- [图说设计模式](http://design-patterns.readthedocs.io/zh_CN/latest/)\n- [设计模式](https://quanke.gitbooks.io/design-pattern-java/)\n- 《Android源码设计模式解析与实战》\n- [工匠若水](http://blog.csdn.net/yanbober/article/category/3148699)\n- [卡奴达摩](http://blog.csdn.net/zhengzhb/article/category/926691)\n- [特种兵—AK47](http://blog.csdn.net/column/details/loveyun.html)","slug":"design-patterns-start","published":1,"updated":"2017-08-17T02:43:54.364Z","comments":1,"photos":[],"link":"","_id":"cjdcfv1lc00a42sivl7vbw6tn","content":"<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><p>设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br></p>\n<p>软件模式包括：</p>\n<ul>\n<li>设计模式</li>\n<li>架构模式</li>\n<li>分析模式</li>\n<li>过程模式</li>\n</ul>\n<h4 id=\"学习设计模式的层次\"><a href=\"#学习设计模式的层次\" class=\"headerlink\" title=\"学习设计模式的层次\"></a>学习设计模式的层次</h4><ul>\n<li>能在白纸上画出所有的模式结构和时序图</li>\n<li>能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用</li>\n<li>灵活运用至项目中</li>\n</ul>\n<p>在线画图工具安利：<a href=\"https://www.processon.com/diagrams\" target=\"_blank\" rel=\"external\">https://www.processon.com/diagrams</a><br>winPC画图工具安利：<a href=\"http://astah.net/\" target=\"_blank\" rel=\"external\">http://astah.net/</a></p>\n<h4 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">定 义</th>\n<th style=\"text-align:center\">使用频率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单一职责原则 (Single Responsibility Principle, SRP)</td>\n<td style=\"text-align:center\">一个类只负责一个功能领域中的相应职责</td>\n<td style=\"text-align:center\">★★★★☆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">开闭原则 (Open-Closed Principle, OCP)</td>\n<td style=\"text-align:center\">软件实体应对扩展开放，而对修改关闭</td>\n<td style=\"text-align:center\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">里氏代换原则 (Liskov Substitution Principle, LSP)</td>\n<td style=\"text-align:center\">所有引用基类对象的地方能够透明地使用其子类的对象</td>\n<td style=\"text-align:center\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">依赖倒转原则 (Dependence Inversion Principle, DIP)</td>\n<td style=\"text-align:center\">抽象不应该依赖于细节，细节应该依赖于抽象</td>\n<td style=\"text-align:center\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">接口隔离原则 (Interface Segregation Principle, ISP)</td>\n<td style=\"text-align:center\">使用多个专门的接口，而不使用单一的总接口</td>\n<td style=\"text-align:center\">★★☆☆☆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">合成复用原则 (Composite Reuse Principle, CRP)</td>\n<td style=\"text-align:center\">尽量使用对象组合，而不是继承来达到复用的目的</td>\n<td style=\"text-align:center\">★★★★☆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">迪米特法则 (Law of Demeter, LoD)</td>\n<td style=\"text-align:center\">一个软件实体应当尽可能少地与其他实体发生相互作用</td>\n<td style=\"text-align:center\">★★★☆☆</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"设计模式分类\"><a href=\"#设计模式分类\" class=\"headerlink\" title=\"设计模式分类\"></a>设计模式分类</h4><h5 id=\"创建型模式-5\"><a href=\"#创建型模式-5\" class=\"headerlink\" title=\"创建型模式(5)\"></a>创建型模式(5)</h5><p>创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道他们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/02/11/design-patterns-singleton-1/\" target=\"_blank\" rel=\"external\">单例模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/03/design-patterns-builder-1/\" target=\"_blank\" rel=\"external\">建造者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/18/design-patterns-prototype-1/\" target=\"_blank\" rel=\"external\">原型模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/24/design-patterns-factory-method/\" target=\"_blank\" rel=\"external\">工厂方法模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/\" target=\"_blank\" rel=\"external\">抽象工厂模式</a></li>\n</ul>\n<h5 id=\"行为型模式-11\"><a href=\"#行为型模式-11\" class=\"headerlink\" title=\"行为型模式(11)\"></a>行为型模式(11)</h5><p>行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用。</p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/\" target=\"_blank\" rel=\"external\">策略模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/19/design-patterns-template-method/\" target=\"_blank\" rel=\"external\">模版方法模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/09/design-patterns-observer/\" target=\"_blank\" rel=\"external\">观察者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/15/design-patterns-iterator/\" target=\"_blank\" rel=\"external\">迭代器模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/\" target=\"_blank\" rel=\"external\">责任链模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/14/design-patterns-command/\" target=\"_blank\" rel=\"external\">命令模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/16/design-patterns-memento/\" target=\"_blank\" rel=\"external\">备忘录模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/26/design-patterns-state-pattern/\" target=\"_blank\" rel=\"external\">状态模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/20/design-patterns-visitor/\" target=\"_blank\" rel=\"external\">访问者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/13/design-patterns-mediator/\" target=\"_blank\" rel=\"external\">中介者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/02/design-patterns-interpreter/\" target=\"_blank\" rel=\"external\">解释器模式</a></li>\n</ul>\n<h5 id=\"结构型模式-7\"><a href=\"#结构型模式-7\" class=\"headerlink\" title=\"结构型模式(7)\"></a>结构型模式(7)</h5><p>描述如何将类或对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，一般只存在继承和实现。对象结构型模式关系类与对象的组合，通过关联关系使一个类中定义另一个类的实例对象。<br>根据“合成复用”原则，在系统中尽量使用关联关系来替代继承关系。</p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/06/21/design-patterns-adapter/\" target=\"_blank\" rel=\"external\">适配器模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/22/design-patterns-bridge/\" target=\"_blank\" rel=\"external\">桥接模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/23/design-patterns-decorator/\" target=\"_blank\" rel=\"external\">装饰模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/26/design-patterns-facade/\" target=\"_blank\" rel=\"external\">外观模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/27/design-patterns-flyweight/\" target=\"_blank\" rel=\"external\">享元模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/28/design-patterns-proxy/\" target=\"_blank\" rel=\"external\">代理模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/26/design-patterns-composite/\" target=\"_blank\" rel=\"external\">组合模式</a></li>\n</ul>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"http://design-patterns.readthedocs.io/zh_CN/latest/\" target=\"_blank\" rel=\"external\">图说设计模式</a></li>\n<li><a href=\"https://quanke.gitbooks.io/design-pattern-java/\" target=\"_blank\" rel=\"external\">设计模式</a></li>\n<li>《Android源码设计模式解析与实战》</li>\n<li><a href=\"http://blog.csdn.net/yanbober/article/category/3148699\" target=\"_blank\" rel=\"external\">工匠若水</a></li>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/category/926691\" target=\"_blank\" rel=\"external\">卡奴达摩</a></li>\n<li><a href=\"http://blog.csdn.net/column/details/loveyun.html\" target=\"_blank\" rel=\"external\">特种兵—AK47</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h4><p>设计模式是软件模式的一部分。软件模式即是软件开发的总体指导思路或参照样板。<br></p>\n<p>软件模式包括：</p>\n<ul>\n<li>设计模式</li>\n<li>架构模式</li>\n<li>分析模式</li>\n<li>过程模式</li>\n</ul>\n<h4 id=\"学习设计模式的层次\"><a href=\"#学习设计模式的层次\" class=\"headerlink\" title=\"学习设计模式的层次\"></a>学习设计模式的层次</h4><ul>\n<li>能在白纸上画出所有的模式结构和时序图</li>\n<li>能用代码实现；如果代码都没有写过，是用不出来的，即看得懂不会用</li>\n<li>灵活运用至项目中</li>\n</ul>\n<p>在线画图工具安利：<a href=\"https://www.processon.com/diagrams\" target=\"_blank\" rel=\"external\">https://www.processon.com/diagrams</a><br>winPC画图工具安利：<a href=\"http://astah.net/\" target=\"_blank\" rel=\"external\">http://astah.net/</a></p>\n<h4 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">定 义</th>\n<th style=\"text-align:center\">使用频率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单一职责原则 (Single Responsibility Principle, SRP)</td>\n<td style=\"text-align:center\">一个类只负责一个功能领域中的相应职责</td>\n<td style=\"text-align:center\">★★★★☆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">开闭原则 (Open-Closed Principle, OCP)</td>\n<td style=\"text-align:center\">软件实体应对扩展开放，而对修改关闭</td>\n<td style=\"text-align:center\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">里氏代换原则 (Liskov Substitution Principle, LSP)</td>\n<td style=\"text-align:center\">所有引用基类对象的地方能够透明地使用其子类的对象</td>\n<td style=\"text-align:center\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">依赖倒转原则 (Dependence Inversion Principle, DIP)</td>\n<td style=\"text-align:center\">抽象不应该依赖于细节，细节应该依赖于抽象</td>\n<td style=\"text-align:center\">★★★★★</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">接口隔离原则 (Interface Segregation Principle, ISP)</td>\n<td style=\"text-align:center\">使用多个专门的接口，而不使用单一的总接口</td>\n<td style=\"text-align:center\">★★☆☆☆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">合成复用原则 (Composite Reuse Principle, CRP)</td>\n<td style=\"text-align:center\">尽量使用对象组合，而不是继承来达到复用的目的</td>\n<td style=\"text-align:center\">★★★★☆</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">迪米特法则 (Law of Demeter, LoD)</td>\n<td style=\"text-align:center\">一个软件实体应当尽可能少地与其他实体发生相互作用</td>\n<td style=\"text-align:center\">★★★☆☆</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"设计模式分类\"><a href=\"#设计模式分类\" class=\"headerlink\" title=\"设计模式分类\"></a>设计模式分类</h4><h5 id=\"创建型模式-5\"><a href=\"#创建型模式-5\" class=\"headerlink\" title=\"创建型模式(5)\"></a>创建型模式(5)</h5><p>创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道他们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/02/11/design-patterns-singleton-1/\" target=\"_blank\" rel=\"external\">单例模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/03/design-patterns-builder-1/\" target=\"_blank\" rel=\"external\">建造者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/03/18/design-patterns-prototype-1/\" target=\"_blank\" rel=\"external\">原型模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/24/design-patterns-factory-method/\" target=\"_blank\" rel=\"external\">工厂方法模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-abstract-factory/\" target=\"_blank\" rel=\"external\">抽象工厂模式</a></li>\n</ul>\n<h5 id=\"行为型模式-11\"><a href=\"#行为型模式-11\" class=\"headerlink\" title=\"行为型模式(11)\"></a>行为型模式(11)</h5><p>行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用。</p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/05/25/design-patterns-strategy-pattern/\" target=\"_blank\" rel=\"external\">策略模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/19/design-patterns-template-method/\" target=\"_blank\" rel=\"external\">模版方法模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/09/design-patterns-observer/\" target=\"_blank\" rel=\"external\">观察者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/15/design-patterns-iterator/\" target=\"_blank\" rel=\"external\">迭代器模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/31/design-patterns-chain-of-responsibility/\" target=\"_blank\" rel=\"external\">责任链模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/14/design-patterns-command/\" target=\"_blank\" rel=\"external\">命令模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/16/design-patterns-memento/\" target=\"_blank\" rel=\"external\">备忘录模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/05/26/design-patterns-state-pattern/\" target=\"_blank\" rel=\"external\">状态模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/20/design-patterns-visitor/\" target=\"_blank\" rel=\"external\">访问者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/13/design-patterns-mediator/\" target=\"_blank\" rel=\"external\">中介者模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/02/design-patterns-interpreter/\" target=\"_blank\" rel=\"external\">解释器模式</a></li>\n</ul>\n<h5 id=\"结构型模式-7\"><a href=\"#结构型模式-7\" class=\"headerlink\" title=\"结构型模式(7)\"></a>结构型模式(7)</h5><p>描述如何将类或对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，一般只存在继承和实现。对象结构型模式关系类与对象的组合，通过关联关系使一个类中定义另一个类的实例对象。<br>根据“合成复用”原则，在系统中尽量使用关联关系来替代继承关系。</p>\n<ul>\n<li><a href=\"http://xusx1024.com/2017/06/21/design-patterns-adapter/\" target=\"_blank\" rel=\"external\">适配器模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/22/design-patterns-bridge/\" target=\"_blank\" rel=\"external\">桥接模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/23/design-patterns-decorator/\" target=\"_blank\" rel=\"external\">装饰模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/26/design-patterns-facade/\" target=\"_blank\" rel=\"external\">外观模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/27/design-patterns-flyweight/\" target=\"_blank\" rel=\"external\">享元模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/28/design-patterns-proxy/\" target=\"_blank\" rel=\"external\">代理模式</a></li>\n<li><a href=\"http://xusx1024.com/2017/06/26/design-patterns-composite/\" target=\"_blank\" rel=\"external\">组合模式</a></li>\n</ul>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"http://design-patterns.readthedocs.io/zh_CN/latest/\" target=\"_blank\" rel=\"external\">图说设计模式</a></li>\n<li><a href=\"https://quanke.gitbooks.io/design-pattern-java/\" target=\"_blank\" rel=\"external\">设计模式</a></li>\n<li>《Android源码设计模式解析与实战》</li>\n<li><a href=\"http://blog.csdn.net/yanbober/article/category/3148699\" target=\"_blank\" rel=\"external\">工匠若水</a></li>\n<li><a href=\"http://blog.csdn.net/zhengzhb/article/category/926691\" target=\"_blank\" rel=\"external\">卡奴达摩</a></li>\n<li><a href=\"http://blog.csdn.net/column/details/loveyun.html\" target=\"_blank\" rel=\"external\">特种兵—AK47</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdcfv19s00002sivso9kjmuu","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1ax000d2sivg3749red"},{"post_id":"cjdcfv1a200022sivljv15xo4","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1b4000k2sivtgoarsi6"},{"post_id":"cjdcfv1b0000h2sivrrgv0z3h","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1ba000p2siv64s7yhht"},{"post_id":"cjdcfv1ae00062siv7rpyiz4y","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1bf000u2sivwfbn7nkf"},{"post_id":"cjdcfv1b3000j2sivp0or7opb","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1bi000x2siv87aubk3x"},{"post_id":"cjdcfv1b8000o2sivbx6r0fo4","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1bn00102sivmuv097d6"},{"post_id":"cjdcfv1ak00072sivszas54jj","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1br00152sivoi953uga"},{"post_id":"cjdcfv1bg000w2sivst6jqaes","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1bv00182siv1pl9ggpc"},{"post_id":"cjdcfv1an00082siv89xt78uk","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1c1001d2siv781b4ai6"},{"post_id":"cjdcfv1bk000z2siv0y2vtc9f","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1c4001g2sivjbi1z1xg"},{"post_id":"cjdcfv1bp00142sivp1gayl7y","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1ce001l2sivti4n2hst"},{"post_id":"cjdcfv1av000c2sivdsnw79wl","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1ck001o2siv97m3slx1"},{"post_id":"cjdcfv1bt00172siv8grk49m0","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1cs001s2sivuun1d2re"},{"post_id":"cjdcfv1by001c2sivlbmeqpeo","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1cx001v2sivepytdbzp"},{"post_id":"cjdcfv1ay000e2siv0gpa0z9n","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1d1001y2sivir6101wt"},{"post_id":"cjdcfv1c2001f2sivu5305bs6","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1d400222sivz45mvb8c"},{"post_id":"cjdcfv1c8001k2sivy1doplwb","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1d600252sivo3h8c1gz"},{"post_id":"cjdcfv1bc000r2sivb6d2af7c","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1da00292sivc8ox0qsn"},{"post_id":"cjdcfv1cg001n2sivba317muo","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1dd002c2sivaz60gt5e"},{"post_id":"cjdcfv1d200202sivn3tz095y","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1dj002h2sivqc5c5of0"},{"post_id":"cjdcfv1d400242sivh0o5jt9w","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1dn002k2sivf7bshr9o"},{"post_id":"cjdcfv1cn001q2sivpl2nl140","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1dp002n2sivqi1mtk4z"},{"post_id":"cjdcfv1d700272sivyg0tn9ci","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1du002q2sivwgdism61"},{"post_id":"cjdcfv1db002b2sivg507d99e","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1dy002u2sivmwknex3d"},{"post_id":"cjdcfv1cv001u2siv8szfnhnf","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1e1002x2sivwspqfbcw"},{"post_id":"cjdcfv1dd002e2sivfoean49c","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1e300302sivv92o3co0"},{"post_id":"cjdcfv1dl002j2sivmnww122l","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1e500332sivksxyaryb"},{"post_id":"cjdcfv1cz001x2sivybpmdses","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1e700362sivf6s2p2ps"},{"post_id":"cjdcfv1do002m2sivws22j3zr","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1ea00392sivk3yqz2q7"},{"post_id":"cjdcfv1dv002s2sivl3dj86jt","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1ec003c2sivuyx16jzf"},{"post_id":"cjdcfv1dz002w2sivfuvi8tjo","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1ef003f2sivr2vsulr2"},{"post_id":"cjdcfv1e2002z2sivblexr7fa","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1ej003i2sivm05p3o23"},{"post_id":"cjdcfv1dq002p2sivkwhl2y96","category_id":"cjdcfv1dy002t2sivgntf5za9","_id":"cjdcfv1em003l2siv0ze9ocxb"},{"post_id":"cjdcfv1e400322siv5dec103q","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1et003o2sivc17tqnc4"},{"post_id":"cjdcfv1e600352sivxpq74gdb","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1ex003r2siv6p08zk3d"},{"post_id":"cjdcfv1e800382sivmw97kij0","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1f1003u2sivmuixron2"},{"post_id":"cjdcfv1eb003b2siv376vber1","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1f4003x2sivko6i9ejv"},{"post_id":"cjdcfv1ed003e2sivt81rgj70","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1f800402sivgdv8c55i"},{"post_id":"cjdcfv1ef003h2siv7yp6f44p","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1fa00432sivy398kyc7"},{"post_id":"cjdcfv1ek003k2siv6gnrscks","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1fd00462sivc66qs4bt"},{"post_id":"cjdcfv1ep003n2sivb2aaknqm","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1ff00492sivtj5sxksy"},{"post_id":"cjdcfv1eu003q2sivko4r8ur9","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1fi004c2siv4ar86n5i"},{"post_id":"cjdcfv1ey003t2sivnnulznb9","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1fl004f2siverqg65x3"},{"post_id":"cjdcfv1f2003w2siv2vrjuvsm","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1fn004i2siv2f7ywspl"},{"post_id":"cjdcfv1f5003z2sivnwwywf8g","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1fq004l2sivh6e3uozb"},{"post_id":"cjdcfv1f800422sivei0kafs0","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1ft004o2sivv6c2x67c"},{"post_id":"cjdcfv1fb00452siv7ia1trp9","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1fw004r2siveco4w0de"},{"post_id":"cjdcfv1fd00482sivso4dhge7","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1fz004u2siv8cvdsx88"},{"post_id":"cjdcfv1fg004b2sivqfh5yk75","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1g1004x2sivihrtxqu6"},{"post_id":"cjdcfv1fj004e2sivdkynh16k","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1g500522siv0lrmjvt3"},{"post_id":"cjdcfv1fl004h2sivw51ich70","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1g800552siv5o8ndfmw"},{"post_id":"cjdcfv1fn004k2sivx69z1lqb","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1gc00582sivm8ft5vh8"},{"post_id":"cjdcfv1fr004n2sivpgvgpldi","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1gg005c2sivgx5nsi9c"},{"post_id":"cjdcfv1fu004q2sivo87hz8j5","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1gi005f2siv59wtksy3"},{"post_id":"cjdcfv1fx004t2sivnbus8we0","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1go005i2sivyv4vp2ee"},{"post_id":"cjdcfv1g1004z2sivef9n7ub3","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1gr005l2sivmkkeb00l"},{"post_id":"cjdcfv1g500542sivu4k379lq","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1gu005o2sivpyjxg7b5"},{"post_id":"cjdcfv1ga00572siv444gdlx5","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1gw005r2sivy0jmyfja"},{"post_id":"cjdcfv1fz004w2sivtux62i4f","category_id":"cjdcfv1g300502sivz64cy0vy","_id":"cjdcfv1h0005u2siv7u2gnsod"},{"post_id":"cjdcfv1gd005a2siv39jut5c5","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1h4005x2sivqx1by8fq"},{"post_id":"cjdcfv1gg005e2sivk1tx9w6f","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1h600602sivgidl52ck"},{"post_id":"cjdcfv1gm005h2sivmsoe92bm","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1h900632sivw1fy325b"},{"post_id":"cjdcfv1gp005k2sivcudea5ts","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hb00662sivmgvxfqjd"},{"post_id":"cjdcfv1gs005n2sivt6qoagzh","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hf00692sivor1p4ycx"},{"post_id":"cjdcfv1gv005q2sivduzyuefn","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hh006c2siv4g9jry1a"},{"post_id":"cjdcfv1gx005t2sivy3ui0rea","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hk006f2sivba2rh8ga"},{"post_id":"cjdcfv1h1005w2sivlsdm7qpm","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hn006j2sivn8qg28pf"},{"post_id":"cjdcfv1h5005z2sivfn8cqeo6","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hr006m2sivngs1pfpg"},{"post_id":"cjdcfv1h700622siv6t8ueo79","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hu006p2sivkksyql2p"},{"post_id":"cjdcfv1h900652sivqr34hxzw","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1hx006t2siv96z5hash"},{"post_id":"cjdcfv1hc00682siv68w5a2xh","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1i0006w2siv8897gc8q"},{"post_id":"cjdcfv1hg006b2sivb1i39ep0","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1i3006z2sivhov7f31s"},{"post_id":"cjdcfv1hi006e2siv38apb4l5","category_id":"cjdcfv1g300502sivz64cy0vy","_id":"cjdcfv1i600732sivi26wiaqp"},{"post_id":"cjdcfv1hk006h2sivghq68slr","category_id":"cjdcfv1g300502sivz64cy0vy","_id":"cjdcfv1i900762siv6fg1tlzh"},{"post_id":"cjdcfv1ho006l2sivaw0o4hxn","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1ic00792sivs6g36096"},{"post_id":"cjdcfv1hs006o2sivkh5volhc","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1ip007c2siv8f9481hw"},{"post_id":"cjdcfv1hv006r2sivfbqnzegp","category_id":"cjdcfv1g300502sivz64cy0vy","_id":"cjdcfv1is007f2siv05xpzvcy"},{"post_id":"cjdcfv1hy006v2siv3ko2tg5m","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1iv007i2siviozj93s3"},{"post_id":"cjdcfv1i1006y2sivpauq0u2z","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1iy007m2sivdkju3llq"},{"post_id":"cjdcfv1i400712sivmkq9va83","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1j3007p2sivb0taow7j"},{"post_id":"cjdcfv1i700752sivra6k6ujl","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1j6007s2sivh5kv4rr8"},{"post_id":"cjdcfv1i900782sivrvd9qr6r","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1j9007w2sivsietzf16"},{"post_id":"cjdcfv1id007b2sivcph643vp","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1jc007z2sivoqq5ytro"},{"post_id":"cjdcfv1iq007e2siv3ul89nco","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1jg00832sivatxrd4lp"},{"post_id":"cjdcfv1it007h2sivkdyxu621","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1jj00862sivdz4e27kf"},{"post_id":"cjdcfv1iw007k2sivup9hku7r","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1jm008a2sivv2yxlbnl"},{"post_id":"cjdcfv1iz007o2sivv37zf8qq","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1jq008d2sivgiwjdvee"},{"post_id":"cjdcfv1j4007r2sivnqvd7p21","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1ju008g2sivk8xw6fyy"},{"post_id":"cjdcfv1j6007u2sivkwba947c","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1jz008j2siv2u3svuof"},{"post_id":"cjdcfv1ja007y2siv9gy1528o","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1k3008m2sivncdt58fj"},{"post_id":"cjdcfv1jd00812sivonde973l","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1k6008p2sivm50negnt"},{"post_id":"cjdcfv1jh00852siv3ncnue0r","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1k9008s2sivzzkxvu5i"},{"post_id":"cjdcfv1jj00882sivfpv6e58c","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1kc008v2siv9oqrfryu"},{"post_id":"cjdcfv1jn008c2siv73u4247f","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1ke008y2sivqyplhys3"},{"post_id":"cjdcfv1jr008f2sivekc9j0es","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1kh00912sivtuvl971e"},{"post_id":"cjdcfv1jw008i2sivu9grkyk4","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1kk00942sivjyvgm5ot"},{"post_id":"cjdcfv1k0008l2siv4vq09mtt","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1km00972sivix2ug3mk"},{"post_id":"cjdcfv1k3008o2sivcosap0cf","category_id":"cjdcfv1as00092sivf2o7a82d","_id":"cjdcfv1ko009a2sivfe64hspw"},{"post_id":"cjdcfv1k7008r2siv20xisrlx","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1kr009d2sivjtfbahow"},{"post_id":"cjdcfv1ka008u2siv80dkvmnp","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1kt009g2sivkqa3nzsr"},{"post_id":"cjdcfv1kd008x2sivr69xyrg8","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1kv009j2sivtf9x6ktp"},{"post_id":"cjdcfv1kf00902sivtqhs4ayp","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1ky009m2sivudc4f8w1"},{"post_id":"cjdcfv1ki00932sivfb4qnp1x","category_id":"cjdcfv1cr001r2sivyw2pq0qj","_id":"cjdcfv1l0009p2sivm56v3yro"},{"post_id":"cjdcfv1kk00962siv77a4kkuu","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1l3009s2siv6xcw3jpj"},{"post_id":"cjdcfv1kn00992sivtlkgx62p","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1l5009v2siv5jc1mvp2"},{"post_id":"cjdcfv1kp009c2sivyt8qslwf","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1l9009z2sivlm4vq3bn"},{"post_id":"cjdcfv1kr009f2sivhk8cgqms","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1lb00a22siv5mhis3ur"},{"post_id":"cjdcfv1ku009i2sivrxztr3ze","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1le00a52siv539p18ql"},{"post_id":"cjdcfv1kw009l2sivrb95zxtx","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1lf00a72siveztqjkg6"},{"post_id":"cjdcfv1kz009o2siv8fqkytzh","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1lg00a92sivabr4j8ub"},{"post_id":"cjdcfv1l1009r2sivil83j4dj","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1lh00ab2sivgdlgocgm"},{"post_id":"cjdcfv1l3009u2sivebyp3gij","category_id":"cjdcfv1d300212siv7p59a53r","_id":"cjdcfv1li00ad2sivvaa8ur2v"},{"post_id":"cjdcfv1l6009x2siv294gobdc","category_id":"cjdcfv1a800042sivspy8bn7s","_id":"cjdcfv1li00af2sivqq6zq5el"},{"post_id":"cjdcfv1l900a12siv9mqu27v1","category_id":"cjdcfv1az000f2siv2zdl0jaw","_id":"cjdcfv1lj00ah2siv5uvfnfn0"},{"post_id":"cjdcfv1lc00a42sivl7vbw6tn","category_id":"cjdcfv1be000s2sive6u5alhs","_id":"cjdcfv1lj00aj2siv2mjzolyt"}],"PostTag":[{"post_id":"cjdcfv19s00002sivso9kjmuu","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1au000b2sivoqd14ndd"},{"post_id":"cjdcfv1a200022sivljv15xo4","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1b1000i2siv9203ggrn"},{"post_id":"cjdcfv1b0000h2sivrrgv0z3h","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1b6000n2sivzw2kznq5"},{"post_id":"cjdcfv1ae00062siv7rpyiz4y","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1bb000q2siv974l3jd0"},{"post_id":"cjdcfv1b3000j2sivp0or7opb","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1bg000v2sivyz42ooah"},{"post_id":"cjdcfv1b8000o2sivbx6r0fo4","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1bk000y2siv1434kurc"},{"post_id":"cjdcfv1ak00072sivszas54jj","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1bn00112sivnxu6aes1"},{"post_id":"cjdcfv1bg000w2sivst6jqaes","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1bs00162sivr5g3jys6"},{"post_id":"cjdcfv1an00082siv89xt78uk","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1bw00192siv59txl1ke"},{"post_id":"cjdcfv1bk000z2siv0y2vtc9f","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1c1001e2sivro21hucp"},{"post_id":"cjdcfv1bp00142sivp1gayl7y","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1c5001h2sivabmanlao"},{"post_id":"cjdcfv1av000c2sivdsnw79wl","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1cf001m2sivdspu4y2g"},{"post_id":"cjdcfv1bt00172siv8grk49m0","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1cl001p2sivrdvftkp2"},{"post_id":"cjdcfv1by001c2sivlbmeqpeo","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1cu001t2sivbzelq4c2"},{"post_id":"cjdcfv1ay000e2siv0gpa0z9n","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1cy001w2sivv41q8yqx"},{"post_id":"cjdcfv1c2001f2sivu5305bs6","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1d1001z2sivx90zien5"},{"post_id":"cjdcfv1c8001k2sivy1doplwb","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1d400232siv6cv5cmi7"},{"post_id":"cjdcfv1bc000r2sivb6d2af7c","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1d700262sivcjzfjzx3"},{"post_id":"cjdcfv1cg001n2sivba317muo","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1da002a2sivzhmk1yzd"},{"post_id":"cjdcfv1cn001q2sivpl2nl140","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1dd002d2sivvc9m158k"},{"post_id":"cjdcfv1cv001u2siv8szfnhnf","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1dj002i2sivxapvhlbc"},{"post_id":"cjdcfv1cz001x2sivybpmdses","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1dn002l2siv0s2jasl1"},{"post_id":"cjdcfv1d200202sivn3tz095y","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1dp002o2sivuwqalqkn"},{"post_id":"cjdcfv1d400242sivh0o5jt9w","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1dv002r2sivipqd9pxb"},{"post_id":"cjdcfv1d700272sivyg0tn9ci","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1dz002v2sivrivkwd1n"},{"post_id":"cjdcfv1dd002e2sivfoean49c","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1e1002y2sivm8fw8m08"},{"post_id":"cjdcfv1dl002j2sivmnww122l","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1e400312sivp9p9h5wf"},{"post_id":"cjdcfv1do002m2sivws22j3zr","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1e600342siv9vhx8mlt"},{"post_id":"cjdcfv1db002b2sivg507d99e","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1e800372sivn4v85a7e"},{"post_id":"cjdcfv1dq002p2sivkwhl2y96","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1ea003a2sivt7qyx471"},{"post_id":"cjdcfv1dv002s2sivl3dj86jt","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ed003d2siv12679812"},{"post_id":"cjdcfv1dv002s2sivl3dj86jt","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1ef003g2sivq1f2flu8"},{"post_id":"cjdcfv1dz002w2sivfuvi8tjo","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1ej003j2sivzl2e28oc"},{"post_id":"cjdcfv1e2002z2sivblexr7fa","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1en003m2sivlghh6fvq"},{"post_id":"cjdcfv1e400322siv5dec103q","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1eu003p2sivtle9u2b8"},{"post_id":"cjdcfv1e600352sivxpq74gdb","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ey003s2sivibtfus9t"},{"post_id":"cjdcfv1e600352sivxpq74gdb","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1f2003v2sivj8iqj54y"},{"post_id":"cjdcfv1e800382sivmw97kij0","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1f5003y2sivybydr8ps"},{"post_id":"cjdcfv1e800382sivmw97kij0","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1f800412sivvzguswxq"},{"post_id":"cjdcfv1eb003b2siv376vber1","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1fa00442siv0ag6ok5u"},{"post_id":"cjdcfv1eb003b2siv376vber1","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1fd00472siv71dmlxuv"},{"post_id":"cjdcfv1ed003e2sivt81rgj70","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1fg004a2sivs9p6myjp"},{"post_id":"cjdcfv1ed003e2sivt81rgj70","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1fi004d2siv7kpyvvkr"},{"post_id":"cjdcfv1ef003h2siv7yp6f44p","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1fl004g2siv506vbuzi"},{"post_id":"cjdcfv1ek003k2siv6gnrscks","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1fn004j2sivxfm75wto"},{"post_id":"cjdcfv1ek003k2siv6gnrscks","tag_id":"cjdcfv1di002g2sivrsu5835b","_id":"cjdcfv1fq004m2sivck5koqbe"},{"post_id":"cjdcfv1ep003n2sivb2aaknqm","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1fu004p2siv8255z261"},{"post_id":"cjdcfv1eu003q2sivko4r8ur9","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1fx004s2sivyslwqsm3"},{"post_id":"cjdcfv1ey003t2sivnnulznb9","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1fz004v2sivcb68zlus"},{"post_id":"cjdcfv1f2003w2siv2vrjuvsm","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1g1004y2siv701nql4s"},{"post_id":"cjdcfv1f5003z2sivnwwywf8g","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1g500532sivt32pflvz"},{"post_id":"cjdcfv1f800422sivei0kafs0","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1g900562sivinqkwzrs"},{"post_id":"cjdcfv1fb00452siv7ia1trp9","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gd00592siveh2bmhrb"},{"post_id":"cjdcfv1fd00482sivso4dhge7","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gg005d2sivnw2anp7c"},{"post_id":"cjdcfv1fg004b2sivqfh5yk75","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gj005g2siv8l23qk3w"},{"post_id":"cjdcfv1fj004e2sivdkynh16k","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gp005j2sivkg4wse4b"},{"post_id":"cjdcfv1fl004h2sivw51ich70","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gr005m2siv4p7lfbxb"},{"post_id":"cjdcfv1fn004k2sivx69z1lqb","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gu005p2siv40f6mm7n"},{"post_id":"cjdcfv1fr004n2sivpgvgpldi","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1gw005s2siv8ev95moy"},{"post_id":"cjdcfv1fu004q2sivo87hz8j5","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1h1005v2sivy18p9sto"},{"post_id":"cjdcfv1fx004t2sivnbus8we0","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1h4005y2sivikmz0fj8"},{"post_id":"cjdcfv1g1004z2sivef9n7ub3","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1h700612siv7gd1x3qg"},{"post_id":"cjdcfv1ga00572siv444gdlx5","tag_id":"cjdcfv1g400512sivizzh7cb8","_id":"cjdcfv1h900642sivhgu6fgmr"},{"post_id":"cjdcfv1fz004w2sivtux62i4f","tag_id":"cjdcfv1g400512sivizzh7cb8","_id":"cjdcfv1hb00672siv10s49i1m"},{"post_id":"cjdcfv1gd005a2siv39jut5c5","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1hf006a2siv8ii2v101"},{"post_id":"cjdcfv1gg005e2sivk1tx9w6f","tag_id":"cjdcfv1g400512sivizzh7cb8","_id":"cjdcfv1hi006d2sivlwhef4ye"},{"post_id":"cjdcfv1g500542sivu4k379lq","tag_id":"cjdcfv1gf005b2sivbgynviwm","_id":"cjdcfv1hk006g2siv30g94jn5"},{"post_id":"cjdcfv1gm005h2sivmsoe92bm","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1ho006k2siv7lwe67vm"},{"post_id":"cjdcfv1gp005k2sivcudea5ts","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1hs006n2sivbm4mx0ua"},{"post_id":"cjdcfv1gs005n2sivt6qoagzh","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1hv006q2sivdtj42qoy"},{"post_id":"cjdcfv1gv005q2sivduzyuefn","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1hy006u2sivnjfwfqr5"},{"post_id":"cjdcfv1gx005t2sivy3ui0rea","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1i1006x2sivioju1975"},{"post_id":"cjdcfv1h1005w2sivlsdm7qpm","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1i400702sivissk3jvt"},{"post_id":"cjdcfv1h5005z2sivfn8cqeo6","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1i600742sivc0831k6k"},{"post_id":"cjdcfv1h700622siv6t8ueo79","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1i900772sivffn3sckb"},{"post_id":"cjdcfv1h900652sivqr34hxzw","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1id007a2sivu3s24dpz"},{"post_id":"cjdcfv1hc00682siv68w5a2xh","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1iq007d2sivkvgzjom0"},{"post_id":"cjdcfv1hg006b2sivb1i39ep0","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1it007g2siv57w470e4"},{"post_id":"cjdcfv1ho006l2sivaw0o4hxn","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1iv007j2sivlluh6z38"},{"post_id":"cjdcfv1hs006o2sivkh5volhc","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1iz007n2sivolf3uzbi"},{"post_id":"cjdcfv1hi006e2siv38apb4l5","tag_id":"cjdcfv1hn006i2sivrrim29gm","_id":"cjdcfv1j4007q2siv6ddtr8f5"},{"post_id":"cjdcfv1hv006r2sivfbqnzegp","tag_id":"cjdcfv1hn006i2sivrrim29gm","_id":"cjdcfv1j6007t2sivix0avf6g"},{"post_id":"cjdcfv1hy006v2siv3ko2tg5m","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1ja007x2sivx75iw5tw"},{"post_id":"cjdcfv1hk006h2sivghq68slr","tag_id":"cjdcfv1hn006i2sivrrim29gm","_id":"cjdcfv1jd00802sivdqr36rbw"},{"post_id":"cjdcfv1i400712sivmkq9va83","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1jh00842sivoxqurvxv"},{"post_id":"cjdcfv1i700752sivra6k6ujl","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1jj00872sivgip2glk9"},{"post_id":"cjdcfv1i900782sivrvd9qr6r","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1jn008b2sivy9gsdoyt"},{"post_id":"cjdcfv1i1006y2sivpauq0u2z","tag_id":"cjdcfv1i600722sivthmfv0jr","_id":"cjdcfv1jq008e2siv9k3pwtqh"},{"post_id":"cjdcfv1id007b2sivcph643vp","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1jv008h2sivgq9larhb"},{"post_id":"cjdcfv1iq007e2siv3ul89nco","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1jz008k2siveu4wu6e4"},{"post_id":"cjdcfv1j4007r2sivnqvd7p21","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1k3008n2sivbi9czzve"},{"post_id":"cjdcfv1j4007r2sivnqvd7p21","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1k7008q2siv85qhy6so"},{"post_id":"cjdcfv1j6007u2sivkwba947c","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ka008t2sivrfpjdwog"},{"post_id":"cjdcfv1j6007u2sivkwba947c","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1kc008w2sivhjo997vf"},{"post_id":"cjdcfv1ja007y2siv9gy1528o","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1kf008z2siv0mu1s78j"},{"post_id":"cjdcfv1ja007y2siv9gy1528o","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1ki00922sivzfot7v06"},{"post_id":"cjdcfv1it007h2sivkdyxu621","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1kk00952sivj4dpp4od"},{"post_id":"cjdcfv1it007h2sivkdyxu621","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1km00982sivpfa94m56"},{"post_id":"cjdcfv1it007h2sivkdyxu621","tag_id":"cjdcfv1j8007v2sivf0iz8i08","_id":"cjdcfv1kp009b2sivdlfdernk"},{"post_id":"cjdcfv1jd00812sivonde973l","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1kr009e2siv374gajai"},{"post_id":"cjdcfv1jd00812sivonde973l","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1kt009h2sivfy8xzk6z"},{"post_id":"cjdcfv1jh00852siv3ncnue0r","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1kw009k2sivt3zch8fy"},{"post_id":"cjdcfv1iw007k2sivup9hku7r","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ky009n2sivtlllzr68"},{"post_id":"cjdcfv1iw007k2sivup9hku7r","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1l1009q2sivlsf28p8g"},{"post_id":"cjdcfv1jj00882sivfpv6e58c","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1l3009t2sivov6ax5nq"},{"post_id":"cjdcfv1jj00882sivfpv6e58c","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1l6009w2sivlg6dfige"},{"post_id":"cjdcfv1jn008c2siv73u4247f","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1l900a02siv6schzfmk"},{"post_id":"cjdcfv1jn008c2siv73u4247f","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lc00a32sivs8nlixl6"},{"post_id":"cjdcfv1iz007o2sivv37zf8qq","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1le00a62sivz7t8qmfr"},{"post_id":"cjdcfv1iz007o2sivv37zf8qq","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lf00a82sivjqovmtnh"},{"post_id":"cjdcfv1jr008f2sivekc9j0es","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lg00aa2sivzqh6xhos"},{"post_id":"cjdcfv1jr008f2sivekc9j0es","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lh00ac2siv114sw525"},{"post_id":"cjdcfv1jw008i2sivu9grkyk4","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1li00ae2sivb9rauw4m"},{"post_id":"cjdcfv1jw008i2sivu9grkyk4","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lj00ag2sivvs3hxexi"},{"post_id":"cjdcfv1k0008l2siv4vq09mtt","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1lj00ai2siva8p4fwzm"},{"post_id":"cjdcfv1k3008o2sivcosap0cf","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1lk00ak2sivht2fyked"},{"post_id":"cjdcfv1k7008r2siv20xisrlx","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1lk00al2sivkhkfmc1h"},{"post_id":"cjdcfv1ka008u2siv80dkvmnp","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1lk00am2sivovs1cxy0"},{"post_id":"cjdcfv1kd008x2sivr69xyrg8","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1lk00an2sivpk1oswqq"},{"post_id":"cjdcfv1kf00902sivtqhs4ayp","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1ll00ao2sivlj092cn6"},{"post_id":"cjdcfv1ki00932sivfb4qnp1x","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1ll00ap2siv2s3m7pjb"},{"post_id":"cjdcfv1kk00962siv77a4kkuu","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ll00aq2siv85wfk6y7"},{"post_id":"cjdcfv1kk00962siv77a4kkuu","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1ll00ar2sivz2hyj8u4"},{"post_id":"cjdcfv1kn00992sivtlkgx62p","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ll00as2sivo5ihsb0d"},{"post_id":"cjdcfv1kn00992sivtlkgx62p","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lm00at2sivvklvb740"},{"post_id":"cjdcfv1kp009c2sivyt8qslwf","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lm00au2sivs1rscdw5"},{"post_id":"cjdcfv1kp009c2sivyt8qslwf","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lm00av2sivney3o9dt"},{"post_id":"cjdcfv1kr009f2sivhk8cgqms","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lm00aw2sivwj1ro95k"},{"post_id":"cjdcfv1kr009f2sivhk8cgqms","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lm00ax2sivhs49xeys"},{"post_id":"cjdcfv1ku009i2sivrxztr3ze","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1ln00ay2sivwxt1jo2y"},{"post_id":"cjdcfv1ku009i2sivrxztr3ze","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lo00az2sivzy4p4uyq"},{"post_id":"cjdcfv1kw009l2sivrb95zxtx","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lp00b02siv61zuxxdg"},{"post_id":"cjdcfv1kw009l2sivrb95zxtx","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lp00b12sivooqe0d2e"},{"post_id":"cjdcfv1kz009o2siv8fqkytzh","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lq00b22sivfu7eyjhv"},{"post_id":"cjdcfv1kz009o2siv8fqkytzh","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lq00b32sivou8m8tl1"},{"post_id":"cjdcfv1l1009r2sivil83j4dj","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lr00b42sivj1myyw09"},{"post_id":"cjdcfv1l1009r2sivil83j4dj","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1lr00b52sivgm16t7rq"},{"post_id":"cjdcfv1l6009x2siv294gobdc","tag_id":"cjdcfv1ac00052sivga2dr4wb","_id":"cjdcfv1lr00b62sivs8d3roiy"},{"post_id":"cjdcfv1l6009x2siv294gobdc","tag_id":"cjdcfv1ix007l2sivvvgwlrje","_id":"cjdcfv1ls00b72sivphtp59yw"},{"post_id":"cjdcfv1l900a12siv9mqu27v1","tag_id":"cjdcfv1b0000g2sivkpctf37l","_id":"cjdcfv1ls00b82siv2q8qpm0q"},{"post_id":"cjdcfv1l900a12siv9mqu27v1","tag_id":"cjdcfv1as000a2siv3qqzs21n","_id":"cjdcfv1ls00b92sivnz5aj2p5"},{"post_id":"cjdcfv1lc00a42sivl7vbw6tn","tag_id":"cjdcfv1bf000t2sivqjirjubz","_id":"cjdcfv1ls00ba2sivwnkzpk15"},{"post_id":"cjdcfv1l3009u2sivebyp3gij","tag_id":"cjdcfv1l8009y2sivq4xfx0os","_id":"cjdcfv1ls00bb2sivlg06symo"}],"Tag":[{"name":"算法","_id":"cjdcfv1ac00052sivga2dr4wb"},{"name":"杂项","_id":"cjdcfv1as000a2siv3qqzs21n"},{"name":"android","_id":"cjdcfv1b0000g2sivkpctf37l"},{"name":"设计模式","_id":"cjdcfv1bf000t2sivqjirjubz"},{"name":"hotfix","_id":"cjdcfv1di002g2sivrsu5835b"},{"name":"javaEE","_id":"cjdcfv1g400512sivizzh7cb8"},{"name":"cognition","_id":"cjdcfv1gf005b2sivbgynviwm"},{"name":"网络","_id":"cjdcfv1hn006i2sivrrim29gm"},{"name":"raspbarry","_id":"cjdcfv1i600722sivthmfv0jr"},{"name":"PAT","_id":"cjdcfv1ix007l2sivvvgwlrje"},{"name":"LeetCode","_id":"cjdcfv1j8007v2sivf0iz8i08"},{"name":"JVM","_id":"cjdcfv1l8009y2sivq4xfx0os"}]}}