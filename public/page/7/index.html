<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.jpg?v=5.1.1" />






<meta name="description" content="博观而约取，厚积而薄发。">
<meta property="og:type" content="website">
<meta property="og:title" content="行次">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="行次">
<meta property="og:description" content="博观而约取，厚积而薄发。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="行次">
<meta name="twitter:description" content="博观而约取，厚积而薄发。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>行次</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">行次</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/suffix-sort-baseon-dc3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/13/suffix-sort-baseon-dc3/" itemprop="url">基于DC3算法实现后缀数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T00:00:00Z">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p> DC3算法(Difference Cover mod 3)是J. Kärkkäinen和P. Sanders在2003年发表的论文 “Simple Linear Work Suffix Array Construction”中描述的线性时间内构造后缀数组的算法。相对Prefix Doubling（前缀倍增）算法而言，虽然它的渐进时间复杂度比较小，但是常数项比较大。DC3算法的思想类似于找中位数的median of medians算法</p>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><ol>
<li>先将后缀分成两部分，然后对第一部分的后缀排序;</li>
<li>利用1的结果，对第二部分的后缀排序;</li>
<li>将1和2的结果合并，即完成对所有后缀排序;</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>package DC3;

/**
 * DC3算法构建后缀数组
 * 
 * @author sxx.xu
 *
 */
public class DC3 {

    public static final char MAX_CHAR = &apos;\u00FF&apos;;

    class Suffix {
        int[] sa;
        int[] rank;
        boolean done;

        public Suffix(int[] sa, int[] rank) {
            this.sa = sa;
            this.rank = rank;
        }
    }

    class Tuple {
        int iSuffix;
        int[] digits;

        public Tuple(int iSuffix, int[] digits) {
            this.iSuffix = iSuffix;
            this.digits = digits;
        }

        public String toString() {
            StringBuffer sb = new StringBuffer();
            sb.append(iSuffix);
            sb.append(&quot;(&quot;);
            for (int i = 0; i &lt; digits.length; i++) {
                sb.append(digits[i]);
                if (i &lt; digits.length - 1)
                    sb.append(&quot;-&quot;);
            }
            sb.append(&quot;)&quot;);
            return sb.toString();
        }
    }

    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {

        int[] C = new int[max + 1];
        for (int i = 0; i &lt;= max; i++) {
            C[i] = 0;
        }

        for (int i = 0; i &lt; tA.length; i++) {
            C[tA[i].digits[d]]++;
        }

        for (int i = 1; i &lt;= max; i++) {
            C[i] += C[i - 1];
        }

        for (int i = tA.length - 1; i &gt;= 0; i--) {
            tB[--C[tA[i].digits[d]]] = tA[i];
        }
    }

    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {
        int len = tA.length;
        int digitsTotalLen = tA[0].digits.length;

        for (int i = digitsTotalLen - 1, j = 0; j &lt; digitsLen; i--, j++) {
            this.countingSort(i, tA, tB, max);
            if (j &lt; digitsLen - 1) {
                for (int k = 0; k &lt; len; k++) {
                    tA[k] = tB[k];
                }
            }
        }
    }

    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {
        int len = tA.length;
        radixSort(tA, tB, max, digitsLen);

        int digitsTotalLen = tA[0].digits.length;

        int[] sa = new int[len];
        sa[0] = tB[0].iSuffix;

        int[] rank = new int[len + 2];
        rank[len] = 1;
        rank[len + 1] = 1;

        int r = 1;

        rank[tB[0].iSuffix] = r;

        for (int i = 1; i &lt; len; i++) {
            sa[i] = tB[i].iSuffix;

            boolean equalLast = true;

            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {
                if (tB[i].digits[j] != tB[i - 1].digits[j]) {
                    equalLast = false;
                    break;
                }
            }

            if (!equalLast)
                r++;

            rank[tB[i].iSuffix] = r;

        }

        Suffix suffix = new Suffix(sa, rank);
        if (r == len) {
            suffix.done = true;
        } else {
            suffix.done = false;
        }

        return suffix;
    }

    private int[] orderSuffix(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {

        int len = tA.length;
        radixSort(tA, tB, max, digitsLen);
        int[] sa = new int[len];
        for (int i = 0; i &lt; sa.length; i++)
            sa[i] = tB[i].iSuffix;

        return sa;

    }

    public Suffix reduce(int[] rank, int max) {

        int len = rank.length - 2;
        int n1 = (len + 1) / 3;
        int n2 = len / 3;

        Tuple[] tA = new Tuple[n1 + n2];
        Tuple[] tB = new Tuple[n1 + n2];

        for (int i = 0, j = 1; i &lt; n1; i++, j += 3) {

            int r1 = rank[j];
            int r2 = rank[j + 1];
            int r3 = rank[j + 2];

            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });
        }

        for (int i = n1, j = 2; i &lt; n1 + n2; i++, j += 3) {

            int r1 = rank[j];
            int r2 = rank[j + 1];
            int r3 = rank[j + 2];

            tA[i] = new Tuple(i, new int[] { r1, r2, r3 });
        }

        return rank(tA, tB, max, 3);
    }

    public int[] skew(int[] rank, int max) {
        int len = rank.length - 2;

        Suffix suffixT12 = reduce(rank, max);

        int[] sa12 = null;

        // 1.caculate sa12
        if (!suffixT12.done) {
            int[] rankT12 = suffixT12.rank;
            int maxT12 = rankT12[suffixT12.sa[suffixT12.sa.length - 1]];
            sa12 = skew(rankT12, maxT12);
        } else {
            sa12 = suffixT12.sa;
        }

        // index conversion for sa12
        int n1 = (len + 1) / 3;
        for (int i = 0; i &lt; sa12.length; i++) {
            if (sa12[i] &lt; n1) {
                sa12[i] = 1 + 3 * sa12[i];
            } else {
                sa12[i] = 2 + 3 * (sa12[i]-n1);
            }
        }

        // recaculate rank for sa12
        int[] rank12 = new int[len + 2];

        rank12[len] = 1;
        rank12[len + 1] = 1;

        for (int i = 0; i &lt; sa12.length; i++) {
            rank12[sa12[i]] = i + 1;
        }

        // 2.caculate sa0

        int n0 = (len + 2) / 3;
        Tuple[] tA = new Tuple[n0];
        Tuple[] tB = new Tuple[n0];

        for (int i = 0, j = 0; i &lt; n0; i++, j += 3) {
            int r1 = rank[j];
            int r2 = rank12[j + 1];
            tA[i] = new Tuple(i, new int[] { r1, r2 });
        }

        int max12 = rank12[sa12[sa12.length - 1]];
        int[] sa0 = orderSuffix(tA, tB, max &lt; max12 ? max12 : max, 2);

        for (int i = 0; i &lt; n0; i++) {
            sa0[i] = 3 * sa0[i];
        }

        // 3.merge sa12 and sa0

        int[] sa = new int[len];
        int i = 0, j = 0, k = 0;

        while (i &lt; sa12.length &amp;&amp; j &lt; sa0.length) {
            int p = sa12[i];
            int q = sa0[j];

            if (p % 3 == 1) {

                if (rank[p] &lt; rank[q]) {
                    sa[k++] = p;
                    i++;
                } else if (rank[p] &gt; rank[q]) {
                    sa[k++] = q;
                    j++;
                } else {
                    if (rank12[p + 1] &lt; rank12[q + 1]) {
                        sa[k++] = p;
                        i++;
                    } else {
                        sa[k++] = q;
                        j++;
                    }
                }
            } else {
                if (rank[p] &lt; rank[q]) {
                    sa[k++] = p;
                    i++;
                } else if (rank[p] &gt; rank[q]) {
                    sa[k++] = q;
                    j++;
                } else {
                    if (rank[p + 1] &lt; rank[q + 1]) {
                        sa[k++] = p;
                        i++;
                    } else if (rank[p + 1] &gt; rank[q + 1]) {
                        sa[k++] = q;
                        j++;
                    } else {
                        if (rank12[p + 2] &lt; rank12[q + 2]) {
                            sa[k++] = p;
                            i++;
                        } else {
                            sa[k++] = q;
                            j++;
                        }
                    }
                }
            }
        }
        for (int m = i; m &lt; sa12.length; m++) {
            sa[k++] = sa12[m];
        }
        for (int m = j; m &lt; sa0.length; m++) {
            sa[k++] = sa0[m];
        }
        return sa;

    }

     public Suffix solve(String text){  
            if(text == null)return null;  
            int len = text.length();  
            if(len == 0) return null;  

            char base = text.charAt(len-1); //the smallest char  
            Tuple[] tA = new Tuple[len];  
            Tuple[] tB = new Tuple[len]; //placeholder  
            for(int i=0;i&lt;len;i++){  
                tA[i] = new Tuple(i,new int[]{0,text.charAt(i)-base});  
            }  
            Suffix suffix = rank(tA,tB,MAX_CHAR-base,1);  

            int max = suffix.rank[suffix.sa[len-1]];  
            int[] sa  = skew(suffix.rank,max);  

            //caculate rank for result suffix array  
            int[] r = new int[len];       
            for(int k=0;k&lt;sa.length;k++){  
                r[sa[k]] = k+1;  
            }  
            return new Suffix(sa,r);  

        }  
        public void report(Suffix suffix){  
            int[] sa = suffix.sa;  
            int[] rank = suffix.rank;  
            int len = sa.length;  

            System.out.println(&quot;suffix array:&quot;);  
            for(int i=0;i&lt;len;i++){  
                System.out.format(&quot; %s&quot;, sa[i]);              
            }  
            System.out.println();  
            System.out.println(&quot;rank array:&quot;);  
            for(int i=0;i&lt;len;i++){  
                System.out.format(&quot; %s&quot;, rank[i]);            
            }         
            System.out.println();  
        }  
        public static void main(String[] args) {  
            String text = &quot;GACCCACCACC#&quot;;  
            DC3 dc3 = new DC3();  
            Suffix suffix = dc3.solve(text);  
            System.out.format(&quot;Text: %s%n&quot;,text);  
            dc3.report(suffix);  

            text = &quot;mississippi#&quot;;  
            dc3 = new DC3();  
            suffix = dc3.solve(text);  
            System.out.format(&quot;Text: %s%n&quot;,text);  
            dc3.report(suffix);  

            text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;  
            dc3 = new DC3();  
            suffix = dc3.solve(text);  
            System.out.format(&quot;Text: %s%n&quot;,text);  
            dc3.report(suffix);  

            text = &quot;yabbadabbado#&quot;;  
            dc3 = new DC3();  
            suffix = dc3.solve(text);  
            System.out.format(&quot;Text: %s%n&quot;,text);  
            dc3.report(suffix);  

            text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;  
            dc3 = new DC3();  
            suffix = dc3.solve(text);  
            System.out.format(&quot;Text: %s%n&quot;,text);  
            dc3.report(suffix);  
        }  
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/suffix-sort-baseon-prefix-doubleing/" itemprop="url">基于(前缀)倍增算法实现后缀数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T00:00:00Z">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有几个基本概念需要知道。<br></p>
<p>&gt;</p>
<ol>
<li><strong>子串：</strong>字符串S的子串r[i…j],i &lt;= j,表示r串从i到j这一段，就是顺次排列r[i],r[i+1],…,r[j]形成的字符串;</li>
<li><strong>后缀：</strong>从某个位置i开始，到整个字符串末尾结束的一个特殊子串。字符串S的从第i个字符开始的后缀表示suffix(i),也就是suffix(i) = r[i…len(r)];<br></li>
<li><strong>大小比较：</strong>关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串u、v，令从i=1，开始顺次比较u[i]和v[i]，如果u[i]=v[i]，则令i++，否则，若u[i]&gt;v[i]则认为u&gt;v，反之则认为u<v，比较结束。如果i>len(u)或者i&gt;len(v)仍比较不出结果，那么若len(u)&gt;len(v)，则认为u&gt;v,反之则认为u<v.<br>从大小比较定义来看，S的后缀比较结果是不可能相等，因为u=v的必要条件len(u)=len(v)无法满足。</v.<br></v，比较结束。如果i></li>
<li><strong>后缀数组：</strong>后缀数组SA是一个一维数组，它保存1…n的某个排列SA[1],SA[2],…,SA[n],并且保证suffix(SA[i])&lt;suffix(SA[i+1]), 1 &lt;= i &lt; n。也就是将S的n个后缀从小到大进行排序之后，把有序的后缀的开头位置顺次放入SA中。</li>
<li><strong>名次数组：</strong>名字数组rank[i]保存的是suffix(i)在所有后缀中从小到大排列的“名次”。简单的说，后缀数组SA是“排第几的是谁？”，名次数组rank是“你排第几？”。容易看出，后缀数组和名次数组互为逆运算。</li>
<li><strong>height数组：</strong>定义height[i]=suffix(SA[i-1])和suffix(SA[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀，h[i]=height[rank[i]],也就是suffix(i)和在它前一名的后缀的最长公共前缀</li>
<li><strong>LCP(i,j):</strong>对正整数i,j定义LCP(i,j)=lcp(Suffix(SA[i]),Suffix(SA[j]),其中i,j均为1至n的整数。LCP(i,j)也就是后缀数组中第i个和第j个后缀的最长公共前缀的长度。其中，函数lcp(u,v)=max{i|u=v},也就是从头开始顺次比较u和v的对应字符，对应字符持续相等的最大位置，称为这两个字符串的最长公共前缀。</li>
</ol>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p> Prefix Doubling算法(前缀倍增法)是构造后缀数组一个比较实用的算法。其基本思想是先计算出每个后缀的k-前缀的rank值，然后在此基础上计算每个后缀的2k-前缀rank值，k从1开始。直到每个后缀都排出先后顺序为止(后缀必有先后顺序，原因见上面的解释)。在处理2k-前缀时，只需要使用<a href="http://xusx1024.com/2017/04/10/radix-sort/" target="_blank" rel="external">基数排序(radix sort)</a>算法，先后对两位数字排序，可以采用<a href="http://xusx1024.com/2017/04/11/counting-sort/" target="_blank" rel="external">计数排序算法(counting sort)</a>对每一位数字排序。在最坏情况下，需要做lgn次基数排序，每一次基数排序的操作次数为2*O(n),因此它的时间复杂是O(nlgn)。倍增法虽然没有达到想DC3算法的线性复杂度，但是它的优点是实现比较简单，因此常常被采用。</p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p><img src="/images/prefix_doubleing_demo_1.png" alt="示例图"><br><br> </p>
<p><img src="/images/SA&amp;rank.png" alt="示例图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>java语言实现：<br></p>
<pre><code>package PrefixDoubling;

import java.util.Arrays;

/**
 * 倍增算法实现后缀数组
 * 
 * @author sxx.xu
 *
 */
public class PrefixDoubling {

    public static final char MAX_CHAR = &apos;\u00FF&apos;;

    /**
     * sa中第i个后缀：SA[rank[i]-1];&lt;br&gt;
     * i是rank数组的下标;&lt;br&gt;
     * 串S的第i个后缀是S[i...n],n=S.length-1.
     * 
     * @author sxx.xu
     *
     */
    class Suffix {
        int[] sa;
        int[] rank;
        boolean done;
    }

    class Tuple {
        int iSuffix;
        int[] digits;

        public Tuple(int suffix, int[] digits) {
            this.iSuffix = suffix;
            this.digits = digits;
        }

        public String toString() {
            StringBuffer sb = new StringBuffer();
            sb.append(iSuffix);
            sb.append(&quot;(&quot;);
            for (int i = 0; i &lt; digits.length; i++) {
                sb.append(digits[i]);
                if (i &lt; digits.length - 1)
                    sb.append(&quot;-&quot;);
            }
            sb.append(&quot;)&quot;);
            return sb.toString();
        }
    }


    private void countingSort(int d, Tuple[] tA, Tuple[] tB, int max) {
        int[] C = new int[max + 1];
        for (int i : C)
            i = 0;

        for (int j = 0; j &lt; tA.length; j++) {
            C[tA[j].digits[d]]++;
        }

        for (int i = 1; i &lt;= max; i++)
            C[i] += C[i - 1];

        for (int j = tA.length - 1; j &gt;= 0; j--) {

            tB[--C[tA[j].digits[d]]] = tA[j];

        }
    }

    private void radixSort(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {
        int len = tA.length;
        int digitsTotalLen = tA[0].digits.length;

        for (int d = digitsTotalLen - 1, j = 0; j &lt; digitsLen; d--, j++) {
            this.countingSort(d, tA, tB, max);
            if (j &lt; digitsLen - 1) {
                for (int i = 0; i &lt; len; i++) {
                    tA[i] = tB[i];
                }
            }
        }

    }

    private Suffix rank(Tuple[] tA, Tuple[] tB, int max, int digitsLen) {
        int len = tA.length;
        radixSort(tA, tB, max, digitsLen);

        int digitsTotalLen = tA[0].digits.length;

        int[] sa = new int[len];
        sa[0] = tB[0].iSuffix;

        int[] rank = new int[len];
        int r = 1;
        rank[tB[0].iSuffix] = r;
        for (int i = 1; i &lt; len; i++) {
            sa[i] = tB[i].iSuffix;

            boolean equalLast = true;

            for (int j = digitsTotalLen - digitsLen; j &lt; digitsTotalLen; j++) {
                if (tB[i].digits[j] != tB[i - 1].digits[j]) {
                    equalLast = false;
                    break;
                }
            }

            if (!equalLast) {
                r++;
            }
            rank[tB[i].iSuffix] = r;
        }

        Suffix suffix = new Suffix();
        suffix.rank = rank;
        suffix.sa = sa;
        if (r == len) {
            suffix.done = true;
        } else {
            suffix.done = false;
        }

        return suffix;
    }

    public Suffix solve(String text) {
        if (text == null)
            return null;
        int len = text.length();
        if (len == 0)
            return null;

        int k = 1;
        char base = text.charAt(len - 1);
        Tuple[] tA = new Tuple[len];
        Tuple[] tB = new Tuple[len];

        for (int i = 0; i &lt; len; i++) {
            tA[i] = new Tuple(i, new int[] { 0, text.charAt(i) - base });
        }

        Suffix suffix = rank(tA, tB, MAX_CHAR - base, 1);
        while (!suffix.done) {
            k &lt;&lt;= 1;
            int offset = k &gt;&gt; 1;
            for (int i = 0, j = i + offset; i &lt; len; i++, j++) {
                tA[i].iSuffix = i;
                tA[i].digits = new int[] { suffix.rank[i], (j &lt; len) ? suffix.rank[i + offset] : 0 };
            }
            int max = suffix.rank[suffix.sa[len - 1]];
            suffix = rank(tA, tB, max, 2);
        }
        return suffix;
    }

    public void report(Suffix suffix) {
        int[] sa = suffix.sa;
        int[] rank = suffix.rank;
        int len = sa.length;
        System.out.println(&quot;suffix array:&quot;);
        for (int i = 0; i &lt; len; i++)
            System.out.format(&quot; %s&quot;, sa[i]);

        System.out.println();
        System.out.println(&quot;rank array:&quot;);
        for (int i = 0; i &lt; len; i++)
            System.out.format(&quot; %s&quot;, rank[i]);
        System.out.println();
    }

    public static void main(String[] args) {
        /*
         * //plain counting sort test:
         * 
         * int[] A= {2,5,3,0,2,3,0,3}; PrefixDoubling pd = new PrefixDoubling();
         * int[] B = new int[A.length]; pd.countingSort(A,B,5); for(int
         * i=0;i&lt;B.length;i++) System.out.format(&quot; %d&quot;, B[i]);
         * System.out.println();
         */

        String text = &quot;GACCCACCACC#&quot;;
        PrefixDoubling pd = new PrefixDoubling();
        Suffix suffix = pd.solve(text);
        System.out.format(&quot;Text: %s%n&quot;, text);
        pd.report(suffix);

        System.out.println(&quot;********************************&quot;);
        text = &quot;mississippi#&quot;;
        pd = new PrefixDoubling();
        suffix = pd.solve(text);
        System.out.format(&quot;Text: %s%n&quot;, text);
        pd.report(suffix);

        System.out.println(&quot;********************************&quot;);
        text = &quot;abcdefghijklmmnopqrstuvwxyz#&quot;;
        pd = new PrefixDoubling();
        suffix = pd.solve(text);
        System.out.format(&quot;Text: %s%n&quot;, text);
        pd.report(suffix);

        System.out.println(&quot;********************************&quot;);
        text = &quot;yabbadabbado#&quot;;
        pd = new PrefixDoubling();
        suffix = pd.solve(text);
        System.out.format(&quot;Text: %s%n&quot;, text);
        pd.report(suffix);

        System.out.println(&quot;********************************&quot;);
        text = &quot;DFDLKJLJldfasdlfjasdfkldjasfldafjdajfdsfjalkdsfaewefsdafdsfa#&quot;;
        pd = new PrefixDoubling();
        suffix = pd.solve(text);
        System.out.format(&quot;Text: %s%n&quot;, text);
        pd.report(suffix);

    }

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/counting-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/counting-sort/" itemprop="url">非比较排序之计数排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T00:00:00Z">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="external">计数排序wiki</a> <br></p>
<ul>
<li>计数排序是用来排序0到100之间的数字的最好的算法</li>
<li>计数排序可以用在基数排序中的算法来排序数据范围很大的数组</li>
<li>计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序</li>
<li>计数排序的优势是对已知数量范围的数组进行排序</li>
<li>基于比较的排序算法是不能突破O(NlogN)</li>
</ul>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><ol>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ol>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>具体的分步动画演示详见：<a href="http://www.cs.usfca.edu/~galles/visualization/CountingSort.html" target="_blank" rel="external">Data Structure Visualizations</a></p>
<p><br><br>对于数据2 5 3 0 2 3 0 3程序执行的过程如下图所示：</p>
<p><img src="/images/counting_sort_1.png" alt="示例图"><br><br><img src="/images/counting_sort_2.png" alt="示例图"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>package CountingSort;

/**
 * 计数排序
 * 
 * @author sxx.xu
 *
 */
public class CountingSort {

    private static void countingSort(int[] array) {
        int min = array[0], max = array[0];
        for (int i : array) {
            if (i &lt; min)
                min = i;
            if (i &gt; max)
                max = i;
        }

        System.out.println(&quot;max value:&quot; + max + &quot;\nmin value:&quot; + min);
        int[] countArray = new int[max + 1];// 此处使用max+1太粗暴，见countingSort2
        int[] countResult = new int[array.length];

        for (int i : array) {
            countArray[i]++;
        }

        for (int i = 1; i &lt; countArray.length; i++) {
            countArray[i] += countArray[i - 1];
        }

        for (int i = array.length - 1; i &gt;= 0; i--) {
            int elem = array[i];
            int index = countArray[elem] - 1;
            countResult[index] = elem;
            System.out.println(&quot;当前元素为：&quot; + elem + &quot;;在排序数组中的位置是：&quot; + index);
            countArray[elem]--;
        }

        for (int i : countResult) {
            System.out.println(i);
        }

        // 桶排序
        // int[][] resultArray = new int[countArray.length][countArray.length];
        // for (int i = 0; i &lt; countArray.length; i++) {
        // for (int j = 0; j &lt; countArray[i]; j++) {
        // resultArray[i][j] = i;
        // }
        // }
        //
        // for (int i = 0; i &lt; resultArray.length; i++) {
        // for (int j = 0; j &lt; resultArray[i].length; j++) {
        // if (resultArray[i][j] != 0)
        // System.out.println(resultArray[i][j]);// 这里直接输出，属于桶排序
        // }
        // }
    }

    /**
     * 优化后的，减少中间数组大小
     * @param array
     */
    private static void countingSort2(int[] array) {

        int min = array[0], max = array[0];
        for (int i : array) {
            if (i &lt; min)
                min = i;
            if (i &gt; max)
                max = i;
        }

        System.out.println(&quot;max value:&quot; + max + &quot;\nmin value:&quot; + min);
        int[] countArray = new int[max - min + 1];
        int[] countResult = new int[array.length];

        for (int i : array) {
            countArray[i - min]++;
        }

        for (int i = 1; i &lt; countArray.length; i++) {
            countArray[i] += countArray[i - 1];
        }

        for (int i = array.length - 1; i &gt;= 0; i--) {
            int elem = array[i] - min;
            int index = countArray[array[i] - min] - 1;
            countResult[index] = array[i];
            countArray[elem]--;
        }

        for (int i : countResult) {
            System.out.println(i);
        }
    }

    public static void main(String[] args) {
        int[] array = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };
        int[] array2 = { 2, 8, 5, 1, 10, 5, 9, 9, 3, 5, 6, 6, 2, 8, 2 };
        countingSort(array);
        countingSort2(array);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/bucket-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/bucket-sort/" itemprop="url">非比较排序之桶/箱排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T00:00:00Z">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<a href="http://xusx1024.com/2017/04/10/radix-sort/" target="_blank" rel="external">基数排序</a>有一定的理解 T.T，而基数排序是<code>桶排序</code>的一种特例。<br></p>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><blockquote>
<p>简单暴力的来说，我们有一组数据，该组数据比如说是高数成绩，那么肯定有最大值，最小值，申请大小为100的桶数组，数组的下标即分数，数组的值代表相同分数的学生有几个。大概如图所示：</p>
<p><img src="/images/buckets_sort.png" alt="示例图"></p>
<p>当然，上述只能有一个大概印象和基本理解，如果想要实际使用或者分析问题，还得看正规军。</p>
</blockquote>
<p><br></p>
<p>桶排序的思想近乎彻底的分治思想。假设现在需要对一亿个数进行排序。我们可以将其等分到10000个虚拟的桶里，平均每个桶只有10000个数。如果每个桶都有序了，则只需顺次输出桶里的有序序列即可。思路如下：<br></p>
<ol>
<li>将待排数据按一个映射函数f(x)分为连续的若干段。理论上最佳的分段方法应该使数据平均分布，实际上通常采用的方法都做不到这一点。显然，对于一个已知输入范围在[0,10000]的数组，最简单的分段莫过于x/m,例如f(x) = x/100.“连续的”这个条件非常重要，它是后面数据按顺序输出的理论保证。</li>
<li>分配足够的桶，按照f(x)从数组起始处向后扫描，并把数据放到合适的桶中。对于上面的例子，如果数据有10000个，则我们需要分配101个桶（因为要考虑边界条件：f(x)=x/100会产生【0，100】共101种情况），理想情况下，每个桶有大约100个数据。</li>
<li>对每个桶进行内部排序，例如，使用快速排序。注意，如果数据足够大，这里可以继续递归使用桶排序，直到数据大小降到合适的范围。</li>
<li>按顺序从每个桶输出数据,排序完成。</li>
</ol>
<p><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" target="_blank" rel="external">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：0~9、10~19、20~29、30~39、40~49，然后分别将这些数放人自己所属的桶，如下图：</p>
<p><img src="/images/bucket-sort-1.png" alt="示例图"></p>
<p>然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：</p>
<p><img src="/images/bucket-sort-2.png" alt="示例图"></p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><pre><code>package BuketsSort;

import java.util.Arrays;

/**
 * 桶排序
 * 
 * @author sxx.xu
 *
 */
public class BuketsSort {

    /*
     * 桶排序
     *
     * 参数说明： a -- 待排序数组 max -- 数组a中最大值的范围
     */
    public static void bucketSort(int[] a, int max) {
        int[] buckets;

        if (a == null || max &lt; 1)
            return;

        // 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。
        buckets = new int[max];

        // 1. 计数
        for (int i = 0; i &lt; a.length; i++)
            buckets[a[i]]++;

        // 2. 排序
        for (int i = 0, j = 0; i &lt; max; i++) {
            while ((buckets[i]--) &gt; 0) {
                a[j++] = i;
            }
        }

        buckets = null;
    }

    public static void bucketSort(int[] arr) {
        // 分桶，这里采用映射函数f(x)=x/10。
        // 输入数据为0~99之间的数字
        int bucketCount = 10;
        Integer[][] bucket = new Integer[bucketCount][arr.length]; // Integer初始为null,以与数字0区别。
        for (int i = 0; i &lt; arr.length; i++) {
            int quotient = arr[i] / 10; // 这里即是使用f(x)
            for (int j = 0; j &lt; arr.length; j++) {
                if (bucket[quotient][j] == null) {
                    bucket[quotient][j] = arr[i];
                    break;
                }
            }
        }
        // 小桶排序
        for (int i = 0; i &lt; bucket.length; i++) {
            // insertion sort
            for (int j = 1; j &lt; bucket[i].length; ++j) {
                if (bucket[i][j] == null) {
                    break;
                }
                int value = bucket[i][j];
                int position = j;
                while (position &gt; 0 &amp;&amp; bucket[i][position - 1] &gt; value) {
                    bucket[i][position] = bucket[i][position - 1];
                    position--;
                }
                bucket[i][position] = value;
            }

        }
        // 输出
        for (int i = 0, index = 0; i &lt; bucket.length; i++) {
            for (int j = 0; j &lt; bucket[i].length; j++) {
                if (bucket[i][j] != null) {
                    arr[index] = bucket[i][j];
                    index++;
                } else {
                    break;
                }
            }
        }
    }

 public static void bucketSort2(int [] arr){  
        //寻找数组中min，max，用于建桶  
        int min = 0, max = 0;  
        for(int i = 0; i &lt;= arr.length - 1; i++){  
            if(arr[i] &lt; min){  
                min = arr[i];  
            }  
            if(arr[i] &gt; max){  
                max = arr[i];  
            }  
        }  
        //开始建桶，注意桶的数量等于max - min + 1  
        int bucketCount = max - min + 1;  
        int[] bucket = new int[bucketCount];  
        for(int i = 0; i &lt;= arr.length - 1; i++){  
            bucket[arr[i] - min]++;  
        }  
        for(int i = 1; i &lt; bucketCount; i++){  
            bucket[i] = bucket[i] + bucket[i - 1];  
        }  
        //开始排序  
        int [] copy = new int[arr.length];  
        System.arraycopy(arr, 0, copy, 0, arr.length);  

        //从后往前排序，保持元素相对位置，保证算法稳定性。  
        for(int i = arr.length - 1; i &gt;= 0; i--){  
            arr[--bucket[copy[i] - min]] = copy[i];  
        }  
        //若从前往后排序，虽然排序结果相同，但会破坏元素相对位置和算法稳定性  
//      for(int i = 0; i &lt;= arr.length - 1; i++){  
//          arr[--bucket[copy[i] - min]] = copy[i];  
//      }  
    }  


    public static void main(String[] args) {
        int i;
        int a[] = { 8, 2, 3, 4, 3, 6, 6, 3, 9 };

        System.out.printf(&quot;before sort:&quot;);
        for (i = 0; i &lt; a.length; i++)
            System.out.printf(&quot;%d &quot;, a[i]);
        System.out.printf(&quot;\n&quot;);

//        bucketSort(a, 10); // 桶排序
//        bucketSort(a); // 桶排序
        bucketSort2(a); // 桶排序

        System.out.printf(&quot;after  sort:&quot;);
        for (i = 0; i &lt; a.length; i++)
            System.out.printf(&quot;%d &quot;, a[i]);
        System.out.printf(&quot;\n&quot;);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/radix-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/radix-sort/" itemprop="url">非比较排序之基数排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T00:00:00Z">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>探究Tinker的BSDiff算法的过程中，发现用到了<code>后缀排序</code>，就去研究后缀排序，然后发现用到<code>倍增算法</code>的思想。而倍增是排序的一种策略，这种策略要求必须对<code>基数排序</code>有一定的理解 T.T。<br><br>好，言归正传。基数排序是<a href="http://xusx1024.com/2017/04/10/bucket-sort/" target="_blank" rel="external">桶排序</a>的一种特例。 </p>
<h4 id="比较和非比较的区别"><a href="#比较和非比较的区别" class="headerlink" title="比较和非比较的区别"></a>比较和非比较的区别</h4><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</p>
<p>在 冒泡排序 之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在 归并排序、快速排序 之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均 O(nlogn) 。</p>
<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>
<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p>
<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 O(n) 。</p>
<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><blockquote>
<p>基数排序是一种非比较型、整数排序算法，其原理是将整数按位数切割成不同的数字，然后按照每个位数分别比较。<br><br></p>
</blockquote>
<p>排序过程：<br><br>将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后从最地位开始，依次进行一次排序。<br></p>
<p>基数排序法会使用到桶，即把要比较的个、十、百、千。。。位的对应的元素分配到0~9个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其他的比较性算法。具体的分步动画演示详见：<a href="http://www.cs.usfca.edu/~galles/visualization/RadixSort.html" target="_blank" rel="external">Data Structure Visualizations</a>。</p>
<p><br><br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>基数排序的时间复杂度是 <strong>O(k·n)</strong>，其中<strong>n</strong>是排序元素个数， <strong>k</strong>是数字位数。注意这不是说这个时间复杂度一定优于 <strong>O(n·log(n))</strong>， <strong>k</strong>的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小； <strong>k</strong>决定了进行多少轮处理，而 <strong>n</strong>是每轮处理的操作数目。</p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>对数组{53, 542, 63, 3, 63, 14, 214, 154, 748, 616}，它的示意图如下：</p>
<p><img src="/images/radix_sort.png" alt="示例图"><br>Java代码如下：</p>
<pre><code>package RadixSort;

/**
 * 基数排序
 * 
 * @author sxx.xu
 *
 */
public class RadixSort {

    private static int getMax(int[] array) {
        int max = array[0];
        for (int i : array) {
            max = i &gt; max ? i : max;
        }
        return max;
    }

    public static void radixSort(int[] array) {
        int exp = 1;// 个、十、百、千。。。位
        int max = getMax(array);

        for (exp = 1; max / exp &gt; 0; exp *= 10)
            countSort(array, exp);
    }

    private static void countSort(int[] array, int exp) {

        int[] outputs = new int[array.length];
        int[] buckets = new int[10];// 0-9

        //统计array中对应位数的元素的个数
        for (int i : array) {
            buckets[(i / exp) % 10]++;
        }
        //统计array中，小于该位的元素的个数，相当于排序
        for (int i = 1; i &lt; buckets.length; i++) {
            buckets[i] += buckets[i - 1];
        }
        //赋值
        for (int i = array.length - 1; i &gt;= 0; i--) {
            outputs[buckets[(array[i] / exp) % 10] - 1] = array[i];
            buckets[(array[i] / exp) % 10]--;
        }

        for (int i = 0; i &lt; outputs.length; i++) {
            array[i] = outputs[i];
        }
        outputs = null;
        buckets = null;
    }

    private static void radixSort(int[] array, int d) {
        int n = 1;// 个、十、百、千。。。位
        int k = 0;// 保存每一位排序后的结果用于下一位的排序输入
        int length = array.length;
        int[][] bucket = new int[10][length];// 排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里
        int[] order = new int[length];// 用于保存每个桶里有多少个数字
        while (n &lt; d) {
            for (int num : array) // 将数组array里的每个数字放在相应的桶里
            {
                int digit = (num / n) % 10;
                bucket[digit][order[digit]] = num;
                order[digit]++;
            }
            for (int i = 0; i &lt; length; i++)// 将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果
            {
                if (order[i] != 0)// 这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中
                {
                    for (int j = 0; j &lt; order[i]; j++) {
                        array[k] = bucket[i][j];
                        k++;
                    }
                }
                order[i] = 0;// 将桶里计数器置0，用于下一次位排序
            }
            n *= 10;
            k = 0;// 将k置0，用于下一轮保存位排序结果
        }

    }

    public static void main(String[] args) {
        int array[] = { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };
        for (int i : array) {
            System.out.print(i + &quot;  &quot;);
        }
        System.out.println(&quot;&quot;);
        System.out.println(&quot;before===================================after&quot;);
        radixSort(array);
        for (int i : array) {
            System.out.print(i + &quot;  &quot;);
        }
        int[] A = new int[] { 53, 3, 542, 748, 14, 214, 154, 63, 616, 70 };
        radixSort(A, 100);
        System.out.println(&quot;&quot;);
        for (int i : A) {
            System.out.print(i + &quot;  &quot;);
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/07/git-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/07/git-command/" itemprop="url">Git使用笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-07T00:00:00Z">
                2017-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index">
                    <span itemprop="name">Others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="git管理github"><a href="#git管理github" class="headerlink" title="git管理github"></a>git管理github</h4><p>1，需要有Githb账号，然后新建仓库，此时保留SSH，长这样：<code>git@github.com:xusx1024/codewars.git</code></p>
<p>2，pc端安装git工具，<code>git --info-path</code>打印git所在路径；创建本地仓库；</p>
<p>3，在本地文件中，右键点击 Git Bash Here，进入git命令行</p>
<p>4，全局配置 <br><br>    <code>git config --global username &quot;此处定义你的名字&quot;</code><br><br>    <code>git config --global useremail xxxxxxx@gmail.com</code></p>
<p>5，初始化本地仓库：<br>    <code>git init</code></p>
<p>6，创建readme，并上传：<br><br>    <code>git add readme.txt</code><br><br>    <code>git commint -m &quot;upload readme&quot;</code><br></p>
<p>7，生成SSH key，用来和Github连接：<br>    <code>ssh-keygen -C &#39;这里填你刚才配置的email地址&#39; -t rsa</code>然后一路点击enter，最后，得到usr/.ssh中的SSH key</p>
<p>8，把SSH key配置到 GitHub中<br>    在用户名上，<code>setting -  SSH and GPG keys</code></p>
<p>9，用到 第一步的那个串了<br><br>    <code>git remote add origin git@github.com:xusx1024/codewars.git</code><br><br>    <code>git push origin master</code><br></p>
<p>10，以后如果添加的话：<br><br>    <code>git add sth</code><br><br>    <code>git commint -m &quot;文件说明&quot;</code><br><br>    <code>git push origin master</code><br></p>
<p>11.<code>git add -A .</code><br>添加所有文件，注意后面有个点。</p>
<p>12.<br><code>git pull</code>  抓取远程仓库所有分支更新并合并到本地</p>
<p>13.<code>git config -l</code> 查看git的配置信息</p>
<h4 id="git-提交空目录"><a href="#git-提交空目录" class="headerlink" title="git 提交空目录"></a>git 提交空目录</h4><p>git与svn不同，git只跟踪文件的变化，不跟踪目录，如果想要提交一个空目录，我们可以在该目录添加一个文件，命名为.gitignore，这是一个变通的方法。</p>
<h4 id="git-克隆分支"><a href="#git-克隆分支" class="headerlink" title="git 克隆分支"></a>git 克隆分支</h4><p>多个分支的仓库，使用git clone的方法，只能把HEAD复制下来，如果有多个分支，可以考虑使用：</p>
<p><code>git branch -r</code>来查看各个分支</p>
<p><code>git checkout xxx</code>来clone指定的分支</p>
<h4 id="filename-too-long"><a href="#filename-too-long" class="headerlink" title="filename too long"></a>filename too long</h4><p>文件夹的层级过多，导致在clone的时候，出现该提示，可以考虑使用：</p>
<p><code>git config --system core.longpaths true</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/findbug-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/01/findbug-notes/" itemprop="url">FindBugs常见错误提示及解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T00:00:00Z">
                2017-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA-kotlin/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA & kotlin</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD"><a href="#ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD" class="headerlink" title="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD"></a>ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><blockquote>
<p>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。</p>
</blockquote>
<p>原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。<br><br></p>
<p>解决：通过get/set方法提供操作。</p>
<h4 id="DM-BOXED-PRIMITIVE-FOR-PARSING"><a href="#DM-BOXED-PRIMITIVE-FOR-PARSING" class="headerlink" title="DM_BOXED_PRIMITIVE_FOR_PARSING"></a>DM_BOXED_PRIMITIVE_FOR_PARSING</h4><blockquote>
<p>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.<br>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。</p>
</blockquote>
<p>原因：</p>
<ul>
<li>static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。</li>
<li>static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。</li>
<li>static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。</li>
</ul>
<p>解决：parseXXX方法代替valueOf</p>
<h4 id="SS-SHOULD-BE-STATIC"><a href="#SS-SHOULD-BE-STATIC" class="headerlink" title="SS_SHOULD_BE_STATIC"></a>SS_SHOULD_BE_STATIC</h4><blockquote>
<p>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.<br>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。</p>
</blockquote>
<p>解决方法：final的字段可以定义为static类型</p>
<h4 id="DLS-DEAD-LOCAL-STORE"><a href="#DLS-DEAD-LOCAL-STORE" class="headerlink" title="DLS_DEAD_LOCAL_STORE"></a>DLS_DEAD_LOCAL_STORE</h4><blockquote>
<p>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br><br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br><br>请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。</p>
</blockquote>
<p>解决方法：注释掉。</p>
<h4 id="SF-SWITCH-NO-DEFAULT"><a href="#SF-SWITCH-NO-DEFAULT" class="headerlink" title="SF_SWITCH_NO_DEFAULT"></a>SF_SWITCH_NO_DEFAULT</h4><blockquote>
<p>This method contains a switch statement where default case is missing. Usually you need to provide a default case.<br>Because the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn’t contain break statements for other cases.<br>此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。<br><br><br>因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。</p>
</blockquote>
<p>解决方法：加上default。</p>
<h4 id="RV-RETURN-VALUE-IGNORED-BAD-PRACTICE"><a href="#RV-RETURN-VALUE-IGNORED-BAD-PRACTICE" class="headerlink" title="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE"></a>RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><blockquote>
<p>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the <code>File.delete()</code> method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an a typical return value.<br>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，<code>File.dlete()</code>方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。</p>
</blockquote>
<h4 id="DC-DOUBLECHECK"><a href="#DC-DOUBLECHECK" class="headerlink" title="DC_DOUBLECHECK"></a>DC_DOUBLECHECK</h4><blockquote>
<p>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.</p>
</blockquote>
<p>see more:<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#" target="_blank" rel="external">双重检查锁定与延迟初始化</a></p>
<h4 id="NM-METHOD-NAMING-CONVENTION"><a href="#NM-METHOD-NAMING-CONVENTION" class="headerlink" title="NM_METHOD_NAMING_CONVENTION"></a>NM_METHOD_NAMING_CONVENTION</h4><blockquote>
<p>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.<br>方法名开头要小写。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/android-study-path/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/01/android-study-path/" itemprop="url">Android学习路线图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T00:00:00Z">
                2017-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index">
                    <span itemprop="name">Others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h4><table>
<thead>
<tr>
<th style="text-align:left">知识点</th>
<th style="text-align:left"></th>
<th style="text-align:left">链接或书籍</th>
<th style="text-align:left">进阶</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>java</strong></td>
<td style="text-align:left">基本语法(如继承、异常、引用、泛型等)</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="external">Java核心技术 卷I</a>（适合入门）</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">Effective Java中文版</a>（如何写好的Java代码）<br><a href="https://book.douban.com/subject/5362860/" target="_blank" rel="external">Java解惑</a>（介绍烂Java代码是什么样的）</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">多线程、并发</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a><br>（系统全面的介绍了Java的并发，如何设计支持并发的数据结构）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Java 7</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/24841235/" target="_blank" rel="external">Java程序员修炼之道</a> （详细的介绍Java 7 的新特性）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Java 8</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/26274206/" target="_blank" rel="external">写给大忙人看的Java SE 8</a><br><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="external">函数式编程思维</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">Java虚拟机</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a> （并不是那么难，Java程序员都该看看）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">性能优化</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/25828043/" target="_blank" rel="external">Java性能优化权威指南</a> （后面的章节好像用处不大，前面有些部分还是值得看）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>算法与数据结构</strong></td>
<td style="text-align:left">算法时间复杂度、空间复杂度的基本认知；<br> 熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br></td>
<td style="text-align:left"><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="external">数据结构与算法分析</a> （涵盖面比较全、示例是Java语言）<br><a href="https://book.douban.com/subject/26337727/" target="_blank" rel="external">算法设计与分析基础</a>（实用主义的典型、偏算法设计<br><a href="https://book.douban.com/subject/3227098/" target="_blank" rel="external">编程珠玑</a>（实践型算法数据</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>操作系统</strong></td>
<td style="text-align:left">对Linux/OS的基本认知<br>Linux的常用命令</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="external">鸟哥的Linux私房菜</a><br><a href="https://book.douban.com/subject/6097773/" target="_blank" rel="external">Linux内核设计与实现(原书第3版)</a>（很精炼的语言描述清楚了内核算法）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>网络</strong></td>
<td style="text-align:left">Http/Https<br>TCP/IP</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="external">图解HTTP</a><br><a href="https://book.douban.com/subject/24737674/" target="_blank" rel="external">图解TCP/IP</a></td>
<td style="text-align:left"><a href="https://book.douban.com/subject/1088054/" target="_blank" rel="external">TCP/IP详解</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>Android</strong></td>
<td style="text-align:left">四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）</td>
<td style="text-align:left"><a href="https://github.com/googlesamples/android-UniversalMusicPlayer" target="_blank" rel="external">UniversalMusicePlayer</a>(通过学习一个音乐播放器的代码能很快了解四大组件)<br><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">Android Training官方课程</a><br><a href="https://github.com/FX-Max/Point-of-Android" target="_blank" rel="external">Android一些重要知识点解析整理</a><br><a href="https://github.com/wasabeef/awesome-android-ui" target="_blank" rel="external">Android UI/UX库</a><br>（各类常用组件及扩展组件的集合）<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>、<a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a>（两个图片加载库）<br><a href="https://github.com/google/iosched" target="_blank" rel="external">The Google I/O 2016 Android App</a>(Google大会官方的App，适合学习各类实现)<br><a href="http://www.devtf.cn/" target="_blank" rel="external">Android开发技术前线</a>（定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）</td>
<td style="text-align:left"><a href="https://github.com/wasabeef/awesome-android-libraries" target="_blank" rel="external">第三方库集合</a></td>
</tr>
</tbody>
</table>
<h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><table>
<thead>
<tr>
<th style="text-align:left">知识点</th>
<th style="text-align:left"></th>
<th style="text-align:left">链接或书籍</th>
<th style="text-align:left">进阶</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>基础工具</strong></td>
<td style="text-align:left">IDE、Git、Maven</td>
<td style="text-align:left"><a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">AndroidStudio</a><br><a href="http://iissnan.com/progit/html/zh/ch1_0.html" target="_blank" rel="external">Git权威指南中文手册</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>软件质量</strong></td>
<td style="text-align:left">代码整洁<br>代码质量<br>代码重构</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/10797189/" target="_blank" rel="external">编写可读代码的艺术</a>（来自Google工程师，专注于代码可读性）<br><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="external">代码整洁之道</a>（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="external">重构-改善既有代码的设计</a>（学习改善已有代码）<br><a href="https://book.douban.com/subject/1173730/" target="_blank" rel="external">重构手册</a>（改善代码的实际操作）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>设计模式</strong></td>
<td style="text-align:left">23种常见设计模式</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="external">大话设计模式</a><br><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="external">Head First设计模式</a>(两本入门级的设计模式书籍)</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="external">设计模式-可复用面向对象软件的基础</a>（设计模式在实际中的应用）</td>
</tr>
<tr>
<td style="text-align:left"><strong>敏捷开发</strong></td>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://book.douban.com/subject/1790225/" target="_blank" rel="external">解析极限编程</a><br><a href="https://book.douban.com/subject/4037534/" target="_blank" rel="external">敏捷开发的艺术</a></td>
<td style="text-align:left"><a href="https://book.douban.com/subject/5348122/" target="_blank" rel="external">敏捷软件开发-原则、模式与实践</a></td>
</tr>
<tr>
<td style="text-align:left"><strong>专业开发</strong></td>
<td style="text-align:left">序员职业素养<br>更高效、更实效</td>
<td style="text-align:left"><a href="https://book.douban.com/subject/11614538/" target="_blank" rel="external">程序员的是职业素养</a><br><a href="https://book.douban.com/subject/5387402/" target="_blank" rel="external">程序员修炼之道-从小工到专家</a></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>思考人生</strong></td>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="external">黑客与画家</a>(硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</td>
</tr>
</tbody>
</table>
<h4 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h4><p><a href="https://www.diycode.cc/topics/122" target="_blank" rel="external">一个老鸟发的公司内部整理的 Android 学习路线图 Markdown 版本</a><br> <br><br><a href="https://www.diycode.cc/topics/117" target="_blank" rel="external">另一份 Android 开发学习路线图</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/30/tinker-source-code-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/30/tinker-source-code-3/" itemprop="url">Tinker学习(三) 核心的算法BSDiff、BSPatch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T00:00:00Z">
                2017-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>BSDiff，用于服务端比较二进制文件并生成差异补丁；<br><br>BSPatch，将旧文件和补丁文件合并生成新的文件。</p>
<p>比较差异使用的算法是<code>suffix sort</code>后缀排序算法。其中：<br></p>
<ul>
<li>C实现可以参照：<a href="https://github.com/cperciva" target="_blank" rel="external">Colin Percival</a>的<a href="https://github.com/cperciva/bsdiff" target="_blank" rel="external">bsdiff</a></li>
<li>Java实现可以参照：<a href="https://github.com/jdesbonnet" target="_blank" rel="external">Joe Desbonnet</a>的<a href="https://github.com/jdesbonnet/jbdiff" target="_blank" rel="external">jbdiff</a><br></li>
</ul>
<p>Tinker的<code>com.tencent.tinker.bsdiff</code>实现基本上和Joe Desbonnet的实现并无两样。</p>
<h4 id="BSDiff基本步骤"><a href="#BSDiff基本步骤" class="headerlink" title="BSDiff基本步骤"></a>BSDiff基本步骤</h4><ol>
<li>将old文件中所有子字符串形成一个字典 </li>
<li>对比old文件和new文件，产生diff string 和 extra string</li>
<li>将diffstring和extra string以及相应的控制字用zip压缩成一个patch包。</li>
</ol>
<p>所有差量更新算法的瓶颈，时间复杂度为O(nlogn)，空间复杂度为O(n)，n为old的文件长度，BSDiff采用了Fast suffix sorting方法生成后缀数组<br><br>关于后缀数组概念，需要懂得非比较排序算法：<br></p>
<ul>
<li><a href="http://xusx1024.com/2017/04/11/counting-sort/" target="_blank" rel="external">非比较排序之计数排序</a></li>
<li><a href="http://xusx1024.com/2017/04/10/bucket-sort/" target="_blank" rel="external">非比较排序之桶/箱排序</a></li>
<li><a href="http://xusx1024.com/2017/04/10/radix-sort/" target="_blank" rel="external">非比较排序之基数排序</a></li>
</ul>
<p>需要懂得生成后缀数组算法：<br></p>
<ul>
<li><a href="http://xusx1024.com/2017/04/11/suffix-sort-baseon-prefix-doubleing/" target="_blank" rel="external">基于倍增算法实现后缀数组</a></li>
<li><a href="http://xusx1024.com/2017/04/13/suffix-sort-baseon-dc3/" target="_blank" rel="external">基于DC3算法实现后缀数组</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/30/tinker-source-code-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XuShengSing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="行次">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/30/tinker-source-code-2/" itemprop="url">Tinker学习(二)标准java虚拟机动态加载代码示例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T00:00:00Z">
                2017-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽说dalvik和标准jvm类加载机制不尽相同，但是此例对于理解我们将要学习的Tinker，感觉仍有益处。<br></p>
<p>自定义classLoader类：</p>
<pre><code>import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class MyClassLoader extends ClassLoader {

    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {

        String classPath = MyClassLoader.class.getResource(&quot;/&quot;).getPath();
        String fileName = name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;;
        File classFile = new File(classPath, fileName);

        if (!classFile.exists()) {
            throw new ClassNotFoundException(classFile.getPath() + &quot; 不存在&quot;);
        }

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ByteBuffer bf = ByteBuffer.allocate(1024);
        FileInputStream fis = null;
        FileChannel fc = null;

        try {
            fis = new FileInputStream(classFile);
            fc = fis.getChannel();
            while (fc.read(bf) &gt; 0) {
                bf.flip();
                bos.write(bf.array(), 0, bf.limit());
                bf.clear();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                fis.close();
                fc.close();
            } catch (Exception e2) {
                // TODO: handle exception
            }

        }

        return defineClass(bos.toByteArray(), 0, bos.toByteArray().length);
    }

}
</code></pre><p>改变的类：</p>
<pre><code>public class Person {

    public void sayHello() {
        System.out.println(&quot;hello world!&quot;);
    }
}
</code></pre><p>测试的类：</p>
<pre><code>import java.lang.reflect.Method;

public class StartUp {

    public static void main(String[] args) {
        int i = 0;

        while (true) {
            MyClassLoader mcl = new MyClassLoader();
            System.out.println(mcl.getParent());
            try {
                Class&lt;?&gt; personClass = mcl.findClass(&quot;Person&quot;);

                Object person = personClass.newInstance();
                Method sayHelloMethod = personClass.getMethod(&quot;sayHello&quot;);
                sayHelloMethod.invoke(person);
                System.out.println(i++);

                Thread.sleep(3000);
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>修改person类里的打印String，会发现我们的main方法里的线程，总是打印我们修改后的文字。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/favicon.jpg"
               alt="XuShengSing" />
          <p class="site-author-name" itemprop="name">XuShengSing</p>
           
              <p class="site-description motion-element" itemprop="description">博观而约取，厚积而薄发。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">101</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xusx1024" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XuShengSing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">

  <div class="powered-by"></div>

<!-- <span class="post-count">博客共字</span> -->

</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

  <!-- 背景动画 -->
<script type="text/javascript" src="/js/src/particle.js"></script>

</body>
</html>
